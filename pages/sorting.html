<!DOCTYPE html>
<html>
	<head>
		<title>Array Sorting</title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				margin:0;
				color:#fff;
				user-select:none;
			}
			::-webkit-scrollbar{
				width:5px;
			}
			::-webkit-scrollbar-thumb{
				background:#777f;
				border-radius:10px;
			}
			@media(orientation:landscape){#cvs{width:auto}}
			@media(orientation:portrait){#cvs{width:98%}}
			#cvs{
				margin:1%;
				background:#000;
			}
			td,
			#sortnamedisp,
			#nextsortdisp,
			.topicname{
				font-family:monospace;
				color:#fff;
			}
			#sortnamedisp,
			#nextsortdisp,
			#statisticsholder{
				margin:5px;
			}
			#cont{
				vertical-align:top;
				height:100%;
			}
			div.btnholder{
				border-radius:2px;
				background:#1e252a;
				border:3px #000 solid;
				height:0px;
				margin:0;
				overflow-x:hidden;
				width:100%;
				text-align:left;
			}
			div.fieldset{
				margin:2px;
				padding:3px;
				border:1px white solid;
				width:100%;
			}
			div.btnholder>div.shown{
				margin-top:3px;
			}
			div.btnholder>div.hidden{
				display:none;
			}
			div.topicname{
				font-family:monospace;
				margin:5px;
				border:2px dashed grey;
				padding:2px;
				text-align:center;
			}
			.flex{
				display:flex;
			}
			input[type=checkbox]{
				margin:0;
			}
			#shuffleType,
			#displayType{
				max-width:105px;
			}
			#searchBar{
				transition-timing-function:linear;
				transition-duration:.2s;
				margin-left:5px;
				width:50%;
				color:#fff;
				border-radius:2px;
				border:1px grey solid;
				outline:none;
				background-color:#0e151a;
				opacity:.5;
				box-shadow:none;
			}
			#searchBar:focus{
				background-color:#121c24;
				opacity:1;
				box-shadow:-.2px -.2px 4px 2px #1d2a35;
			}
		</style>
	</head>
	<body bgcolor=#0e151a>
		<div id=flexbox>
			<canvas id=cvs></canvas>
			<div id=statisticsholder>
				<div>
					<span id=sortnamedisp></span><br>
					<span id=nextsortdisp></span>
				</div>
				<div class=flex style='width:100%'>
					<div class=fieldset>
						<table>
							<tr>
								<td>Display</td>
								<td>
									<select id=displayType oninput='draw();if(parseInt(this.value)==2)verifyc();else if(this.value=="5")verify(prompt("url",""));'>
										<option value=0>Bar</option>
										<option value=1>Point</option>
										<option value=2>Gradient</option>
										<option value=2.5>Gradient - Bars</option>
										<option value=3>RGB</option>
										<option value=4>Circle</option>
										<option value=5>Custom Image</option>
									</select>
								</td>
							</tr>
							<tr>
								<td>Shuffle</td>
								<td>
									<select id=shuffleType>
										<option>Normal</option>
										<option>Reverse</option>
										<option>Slighty Shuffled</option>
										<option>Sorted</option>
										<option>Naive</option>
										<option>Shuffled Tail</option>
										<option>Shuffled Head</option>
										<option>Shifted Elements</option>
										<option>Noisy</option>
										<option>Shuffled Odds</option>
										<option>Final Merge</option>
										<option>Shuffled Final Merge</option>
										<option>Shuffled Half</option>
										<option>Partitioned</option>
										<option>Sawtooth</option>
										<option>Pipe Organ</option>
										<option>Final Bitonic Pass</option>
										<option>Interlaced</option>
										<option>Double Layered</option>
										<option>Final Radix</option>
										<option>Real Final Radix</option>
										<option>Recursive Final Radix</option>
										<option>Half Rotation</option>
										<option>Half Reversed</option>
										<option>Logarithmic Slopes</option>
										<option>Heapified</option>
										<option>Triangular Heapified</option>
										<option>First Circle Pass</option>
										<option>Final Pairwise Pass</option>
										<option>Recursive Reversal</option>
										<option>Gray Code Fractal</option>
										<option>Sierpinski Triangle</option>
										<option>Triangular</option>
										<option>Quicksort Adversary</option>
										<option>Grailsort Adversary</option>
										<option>Shuffle Merge Adversary</option>
										<option>Bit Reversal</option>
										<option>Randomly w/ Blocks</option>
										<option>Block Reverse</option>
									</select>
								</td>
							</tr>
							<tr>
								<td>Prompts</td>
								<td><input type=checkbox checked id='prompts'/></td>
							</tr>
							<tr>
								<td>Mark</td>
								<td><input type=checkbox checked id='markArray'/></td>
							</tr>
							<tr id=markRequired>
								<td>Sound</td>
								<td><input type=checkbox oninput='playsound=true'id='playSound'/></td>
							</tr>
							<tr>
								<td>Next Sort</td>
								<td><input type=checkbox checked id='nextSort'/></td>
							</tr>
							<tr id=nextRequired>
								<td>Loop</td>
								<td><input type=checkbox id='loopSort'/></td>
							</tr>
							<tr id=loopRequired>
								<td>Next Shuffle</td>
								<td><input type=checkbox id='nextShuffle'/></td>
							</tr>
							<tr>
								<td colspan=2><button onclick='stopped=true'>Skip</button></td>
							</tr>
							<tr>
								<td colspan=2><button onclick='setArraySize()'>Array Size</button></td>
							</tr>
							<tr>
								<td colspan=2><button onclick='cvs.style.backgroundColor=prompt("Color","#000")'>BG Color</button></td>
							</tr>
							<tr><td colspan=2 id=fpsDisplay></td></tr>
							<tr><td colspan=2 id=comparisonsDisplay></td></tr>
							<tr><td colspan=2 id=swapsDisplay></td></tr>
							<tr><td colspan=2 id=writesDisplay></td></tr>
							<tr><td colspan=2 id=reversalDisplay></td></tr>
							<tr><td colspan=2 id=auxWritesDisplay></td></tr>
							<tr><td colspan=2 id=progressDisplay></td></tr>
						</table>
					</div>
					<div class=fieldset style="max-width:50%">
						<div id=cont><input id=searchBar oninput='filterSorts(this.value)'placeholder='Search...'/><div class=topicname><span id=nameholder>Sorts</span><div class=flex><div id=sortsholder class=btnholder></div></div></div></div>
					</div>
				</div>
			</div>
		</div>
		<script>
/* Sources:
github.com/Gaming32/ArrayV/tree/c90c065805d682b3e92a8a056f891765fe1992f0/src/main/java/io/github/arrayv/sorts
github.com/Gaming32/ArrayV-Extra-Sorts/tree/main/src/main/java/io/github/arrayv/sorts
github.com/PCBoyGames/ArrayV-v4.0/tree/PCBoy's-Personal-Build/src/sorts
*/
function ctz(n){n|=n;let b=n.toString(2);return parseInt(b)?(b.match(/0*$/)+"").length:32}
const ctx=cvs.getContext("2d"),{random,ceil,floor,round,sqrt,cbrt,log,cos,abs,pow,clz32,PI,sin,sign,min:minVal,max:maxVal}=Math;
let winRtn="",aud;
let arr_size=256;
let soundPerSec=0;
let sortRunning=false,playsound=false,displayCooldown=false;
let stopped=false;
let emergencyStop=false;
let willLoop=false;
let restoreLen=null;
let shuffling=true;
let maxValue=arr_size;
let sortQueue=null;
let image=new Image();
let arr=new Array(arr_size).fill().map((e,i)=>++i);
let shuffleNames=[...shuffleType.children].map(e=>e.value);
let counts={
	swp:0,wrt:0,rev:0,aux:0,cmps:0,
	comp:function(){this.cmps++},
	reset:function(){this.cmps=this.swp=this.wrt=this.rev=this.aux=0}
}
function toLong(n){return BigInt(n)}
function toInt(n){return Number(n)>>32}
let prevTime=0,frames=0;
requestAnimationFrame(function update(time){
	let btns=document.querySelectorAll("div.btnholder>div");
	if(time-prevTime>=500){
		prevTime=time;
		fpsDisplay.innerText=frames+" FPS";
		let c=frames=0;
		for(let i=0;i<btns.length;i++)
			if(btns[i].className=="shown")c++;
		nameholder.innerText=`Sorts(${c})`
	}else frames+=2;
	winRtn=window.innerWidth<window.innerHeight?"portrait":"landscape";
	flexbox.style.display=winRtn=="portrait"?"inline-block":"flex";
	nextRequired.style.display=nextSort.checked?"table-row":"none";
	loopRequired.style.display=nextSort.checked&&loopSort.checked?"table-row":"none";
	markRequired.style.display=markArray.checked?"table-row":"none";
	if(sortnamedisp.innerText!="Running: ..."){
		let c=sortnamedisp.innerText.split(" ")[1];
		if(!nextSort.checked)nextsortdisp.innerText="Next: ...";
		else if(loopSort.checked)nextsortdisp.innerText="Next: "+c;
		else if(sortQueue)nextsortdisp.innerText="Next: "+sortQueue;
		else nextsortdisp.innerText="Next: "+sortNames[(1+sortNames.indexOf(c))%sortNames.length];
	}
	requestAnimationFrame(update);
})
window.onresize=function(){
	let dim=minVal(window.innerWidth,window.innerHeight);
	let m=winRtn=="portrait";
	cvs.width=dim*(m?2:1);
	cvs.height=dim/(m?1:2);
	draw();
}
window.onresize();
//Project Started: April 4, 2024
function setArraySize(){
	let pn=prompt("Array Size");
	if(pn=="max")pn=2048;
	if(pn=="min")pn=2;
	let n=minVal(2048,maxVal(2,parseInt(pn)));
	if(typeof n!=="number"||isNaN(n))return;
	arr=[...new Array(arr_size=n)].map((e,i)=>++i);
	maxValue=arr_size;
	willLoop=loopSort.checked;
	emergencyStop=stopped=loopSort.checked=true;
}
function limitArraySize(n){
	let old=arr_size;
	if(old<=n)return old;
	arr_size=minVal(old,n);
	let t=[...arr];arr=[];
	arraycopy(t,0,arr,0,n,0,false,true);
	maxValue=arr_size;
	willLoop=loopSort.checked;
	emergencyStop=stopped=loopSort.checked=true;
	restoreLen=old;
}
function restoreArraySize(){
	if(restoreLen===null)return;
	arr=[...new Array(arr_size=restoreLen)].map((e,i)=>++i);
	restoreLen=null;
	maxValue=arr_size;
	draw();
}
class Gradient{
	hex(c){
		let s="0123456789abcdef",i=parseInt(c);
		if(!i||isNaN(c))return"00";
		i=round(minVal(maxVal(0,i),255));
		return s.charAt((i-i%16)/16)+s.charAt(i%16);
	}
	convertToHex(rgb){
		return this.hex(rgb[0])+this.hex(rgb[1])+this.hex(rgb[2]);
	}
	trim(s){
		return s.charAt(0)=="#"?s.substring(1,7):s
	}
	convertToRGB(h){
		return[
			parseInt(this.trim(h).substring(0,2),16),
			parseInt(this.trim(h).substring(2,4),16),
			parseInt(this.trim(h).substring(4,6),16)
		]
	}
	verify(rh){
		let h=this.trim(rh.replaceAll(/[^\d^a-f]/g,"")),l=h.length;
		if(l==3){
			let[r,g,b]=h.split("");
			return r+r+g+g+b+b;
		}else if(l==6)return h;
		else return 0;
	}
	gen(cS,cE,cC){
		let ts=this.verify(cS),te=this.verify(cE);
		let s=this.convertToRGB(ts?ts:"000000"),e=this.convertToRGB(te?te:"ffffff");
		let l=cC,a=0,r=[],i,j;
		for(i=0;i<l;i++){
			let c=[];
			a+=1/l;
			for(j=0;j<3;j++) 
				c[j]=s[j]*a+(1-a)*e[j];
			r.push("#"+this.convertToHex(c));
	
		}
		return r;
	}
	genRGB(l){
		let r=[],s=360/l;
		let{hex}=this;
		function hsl2rgb(h,s,l){
			let a=s*minVal(l,1-l);
			let f=(n,k=(n+h/30)%12)=>(l-a*maxVal(minVal(k-3,9-k,1),-1))*255;
			return "#"+hex(f(0))+hex(f(8))+hex(f(4));
		}
		for(let i=0;i<=360;i+=s)
			r.push(hsl2rgb(i,1,.5));
		return r;
	}
}
const gradient={
	c1:"#000",c2:"#fff",
	gen:function(){
		return new Gradient().gen(this.c2,this.c1,arr_size+1);
	},
	genRGB:function(){
		return new Gradient().genRGB(arr_size);
	}
}
function verifyc(){
	let c1=prompt("color 1",gradient.c1);
	let c2=prompt("color 2",gradient.c2);
	gradient.c1=c1.toLowerCase();
	gradient.c2=c2.toLowerCase();
}
function verify(s){
	if(image.src==s)return;
	image.setAttribute("crossorigin","anonymous");
	image.src=s;
}
function fill(hex="#fff"){
	ctx.fillStyle=hex;
}
function getPixelR(){
	return{w:cvs.width/arr_size,h:cvs.height/maxValue};
}
function localeS(s){
	return s.toLocaleString();
}
function findSegments(a,l){
	let c=0;
	for(let i=0;i<l-1;i++)if(a[i]<=a[i+1])c++;
	return c/(l-1)*100;
}
function draw(){
	if(displayCooldown)return;
	displayCooldown=true;setTimeout(()=>displayCooldown=false);
	const{w,h}=getPixelR();
	ctx.clearRect(0,0,cvs.width,cvs.height);
	let t=parseFloat(displayType.value);
	fill();
	let g,center=[cvs.width/2,cvs.height/2],rad=minVal(...center)*.9,getDist,angles,cosA,sinA;
	if(t>1)g=t<3?gradient.gen():gradient.genRGB();
	let iw=image.width;
	let ih=image.height;
	let cu3=iw>0;
	let temp,scale,cut;
	if(cu3){
		temp=document.createElement("canvas");
		scale=1.5;
		temp.width=cvs.width/scale;temp.height=cvs.height/scale;
		let wR=temp.width/iw,hR=temp.height/ih;
		cut=temp.width/arr_size;
		temp.getContext("2d").drawImage(image,0,0,iw,ih,0,0,iw*wR,ih*hR);
	}
	if(t==4){
		const correct=[...arr].sort((a,b)=>a-b);
		getDist=function(n,i){
			return(arr_size-abs(correct.indexOf(n)-i))/(arr_size)*rad;
		}
		angles=new Array(arr_size).fill(2*PI/arr_size).map((e,i)=>e*i-.5*PI);
		cosA=angles.map(e=>cos(e));
		sinA=angles.map(e=>sin(e));
	}
	for(let i=0;i<arr_size;i++){
		let v=arr[i];
		if(t<2)ctx.fillRect(i*w,cvs.height-v*h,w*1.05,!t?v*h:w);
		else if(t<4){
			fill(g[arr[i]]);
			if(t<2.1)ctx.fillRect(i*w,0,w*1.05,cvs.height);
			else ctx.fillRect(i*w,cvs.height-v*h,w*1.05,v*h);
		}else if(t<5){
			let rd=getDist(v,i);
			ctx.beginPath();
			ctx.arc(center[0]+cosA[i]*rd,center[1]+sinA[i]*rd,w*1.05,0,2*PI);
			ctx.fill();
		}else
			if(cu3)
				ctx.drawImage(temp,v*w/scale,0,w*cut*scale,temp.height,i*w,0,w*2.025*scale,cvs.height);
	}
	comparisonsDisplay.innerText=localeS(counts.cmps)+" Comparisons";
	swapsDisplay.innerText=localeS(counts.swp)+" Swaps";
	writesDisplay.innerText=localeS(counts.wrt)+" Writes";
	reversalDisplay.innerText=localeS(counts.rev)+" Reversals";
	auxWritesDisplay.innerText=localeS(counts.aux)+" Aux Writes";
	progressDisplay.innerText=findSegments(arr,arr_size).toFixed(1)+"% Sorted";
}
function sleep(ms){
	return new Promise(r=>setTimeout(r,ms));
}
function sound(fr,g=.1){
	if(!playsound)return;
	if(soundPerSec++>2)playsound=0;
	setTimeout(()=>playsound=playSound.checked,soundPerSec=0);
	if(!aud)aud=new AudioContext();
	let o=aud.createOscillator();
	let f=250+fr/maxValue*1000;
	o.frequency.value=f;o.start();o.stop(aud.currentTime+.09);
	let n=aud.createGain();
	n.gain.value=g;n.gain.linearRampToValueAtTime(0,aud.currentTime+.05);o.connect(n);n.connect(aud.destination);
}
const Rotations={
	swapBlocksBackwards:async function(A,a,b,l,sl,m,x){
		let j=0;
		for(let i=0;i<l;i++){
			swap(A,a+l-i-1,b+l-i-1,0,false,x);
			if(++j*sl>=1){
				if(m)mark(a+i);
				await sleep(j=0);
			}
		}
	},
	blockSwap:async function(A,a,b,l,sl,m,x){
		let j=0;
		for(let i=0;i<l;i++){
			swap(A,a+i,b+i,0,false,x);
			if(++j*sl>=1){
				if(m)mark(a+i);
				await sleep(j=0);
			}
		}
	},
	shiftForwards:async function(A,s,l,sl,m,x){
		let t=A[s];
		for(let i=0;i<l;i++){
			write(A,s+i,A[s+i+1],0,m,x);
			if(!x)await sleep(sl);
		}
		write(A,s+l,t,sl,m,x);
		if(!x)await sleep(sl);
	},
	shiftBackwards:async function(A,s,l,sl,m,x){
		let t=A[s+l];
		for(let i=l;i>0;i--){
			write(A,s+i,A[s+i-1],sl,m,x);
			if(!x)await sleep(sl);
		}
		write(A,s,t,sl,m,x);
		if(!x)await sleep(sl);
	},
	mapIndex:function(i,n,l){
		return(i-n+l)%l;
	},
	swap:async function(A,a,v,sl,m,x){
		let o=A[a];
		write(A,a,v,sl,m,x);
		if(!x)await sleep(sl);
		return o;
	},
	griesMills:async function(A,p,lA,lB,sl,m,x){
		while(lA&&lB){
			if(lA<=lB){
				await this.blockSwap(A,p,p+lA,lA,sl,m,x);
				p+=lA;
				lB-=lA;
			}else{
				await this.blockSwap(A,p+lA-lB,p+lA,lB,sl,m,x);
				lA-=lB;
			}
		}
	},
	threeReversal:async function(A,p,lA,lB,sl,m,x){
		await reversal(A,p,p+lA-1,sl,m,x);
		await reversal(A,p+lA,p+lA+lB-1,sl,m,x);
		await reversal(A,p,p+lA+lB-1,sl,m,x);
	},
	holyGriesMills:async function(A,p,lA,lB,sl,mark,x){
		while(lA>1&&lB>1){
			while(lA<=lB){
				await this.blockSwap(A,p,p+lA,lA,sl,mark,x);
				p+=lA;
				lB-=lA;
			}
			if(lA<=1||lB<=1)break;
			while(lA>lB){
				await this.swapBlocksBackwards(A,p+lA-lB,p+lA,lB,sl,mark,x);
				lA-=lB;
			}
		}
		if(lA==1)await this.shiftForwards(A,p,lB,sl,mark,x);
		else if(lB==1)await this.shiftBackwards(A,p,lA,sl,mark,x);
	},
	helium:async function(A,p,lA,lB,sl,mark,x){
		while(lB>1&&lA>1){
			if(lB<lA){
				await this.blockSwap(A,p,p+lA,lB,sl,mark,x);
				p+=lB;
				lA-=lB;
			}else{
				await this.swapBlocksBackwards(A,p,p+lB,lA,sl,mark,x);
				lB-=lA;
			}
		}
		if(lB==1)await this.shiftBackwards(A,p,lA,sl,mark,x);
		else if(lA==1)await this.shiftForwards(A,p,lB,sl,m,x);
	},
	cycleReverse:async function(A,p,lA,lB,sl,m,x){
		if(lA<1||lB<1)return;
		let a=p,b=p+lA-1,c=p+lA,d=p+lA+lB-1;
		let sw;
		while(a<b&&c<d){
			sw=A[b];
			write(A,b--,A[a],0,m,x);
			write(A,a++,A[c],0,m,x);
			write(A,c++,A[d],0,m,x);
			await write(A,d--,sw,sl,m,x);
		}
		while(a<b){
			sw=A[b];
			write(A,b--,A[a],0,m,x);
			write(A,a++,A[d],0,m,x);
			await write(A,d--,sw,sl,m,x);
		}
		while(c<d){
			sw=A[c];
			write(A,c++,A[d],0,m,x);
			write(A,d--,A[a],0,m,x);
			await write(A,a++,sw,sl,m,x);
		}
		if(a<d)await reversal(A,a,d,sl,m,x);
	},
	juggling:async function(A,pos,lA,lB,sl,mark,x){
		let l=lA+lB;
		lA%=l;
		if(lA==0)return;
		for(let cnt=0,index=0,value=A[pos+index],sIndex=index;cnt<l;cnt++){
			let nextIndex=this.mapIndex(index,lA,l);
			value=await this.swap(A,pos+nextIndex,value,sl,mark,x);
			if(nextIndex==sIndex){
				sIndex=index=this.mapIndex(index,1,l);
				value=A[pos+index];
			}else{
				index=nextIndex;
			}
		}
	},
	bridge:async function(A,pos,left,right,sl,mark,x){
		if(left<1||right<1)return;
		let pta=pos,ptb=pos+left,ptc=pos+right,ptd=ptb+right;
		if(left<right){
			let bridge=right-left;
			if(bridge<left){
				let loop=left;
				let swp=new Array(bridge).fill(0);
				arraycopy(A,ptb,swp,0,bridge,0,false,true);
				while(loop-->0){
					await write(A,--ptc,A[--ptd],sl/2,mark,x);
					await write(A,ptd,A[--ptb],sl/2,mark,x);
				}
				await arraycopy(swp,0,A,pta,bridge,sl,mark,x);
			}else{
				let swp=new Array(left).fill(0);
				arraycopy(A,pta,swp,0,left,0,false,true);
				await arraycopy(A,ptb,A,pta,right,sl,mark,x);
				await arraycopy(swp,0,A,ptc,left,sl,mark,x);
			}
		}else if(right<left){
			let bridge=left-right;
			if(bridge<right){
				let loop=right;
				let swp=new Array(bridge).fill(0);
				arraycopy(A,ptc,swp,0,bridge,0,false,true);
				while(loop-->0){
					await write(A,ptc++,A[pta],sl/2,mark,x);
					await write(A,pta++,A[ptb++],sl/2,mark,x);
				}
				await arraycopy(swp,0,A,ptd-bridge,bridge,sl,mark,x);
			}else{
				let swp=new Array(right).fill(0);
				arraycopy(A,ptb,swp,0,right,0,false,true);
				while(left-->0)
					await write(A,--ptd,A[--ptb],sl,mark,x);
				await arraycopy(swp,0,A,pta,right,sl,mark,x);
			}
		}else{
			while(left-->0)
				await swap(A,pta++,ptb++,sl,mark,x);
		}
	},
	adaptable:async function(A,p,lA,lB,sl,m,x){
		if(!lA||!lB)return;
		if(lA%lB<1||lB%lA<1)await this.holyGriesMills(A,p,lA,lB,sl,m,x);
		else await this.cycleReverse(A,p,lA,lB,sl,m,x);
	}
}
const IndexedRotations={
	griesMills:async function(A,s,m,e,sl,r,x){await Rotations.griesMills(A,s,m-s,e-m,sl,r,x)},
	threeReversal:async function(A,s,m,e,sl,r,x){await Rotations.threeReversal(A,s,m-s,e-m,sl,r,x)},
	juggling:async function(A,s,m,e,sl,r,x){await Rotations.juggling(A,s,m-s,e-m,sl,r,x)},
	holyGriesMills:async function(A,s,m,e,sl,r,x){await Rotations.holyGriesMills(A,s,m-s,e-m,sl,r,x)},
	helium:async function(A,s,m,e,sl,r,x){await Rotations.helium(A,s,m-s,e-m,sl,r,x)},
	cycleReverse:async function(A,s,m,e,sl,r,x){await Rotations.cycleReverse(A,s,m-s,e-m,sl,r,x)},
	bridge:async function(A,s,m,e,sl,r,x){await Rotations.bridge(A,s,m-s,e-m,sl,r,x)},
	adaptable:async function(A,s,m,e,sl,r,x){await Rotations.adaptable(A,s,m-s,e-m,sl,r,x)}
}
const Wr={
	insert:async function(A,p,t,sl,m,x){
		let tm=A[p],j;
		if(t-p>0){
			for(let i=p;i<t;i++){
				write(A,i,A[i+1],0,false,x);
				if(++j*sl>=1){
					if(m)mark(i);
					await sleep()
				}
			}
		}else if(t-p<0){
			for(let i=p;i>t;i--){
				write(A,i,A[i-1],0,false,x);
				if(++j*sl>=1){
					if(m)mark(i);
					await sleep()
				}
			}
		}
		if(p-t)
			await write(A,t,tm,sl,m,x);
	}
}
function ask(t,d){return !prompts.checked?d:prompt(t,d)}
function askForBase(d){
	let r=Number(ask("Base",d))|0;
	return r>1&&r<=arr_size?r:d;
}
function mark(i){
	if(markArray.checked){
		sound(Number(arr[i])||0,.05);
		let{w,h}=getPixelR();
		ctx.strokeStyle="#f00";
		let dt=parseFloat(displayType.value);
		fill(dt-3?"#f00":"#fff");
		let t=dt>1&&dt<2.1;
		if(dt-4)ctx.fillRect(i*w,!t?cvs.height-arr[i]*h:0,w,!t?arr[i]*h:cvs.height);
		else{
			let correct=[...arr].sort((a,b)=>a-b);
			let rad=minVal(cvs.width,cvs.height)/2*.9;
			function getDist(n,i){
				return(arr_size-abs(correct.indexOf(n)-i))/(arr_size)*rad;
			}
			let v=arr[i];
			let rd=getDist(v,i);
			let a=2*PI/arr_size*i-.5*PI;
			ctx.beginPath();
			ctx.moveTo(cvs.width/2,cvs.height/2);
			ctx.lineTo(cvs.width/2+cos(a)*rd,cvs.height/2+sin(a)*rd);
			ctx.stroke();
		}
	}
}
function stop(reason){
	if(shuffling)return stopped=false;
	stopped=sortRunning=false;
	arr=[...new Array(arr_size)].map((e,i)=>++i);
	maxValue=maxVal(...arr);
	draw();
	throw"Stopped: "+reason;
}
function markSwap(a,b){
	mark(a);
	mark(b);
}
function swap(a,i,j,s,m,x){
	if(stopped)return stop("UserInput");
	i|=0;j|=0;
	[a[i],a[j]]=[a[j],a[i]];
	if(!x){
		draw();
		counts.swp++;
		counts.wrt+=i-j?2:1;
	}else
		counts.aux+=i-j?2:1;
	if(m)markSwap(i,j);
	return sleep(s);
}
async function multiSwap(A,p,t,s,m,x){
	let j=0;
	if(t-p>0)for(let i=p;i<t;i++){
		swap(A,i,i+1,0,false,x);
		if(s*++j>=1){
			if(m)mark(i);
			await sleep(j=0);
		}
	}else for(let i=p;i>t;i--){
		swap(A,i,i-1,0,false,x);
		if(s*++j>=1){
			if(m)mark(i);
			await sleep(j=0);
		}
	}
}
function write(a,t,v,s,m,x){
	if(stopped)stop("UserInput");
	a[t|=0]=v|0;
	if(!x){
		draw();
		counts.wrt++;
	}else
		counts.aux++;
	if(m)mark(t);
	return sleep(s);
}
async function reversal(A,s,l,sl,m,x){
	counts.rev++;
	for(let i=s,j=0;i<s+(l-s+1)/2|0;i++){
		swap(A,i,s+l-i,0,false,x);
		if(sl*++j>=1){
			if(m)mark(i);
			await sleep(j=0);
		}
	}
	if(sl)await sleep();
}
async function transcribe(A,r,s,m,x){
	let t=s;
	for(let i=0;i<r.length;i++){
		for(let j=0;j<r[i].length;j++){
			write(A,t++,r[i][j],0,m,x);
			if(m)await sleep();
		}
		r[i]=[];
	}
}
async function transcribeMSD(A,r,s,n,sl,m,x){
	let t=s,tm=0;
	for(let i=0;i<r.length;i++)t+=r[i].length;
	for(let i=r.length-1;i>=0;i--){
		for(let j=r[i].length-1;j>=0;j--){
			write(A,t+n-tm++-1,r[i][j],0,m,x);
			if(m)await sleep(sl);
		}
	}
}
async function fancyTranscribe(A,l,regs,s){
	let tA=new Array(l);
	let tW=new Array(l).fill(!1);
	let rad=regs.length;
	transcribe(tA,regs,0,false,true);
	counts.aux-=l;
	for(let i=0;i<l;i++){
		let reg=i%rad;
		let p=(reg*(l/rad|0))+i/rad|0;
		if(!tW[p]){
			write(A,p,tA[p],0);
			tW[p]=true;
		}
		mark(p);
		if(!reg)await sleep(s);
	}
	for(let i=0;i<l;i++)
		if(!tW[i])
			write(A,i,tA[i],0);
}
async function arraycopy(s,sp,d,dp,l,sl,m,x){
	let b=s!=d||dp<sp;
	let st=b?0:l-1;
	let en=b?l:-1;
	let dr=b?1:-1;
	let j=0,sd=false;
	for(let i=st;i!=en;i+=dr){
		if(++j*sl>=1){
			sd=true;
			if(m){
				if(x)mark(sp+i);
				else mark(dp+i);
			}
			await sleep(j=0);
		}
		write(d,dp+i,s[sp+i],0,false,x);
	}
	if(!sd)await sleep();
}
function compareValues(a,b){counts.comp();return a==b?0:a>b?1:-1}
function compareIndexValue(a,b,c){b|=0;c|=0;counts.comp();return a[b]==c?0:a[b]>c?1:-1}
function compareValueIndex(a,b,c){b|=0;c|=0;counts.comp();return b==a[c]?0:b>a[c]?1:-1}
function compareIndices(a,b,c){b|=0;c|=0;counts.comp();return a[b]==a[c]?0:a[b]>a[c]?1:-1}
async function shuffle(){
	shuffling=true;
	sortnamedisp.innerText="Running: ...";
	nextsortdisp.innerText="Next: ...";
	const L=arr_size,R=new Random();
	let delay=cbrt(L)|0;
	let aux=new Array(L),tmp=new Array(L).fill(0),cnt,a,b,c,d,e,f,g,h,i=0,j=0,k=0,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,sm,sb,d1,d2;
	async function shuf(a,s,l,sl,x){
		for(let i=s,j=0;i<l;i++){
			swap(a,i,R.nextInt(l-i)+i,0,false,x);
			if(++j*sl>=1){
				if(!x)mark(i);
				await sleep(j=0);
			}
		}
	}
	async function sort(a,s,l,sl=1){
		let n=a[s],x=n,k=0;
		for(let i=s+1;i<l;i++){
			if(a[i]<n)n=a[i];
			else if(a[i]>x)x=a[i];
		}
		let z=x-n+1;
		let h=new Array(z).fill(0);
		for(let i=s;i<l;i++)
			write(h,a[i]-n,h[a[i]-n]+1,0,false,true);
		for(let i=0,j=s;i<z;i++){
			while(h[i]>0){
				write(h,i,h[i]-1,0,false,true);
				write(a,j++,i+n,0,true);
				if(++k*sl>=1)await sleep(k=0);
			}
		}
	}
	switch(shuffleType.value){
		case"Normal":
			await shuf(arr,0,L,1/delay);
			break;
		case"Reverse":
			await reversal(arr,0,L-1,1/delay,true);
			break;
		case"Slighty Shuffled":
			for(;i<maxVal(L/20|0,1);i++)
				await swap(arr,R.nextInt(L),R.nextInt(L),0,true);
			break;
		case"Naive":
			for(;i<L;i++){
				swap(arr,i,R.nextInt(L),0);
				if(++j*delay>=1)await sleep(j=0);
			}
			break;
		case"Shuffled Tail":
			while(i<L){
				mark(i);
				if(randBool(6/7))write(aux,k++,arr[i++],0,false,true);
				else await write(arr,j++,arr[i++],1,true);
			}
			await arraycopy(aux,0,arr,j,k,1,true);
			await shuf(arr,j,L,1);
			break;
		case"Shuffled Head":
			while(i<L){
				mark(i);
				if(randBool(6/7))write(aux,k++,arr[i++],0,false,true);
				else await write(arr,j++,arr[i++],1,true);
			}
			await arraycopy(aux,0,arr,j,k,1,true);
			await shuf(arr,j,L,1);
			for(i=j-1;i>=0;i--)
				await swap(arr,(L-j+i)%L,i%L,1,true);
			break;
		case"Shifted Elements":
			s=R.nextInt(L);
			d=R.nextInt(L);
			if(d<s)await IndexedRotations.holyGriesMills(arr,d,s,s+1,1,true);
			else await IndexedRotations.holyGriesMills(arr,s,s+1,d,1,true);
			break;
		case"Noisy":
			s=maxVal(4,sqrt(L)/2|0);
			for(;i+s<=L;i+=R.nextInt(s-1)+1)
				await shuf(arr,i,i+s,1);
			await shuf(arr,i,L,1);
			break;
		case"Shuffled Odds":
			for(i=1;i<L;i+=2)
				await swap(arr,i,(R.nextInt(L-i)/2|0)*2+i,0,true);
			break;
		case"Final Merge":
			for(c=2;j<c;j++)
				for(i=j;i<L;i+=c)
					write(tmp,k++,arr[i],0,false,true);
			for(i=0;i<L;i++)
				await write(arr,i,tmp[i],1,true);
			break;
		case"Shuffled Final Merge":
			await shuf(arr,0,L,.1);
			await sort(arr,0,L/2|0);
			await sort(arr,L/2|0,L);
			break;
		case"Shuffled Half":
			await shuf(arr,0,L,2/3);
			await sort(arr,0,L/2|0);
			break;
		case"Partitioned":
			await shuf(arr,0,L/2|0,.5);
			await shuf(arr,L/2|0,L,.5);
			break;
		case"Sawtooth":
			for(;j<4;j++)
				for(i=j;i<L;i+=4)
					write(tmp,k++,arr[i],0,false,true);
			for(i=0;i<L;i++)
				await write(arr,i,tmp[i],1,true);
			break;
		case"Pipe Organ":
			for(;i<L;i+=2)
				tmp[j++]=arr[i];
			for(i=1,j=L;i<L;i+=2)
				tmp[--j]=arr[i];
			for(i=0;i<L;i++)
				await write(arr,i,tmp[i],1,true);
			break;
		case"Final Bitonic Pass":
			await reversal(arr,0,L-1,.1,true);
			for(;i<L;i+=2)
				tmp[j++]=arr[i];
			for(i=1,j=L;i<L;i+=2)
				tmp[--j]=arr[i];
			for(i=0;i<L;i++)
				await write(arr,i,tmp[i],0,true);
			break;
		case"Interlaced":
			arraycopy(arr,0,aux,0,L);
			j=1;
			k=L-1;
			for(i=1;i<L;i++)
				if(i%2)await write(arr,i,aux[k--],1,true);
				else await write(arr,i,aux[j++],1,true);
			break;
		case"Double Layered":
			for(;i<L/2|0;i+=2)
				await swap(arr,i,L-i-1,0,true);
			break;
		case"Final Radix":
			l=L;l-=l%2;m=l/2|0;
			tmp=new Array(m);
			for(;i<m;i++)
				write(tmp,i,arr[i],0,false,true);
			for(i=m;i<l;i++,j+=2){
				await write(arr,j,arr[i],1,true);
				await write(arr,j+1,tmp[i-m],1,true);
			}
			break;
		case"Real Final Radix":
			c=2;e=1;p=0;
			m=minVal(...arr);
			x=maxVal(...arr);
			for(;(x-m)/e>=1&&p++<2;e*=10){
				b=new Array(10).fill(0);
				o=new Array(L);
				for(n=0;n<L;n++)
					b[((arr[n]-m)/e)%10|0]++;
				for(n=1;n<10;n++)
					b[n]+=b[n-1];
				for(n=L-1;n>=0;n--)
					o[--b[((arr[n]-m)/e)%10|0]]=arr[n];
				for(n=0;n<L;n++)
					await write(arr,n,o[n],1,true);
			}
			break;
		case"Recursive Final Radix":
			w=async(A,p,l,g)=>{
				if(l<2)return;
				let m2=l%2;
				l-=m2;
				let m=l/2|0;
				let t=new Array(m);
				for(let i=p,j=0;i<p+g*m;i+=g,j++)
					write(t,j,A[i],0,false,true);
				for(let i=p+g*m,j=p,k=0;i<p+g*l;i+=g,j+=2*g,k++){
					await write(A,j,A[i],0,true);
					await write(A,j+g,t[k],0,true);
				}
				await w(A,p,m+m2,2*g);
				await w(A,p+g,m,2*g);
			}
			await w(arr,0,L,1);
			break;
		case"Half Rotation":
			m=(L+1)/2|0;
			if(L%2){
				t=arr[i];
				while(m<L){
					await write(arr,i++,arr[m],1,true);
					await write(arr,m++,arr[i],1,true);
				}
				await write(arr,i,t,1,true);
			}else while(m<L)
				await swap(arr,i++,m++,1,true);
			break;
		case"Half Reversed":
			await reversal(arr,0,L-1,.25,true);
			await reversal(arr,L/4|0,(3*L+3)/4-1|0,.25,true);
			break;
		case"Logarithmic Slopes":
			for(;i<L;i++)
				write(tmp,i,arr[i],0,false,true);
			await write(arr,0,0,1,true);
			for(i=1;i<L;i++){
				l=log(i)/log(2)|0;
				p=2**l;
				v=tmp[2*(i-p)+1];
				await write(arr,i,v,1,true);
			}
			break;
		case"Heapified":
			h=new HeapSorting(true);
			await h.heapify(arr,0,L,1);
			break;
		case"Triangular Heapified":
			s=async(a,e,r)=>{
				const trt=v=>sqrt((8*v+1)-1)/2|0;
				let t=a[r],ln=trt(r),l=r+ln+1,ri=l+1;
				while(l<e){
					if(ri>=e){
						if(compareValues(a[l],t)>0)await write(a,r,a[l],1,true);
						break;
					}
					let mx=compareIndices(a,ri,l)<1?l:ri;
					if(compareValues(a[mx],t)>0){
						await write(a,r,a[r=mx],1,true);
						ln=trt(r);l=r+ln+1;ri=l+1;
						continue;
					}
					break;
				}
				await write(a,r,t,1,true);
			}
			for(let i=L-1;i>=0;i--)await s(arr,L,i);
			break;
		case"First Circle Pass":
			await shuf(arr,0,L,.2);
			let cs=async(A,lo,hi,e)=>{
				if(lo==hi)return;
				let h=hi;
				let l=lo;
				let m=(hi-lo)/2|0;
				while(lo<hi){
					if(hi<e&&compareIndices(A,lo,hi)>0)
						await swap(A,lo,hi,1,true);
					lo++;hi--;
				}
				await cs(A,l,l+m,e);
				if(l+m+1<e)await cs(A,l+m+1,h,e);
			}
			for(n=1;n<L;n*=2);
			await cs(arr,0,n-1,L);
			break;
		case"Final Pairwise Pass":
			await shuf(arr,0,L,1);
			tmp=[];aux=[];
			for(i=1;i<L;i+=2)
				if(compareIndices(arr,i-1,i)>0)
					await swap(arr,i-1,i,1,true);
			for(i=0;i<L;i++){
				if(i%2)tmp[k++]=arr[i];
				else aux[j++]=arr[i];
			}
			aux.sort((a,b)=>a-b);tmp.sort((a,b)=>a-b);
			for(i=0,j=0,k=0;i<L;i++){
				if(i%2)await write(arr,i,tmp[k++],1,true);
				else await write(arr,i,aux[j++],1,true);
			}
			break;
		case"Recursive Reversal":
			r=async(a,b)=>{
				if(b-a<2)return;
				await reversal(arr,a,b-1,.2,true);
				let m=(a+b)/2|0;
				await r(a,m);
				await r(m,b);
			}
			await r(0,L);
			break;
		case"Gray Code Fractal":
			r=async (a,b,d)=>{
				if(b-a<3)return;
				let m=(a+b)/2|0;
				if(d)await reversal(arr,a,m-1,.2,true);
				else await reversal(arr,m,b-1,.2,true);
				await r(a,m,false);
				await r(m,b,true);
			}
			await r(0,L,false);
			break;
		case"Sierpinski Triangle":
			t=(tm,a,b)=>{
				if(b-a<2)return;if(b-a==2)return tm[a+1]++;
				let h=(b-a)/3|0,t1=(a+a+b)/3|0,t2=(a+b+b+2)/3|0;
				for(let i=a;i<t1;i++)tm[i]+=h;
				for(let i=t1;i<t2;i++)tm[i]+=2*h;
				t(tm,a,t1);
				t(tm,t1,t2);
				t(tm,t2,b);
			}
			t(tmp,0,L);
			aux=[...arr];
			for(let i=0;i<L;i++)
				await write(arr,i,aux[tmp[i]]);
			break;
		case"Triangular":
			k=2;m=0;
			for(i=1;i<L;i++,j++){
				if(i==k){
					j=0;
					k*=2;
				}
				tmp[i]=tmp[j]+1;
				if(tmp[i]>m)m=tmp[i];
			}
			c=new Array(m+1).fill(0);
			for(i=0;i<L;i++)c[tmp[i]]++;
			for(i=1;i<c.length;i++)c[i]+=c[i-1];
			for(i=L-1;i+1;i--)tmp[i]=--c[tmp[i]];
			aux=[...arr];
			for(i=0;i<L;i++)
				await write(arr,i,aux[tmp[i]],1,true);
			break;
		case"Quicksort Adversary":
			for(j=L-L%2-2,i=j-1;i>=0;i-=2,j--)
				await swap(arr,i,j,1,true);
			break;
		case"Grailsort Adversary":
			r=async(A,a,m,b)=>{
				await reversal(A,a,m-1,.1,true);
				await reversal(A,m,b-1,.1,true);
				await reversal(A,a,b-1,.1,true);
			}
			p=async(A,a,b,bL)=>{
				let l=b-a,b1=b-l%bL,l1=b1-a;
				if(l1<=2*bL)return;
				let m=bL;
				while(2*m<l)m*=2;
				m+=a;
				if(b1-m<bL)await p(A,a,m,bL);
				else{
					m=a+b1-m;
					await r(A,m-bL+2,b1-bL+1,b1);
					await multiSwap(A,a,m,.1,true);
					await r(A,a,m,b1);
					m=a+b1-m;
					await p(A,a,m,bL);
					await p(A,m,b,bL);
				}
			}
			if(L<17)await reversal(arr,0,L-1,.5,true);
			else{
				let bL=1;
				while(bL*bL<L)bL*=2;
				let nK=(L-1)/bL+1|0;
				let k=bL+nK;
				await shuf(arr,0,L,.25);
				await sort(arr,0,k,);
				await reversal(arr,0,k-1,.25,true);
				await sort(arr,k,L);
				await p(arr,k,L,bL);
			}
			break;
		case"Shuffle Merge Adversary":
			d=2;
			e=1<<(log(L-1)/log(2)+1|0);
			sm=async(A,T,a,m,b)=>{
				if((b-a)%2){
					if(m-a>b-m)a++;
					else b--;
				}
				await sb(A,T,a,b);
			}
			sb=async(A,T,a,b)=>{
				if(b-a<2)return;
				let m=(a+b)/2|0;
				let s=(b-a-1)/4+1|0;
				a=m-s;b=m+s;
				let j=a;
				for(let i=a+1;i<b;i+=2)
					write(T,j++,A[i],0,false,true);
				for(let i=a;i<b;i+=2)
					write(T,j++,A[i],0,false,true);
				await arraycopy(T,a,A,a,b-a,1,true);
			}
			while(d<=e){
				i=c=0;
				while(i<L){
					j=i;c+=L;
					while(c>=d){
						c-=d;
						j++;
					}
					k=j;c+=L;
					while(c>=d){
						c-=d;
						k++;
					}
					await sm(arr,tmp,i,j,k);
					i=k;
				}
				d*=2;
			}
			break;
		case"Bit Reversal":
			e=1<<(log(L)/log(2)|0);
			p=e==L;
			tmp=[...arr];
			for(i=0;i<e;i++)arr[i]=i;
			m=0;
			d1=e>>1;d2=d1+(d1>>1);
			for(i=1;i<e-1;i++){
				j=d1;
				for(
					k=i,n=d2;
					!(k&1);
					j-=n,k>>=1,n>>=1
				);
				m+=j;
				if(m>i)await swap(arr,i,m,1,true);
			}
			if(!p){
				for(i=e;i<L;i++)
					await write(arr,i,arr[i-e],.5,true);
				cnt=new Array(e).fill(0);
				for(i=0;i<L;i++)
					cnt[arr[i]]++;
				for(i=1;i<cnt.length;i++)
					cnt[i]+=cnt[i-1];
				for(i=L-1;i+1;i--)
					await write(arr,i,--cnt[arr[i]],.5,true);
			}
			aux=[...arr];
			for(i=0;i<L;i++)
				await write(arr,i,tmp[aux[i]],0,true);
			break;
		case"Randomly w/ Blocks":
			p=v=>{
				let a;
				for(a=1;a<=v;a<<=1);
				return a>>1;
			}
			z=p(sqrt(L)|0);
			b=async(A,a,b,l)=>{
				for(let i=0;i<l; i++)
					await swap(A,a+i,b+i,1,true);
			}
			for(i=0;i<L;i+=z)
				await b(arr,i,R.nextInt((L-i)/z|0)*z+i,z);
			break;
		case"Block Reverse":
			e=L;
			p=v=>{
				let a;
				for(a=1;a<=v;a<<=1);
				return a>>1;
			}
			z=p(sqrt(L)|0);
			b=async(A,a,b,l)=>{
				for(let i=0;i<l; i++)
					await swap(A,a+i,b+i,1,true);
			}
			e-=e%z;
			i=0;j=e-z;
			while(i<j){
				await b(arr,i,j,z);
				i+=z;
				j-=z;
			}
			break;
	}
	await sleep(100);
	shuffling=false;
}
function randInt(s=0,e=2){
	return random()*(e-s)+s|0;
}
function randBool(n=.5){
	return random()>n;
}
async function bogoSwap(A,s,l,sl,x){
	for(let i=s;i<l;++i){
		swap(A,i,randInt(i,l),0,sl>0,x);
		if(sl>0)await sleep(sl);
	}
}
async function bogoCombo(A,s,l,z,x){
	for(let i=s;i<l;++i)
		await write(A,i,0,0,true,x);
	for(let i=l-z;i<l;++i){
		let j=randInt(s,i+1);
		await write(A,compareValues(A[j],0)?i:j,1,0,true,x);
	}
}
function isRangeSorted(A,s,e){
	for(let i=s;i<e-1;++i)if(compareIndices(A,i,i+1)>0)return false;
	return true;
}
function isArraySorted(A,l){
	return isRangeSorted(A,0,l);
}
function isRangePartitioned(A,s,p,e){
	for(let i=s;i<p;i++)if(compareIndices(A,i,p)>0)return false;
	for(let i=p+1;i<e;i++)if(compareIndices(A,p,i)>0)return false;
	return true;
}
function isMinSorted(A,s,e){
	return isRangePartitioned(A,s,s,e);
}
function isMaxSorted(A,s,e){
	return isRangePartitioned(A,s,e-1,e);
}
function isRangeSplit(A,s,m,e){
	let lM=A[s];
	if(stopped)return A.sort((a,b)=>a-b),draw();
	for(let i=s+1;i<m;++i)if(compareValues(lM,A[i])<0)lM=A[i];
	for(let i=m;i<e;++i)if(compareValues(lM,A[i])>0)return false;
	return true;
}
function analyzeMaxLog(a,l,b){
	let m=0,i;
	for(i=0;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return log(m)/log(b)|0;
}
function analyzeMaxCeilingLog(A,l,b){
	let x=0;
	for(let i=0;i<l;i++){
		let v=A[i];
		if(v>x)x=v;
	}
	return log(x)/log(b)|0;
}
function analyzeBit(a,l){
	draw();
	let m=0;
	for(let i=0;i<l;i++){
		let v=a[i];
		if(v>m)m=v;
	}
	return 31-clz32(m);
}
function getDigit(a,p,r){
	return(a/pow(r,p)|0)%r;
}
function getBit(n,k){
	return(n>>k&1)==1;
}
//Sort Functions
async function insertSort(a,s,l,sl,x){
	let j=0,sd=false;
	for(let i=s;i<l;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0){
			write(a,p+1,a[p--],0,false,x);
			if(++j*sl>=1){
				sd=true;
				if(!x)mark(p+2);
				await sleep(j=0);
			}
		}
		write(a,p+1,c,0,false,x);
	}
}
async function binaryInsertion(A,s,e,sl){
	let k=0;
	for(let i=s;i<e;i++){
		let n=A[i],l=s,h=i;
		while(l<h){
			let m=l+(h-l)/2|0;
			if(compareValues(n,A[m])<0)h=m;
			else l=m+1;
		}
		let j=i-1;
		while(j>=l){
			write(A,j+1,A[j--],0);
			if(++k*sl>=1){
				mark(j+2);
				await sleep(k=0);
			}
		}
		await write(A,l,n,0,true);
	}
}
async function binaryDoubleInsertion(A,a,b){
	function leftBinarySearch(A,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	function rightBinarySearch(A,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	let k=0;
	async function insertToLeft(A,a,b,t){
		while(a>b){
			write(A,a,A[--a],0);
			if(++k>=arr_size){
				mark(a+1);
				await sleep(k=0);
			}
		}
		await write(A,b,t,0,true);
	}
	async function insertToRight(A,a,b,t){
		while(a<b){
			write(A,a,A[++a],0);
			if(++k>=arr_size){
				mark(a-1);
				await sleep(k=0);
			}
		}
		await write(A,a,t,0,true);
	}
	async function doubleInsertion(A,a,b){
		if(b-a<2)return;
		let j=a+(b-a-2)/2+1|0,i=a+(b-a-1)/2|0;
		if(j>i&&compareIndices(A,i,j)>0)
			await swap(A,i,j,0,true,false);
		i--;j++;
		while(j<b){
			if(compareIndices(A,i,j)>0){
				let l=A[j],r=A[i],m=rightBinarySearch(A,i+1,j,l);
				await insertToRight(A,i,m-1,l);
				await insertToLeft(A,j,leftBinarySearch(A,m,j,r),r);
			}else{
				let l=A[i],r=A[j],m=leftBinarySearch(A,i+1,j,l);
				await insertToRight(A,i,m-1,l);
				await insertToLeft(A,j,rightBinarySearch(A,m,j,r),r);
			}
			i--;j++;
		}
	}
	await doubleInsertion(A,a,b);
}
async function cocktailShaker(a,s,l,sl=1,x){
	let k=0;
	for(let i=s;i<(l/2|0)+s;){
		let sw=true;
		for(let j=i;j<l+s-i-1;j++)
			if(compareIndices(a,j,j+1)>0){
				sw=false;
				swap(a,j,j+1,0,false,x);
				if(++k*sl>=1){
					mark(j);
					await sleep(k=0);
				}
			}
		for(let j=l+s-i-1;j>i;j--)
			if(compareIndices(a,j,j-1)<0){
				sw=false;
				swap(a,j,j-1,0,false,x);
				if(++k*sl>=1){
					mark(j);
					await sleep(k=0);
				}
			}
		if(sw)break;else i++;
	}
	draw();
}
async function iterativeCircleSortRoutine(A,l){
	let e=arr_size,sc=0;
	for(let g=l/2|0;g>0;g=g/2|0){
		for(let st=0;st+g<e;st+=2*g){
			let hi=st+2*g-1,lo=st;
			while(lo<hi){
				if(hi<e&&compareIndices(A,lo,hi)>0){
					await swap(A,lo,hi,0,true);
					sc++;
				}
				lo++;hi--;
			}
		}
	}
	return sc;
}
async function recursiveCircleSortRoutine(A,lo,hi,sc){
	if(lo==hi)return sc;
	let e=arr_size,h=hi,l=lo,m=(hi-lo)/2|0;
	while(lo<hi){
		if(hi<e&&compareIndices(A,lo,hi)>0){
			await swap(A,lo,hi,0,true);
			sc++;
		}
		lo++;
		hi--;
	}
	sc=await recursiveCircleSortRoutine(A,l,l+m,sc);
	if(l+m+1<e)sc=await recursiveCircleSortRoutine(A,l+m+1,h,sc);
	return sc;
}
class Random{
	nextInt(l,h){
		if(h===undefined)return Math.random()*l|0;
		else{
			let n=minVal(l,h);
			let x=maxVal(l,h);
			return random()*(x-n)+n|0;
		}
	}
	next(){
		return random();
	}
}
//Sort Classes
class TimSorting{
	G=7;sS=0;
	static getMinRun(){
		return 16;
	}
	constructor(a,l){
		this.a=a;
		this.len=l;
		let nA=new Array(l<512?l>>>1:256);
		this.tmp=nA;
		let sL=l<120?5:l<1542?10:l<119151?19:40;
		this.rB=new Array(sL);
		this.rL=new Array(sL);
	}
	async customSort(a,s,l){
		await TimSorting.sort(this,a,s,l);
	}
	static async sort(ts,a,lo,hi){
		let nR=hi-lo;
		if(nR<32)return await ts.binarySort(a,lo,hi,lo+await ts.countRunAndMakeAscending(a,lo,hi));
		let mR=ts.minRunLength(nR);
		do{
			let rL=await ts.countRunAndMakeAscending(a,lo,hi);
			if(rL<mR){
				let f=nR<=mR?nR:mR;
				await ts.binarySort(a,lo,lo+f,lo+rL);
				rL=f;
			}
			ts.pushRun(lo,rL);
			await ts.mergeCollapse();
			lo+=rL;nR-=rL;
		}while(nR);
		await ts.mergeForceCollapse();
	}
	async binarySort(a,lo,hi,s){
		if(s==lo)s++;
		for(;s<hi;s++){
			let p=a[s],l=lo,r=s;
			while(l<r){
				let m=l+r>>>1;
				if(compareValues(p,a[m])<0)r=m;
				else l=m+1;
			}
			let n=s-l;
			switch(n){
				case 2:await write(a,l+2,a[l+1],1,true);
				case 1:await write(a,l+1,a[l],1,true);break;
				default:await arraycopy(a,l,a,l+1,n,1,true);
			}
			await write(a,l,p,1,true);
		}
	}
	async countRunAndMakeAscending(a,lo,hi){
		let rH=lo+1;
		if(rH==hi)return 1;
		if(compareIndices(a,rH++,lo)<0){
			while(rH<hi&&compareIndices(a,rH,rH-1)<0)rH++;
			await reversal(a,lo,rH-1,1,true);
		}else while(rH<hi&&compareIndices(a,rH-1,rH)<1)rH++;
		return rH-lo;
	}
	minRunLength(n){
		let r=0;
		while(n>31){
			r|=n&1;
			n>>=1;
		}
		return n+r;
	}
	pushRun(rB,rL){
		this.rB[this.sS]=rB;
		this.rL[this.sS++]=rL;
	}
	async mergeCollapse(){
		while(this.sS>1){
			let n=this.sS-2;
			if((n>0&&this.rL[n-1]<=this.rL[n]+this.rL[n+1])||(n>1&&this.rL[n-2]<=this.rL[n]+this.rL[n-1])){
				if(this.rL[n-1]<this.rL[n+1])n--;
			}else if(this.rL[n]>this.rL[n+1])break;
			await this.mergeAt(n);
		}
	}
	async mergeForceCollapse(){
		while(this.sS>1){
			let n=this.sS-2;
			if(n>0&&this.rL[n-1]<this.rL[n+1])n--;
			await this.mergeAt(n);
		}
	}
	async mergeAt(i){
		let b1=this.rB[i],b2=this.rB[i+1];
		let l1=this.rL[i],l2=this.rL[i+1];
		this.rL[i]=l1+l2;
		if(i==this.sS-3){
			this.rB[i+1]=this.rB[i+2];
			this.rL[i+1]=this.rL[i+2];
		}
		this.sS--;
		let k=this.gallopRight(this.a[b2],this.a,b1,l1,0);
		b1+=k;l1-=k;
		if(!l1)return;
		l2=this.gallopLeft(this.a[b1+l1-1],this.a,b2,l2,l2-1);
		if(!l2)return;
		if(l1<=l2)await this.mergeLo(this,b1,l1,b2,l2);
		else await this.mergeHi(this,b1,l1,b2,l2);
	}
	gallopLeft(k,a,b,l,h){
		let lO=0,of=1;
		if(compareValues(k,a[b+h])>0){
			let mO=l-h;
			while(of<mO&&compareValues(k,a[b+h+of])>0){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;
			lO+=h;of+=h;
		}else{
			let mO=h+1;
			while(of<mO&&compareValues(k,a[b+h-of])<1){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;
			let t=lO;
			lO=h-of;of=h-t;
		}
		lO++;
		while(lO<of){
			let m=lO+(of-lO>>>1);
			if(compareValues(k,a[b+m])>0)lO=m+1; 
			else of=m;
		}
		return of;
	}
	gallopRight(k,a,b,l,h){
		let of=1,lO=0;
		if(compareValues(k,a[b+h])<0){
			let mO=h+1;
			while(of<mO&&compareValues(k,a[b+h-of])<0){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;
			let t=lO;
			lO=h-of;of=h-t;
		}else{
			let mO=l-h;
			while(of<mO&&compareValues(k,a[b+h+of])+1){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;
			lO+=h;of+=h;
		}
		lO++;
		while(lO<of){
			let m=lO+(of-lO>>>1);
			if(compareValues(k,a[b+m])<0)of=m;
			else lO=m+1;
		}
		return of;
	}
	async mergeLo(ts,b1,l1,b2,l2){
		let a=ts.a,tmp=ts.ensureCapacity(l1);
		arraycopy(a,b1,tmp,0,l1,0,false,true);
		let c1=0,c2=b2,ds=b1;
		await write(a,ds++,a[c2++],1);
		if(!--l2)return await arraycopy(tmp,c1,a,ds,l1,1,true);
		if(l1==1){
			await arraycopy(a,c2,a,ds,l2,1,true);
			await write(a,ds+l2,tmp[c1],1);
			return;
		}
		let mG=ts.G;
		outer:while(1){
			let cn1=0,cn2=0;
			do{
				if(compareValues(a[c2],tmp[c1])<0){
					await write(a,ds++,a[c2++],1,true);
					cn2++;cn1=0;
					if(!--l2)break outer;
				}else{
					await write(a,ds++,tmp[c1++],1,true);
					cn1++;cn2=0;
					if(--l1==1)break outer;
				}
			}while((cn1|cn2)<mG);
			do{
				cn1=ts.gallopRight(a[c2],tmp,c1,l1,0);
				if(cn1){
					await arraycopy(tmp,c1,a,ds,cn1,1,true);
					ds+=cn1;c1+=cn1;l1-=cn1;
					if(l1<2)break outer;
				}
				await write(a,ds++,a[c2++],1,true);
				if(!--l2)break outer;
				cn2=ts.gallopLeft(tmp[c1],a,c2,l2,0);
				if(cn2){
					await arraycopy(a,c2,a,ds,cn2,1,true);
					ds+=cn2;c2+=cn2;l2-=cn2;
					if(!l2)break outer;
				}
				await write(a,ds++,tmp[c1++],1,true);
				if(--l1==1)break outer;
				mG--;
			}while(cn1>6|cn2>6);
			if(mG<0)mG=0;
			mG+=2; 
		}
		ts.G=mG<1?1:mG;
		if(l1==1){
			await arraycopy(a,c2,a,ds,l2,1,true);
			await write(a,ds+l2,tmp[c1],1,true);
		}else if(!l1)throw"violates contract!";
		else await arraycopy(tmp,c1,a,ds,l1,1,true);
	}
	async mergeHi(ts,b1,l1,b2,l2){
		let a=ts.a,tmp=ts.ensureCapacity(l2);
		arraycopy(a,b2,tmp,0,l2,0,false,true);
		let c1=b1+l1-1,c2=l2-1,ds=b2+l2-1;
		await write(a,ds--,a[c1--],1);
		if(!--l1)return await arraycopy(tmp,0,a,ds-l2+1,l2,1,true);
		if(l2==1){
			ds-=l1;c1-=l1;
			await arraycopy(a,c1+1,a,ds+1,l1,1,true);
			await write(a,ds,tmp[c2],1);
			return;
		}
		let mG=ts.G;
		outer:while(1){
			let cn1=0,cn2=0;
			do{
				if(compareValues(tmp[c2],a[c1])<0){
					await write(a,ds--,a[c1--],1,true);
					cn1++;cn2=0;
					if(!--l1)break outer;
				}else{
					await write(a,ds--,tmp[c2--],1,true);
					cn2++;cn1=0;
					if(--l2==1)break outer;
				}
			}while((cn1|cn2)<mG);
			do{
				cn1=l1-this.gallopRight(tmp[c2],a,b1,l1,l1-1);
				if(cn1){
					ds-=cn1;c1-=cn1;l1-=cn1;
					await arraycopy(a,c1+1,a,ds+1,cn1,1,true);
					if(!l1)break outer;
				}
				await write(a,ds--,tmp[c2--],1);
				if(--l2==1)break outer;
				cn2=l2-this.gallopLeft(a[c1],tmp,0,l2,l2-1);
				if(cn2){
					ds-=cn2;c2-=cn2;l2-=cn2;
					await arraycopy(tmp,c2+1,a,ds+1,cn2,1,true);
					if(l2<2)break outer;
				}
				await write(a,ds--,a[c1--],1,true);
				if(!--l1)break outer;
				mG--;
			}while(cn1>6|cn2>6);
			if(mG<0)mG=0;
			mG+=2;
		}
		ts.G=mG<1?1:mG;
		if(l2==1){
			ds-=l1;c1-=l1;
			await arraycopy(a,c1+1,a,ds+1,l1,1,true);
			await write(a,ds,tmp[c2],1,true);
		}else if(!l2)throw"violates contract!";
		else await arraycopy(tmp,0,a,ds-l2+1,l2,1,true);
	}
	ensureCapacity(m){
		if(this.tmp.length<m){
			let n=m;
			for(let i=0;i<5;i++)n|=n>>(2**i)
			if(++n<0)n=m;
			else n=minVal(n,this.len>>>1);
			this.tmp=new Array(n);
		}
		return this.tmp;
	}
}
class PDQSorting{
	hs=new HeapSorting(true);
	lO=new Array(128);
	rO=new Array(128);
	pdqLog(n){
		let l=0;
		while(n>>=1)++l;
		return l;
	}
	pdqLessThan(a,b){
		counts.comp();
		return 1&((a<b?1231:1237)>>1);
	}
	async pdqInsertSort(A,b,e){
		if(b==e)return;
		for(let c=b+1;c-e;++c){
			let s=c,s1=c-1;
			if(compareIndices(A,s,s1)<0){
				let t=A[s];
				do await write(A,s--,A[s1],1,true);while(s-b&&compareValues(t,A[--s1])<0);
				await write(A,s,t,1,true);
			}
		}
	}
	async pdqUnguardInsertSort(A,b,e){
		if(b==e)return;
		for(let c=b+1;c-e;++c){
			let s=c,s1=c-1;
			if(compareIndices(A,s,s1)<0){
				let t=A[s];
				do await write(A,s--,A[s1],1,true);while(compareValues(t,A[--s1])<0);
				await write(A,s,t,1,true);
			}
		}
	}
	async pdqPartialInsertSort(A,b,e){
		if(b==e)return true;
		let l=0;
		for(let c=b+1;c-e;++c){
			if(l>8)return false;
			let s=c,s1=c-1;
			if(compareIndices(A,s,s1)<0){
				let t=A[s];
				do await write(A,s--,A[s1],1,true);while(s-b&&compareValues(t,A[--s1])<0);
				await write(A,s,t,1,true);
				l+=c-s;
			}
		}
		return true;
	}
	async pdqSortTwo(A,a,b){
		if(compareIndices(A,b,a)<0)
			await swap(A,a,b,1,true);
	}
	async pdqSortThree(A,a,b,c){
		await this.pdqSortTwo(A,a,b);
		await this.pdqSortTwo(A,b,c);
		await this.pdqSortTwo(A,a,b);
	}
	async pdqSwapOffsets(A,s,e,lOs,lOP,rOs,rOP,n,u){
		if(u){
			for(let i=0;i<n;++i)
				await swap(A,s+lOs[lOP+i],e-rOs[rOP+i],1,true);
		}else if(n>0){
			let l=s+lOs[lOP],r=e-rOs[rOP];
			let t=A[l];
			await write(A,l,A[r],1,true);
			for(let i=1;i<n;++i){
				await write(A,r,A[l=s+lOs[lOP+i]],1,true);
				await write(A,l,A[r=e-rOs[rOP+i]],1,true);
			}
			await write(A,r,t,1,true);
		}
	}
	async pdqPartRightBranchless(A,b,e){
		let pv=A[b];
		let f=b,l=e;
		while(this.pdqLessThan(A[++f],pv)==1);
		if(f-1==b)while(f<l&&!this.pdqLessThan(A[--l],pv));
		else while(!this.pdqLessThan(A[--l],pv));
		let aP=f>=l,lN,rN,lS,rS;
		if(!aP)await swap(A,f++,l,1,true);
		lN=rN=lS=rS=0;
		while(l-f>128){
			if(!lN){
				lS=0;
				let it=f;
				for(let i=0;i<64;)for(let j=0;j<8;j++){
					this.lO[lN]=i++;
					lN+=abs(this.pdqLessThan(A[it++],pv)-1);
					counts.aux++;
				}
			}
			if(!rN){
				rS=0;
				let it=l;
				for(let i=0;i<64;)for(let j=0;j<8;j++){
					this.rO[rN]=++i;
					rN+=this.pdqLessThan(A[--it],pv);
					counts.aux++;
				}
			}
			let n=minVal(lN,rN);
			await this.pdqSwapOffsets(A,f,l,this.lO,lS,this.rO,rS,n,lN==rN);
			lN-=n;rN-=n;
			lS+=n;rS+=n;
			if(!lN)f+=64;
			if(!rN)l-=64;
		}
		let lZ=0,rZ=0;
		let uL=l-f-((rN||lN)?64:0);
		if(rN){
			lZ=uL;
			rZ=64;
		}else if(lN){
			lZ=64;
			rZ=uL;
		}else{
			lZ=uL/2|0;
			rZ=uL-lZ;
		}
		if(uL&&!lN){
			lS=0;
			let it=f;
			for(let i=0;i<lZ;){
				this.lO[lN]=i++;
				lN+=abs(this.pdqLessThan(A[it++],pv)-1);
				counts.aux++;
			}
		}
		if(uL&&!rN){
			rS=0;
			let it=l;
			for(let i=0;i<rZ;){
				this.rO[rN]=++i;
				rN+=this.pdqLessThan(A[--it],pv);
				counts.aux++;
			}
		}
		let n=minVal(lN,rN);
		await this.pdqSwapOffsets(A,f,l,this.lO,lS,this.rO,rS,n,lN==rN);
		lN-=n;rN-=n;
		lS+=n;rS+=n;
		if(!lN)f+=lZ;
		if(!rN)l-=rZ;
		let lP=0,rP=0;
		if(lN){
			lP+=lS;
			while(lN--)await swap(A,f+this.lO[lP+lN],--l,1,true);
			f=l;
		}
		if(rN){
			rP+=rS;
			while(rN--)await swap(A,l-this.rO[rP+rN],f++,1,true);
			l=f;
		}
		let pvP=f-1;
		await write(A,b,A[pvP],1,true);
		await write(A,pvP,pv,1,true);
		return[pvP,aP];
	}
	async pdqPartRight(A,b,e){
		let pv=A[b];
		let f=b,l=e;
		while(compareValues(A[++f],pv)<0);
		if(f-1==b)while(f<l&&compareValues(pv,A[--l])<1);
		else while(compareValues(pv,A[--l])<1);
		let aP=f>=l;
		while(f<l){
			await swap(A,f,l,1,true);
			while(compareValues(A[++f],pv)<0);
			while(compareValues(pv,A[--l])<1);
		}
		let pvP=f-1;
		await write(A,b,A[pvP],1,true);
		await write(A,pvP,pv,1,true);
		return[pvP,aP];
	}
	async pdqPartLeft(A,b,e){
		let pv=A[b];
		let f=b,l=e;
		while(compareValues(pv,A[--l])<0);
		if(l+1==e)while(f<l&&compareValues(A[++f],pv)<1);
		else while(compareValues(A[++f],pv)<1);
		while(f<l){
			await swap(A,f,l,1,true);
			while(compareValues(pv,A[--l])<0);
			while(compareValues(A[++f],pv)<1);
		}
		let pvP=l;
		await write(A,b,A[pvP],1,true);
		await write(A,pvP,pv,1,true);
		return pvP;
	}
	async pdqLoop(A,b,e,br,bA){
		let lm=true;
		while(1){
			let z=e-b;
			if(z<24){
				if(lm)await this.pdqInsertSort(A,b,e);
				else await this.pdqUnguardInsertSort(A,b,e);
				return;
			}
			let hf=z/2|0;
			if(z>128){
				await this.pdqSortThree(A,b,b+hf,e-1);
				await this.pdqSortThree(A,b+1,b+hf-1,e-2);
				await this.pdqSortThree(A,b+2,b+hf+1,e-3);
				await this.pdqSortThree(A,b+hf-1,b+hf,b+hf+1);
				await swap(A,b,b+hf,1,true);
			}else await this.pdqSortThree(A,b+hf,b,e-1);
			if(!lm&&compareIndices(A,b,b-1)<1){
				b=await this.pdqPartLeft(A,b,e)+1;
				continue;
			}
			let[pvP,aP]=br?await this.pdqPartRightBranchless(A,b,e):await this.pdqPartRight(A,b,e);
			let lZ=pvP-b,rZ=e-pvP-1;
			if(lZ<(z/8|0)||rZ<(z/8|0)){
				if(!--bA)return await this.hs.sort(A,b,e);
				if(lZ>23){
					await swap(A,b,b+lZ/4,65,true);
					await swap(A,pvP-1,pvP-lZ/4,65,true);
					if(lZ>128){
						await swap(A,b+1,b+lZ/4+1,65,true);
						await swap(A,b+2,b+lZ/4+2,65,true);
						await swap(A,pvP-2,pvP-lZ/4-1,65,true);
						await swap(A,pvP-3,pvP-lZ/4-2,65,true);
					}
				}
				if(rZ>23){
					await swap(A,pvP+1,pvP+1+rZ/4,65,true);
					await swap(A,e-1,e-rZ/4,65,true);
					if(rZ>128){
						await swap(A,pvP+2,pvP+2+rZ/4,65,true);
						await swap(A,pvP+3,pvP+3+rZ/4,65,true);
						await swap(A,e-2,e-1-rZ/4,65,true);
						await swap(A,e-3,e-2-rZ/4,65,true);
					}
				}
			}else if(aP&&await this.pdqPartialInsertSort(A,b,pvP)&&await this.pdqPartialInsertSort(A,pvP+1,e))return;
			await this.pdqLoop(A,b,pvP,br,bA);
			b=pvP+1;
			lm=false;
		}
	}
}
class MultiWayMergeSorting{
	keyLessThan(s,p,a,b){
		let c=compareIndices(s,p[a],p[b]);
		return c<0||(!c&&compareValues(a,b)<0);
	}
	siftDown(s,h,p,t,r,z){
		while(2*r+2<z){
			let n=2*r+1;
			let m=n+(this.keyLessThan(s,p,h[n],h[n+1])?0:1);
			if(this.keyLessThan(s,p,h[m],t))
				write(h,r,h[r=m],0,false,true);
			else break;
		}
		let m=2*r+1;
		if(m<z&&this.keyLessThan(s,p,h[m],t))
			write(h,r,h[r=m],0,false,true);
		write(h,r,t,0,false,true);
	}
	async kWayMerge(s,d,h,a,b,z,x){
		for(let i=0;i<z;i++)
			write(h,i,i,0,false,true);
		for(let i=(z-1)/2|0;i>=0;i--)
			this.siftDown(s,h,p,h[i],i,z);
		for(let i=0;z>0;i++){
			let m=h[0];
			write(d,i,s[a[m]],0.5,!x,x);
			if(!x)await sleep();
			write(a,m,a[m]+1,0,false,true);
			if(a[m]==b[m])this.siftDown(s,h,a,h[--z],0,z);
			else this.siftDown(s,h,a,h[0],0,z);
		}
	}
}
class HeapSorting{
	j=0;
	constructor(isMax){
		this.m=isMax;
	}
	async siftDown(A,r,d,s,sl){
		let v=this.m?-1:1;
		while(r<=(d/2|0)){
			let l=2*r;
			if(l<d&&compareIndices(A,s+l-1,s+l)==v)l++;
			if(compareIndices(A,s+r-1,s+l-1)==v){
				swap(A,s+r-1,s+l-1,0);
				if(++this.j*sl>=1){
					mark(s+r-1);
					await sleep(this.j=0);
				}
				r=l;
			}else break;
		}
	}
	async heapify(A,l,h,sl){
		let n=h-l;
		for(let i=n/2|0;i>=1;i--)
			await this.siftDown(A,i,n,l,sl);
	}
	async sort(A,s,l,sl=1){
		await this.heapify(A,s,l,sl);
		for(let i=l-s;i>1;i--){
			await swap(A,s,s+i-1,0,true);
			await this.siftDown(A,1,i-1,s,sl);
		}
		if(!this.m)await reversal(A,s,s+l-1,1,true);
	}
}
class BlockMergeSorting{
	async shiftFW(A,a,m,b){
		while(m<b)await swap(A,a++,m++,1,true);
	}
	async shiftBW(A,a,m,b){
		while(m>a)await swap(A,--b,--m,1,true);
	}
	async shiftFWExt(A,a,m,b){
		while(m<b)await write(A,a++,A[m++],1,true);
	}
	async shiftBWExt(A,a,m,b){
		while(m>a)await write(A,--b,A[--m],1,true);
	}
	async insertTo(A,a,b){
		let t=A[a];
		while(a>b)await write(A,a,A[--a],0.5,true);
		await write(A,b,t,0.5,true);
	}
	async insertToBW(A,a,b){
		let t=A[a];
		while(a<b)await write(A,a,A[++a],0.5,true);
		await write(A,a,t,0.5,true);
	}
	async multiSwap(A,a,b,l){
		for(let i=0;i<l;i++)
			await swap(A,a+i,b+i,1,true);
	}
	async rotate(A,a,m,b){
		await IndexedRotations.cycleReverse(A,a,m,b,1,true);
	}
	leftBinSearch(A,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	rightBinSearch(A,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	async buildRuns(A,a,b){
		let S=true;
		let i=a+1,j=a;
		while(i<b){
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,j,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			if(i<b){
				S=false;
				j=i-(i-j-1)%16-1;
			}
			while(i-j<16&&i<b)
				await this.insertTo(A,i,this.rightBinSearch(A,j,i,A[i++]));
			j=i++;
		}
		return S;
	}
	async findKeys(A,a,b,nK,n){
		let p=a,pE=a+nK;
		for(let i=pE;i<b&&nK<n;i++){
			let loc=this.leftBinSearch(A,p,pE,A[i]);
			if(pE==loc||compareIndices(A,i,loc)){
				await this.rotate(A,p,pE,i);
				let inc=i-pE;
				p+=inc;
				pE+=inc;
				await this.insertTo(A,pE++,loc+=inc);
				nK++;
			}
		}
		await this.rotate(A,a,p,pE);
		return nK;
	}
	async findKeysBW(A,a,b,nK,n){
		let p=b-nK,pE=b;
		for(let i=p-1;i>=a&&nK<n;i--){
			let loc=this.leftBinSearch(A,p,pE,A[i]);
			if(pE==loc||compareIndices(A,i,loc)){
				await this.rotate(A,i+1,p,pE);
				let inc=p-(i+1);
				loc-=inc;
				pE-=inc;
				p-=inc+1;
				nK++;
				await this.insertToBW(A,i,loc-1);
			}
		}
		await this.rotate(A,p,pE,b);
		return nK;
	}
	async binaryInsertion(A,a,b){
		for(let i=a+1;i<b;i++)
			await this.insertTo(A,i,this.rightBinSearch(A,a,i,A[i]));
	}
	boundCheck(A,a,m,b){
		return m>=b||compareIndices(A,m-1,m)<1;
	}
	async mergeBW(A,a,m,b,p){
		if(this.boundCheck(A,a,m,b))return;
		let pL=b-m;
		await this.multiSwap(A,m,p,pL);
		let i=pL-1,j=m-1,k=b-1;
		while(i>=0&&j>=a){
			if(compareIndices(A,j,p+i)<1)
				await swap(A,k--,p+(i--),1,true);
			else
				await swap(A,k--,j--,1,true);
		}
		while(i>=0)await swap(A,k--,p+(i--),1,true);
	}
	async mergeTo(A,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b){
			if(compareIndices(A,i,j)<1)
				await swap(A,p++,i++,1,true);
			else
				await swap(A,p++,j++,1,true);
		}
		while(i<m)await swap(A,p++,i++,1,true);
		while(j<b)await swap(A,p++,j++,1,true);
	}
	async pingPongMerge(A,a,m1,m2,m3,b,p){
		if(compareIndices(A,m1-1,m1)>0||(m3<b&&compareIndices(A,m3-1,m3)>0)){
			let p1=p+m2-a,pE=p+b-a;
			await this.mergeTo(A,a,m1,m2,p);
			await this.mergeTo(A,m2,m3,b,p1);
			await this.mergeTo(A,p,p1,pE,a);
		}else await this.mergeBW(A,a,m2,b,p);
	}
	async mergeFWExt(A,tmp,a,m,b){
		let s=m-a;
		arraycopy(A,a,tmp,0,s,0,false,true);
		let i=0,j=m;
		while(i<s&&j<b){
			if(compareValues(tmp[i],A[j])<1)
				await write(A,a++,tmp[i++],1,true);
			else
				await write(A,a++,A[j++],1,true);
		}
		while(i<s)await write(A,a++,tmp[i++],1,true);
	}
	async mergeBWExt(A,tmp,a,m,b){
		let s=b-m;
		arraycopy(A,m,tmp,0,s,0,false,true);
		let i=s-1,j=m-1;
		while(i>=0&&j>=a){
			if(compareValues(A[j],tmp[i])<1)
				await write(A,--b,tmp[i--],1,true);
			else
				await write(A,--b,A[j--],1,true);
		}
		while(i>=0)await write(A,--b,tmp[i--],1,true);
	}
	async mergeWithBufFW(A,a,m,b,p){
		let i=m;
		while(a<m&&i<b){
			if(compareIndices(A,a,i)<1)
				await swap(A,p++,a++,1,true);
			else
				await swap(A,p++,i++,1,true);
		}
		if(a>p)await this.shiftFW(A,p,a,m);
		await this.shiftFW(A,p,i,b);
	}
	async mergeWithBufBW(A,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a){
			if(compareIndices(A,i,b)<1)
				await swap(A,--p,b--,1,true,false);
			else
				await swap(A,--p,i--,1,true,false);
		}
		if(p>b)await this.shiftBW(A,m,b+1,p);
		await this.shiftBW(A,a,i+1,p);
	}
	async mergeWithBufFWExt(A,a,m,b,p){
		let i=m;
		while(a<m&&i<b){
			if(compareIndices(A,a,i)<1)
				await write(A,p++,A[a++],1,true);
			else
				await write(A,p++,A[i++],1,true);
		}
		if(a>p)await this.shiftFWExt(A,p,a,m);
		await this.shiftFWExt(A,p,i,b);
	}
	async mergeWithBufBWExt(A,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a){
			if(compareIndices(A,i,b)<1)
				await write(A,--p,A[b--],1,true);
			else
				await write(A,--p,A[i--],1,true);
		}
		if(p>b)await this.shiftBWExt(A,m,b+1,p);
		await this.shiftBWExt(A,a,i+1,p);
	}
	async inPlaceMerge(A,a,m,b){
		while(a<m&&m<b){
			a=this.rightBinSearch(A,a,m,A[m]);
			if(a==m)return;
			let i=this.leftBinSearch(A,m,b,A[a]);
			await this.rotate(A,a,m,i);
			let t=i-m;
			m=i;
			a+=t+1;
		}
	}
	async inPlaceMergeBW(A,a,m,b){
		while(b>m&&m>a){
			let i=this.rightBinSearch(A,a,m,A[b-1]);
			await this.rotate(A,i,m,b);
			let t=m-i;
			m=i;
			b-=t+1;
			if(m==a)break;
			b=this.leftBinSearch(A,m,b,A[m-1]);
		}
	}
}
class QuadSortBase{
	async swapTwo(A,s){
		if(compareIndices(A,s,s+1)>0)
			await swap(A,s,s+1,1,true);
	}
	async swapThree(A,s){
		if(compareIndices(A,s,s+1)>0){
			if(compareIndices(A,s,s+2)<1)
				await swap(A,s,s+1,1,true);
			else if(compareIndices(A,s+1,s+2)>0)
				await swap(A,s,s+2,1,true);
			else{
				let t=A[s];
				await write(A,s,A[s+1],1,true);
				await write(A,s+1,A[s+2],1,true);
				await write(A,s+2,t,1,true);
			}
		}else if(compareIndices(A,s+1,s+2)>0){
			if(compareIndices(A,s,s+2)>0){
				let t=A[s+2];
				await write(A,s+2,A[s+1],1,true);
				await write(A,s+1,A[s],1,true);
				await write(A,s,temp,1,true);
			}else 
				await swap(A,s+2,s+1,1,true);
		}
	}
	async swapFour(A,s){
		if(compareIndices(A,s,s+1)>0)
			await swap(A,s,s+1,1,true);
		if(compareIndices(A,s+2,s+3)>0)
			await swap(A,s+2,s+3,1,true);
		if(compareIndices(A,s+1,s+2)>0){
			if(compareIndices(A,s,s+2)<1){
				if(compareIndices(A,s+1,s+3)<1)
					await swap(A,s+1,s+2,1,true);
				else{
					let t=A[s+1];
					await write(A,s+1,A[s+2],1,true);
					await write(A,s+2,A[s+3],1,true);
					await write(A,s+3,t,1,true);
				}
			}else if(compareIndices(A,s,s+3)>0){
				await swap(A,s+1,s+3,1,true);
				await swap(A,s,s+2,1,true);
			}else if(compareIndices(A,s+1,s+3)<1){
				let t=A[s+1];
				await write(A,s+1,A[s],1,true);
				await write(A,s,A[s+2],1,true);
				await write(A,s+2,t,1,true);
			}else{
				let t=A[s+1];
				await write(A,s+1,A[s],1,true);
				await write(A,s,A[s+2],1,true);
				await write(A,s+2,A[s+3],1,true);
				await write(A,s+3,t,1,true);
			}
		}
	}
	async swapFive(A,s){
		this.end=s+4;
		this.pta=this.end++;
		this.ptt=this.pta--;
		if(compareIndices(A,this.pta,this.ptt)>0){
			this.key=A[this.ptt];
			await write(A,this.ptt--,A[this.pta--],1,true);
			if(this.pta>s&&compareValues(A[this.pta-1],this.key)>0){
				await write(A,this.ptt--,A[this.pta--],1,true);
				await write(A,this.ptt--,A[this.pta--],1,true);
			}
			if(this.pta>=s&&compareValues(A[this.pta],this.key)>0)
				await write(A,this.ptt--,A[this.pta--],1,true);
			A[this.ptt]=this.key;
		}
	}
	async tailSwapEight(A,s){
		this.pta=this.end++;
		this.ptt=this.pta--;
		if(compareIndices(A,this.pta,this.ptt)>0){
			this.key=A[this.ptt];
			await write(A,this.ptt--,A[this.pta--],1,true);
			if(compareValues(A[this.pta-2],this.key)>0){
				for(let i=0;i<3;i++)
					await write(A,this.ptt--,A[this.pta--],1,true);
			}
			if(this.pta>s&&compareValues(A[this.pta-1],this.key)>0){
				await write(A,this.ptt--,A[this.pta--],1,true);
				await write(A,this.ptt--,A[this.pta--],1,true);
			}
			if(this.pta>=s&&compareValues(A[this.pta],this.key)>0)
				await write(A,this.ptt--,A[this.pta--],1,true);
			A[this.ptt]=this.key;
		}
	}
	async swapSix(A,s){
		await this.swapFive(A,s);
		await this.tailSwapEight(A,s);
	}
	async swapSeven(A,s){
		await this.swapSix(A,s);
		await this.tailSwapEight(A,s);
	}
	async swapEight(A,s){
		await this.swapSeven(A,s);
		await this.tailSwapEight(A,s);
	}
}
class QuadSorting{
	qs=new QuadSortBase();
	async tailSwap(A,s,n){
		let m,t,o;
		switch(n){
			case 0:
			case 1:return;
			case 2:await this.qs.swapTwo(A,s);return;
			case 3:await this.qs.swapThree(A,s);return;
			case 4:await this.qs.swapFour(A,s);return;
			case 5:await this.qs.swapFour(A,s);await this.qs.swapFive(A,s);return;
			case 6:await this.qs.swapFour(A,s);await this.qs.swapSix(A,s);return;
			case 7:await this.qs.swapFour(A,s);await this.qs.swapSeven(A,s);return;
			case 8:await this.qs.swapFour(A,s);await this.qs.swapEight(A,s);return;
		}
		await this.qs.swapFour(A,s);
		await this.qs.swapEight(A,s);
		this.qs.end=s+8;
		o=8;
		while(o<n){
			t=o++;
			this.qs.pta=this.qs.end++;
			this.qs.ptt=this.qs.pta--;
			if(compareIndices(A,this.qs.pta,this.qs.ptt)<1)continue;
			let tm=A[this.qs.ptt];
			while(t>1){
				m=t/2|0;
				if(compareValues(A[this.qs.pta-m],tm)>0)
					this.qs.pta-=m;
				t-=m;
			}
			for(let i=this.qs.ptt;i>this.qs.pta;i--)
				await write(A,i,A[i-1],1,true);
			await write(A,this.qs.pta,tm,1,true);
		}
	}
	async parityMerge4(from,s,dest,xO){
		let ptl,ptr;
		let auxP=xO;
		ptl=s;
		ptr=s+4;
		for(let i=0;i<3;i++){
			if(compareIndices(from,ptl,ptr)<1)
				write(dest,auxP++,from[ptl++],0,false,true);
			else
				write(dest,auxP++,from[ptr++],0,false,true);
		}
		if(compareIndices(from,ptl,ptr)<1)
			write(dest,auxP,from[ptl],1,false,true);
		else
			write(dest,auxP,from[ptr],1,false,true);
		ptl=s+3;
		ptr=s+7;
		auxP+=4;
		for(let i=0;i<3;i++){
			if(compareIndices(from,ptl,ptr)>0)
				write(dest,auxP--,from[ptl--],1,false,true);
			else
				write(dest,auxP--,from[ptr--],1,false,true);
		}
		if(compareIndices(from,ptl,ptr)>0)
			write(dest,auxP,from[ptl],1,false,true);
		else
			write(dest,auxP,from[ptr],1,false,true);
	}
	async parityMerge8(from,s,dest){
		let ptl,ptr;
		let mainP=s;
		ptl=0;
		ptr=8;
		for(let i=0;i<7;i++){
			if(compareIndices(from,ptl,ptr)<1)
				await write(dest,mainP++,from[ptl++],1,true);
			else
				await write(dest,mainP++,from[ptr++],1,true);
		}
		if(compareIndices(from,ptl,ptr)<1)
			await write(dest,mainP,from[ptl],1,true);
		else
			await write(dest,mainP,from[ptr],1,true);
		ptl=7;
		ptr=15;
		mainP+=8;
		for(let i=0;i<7;i++){
			if(compareIndices(from,ptl,ptr)>0)
				await write(dest,mainP--,from[ptl--],1,true);
			else
				await write(dest,mainP--,from[ptr--],1,true);
		}
		if(compareIndices(from,ptl,ptr)>0)
			await write(dest,mainP,from[ptl],1,true);
		else
			await write(dest,mainP,from[ptr],1,true);
	}
	async parityMerge16(A,s,aux){
		if(compareIndices(A,s+3,s+4)<1&&compareIndices(A,s+7,s+8)<1&&compareIndices(A,s+11,s+12)<1)return;
		await this.parityMerge4(A,s,aux,0);
		await this.parityMerge4(A,s+8,aux,8);
		await this.parityMerge8(aux,s,A);
	}
	async partialBackwardMerge(A,aux,st,n,block){
		let r,m,e,s;
		m=st+block;
		e=st+n-1;
		r=m--;
		if(compareIndices(A,m,r)<1)return;
		while(compareIndices(A,m,e)<1)e--;
		for(let i=r;i<r+(e-m);i++)
			write(aux,i-r,A[i],1,false,true);
		s=e-r;
		await write(A,e--,A[m--],1,true);
		if(compareValues(A[st],aux[0])<1){
			do{
				while(compareValues(A[m],aux[s])>0)
					await write(A,e--,A[m--],1,true);
				await write(A,e--,aux[s--],1,true);
			}while(s>=0);
		}else{
			do{
				while(compareValues(A[m],aux[s])<1)
					await write(A,e--,aux[s--],1,true);
				await write(A,e--,A[m--],1,true);
			}while(m>=st);
			do await write(A,e--,aux[s--],1,true);while(s>=0);
		}
	}
	async tailMerge(A,aux,s,n,block){
		let pta,pte;
		pte=s+n;
		while(block<n){
			pta=s;
			for(pta=s;pta+block<pte;pta+=block*2){
				if(pta+block*2<pte){
					await this.partialBackwardMerge(A,aux,pta,block*2,block);
					continue;
				}
				await this.partialBackwardMerge(A,aux,pta,pte-pta,block);
				break;
			}
			block*=2;
		}
	}
	async forwardMerge(dest,from,s,auxStart,block,toAux){
		let l,r,m,e;
		let mergeP=toAux?auxStart:s;
		l=toAux?s:auxStart;
		r=toAux?s+block:auxStart+block;
		m=r;
		e=r+block;
		if(compareIndices(from,r-1,e-1)<1){
			leftFirst:do{
				for(let i=0;i<3;i++){
					if(compareIndices(from,l,r)<1){
						write(dest,mergeP++,from[l++],toAux?0:1,!toAux,toAux);
						if(!toAux)await sleep();
						continue leftFirst;
					}
					write(dest,mergeP++,from[r++],toAux?0:1,!toAux,toAux);
					if(!toAux)await sleep();
				}
			}while(l<m);
			do{
				write(dest,mergeP++,from[r++],toAux?0:1,!toAux,toAux);
				if(!toAux)await sleep();
			}while(r<e);
		}else{
			rightFirst:do{
				for(let i=0;i<3;i++){
					if(compareIndices(from,l,r)>0){
						write(dest,mergeP++,from[r++],toAux?0:1,!toAux,toAux);
						if(!toAux)await sleep();
						continue rightFirst;
					}
					write(dest,mergeP++,from[l++],toAux?0:1,!toAux,toAux);
					if(!toAux)await sleep();
				}
			}while(r<e);
			do{
				write(dest,mergeP++,from[l++],toAux?0:1,!toAux,toAux);
				if(!toAux)await sleep();
			}while(l<m);
		}
	}
	async quadMergeBlock(A,s,aux,block){
		let pts,c,cMax;
		let blockX2=block*2;
		cMax=s+block;
		if(compareIndices(A,cMax-1,cMax)<1){
			cMax+=blockX2;
			if(compareIndices(A,cMax-1,cMax)<1){
				cMax-=block;
				if(compareIndices(A,cMax-1,cMax)<1)return;
				pts=0;
				c=s;
				do{
					write(aux,pts++,A[c++],1,false,true);
				}while(c<cMax);
				cMax=c+blockX2;
				do{
					write(aux,pts++,A[c++],1,false,true);
				}while(c<cMax);
				await this.forwardMerge(A,aux,s,0,blockX2,false);
				return;
			}
			pts=0;
			c=s;
			cMax=s+blockX2;
			do{
				write(aux,pts++,A[c++],1,false,true);
			}while(c<cMax);
		}else
			await this.forwardMerge(aux,A,s,0,block,true);
		await this.forwardMerge(aux,A,s+blockX2,blockX2,block,true);
		await this.forwardMerge(A,aux,s,0,blockX2,false);
	}
	async quadMerge(A,aux,s,n,block){
		let pta,pte;
		pte=s+n;
		block*=4;
		while(block*2<=n){
			pta=s;
			do{
				await this.quadMergeBlock(A,pta,aux,block/4|0);
				pta+=block;
			}while(pta+block<=pte);
			await this.tailMerge(A,aux,pta,pte-pta,block/4|0);
			block*=4;
		}
		await this.tailMerge(A,aux,s,n,block/4|0);
	}
	async quadSwap(A,s,n){
		let swp=new Array(16);
		let count,reverse;
		let pta,pts=0,ptt=0,temp=0;
		pta=s;
		count=n/4|0;
		swapper:
		while(count-->0){
			while(1){
				if(compareIndices(A,pta,pta+1)>0){
					if(compareIndices(A,pta+2,pta+3)>0){
						if(compareIndices(A,pta+1,pta+2)>0){
							pts=pta;
							pta+=4;
							break;
						}
						await swap(A,pta+2,pta+3,1,true);
					}
					await swap(A,pta,pta+1,1,true);
				}else if(compareIndices(A,pta+2,pta+3)>0)
					await swap(A,pta+2,pta+3,1,true);
				if(compareIndices(A,pta+1,pta+2)>0){
					if(compareIndices(A,pta,pta+2)<1){
						if(compareIndices(A,pta+1,pta+3)<1)
							await swap(A,pta+1,pta+2,1,true);
						else{
							temp=A[pta+1];
							await write(A,pta+1,A[pta+2],1,true);
							await write(A,pta+2,A[pta+3],1,true);
							await write(A,pta+3,temp,1,true);
						}
					}else if(compareIndices(A,pta,pta+3)>0){
						await swap(A,pta+1,pta+3,1,true);
						await swap(A,pta,pta+2,1,true);
					}else if(compareIndices(A,pta+1,pta+3)<1){
						temp=A[pta+1];
						await write(A,pta+1,A[pta],1,true);
						await write(A,pta,A[pta+2],1,true);
						await write(A,pta+2,temp,1,true);
					}else{
						temp=A[pta+1];
						await write(A,pta+1,A[pta],1,true);
						await write(A,pta,A[pta+2],1,true);
						await write(A,pta+2,A[pta+3],1,true);
						await write(A,pta+3,temp,1,true);
					}
				}
				pta+=4;
				continue swapper;
			}
			while(1){
				if(count-->0){
					if(compareIndices(A,pta,pta+1)> 0){
						if(compareIndices(A,pta+2,pta+3)>0){
							if(compareIndices(A,pta+1,pta+2)>0){
								if(compareIndices(A,pta-1,pta)>0){
									pta+=4;
									continue;
								}
							}
							await swap(A,pta+2,pta+3,1,true);
						}
						await swap(A,pta,pta+1,1,true);
					}else if(compareIndices(A,pta+2,pta+3)>0)
						await swap(A,pta+2,pta+3,1,true);
					if(compareIndices(A,pta+1,pta+2)>0){
						if(compareIndices(A,pta,pta+2)<1){
							if(compareIndices(A,pta+1,pta+3)<1)
								await swap(A,pta+1,pta+2,1,true);
							else{
								temp=A[pta+1];
								await write(A,pta+1,A[pta+2],1,true);
								await write(A,pta+2,A[pta+3],1,true);
								await write(A,pta+3,temp,1,true);
							}
						}else if(compareIndices(A,pta,pta+3)>0){
							await swap(A,pta,pta+2,1,true);
							await swap(A,pta+1,pta+3,1,true);
						}else if(compareIndices(A,pta+1,pta+3)<1){
							temp=A[pta];
							await write(A,pta,A[pta+2],1,true);
							await write(A,pta+2,A[pta+1],1,true);
							await write(A,pta+1,temp,1,true);
						}else{
							temp=A[pta];
							await write(A,pta,A[pta+2],1,true);
							await write(A,pta+2,A[pta+3],1,true);
							await write(A,pta+3,A[pta+1],1,true);
							await write(A,pta+1,temp,1,true);
						}
					}
					ptt=pta-1;
					reverse=(ptt-pts)/2|0;
					do{
						await swap(A,pts++,ptt--,1,true);
					}while(reverse-->0);
					pta+=4;
					continue swapper;
				}
				if(pts==s){
					switch(n%4){
						case 3:if(compareIndices(A,pta+1,pta+2)<1)break;
						case 2:if(compareIndices(A,pta,pta+1)<1)break;
						case 1:if(compareIndices(A,pta-1,pta)<1)break;
						case 0:
							ptt=pts+n-1;
							reverse=(ptt-pts)/2|0;
							do{
								await swap(A,pts++,ptt--,1,true);
							}while(reverse-->0);
							return 1;
					}
				}
				ptt=pta-1;
				reverse=(ptt-pts)/2|0;
				do{
					await swap(A,pts++,ptt--,1,true);
				}while(reverse-->0);
				break swapper;
			}
		}
		await this.tailSwap(A,pta,n%4);
		pta=s;
		count=n/16|0;
		while(count-->0){
			await this.parityMerge16(A,pta,swp);
			pta +=16;
		}
		if(n%16>4)
			await this.tailMerge(A,swp,pta,n%16,4);
		return 0;
	}
	async quadSort(A,s,l){
		if(l<16)
			await this.tailSwap(A,s,l);
		else if(l<256){
			if(await this.quadSwap(A,s,l)==0){
				let swp=new Array(128);
				await this.tailMerge(A,swp,s,l,16);
			}
		}else{
			if(await this.quadSwap(A,s,l)==0){
				let swp=new Array(l/2|0);
				await this.quadMerge(A,swp,s,l,16);
			}
		}
	}
	async quadSortSwap(A,swp,s,l){
		if(l<16)
			await this.tailSwap(A,s,l);
		else if(l<256){
			if(await this.quadSwap(A,s,l)==0)
				await this.tailMerge(A,swp,s,l,16);
		}else
			if(await this.quadSwap(A,s,l)==0)
				await this.quadMerge(A,swp,s,l,16);
	}
}
class Sorts{
	getNames(){
		return Object.getOwnPropertyNames(Sorts.prototype).filter(e=>new Sorts()[e]instanceof(async()=>{}).constructor).sort((a,b)=>a.localeCompare(b));
	}
	randomSort(){
		let sorts=this.getNames();
		runSort(sorts[random()*sorts.length|0]);
	}
	async bitonicSortIterative(len){
		let i,j,k;
		for(k=2;k<len*2;k=2*k){
			let m=((len+k-1)/k|0)%2!=0;
			for(j=k>>1;j>0;j=j>>1){
				for(i=0;i<len;i++){
					let n=i^j;
					if(n>i&&n<len)if(((((i&k)==0)==m)&&compareIndices(arr,i,n)>0)||((((i&k)!=0)==m)&&compareIndices(arr,i,n)<0))await swap(arr,i,n,0,true);
				}
			}
		}
	}
	async bitonicSortRecursive(len){
		function gpot(n){
			let k=1;
			while(k<n)k<<=1;
			return k>>1;
		}
		async function c(A,i,j,d){
			let m=compareIndices(A,i,j);
			if(m==1==d)await swap(A,i,j,0,true);
		}
		async function bitonicMerge(A,lo,n,d){
			if(n>1){
				let m=gpot(n);
				for(let i=lo;i<lo+n-m;i++)await c(A,i,i+m,d);
				await bitonicMerge(A,lo,m,d);
				await bitonicMerge(A,lo+m,n-m,d);
			}
		}
		async function bitonicSort(A,lo,n,d){
			if(n>1){
				let m=n/2|0;
				await bitonicSort(A,lo,m,!d);
				await bitonicSort(A,lo+m,n-m,d);
				await bitonicMerge(A,lo,n,d);
			}
		}
		await bitonicSort(arr,0,len,true);
	}
	async boseNelsonSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function rc(A,a,b,o){
			let h=(b-a)/2|0,m=a+h;a+=o;
			for(let i=0;i<h-o;i++)if((i&~o)==i)await cs(A,a+i,m+i);
		}
		let e=len;
		len=1<<ceil(log(len)/log(2));
		for(let k=2;k<=len;k*=2)
			for(let j=0;j<k/2|0;j++)
				for(let i=0;i+j<e;i+=k)
					await rc(arr,i,i+k,j);
	}
	async boseNelsonSortRecursive(len){
		function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function boseNelsonMerge(A,s1,l1,s2,l2){
			if(l1==1&&l2==1){
				await cs(A,s1,s2);
			}else if(l1==1&&l2==2){
				await cs(A,s1,s2+1);
				await cs(A,s1,s2);
			}else if(l1==2&&l2==1){
				await cs(A,s1,s2);
				await cs(A,s1+1,s2);
			}else{
				let m1=l1/2|0;
				let m2=l1%2?l2/2|0:(l2+1)/2|0;
				await boseNelsonMerge(A,s1,m1,s2,m2);
				await boseNelsonMerge(A,s1+m1,l1-m1,s2+m2,l2-m2);
				await boseNelsonMerge(A,s1+m1,l1-m1,s2,m2);
			}
		}
		async function boseNelson(A,s,l){
			if(l>1){
				let m=l/2|0;
				await boseNelson(A,s,m);
				await boseNelson(A,s+m,l-m);
				await boseNelsonMerge(A,s,m,s+m,l-m);
			}
		}
		await boseNelson(arr,0,len);
	}
	async creaseSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		let m=1;
		for(;m*2<len;m*=2);
		for(let n=m;n>0;n=n/2|0){
			for(let i=0;i+1<len;i+=2)await cs(arr,i,i+1);
			for(let j=m;j>=n&&j>1;j=j/2|0)for(let i=1;i+j-1<len;i+=2)await cs(arr,i,i+j-1);
		}
	}
	async diamondSortIterative(len){
		function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		let n=1,m=4;
		for(;n<len;n*=2);
		for(;m<=n;m*=2)for(let k=0;k<m/2;k++){
			let c=k<=m/4?k:m/2-k;
			for(let j=0;j<len;j+=m)
				if(j+c+1<len)
					for(let i=j+c;i+1<minVal(len,j+m-c);i+=2)
						await cs(arr,i,i+1);
		}
		m/=2;
		for(let k=0;k<=m/2;k++)
			for(let i=k;i+1<minVal(len,m-k);i+=2)
				await cs(arr,i,i+1);
	}
	async diamondSortRecursive(len){
		async function sort(A,s,e,m){
			if(e-s==2){
				if(compareIndices(A,s,e-1)>0)
					await swap(A,s,e-1,0,true);
			}else if(e-s>=3){
				let d=(e-s)/4;
				let md=(e-s)/2+s|0;
				if(m){
					await sort(A,s,md,true);
					await sort(A,md,e,true);
				}
				await sort(A,d+s|0,d*3+s|0);
				await sort(A,s,md);
				await sort(A,md,e);
				await sort(A,d+s|0,d*3+s|0);
			}
		}
		await sort(arr,0,len,true);
	}
	async foldSort(len){
		let cL=1;
		for(;1<<cL<len;cL++);
		let e=len;len=1<<cL;
		for(let k=len>>1;k>0;k>>=1)
			for(let i=len;i>=k;i>>=1)
				for(let j=0;j<e;j+=i)
					for(let l=j,h=j+i-1;l<h;l++,h--)
						if(h<e&&compareIndices(arr,l,h)>0)
							await swap(arr,l,h,.5,true);
	}
	async matrixSort(len){
		class MtSp{
			constructor(w,h,l){
				this.w=w;
				this.iL=(w==1)^(h==1)||l;
			}
		}
		async function gR(A,s,e,g){
			for(let i=s,j=e;i<j;i+=g,j-=g)await swap(A,i,j-g,0,true);
		}
		const dCV=(l,r,d)=>d?compareValues(l,r):(compareValues(l,r)*-1);
		async function inL(ar,a,b,g,dr){
			let d=0,k=ar[b],j=b-g;
			while(j>=a&&dCV(k,ar[j],dr)<0){
				await write(ar,j+g,ar[j],0,true);
				d=1;j-=g;
			}
			await write(ar,j+g,k);
			return d;
		}
		function gMD(l){
			let d=sqrt(l)|0,iL=(d*d==l-1)
			for(;l%d;d--);
			return new MtSp(d,l/d|0,iL);
		}
		async function mS(a,s,e,g,dr){
			let d=0,l=(e-s)/g|0;
			if(l<2)return 0;
			else if(l<17){
				d=0;
				for(let i=s;i<e;i+=g)d=await inL(a,s,i,g,dr)|d;
			}else{
				let nd,mSh=gMD(l);
				if(mSh.iL){
					let d1=await mS(a,s,e-g,g,dr);
					let d2=await inL(a,s,e-g,g,dr);
					return d1||d2;
				}
				for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)await gR(a,i,i+mSh.w*g,g);
				d=0;
				do{
					nd=0;
					for(let i=s,cd=dr;i<e;i+=mSh.w*g){
						nd=await mS(a,i,i+mSh.w*g,g,cd)||nd;
						d=d||nd;
						cd=!cd;
					}
					nd=0;
					for(let i=0;i<mSh.w;d=d||nd,i++)nd=await mS(a,s+i*g,e+i*g,g*mSh.w,dr)||nd;
				}while(nd);
				for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)await gR(a,i,i+mSh.w*g,g);
			}
			return d;
		}
		await mS(arr,0,len,1,true);
	}
	async mergeExchangeSortIterative(len){
		let t=log(len-1)/log(2)+1|0;
		let p0=1<<(t-1);
		for(let p=p0;p>0;p>>=1){
			let q=p0,r=0,d=p;
			while(1){
				for(let i=0;i<len-d;i++)
					if((i&p)==r&&compareIndices(arr,i,i+d)>0)
						await swap(arr,i,i+d,.5,true);
				if(q==p)break;
				d=q-p;q>>=1;r=p;
			}
		}
	}
	async oddEvenMergeSortIterative(len){
		for(let p=1;p<len;p*=2)
			for(let k=p;k>0;k=k/2|0)
				for(let j=k%p;j+k<len;j+=2*k)
					for(let i=0;i<k;i++)
						if(((i+j)/2/p|0)==((i+j+k)/2/p|0))
							if(i+j+k<len)
								if(compareIndices(arr,i+j,i+j+k)>0)
									await swap(arr,i+j,i+j+k,.5,true);
	}
	async oddEvenMergeSortRecursive(len){
		function c(A,a,b){
			if(compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function oddEvenMerge(A,l,m2,n,r){
			let m=r*2;
			if(m<n){
				let s=(n/r|0)%2;
				await oddEvenMerge(A,l,(m2+1)/2|0,n+(s?r:0),m);
				await oddEvenMerge(A,l+r,m2/2|0,n-(s?r:0),m);
				if(m2%2)for(let i=l;i+r<l+n;i+=m)await c(A,i,i+r);
				else for(let i=l+r;i+r<l+n;i+=m)await c(A,i,i+r);
			}else if(n>r)await c(A,l,l+r);
		}
		async function oddEvenMergeSort(A,l,n){
			if(n>1){
				let m=n/2|0;
				await oddEvenMergeSort(A,l,m);
				await oddEvenMergeSort(A,l+m,n-m);
				await oddEvenMerge(A,l,m,n,1);
			}
		}
		await oddEvenMergeSort(arr,0,len);
	}
	async pairwiseMergeSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		let e=len;
		let n=1;
		for(;n<len;n<<=1);
		for(let k=n>>1;k>0;k>>=1)
			for(let j=0;j<len;j+=k<<1)
				for(let i=0;i<k;i++)
					await cs(arr,j+i,j+k+i);
		for(let k=2;k<n;k<<=1)
			for(let m=k>>1;m>0;m>>=1)
				for(let j=0;j<len;j+=k<<1)
					for(let p=m;p<(k-m)<<1;p+=m<<1)
						for(let i=0;i<m;i++)
							await cs(arr,j+p+i,j+p+m+i);
	}
	async pairwiseMergeSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function pairwiseMerge(A,a,b){
			let m=(a+b)/2|0,m1=(a+m)/2|0,g=m-m1;
			for(let i=0;m1+i<m;i++)
				for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))
					await cs(A,j+i,j+i+k);
			if(b-a>4)await pairwiseMerge(A,m,b);
		}
		async function pairwiseMergeSort(A,a,b){
			let m=(a+b)/2|0;
			for(let i=a,j=m;i<m;i++,j++)
				await cs(A,i,j);
			if(b-a>2){
				await pairwiseMergeSort(A,a,m);
				await pairwiseMergeSort(A,m,b);
				await pairwiseMerge(A,a,b);
			}
		}
		let e=len;
		let n=1;
		for(;n<e;n<<=1);
		await pairwiseMergeSort(arr,0, n);
	}
	async pairwiseSortIterative(len){
		async function iterativepairwise(A,l){
			let a=1,b,c,d,e;
			b=c=d=e=0;
			while(a<l){
				b=a;c=0;
				while(b<l){
					if(compareIndices(A,b-a,b)>0)
						await swap(A,b-a,b,.5,true);
					c=(c+1)%a;
					b+=c?1:a+1;
				}
				a*=2;
			}
			a=a/4|0;e=1;
			while(a>0){
				d=e;
				while(d>0){
					b=(d+1)*a;c=0;
					while(b<l){
						if(compareIndices(A,b-d*a,b)>0)
							await swap(A,b-d*a,b,.5,true);
						c=(c+1)%a;
						b+=c?1:a+1;
					}
					d=d/2|0;
				}
				a=a/2|0;e=e*2+1;
			}
		}
		await iterativepairwise(arr,len);
	}
	async pairwiseSortRecursive(len){
		async function pairwiserecursive(A,s,e,g){
			if(s==e-g)return;
			let b=s+g;
			while(b<e){
				if(compareIndices(A,b-g,b)>0)
					await swap(A,b-g,b,.5,true);
				b+=2*g;
			}
			if(((e-s)/g|0)%2==0){
				await pairwiserecursive(A,s,e,g*2);
				await pairwiserecursive(A,s+g,e+g,g*2);
			}else{
				await pairwiserecursive(A,s,e+g,g*2);
				await pairwiserecursive(A,s+g,e,g*2);
			}
			let a=1;
			while(a<(e-s)/g|0)a=a*2+1;
			b=s+g;
			while(b+g<e){
				let c=a;
				while(c>1){
					c=c/2|0;
					if(b+c*g<e)
						if(compareIndices(A,b,b+c*g)>0)
							await swap(A,b,b+c*g,.5,true);
				}
				b+=2*g;
			}
		}
		await pairwiserecursive(arr,0,len,1);
	}
	async weaveSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		let e=len;
		let n=1;
		for(;n<len;n*=2);
		for(let i=1;i<n;i*=2)
			for(let j=1;j<=i;j*=2)
				for(let k=0;k<n;k+=n/j|0)
					for(let d=n/i/2|0,m=0,l=n/j-d|0;l>=n/j/2|0;l-=d)
						for(let p=0;p<d;p++,m++)
							await cs(arr,k+m,k+l+p);
	}
	async weaveSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function circle(A,p,l,g){
			if(l<2)return;
			for(let i=0;2*i<(l-1)*g;i+=g)
				await cs(A,p+i,p+(l-1)*g-i);
			await circle(A,p,l/2|0,g);
			if(p+l*g/2|0<e)await circle(A,p+l*g/2|0,l/2|0,g);
		}
		async function weaveCircle(A,p,l,g){
			if(l<2)return;
			await weaveCircle(A,p,l/2|0,2*g);
			await weaveCircle(A,p+g,l/2|0,2*g);
			await circle(A,p,l,g);
		}
		let e=len,n=1;
		for(;n<e;n*=2);
		await weaveCircle(arr,0,n,1);
	}
	async americanFlagSort(len){
		let base=askForBase(64);
		function gMND(A,l){
			let m=-1/0,t=0;
			for(let i=0;i<l;i++){
				t=log(A[i])/log(base)+1|0;
				if(t>m)m=t;
			}
			return m;
		}
		function getDigit(i,d){
			return(i/d|0)%base;
		}
		async function sort(A,s,l,d){
			let cn=new Array(base).fill(0);
			let os=new Array(base).fill(0);
			let dg=0;
			for(let i=s;i<l;i++){
				let d2=A[i];
				dg=getDigit(d2,d);
				write(cn,dg,cn[dg]+1,0,false,true);
			}
			write(os,0,s,0,false,true);
			for(let i=1;i<base;i++)write(os,i,cn[i-1]+os[i-1],0,false,true);
			for(let b=0;b<base;b++){
				while(cn[b]>0){
					let or=os[b],fr=or,n=A[fr];
					do{
						dg=getDigit(n,d);
						let to=os[dg];
						write(os,dg,os[dg]+1,0,false,true);
						write(cn,dg,cn[dg]-1,0,false,true);
						let t=A[to];
						await write(A,to,n,.75,true,false);
						n=t;fr=to;
					}while(fr-or);
				}
			}
			if(d>1)for(let i=0;i<base;i++){
				let bg=i>0?os[i-1]:s;
				let e=os[i];
				if(e-bg>1)await sort(A,bg,e,d/base|0);
			}
		}
		let nOD=gMND(arr,len),max=1;
		for(let i=0;i<nOD-1;i++)max*=base;
		await sort(arr,0,len,max);
	}
	async binaryQuickSortRecursive(len){
		async function partition(A,p,r,b){
			let i=p-1;
			let j=r+1;
			while(1){
				do i++;while(i<=r&&!getBit(arr[i],b));
				do j--;while(j>=p&&getBit(arr[j],b));
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function binaryQuickSortRecursive(A,p,r,b){
			if(p<r&&b>=0){
				let q=await partition(A,p,r,b);
				await binaryQuickSortRecursive(A,p,q,b-1);
				await binaryQuickSortRecursive(A,q+1,r,b-1);
			}
		}
		let msb=analyzeBit(arr,len);
		await binaryQuickSortRecursive(arr,0,len-1,msb);
	}
	async bogoSort(len){
		while(!isArraySorted(arr,len)){
			bogoSwap(arr,0,len,0);
			await sleep();
		}
	}
	async bozoSort(len){
		while(!isArraySorted(arr,len))
			await swap(arr,randInt(0,len),randInt(0,len),0,true);
	}
	async cocktailBogoSort(len){
		let n=0,x=len,j=0;
		while(n<x-1){
			if(isMinSorted(arr,n,x)){
				mark(n++);
				continue;
			}
			if(isMaxSorted(arr,n,x)){
				mark(--x);
				continue;
			}
			for(let i=n;i<x;++i){
				swap(arr,i,randInt(i,x),0,true);
				if(++j>=64)await sleep(j=0);
			}
		}
	}
	async deterministicBogoSort(len){
		async function permutationSort(A,d,l){
			if(d>=l-1)return isArraySorted(A,l);
			for(let i=len-1;i>d;--i){
				if(await permutationSort(A,d+1,l))return true;
				if((l-d)%2==0)await swap(A,d,i,0,true);
				else await swap(A,d,l-1,0,true);
			}
			return await permutationSort(A,d+1,l);
		}
		await permutationSort(arr,0,len);
	}
	async flashSort(len){
		async function sort(A,l){
			if(l<1)return;
			let m=.2*l+2|0;
			let min,max,maxIndex;
			min=max=A[0];
			maxIndex=0;
			for(let i=1;i<l-1;i+=2){
				let small,big,bigIndex;
				if(compareIndices(A,i,i+1)<0){
					small=A[i];
					big=A[i+1];
					bigIndex=i+1;
				}else{
					big=A[i];
					bigIndex=i;
					small=A[i+1];
				}
				if(big>max){
					max=big;
					maxIndex=bigIndex;
				}
				if(small<min){
					min=small;
				}
			}
			if(compareValues(A[l-1],min)<0){
				min=A[l-1];
			}else if(compareValues(A[l-1],max)>0){
				max=A[l-1];
				maxIndex=l-1;
			}
			if(max==min)return;
			let L=new Array(m+1).fill(0);
			let c=(m-1)/(max-min);
			let K;
			for(let h=0;h<l;h++){
				K=(A[h]-min)*c+1|0;
				write(L,K,L[K]+1,0,false,true);
			}
			for(K=2;K<=m;K++)write(L,K,L[K]+L[K-1],0,false,true);
			await swap(A,maxIndex,0,1,true);
			let j=0;K=m;
			let numMoves=0;
			while(numMoves<l){
				while(j>=L[K])K=(A[++j]-min)*c+1|0;
				let evicted=A[j];
				while(j<L[K]){
					K=(evicted-min)*c+1|0;
					let location=L[K]-1;
					let temp=A[location];
					await write(A,location,evicted,0,true,false);
					evicted=temp;
					write(L,K,L[K]-1,0,false,true);
					numMoves++;
				}
			}
			await insertSort(A,0,l);
		}
		await sort(arr,len);
	}
	async gravitySort(len){
		let m=maxVal(...arr);
		let T=[...arr].sort((a,b)=>a-b);
		for(let i=len-1;i>=0;i--){
			for(let j=0;j<i;j++)
				if(compareValues(arr[j],T[i])>0)
					await write(arr,j,T[i],0,true);
			for(let j=len-1;j>=i;j--)
				if(compareValues(arr[j],T[j])<0)await write(arr,j,arr[j]+1,0,true);
				else await write(arr,j,T[j],0,true);
		}
	}
	async indexSort(len){
		let m=minVal(...arr);
		for(let i=0;i<len;i++){
			let c=0;
			while(compareValues(i,arr[i]-m)&&c<len){
				await swap(arr,i,arr[i]-m,.5,true);
				c++;
			}
			if(c>=len-1)break;
			await sleep();
		}
	}
	async inPlaceLSDRadixSort(len){
		let base=askForBase(10);
		let ps=0,regs=new Array(base-1),hp=analyzeMaxLog(arr,len,base);
		for(let p=0;p<=hp;p++){
			for(let i=0;i<regs.length;i++)write(regs,i,len-1,true);
			ps=0;
			for(let i=0;i<len;i++){
				let dg=getDigit(arr[ps],p,base);
				if(!dg)ps++;
				else{
					multiSwap(arr,ps,regs[dg-1],0);
					for(let j=0;j<regs.length;j++){
						mark(regs[j]);
					}
					await sleep();
					for(let j=dg-1;j>0;j--)write(regs,j-1,regs[j-1]-1,true);
				}
			}
		}
		draw();
	}
	async lessBogoSort(len){
		for(let i=0;i<len;++i){
			while(!isMinSorted(arr,i,len)){
				bogoSwap(arr,i,len);
				await sleep();
			}
		}
	}
	async LSDRadixSort(len){
		let base=askForBase(4);
		let hp=analyzeMaxLog(arr,len,base);
		let regs=new Array(base);
		for(let i=0;i<base;i++)regs[i]=[];
		for(let p=0;p<=hp;p++){
			for(let i=0;i<len;i++)
				regs[getDigit(arr[i],p,base)].push(arr[i]);
			await fancyTranscribe(arr,len,regs,0);
		}
	}
	async medianQuickBogoSort(len){
		async function mQB(A,s,e){
			if(s>=e-1)return;
			let m=(s+e)/2|0;
			while(!isRangeSplit(A,s,m,e)){
				bogoSwap(A,s,e);
				await sleep();
			}
			await mQB(A,s,m);
			await mQB(A,m,e);
		}
		await mQB(arr,0,len);
	}
	async mergeBogoSort(len){
		async function bogoWeave(A,t,s,m,e){
			await bogoCombo(A,s,e,e-m);
			let l=s,h=m;
			for(let i=s;i<e;++i){
				if(!compareValues(A[i],0))await write(A,i,t[l++],0,true);
				else await write(A,i,t[h++],0,true);
			}
		}
		async function merge(A,t,s,e){
			if(s>=e-1)return;
			let m=(s+e)/2|0;
			await merge(A,t,s,m);
			await merge(A,t,m,e);
			arraycopy(A,s,t,s,e-s,0,true,true);
			while(!isRangeSorted(A,s,e))
				await bogoWeave(A,t,s,m,e);
		}
		await merge(arr,new Array(len),0,len);
	}
	async MSDRadixSort(len){
		let base=askForBase(2);
		async function radixMSD(A,l,n,x,r,p){
			if(n>=x||p<0)return;
			let regs=new Array(r);
			for(let i=0;i<r;i++)regs[i]=[];
			for(let i=n;i<x;i++)regs[getDigit(A[i],p,r)].push(A[i]);
			await transcribeMSD(A,regs,0,n,.8,true);
			let s=0;
			for(let i=0;i<regs.length;i++){
				await radixMSD(A,l,s+n,s+n+regs[i].length,r,p-1);
				s+=regs[i].length;
				regs[i]=[];
			}
		}
		let hp=analyzeMaxLog(arr,len,base);
		await radixMSD(arr,len,0,len,base,hp);
	}
	async guessSort(len){
		let loops=new Array(len);
		while(1){
			let sorted=true;
			for(let i=0;i<len-1;++i){
				let c=compareIndices(arr,loops[i],loops[i+1]);
				if(c<0||!c&&loops[i]<loops[i+1])continue;
				sorted=false;
				break;
			}
			draw();
			if(sorted)break;
			for(let p=0;p<len;++p)
				if(loops[p]<len-1){
					write(loops,p,loops[p]+1,0,false,true);
					break;
				}else
					await write(loops,p,0,1,true,true);
		}
		for(let i=0;i<len;i++)await write(loops,i,arr[loops[i]],1,true,true);
		for(let i=0;i<len;i++)await write(arr,i,loops[i],1,true);
	}
	async quickBogoSort(len){
		async function quickBogoSwap(A,s,p,e){
			for(let i=s;i<e;i++){
				let j=randInt(i,e);
				if(p==i)p=j;
				else if(p==j)p=i;
				swap(A,i,j,0);
			}
			await sleep();
			return p;
		}
		async function quickBogo(A,s,e){
			if(s>=e-1)return;
			let p=s;
			while(!isRangePartitioned(A,s,p,e))
				p=await quickBogoSwap(A,s,p,e);
			await quickBogo(A,s,p);
			await quickBogo(A,p+1,e);
		}
		await quickBogo(arr,0,len);
	}
	async rotateLSDRadixSort(len){
		let base=askForBase(10);
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,.5,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function binSearch(A,a,b,d,p){
			while(a<b){
				let m=(a+b)/2|0;
				if(getDigit(A[m],p,base)>=d)b=m;
				else a=m+1;
			}
			return a;
		}
		async function merge(A,a,m,b,da,db,p){
			if(b-a<2||db-da<2)return;
			let dm=(da+db)/2|0;
			let m1=binSearch(A,a,m,dm,p);
			let m2=binSearch(A,m,b,dm,p);
			await rotate(A,m1,m,m2);
			m=m1+(m2-m);
			await merge(A,m,m2,b,dm,db,p);
			await merge(A,a,m1,m,da,dm,p);
		}
		async function mergeSort(A,a,b,p){
			if(b-a<2)return;
			let m=(a+b)/2|0;
			await mergeSort(A,a,m,p);
			await mergeSort(A,m,b,p);
			await merge(A,a,m,b,0,base,p);
		}
		let max=analyzeMaxLog(arr,len,base);
		for(let i=0;i<=max;i++)
			await mergeSort(arr,0,len,i);
	}
	async rotateMSDRadixSort(len){
		let base=askForBase(10);
		function shift(n,q){
			while(q>0){
				n=n/base|0;
				q--;
			}
			return n;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,.5,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function binSearch(A,a,b,d,p){
			while(a<b){
				let m=(a+b)/2|0;
				if(getDigit(A[m],p,base)>=d)b=m;
				else a=m+1;
			}
			return a;
		}
		async function merge(A,a,m,b,da,db,p){
			if(b-a<2||db-da<2)return;
			let dm=(da+db)/2|0;
			let m1=binSearch(A,a,m,dm,p);
			let m2=binSearch(A,m,b,dm,p);
			await rotate(A,m1,m,m2);
			m=m1+(m2-m);
			await merge(A,m,m2,b,dm,db,p);
			await merge(A,a,m1,m,da,dm,p);
		}
		async function mergeSort(A,a,b,p){
			if(b-a<2)return;
			let m=(a+b)/2|0;
			await mergeSort(A,a,m,p);
			await mergeSort(A,m,b,p);
			await merge(A,a,m,b,0,base,p);
		}
		async function dist(A,a,b,p){
			await mergeSort(A,a,b,p);
			return binSearch(A,a,b,1,p);
		}
		let q=analyzeMaxLog(arr,len,base);
		let m=0,i=0,b=len;
		while(i<len){
			let p=b-i<1?i:await dist(arr,i,b,q);
			if(q==0){
				m+=base;
				let t=m/base|0;
				while(t%base==0){
					t=t/base|0;
					q++;
				}
				i=b;
				while(b<len&&shift(arr[b],q+1)==shift(m,q+1))b++;
			}else{
				b=p;
				q--;
			}
		}
	}
	async selectionBogoSort(len){
		for(let i=0;i<len;++i)
			while(!isMinSorted(arr,i,len))
				await swap(arr,i,randInt(i,len),0,true);
	}
	async smartBogoBogoSort(len){
		async function smartBogoBogo(A,l){
			if(l<2)return;
			await smartBogoBogo(A,l-1);
			while(compareIndices(A,l-2,l-1)>0){
				await bogoSwap(A,0,l);
				await smartBogoBogo(A,l-1);
			}
		}
		await smartBogoBogo(arr,len);
	}
	async smartGuessSort(len){
		let loops=new Array(len).fill(0);
		while(1){
			let sorted=true;
			let i=len-2;
			for(;i>=0;--i){
				let comp=compareIndices(arr,loops[i],loops[i+1]);
				if(comp<0||!comp&&loops[i]<loops[i+1])continue;
				sorted=false;
				break;
			}
			draw()
			if(sorted)break;
			for(let p=0;p<len;++p)
				if(p>=i&&loops[p]<length-1){
					write(loops,p,loops[p]+1,0,false,true);
					break;
				}else
					await write(loops,p,0,0,true,true);
		}
		for(let i=0;i<len;i++)await write(loops,i,arr[loops[i]],0,true,true);
		for(let i=0;i<len;i++)await write(arr,i,loops[i],0,true,false);
	}
	async stacklessAmericanFlagSort(len){
		let base=askForBase(10);
		async function shift(n,q,r){
			while(q>0){
				n=n/r|0;
				q--;
			}
			return n;
		}
		async function dist(A,cnts,offs,a,b,q,r){
			for(let i=1;i<r;i++){
				write(cnts,i,cnts[i]+cnts[i-1],0,false,true);
				write(offs,i,cnts[i-1],0,false,true);
			}
			for(let i=0;i<r-1;i++){
				let pos=a+offs[i];
				if(cnts[i]>offs[i]){
					mark(pos);
					let t=A[pos];
					do{
						let d=getDigit(t,q,r);
						write(cnts,d,cnts[d]-1,0,false,true);
						let t1=A[a+cnts[d]];
						await write(A,a+cnts[d],t,0,true);
						t=t1;
					}while(cnts[i]>offs[i]);
					draw();
				}
			}
			let p=a+offs[1];
			for(let i=0;i<r;i++){
				write(cnts,i,0,0,false,true);
				write(offs,i,0,0,false,true);
			}
			return p;
		}
		let r=base,q=analyzeMaxLog(arr,len,r),m=0,i=0,b=len;
		let cnts=new Array(r).fill(0),offs=new Array(r).fill(0);
		for(let j=i;j<b;j++){
			let d=getDigit(arr[j],q,r);
			write(cnts,d,cnts[d]+1,0,false,true);
		}
		while(i<len){
			let p=b-i<1?i:await dist(arr,cnts,offs,i,b,q,r);
			if(q==0){
				m+=r;
				let t=m/r|0;
				while(t%r==0){
					t=t/r|0;
					q++;
					if(t>len)stop("Unstable");
				}
				i=b;
				while(b<len&&shift(arr[b],q+1,r)==shift(m,q+1,r)){
					let d=getDigit(arr[b],q,r);
					write(cnts,d,cnts[d]+1,0,false,true);
					b++;
					await sleep();
				}
			}else{
				b=p;
				q--;
				for(let j=i;j<b;j++){
					let d=getDigit(arr[j],q,r);
					write(cnts,d,cnts[d]+1,0,false,true);
				}
			}
		}
	}
	async stacklessBinaryQuickSort(len){
		async function partition(A,a,b,t){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&!getBit(A[i],t));
				do j--;while(j>i&&getBit(A[j],t));
				if(i<j)await swap(A,i,j,1,true,false);
				else return i;
			}
		}
		let q=analyzeBit(arr,len),m=0,i=0,b=len;
		while(i<len){
			let p=b-i<1?i:await partition(arr,i,b,q);
			if(q==0){
				m+=2;
				while(!getBit(m,q+1))q++;
				i=b;
				while(b<len&&(arr[b]>>(q+1))==(m>>(q+1)))b++;
			}else{
				b=p;
				q--;
			}
		}
	}
	async staticSort(len){
		function findMinMax(A,a,b){
			let n=A[a],x=n;
			for(let i=a+1;i<b;i++){
				if(compareIndexValue(A,i,n)<0)n=A[i];
				else if(compareIndexValue(A,i,x)>0)x=A[i];
			}
			return[n,x];
		}
		async function sort(A,a,b){
			let nx=findMinMax(A,a,b);
			let auxLen=b-a;
			let cnts=new Array(auxLen+1).fill(0),offs=new Array(auxLen+1).fill(0);
			let CONST=auxLen/(nx[1]-nx[0]+1);
			let idx;
			for(let i=a;i<b;i++){
				idx=(A[i]-nx[0])*CONST|0;
				write(cnts,idx,cnts[idx]+1,0,false,true);
			}
			write(offs,0,a,0,false,true);
			for(let i=1;i<auxLen;i++)write(offs,i,cnts[i-1]+offs[i-1],0,false,true);
			for(let v=0;v<auxLen;v++){
				while(cnts[v]>0){
					let origin=offs[v];
					let from=origin;
					let num=A[from];
					await write(A,from,-1,.5,true);
					do{
						idx=(num-nx[0])*CONST|0;
						let to=offs[idx];
						write(offs,idx,offs[idx]+1,0,false,true);
						write(cnts,idx,cnts[idx]-1,0,false,true);
						let temp=A[to];
						await write(A,to,num,1,true);
						num=temp;
						from=to;
					}while(from-origin);
				}
			}
			for(let i=0;i<auxLen;i++){
				let s=i>1?offs[i-1]:a,e=offs[i];
				if(e-s<=1)continue;
				await insertSort(A,s,e);
			}

		}
		await sort(arr,0,len);
	}
	async binaryGnomeSort(len){
		for(let i=1;i<len;i++){
			let n=arr[i];
			let l=0,h=i;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(compareValues(n,arr[m])<0)h=m
				else l=m+1;
			}
			let j=i;
			while(j>l)await swap(arr,j,--j,.05,true);
		}
	}
	async bubbleBogoSort(len){
		let j=0;
		while(!isArraySorted(arr,len)){
			let i=randInt(0,len-1);
			if(compareIndices(arr,i,i+1)>0){
				swap(arr,i,i+1,0,true);
				if(1/16*++j>=1)await sleep(j=0);
			}
		}
	}
	async bubbleSort(len){
		let k=0;
		for(let i=len-1;i>0;i--){
			let s=true;
			for(let j=0;j<i;j++){
				if(compareIndices(arr,j,j+1)>0){
					swap(arr,j,j+1,0);
					if(++k>=16){
						markSwap(j,j+1);
						await sleep(k=0);
					}
					s=false;
				}
			}
			if(s)break;
		}
	}
	async circleSortIterative(len){
		let n=1;
		for(;n<len;n*=2);
		while(await iterativeCircleSortRoutine(arr,n));
	}
	async circleSortRecursive(len){
		let n=1;
		for(;n<len;n*=2);
		while(await recursiveCircleSortRoutine(arr,0,n-1,0));
	}
	async circloidSort(len){
		async function circle(A,a,b){
			let s=false;
			while(a<b){
				if(compareIndices(A,a,b)>0){
					await swap(A,a,b,1,true);
					s=true;
				}
				a++;b--;
				if(a==b)b++;
			}
			return s;
		}
		async function circlePass(A,L,R){
			if(L>=R)return;
			let m=(L+R)/2|0;
			let l=await circlePass(A,L,m);
			let r=await circlePass(A,m+1,R);
			return await circle(A,L,R)||l||r;
		}
		while(await circlePass(arr,0,len-1));
	}
	async classicThreeSmoothCombSort(len){
		function is3Smooth(n){
			while(n%6==0)n=n/6;
			while(n%3==0)n=n/3;
			while(n%2==0)n=n/2;
			return n==1;
		}
		for(let g=len-1;g>0;g--)
			if(is3Smooth(g))
				for(let i=g;i<len;i++)
					if(compareIndices(arr,i-g,i)>0)
						await swap(arr,i-g,i,0,true,false);
	}
	async cocktailShakerSort(len){
		await cocktailShaker(arr,0,len,1/sqrt(len));
	}
	async combSort(len){
		let sw=false,g=len,k=0;
		while(g>1||sw){
			if(g>1)g=g/1.3|0;
			sw=false;
			for(let i=0;g+i<len;++i){
				if(compareIndices(arr,i,i+g)>0){
					swap(arr,i,i+g,0,true);
					sw=true;
					if(++k>=4)await sleep(k=0);
				}
			}
		}
	}
	async hybridCombSort(len){
		let sw=false,g=len;
		while(g>1||sw){
			if(g>1)g=g/1.3|0;
			sw=false;
			for(let i=0;g+i<len;++i){
				if(g<=minVal(8,len*(1/32))){
					g=0;
					await insertSort(arr,0,len);
					break;
				}
				if(compareIndices(arr,i,i+g)>0){
					await swap(arr,i,i+g,0.75,true);
					sw=true;
				}
			}
		}
	}
	async completeGraphSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		async function split(A,a,m,b){
			if(b-a<2)return;
			let c=0,l1=(b-a)/2|0,odd=(b-a)%2==1;
			if(odd){
				if(m-a>b-m)c=a++;
				else c=--b;
			}
			for(let s=0;s<l1;s++){
				let i=a;
				for(let j=s;j<l1;j++)
					await cs(A,i++,m+j);
				for(let j=0;j<s;j++)
					await cs(A,i++,m+j);
			}
			if(odd){
				if(c<m)for(let j=0;j<l1;j++)await cs(A,c,m+j);
				else for(let j=0;j<l1;j++)await cs(A,a+j,c);
			}
		}
		let n=len,d=2,e=1<<(log(n-1)/log(2)+1|0);
		while(d<=e){
			let i=0,dec=0;
			while(i<n){
				let j=i;
				dec+=n;
				while(dec>=d){
					dec-=d;
					j++;
				}
				let k=j;
				dec+=n;
				while(dec>=d){
					dec-=d;
					k++;
				}
				await split(arr,i,j,k);
				i=k;
			}
			d*=2;
		}
	}
	async dualPivotQuickSort(len){
		async function dualPivot(A,l,r,d){
			let ln=r-l;
			if(ln<4)return await insertSort(arr,l,r+1);
			let th=ln/d|0,m1=l+th,m2=r-th;
			if(m1<=l)m1=l+1;
			if(m2>=r)m2=r-1;
			if(compareIndices(A,m1,m2)<0){
				await swap(A,m1,l,0,true);
				await swap(A,m2,r,0,true);
			}else{
				await swap(A,m1,r,0,true);
				await swap(A,m2,l,0,true);
			}
			let p1=A[l],p2=A[r],ls=l+1,gr=r-1;
			for(let k=ls;k<=gr;k++){
				if(compareValues(A[k],p1)<0)await swap(A,k,ls++,0,true);
				else if(compareValues(A[k],p2)>0){
					while(k<gr&&compareValues(A[gr],p2)>0)gr--;
					await swap(A,k,gr--,0,true);
					if(compareValues(A[k],p1)<0)await swap(A,k,ls++,0,true);
				}
			}
			let ds=gr-ls;
			if(ds<13)d++;
			await swap(A,ls-1,l,0,true);
			await swap(A,gr+1,r,0,true);
			await dualPivot(A,l,ls-2,d);
			if(p1<p2)await dualPivot(A,ls,gr,d);
			await dualPivot(A,gr+2,r,d);
		}
		await dualPivot(arr,0,len-1,3);
	}
	async exchangeBogoSort(len){
		while(!isArraySorted(arr,len)){
			let i=randInt(0,len),j=randInt(0,len),c=compareIndices(arr,i,j);
			if(i<j?c>0:c<0)await swap(arr,i,j,0,true);
		}
	}
	async forcedStableQuickSort(len){
		function stableComp(A,K,a,b){
			let c=compareIndices(A,a,b);
			return c>0||(!c&&compareIndices(K,a,b)>0);
		}
		async function stableSwap(A,K,a,b){
			await swap(A,a,b,0,true);
			swap(K,a,b,0,false,true);
		}
		async function medianOfThree(A,K,a,b){
			let m=a+(b-1-a)/2|0;
			if(stableComp(A,K,a,m))await stableSwap(A,K,a,m);
			if(stableComp(A,K,m,b-1)){
				await stableSwap(A,K,m,b-1);
				if(stableComp(A,K,a,m))return;
			}
			await stableSwap(A,K,a,m);
		}
		async function partition(A,K,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&!stableComp(A,K,i,p));
				do j--;while(j>=i&&stableComp(A,K,j,p));
				if(i<j)await stableSwap(A,K,i,j);
				else return j;
			}
		}
		async function quickSort(A,K,a,b){
			if(b-a<3){
				if(b-a==2&&stableComp(A,K,a,a+1))await stableSwap(A,K,a,a+1);
				return;
			}
			await medianOfThree(A,K,a,b);
			let p=await partition(A,K,a+1,b,a);
			await stableSwap(A,K,a,p);
			await quickSort(A,K,a,p);
			await quickSort(A,K,p+1,b);
		}
		let K=new Array(len);
		for(let i=0;i<len;i++)write(K,i,i,0,false,true);
		await quickSort(arr,K,0,len);
	}
	async funSort(len){
		function binarySearch(A,s,e,v){
			while(s<e){
				let m=(s+e)>>>1;
				if(compareValues(A[m],v)<0)s=m+1;
				else e=m;
			}
			return s;
		}
		for(let i=1;i<len;i++){
			let d=false;
			do{
				d=true;
				let p=binarySearch(arr,0,len-1,arr[i]);
				if(compareIndices(arr,p,i,0,false)){
					if(i<p-1)await swap(arr,i,p-1,2,true);
					else if(i>p)await swap(arr,i,p,2,true);
					d=false;
				}
			}while(!d);
		}
	}
	async gnomeSort(len){
		for(let i=1;i<len;){
			if(compareIndices(arr,i,i-1)>=0)i++;
			else{
				await swap(arr,i,i-1,0.02,true);
				if(i>1)i--;
			}
		}
	}
	async LLQuickSort(len){
		async function partition(A,l,h){
			let p=A[h],i=l;
			for(let j=l;j<h;j++)
				if(compareValues(A[j],p)<0)
					await swap(A,i++,j,1,true);
			await swap(A,i,h,1,true);
			return i;
		}
		async function quickSort(A,l,h){
			if(l<h){
				let p=await partition(A,l,h);
				await quickSort(A,l,p-1);
				await quickSort(A,p+1,h);
			}
		}
		await quickSort(arr,0,len-1);
	}
	async LRQuickSort(len){
		async function quickSort(a,p,r){
			let pv=p+(r-p+1)/2|0,x=a[pv],i=p,j=r;
			while(i<=j){
				while(compareValues(a[i],x)<0)i++;
				while(compareValues(a[j],x)>0)j--;
				if(i<=j)await swap(a,i++,j--,1,true);
			}
			if(p<j)await quickSort(a,p,j);
			if(i<r)await quickSort(a,i,r);
		}
		await quickSort(arr,0,len-1);
	}
	async oddEvenSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let i=1;i<len-1;i+=2){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,0.075,true);
					s=false;
				}
			}
			for(let i=0;i<len-1;i+=2){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,0.075,true);
					s=false;
				}
			}
		}
	}
	async optimizedBubbleSort(len){
		let s;
		for(let i=len-1;i>0;i-=s){
			s=1;
			for(let j=0;j<i;j++){
				if(compareIndices(arr,j,j+1)>0){
					await swap(arr,j,j+1,0.075,true);
					s=1;
				}else s++;
			}
		}
	}
	async optimizedCocktailShakerSort(len){
		for(let st=0,e=len-1;st<e;){
			let s=1;
			for(let i=st;i<e;i++){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,0.075,true);
					s=1;
				}else s++;
			}
			e-=s;s=1;
			for(let i=e;i>st;i--){
				if(compareIndices(arr,i-1,i)>0){
					await swap(arr,i-1,i,0.075,true);
					s=1;
				}else s++;
			}
			st+=s;
		}
	}
	async optimizedGnomeSort(len){
		async function smartGnomeSort(A,l,h){
			let p=h;
			while(p>l&&compareValues(A[p-1],A[p])>0)await swap(A,p--,p,0,true);
		}
		for(let i=1;i<len;i++)await smartGnomeSort(arr,0,i);
	}
	async optimizedStoogeSort(len){
		async function forward(A,l,r){
			while(l<r){
				let i=r;
				while(l<i){
					if(compareIndices(A,l,i)>0)await swap(A,l,i,0.075,true);
					l++;i--;
				}
				l=0;r--;
			}
		}
		async function backward(A,l,r){
			let ln=r;
			while(l<r){
				let i=l;
				while(i<r){
					if(compareIndices(A,i,r)>0)await swap(A,i,r,0.075,true);
					i++;r--;
				}
				l++;r=ln;
			}
		}
		async function exchange(A,ln){
			let l=0,r=ln-1;
			while(l<r){
				if(compareIndices(A,l,r)>0)await swap(A,l,r,0.075,true);
				l++;r--;
			}
			await forward(A,0,ln-2);
			await backward(A,1,ln-1);
		}
		await exchange(arr,len);
	}
	async optimizedStoogeSortStudio(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,0,true);
				return true;
			}
			return false;
		}
		async function stoogeSort(A,a,m,b,mr){
			if(a>=m)return false;
			if(b-a==2)return await compSwap(A,a,m);
			let lC=false,rC=false,a2=(a+a+b)/3|0,b2=(a+b+b+2)/3|0;
			if(m<b2){
				lC=await stoogeSort(A,a,m,b2,mr);
				if(mr){
					rC=await stoogeSort(A,maxVal(a+b2-m,a2),b2,b,true);
					if(rC)await stoogeSort(A,a+b2-m,a2,2*a2-a,true);
				}else{
					rC=await stoogeSort(A,a2,b2,b,false);
					if(rC)await stoogeSort(A,a,a2,2*a2-a,true);
				}
			}else{
				rC=await stoogeSort(A,a2,m,b,mr);
				if(rC)await stoogeSort(A,a,a2,a2+b-m,true);
			}
			return lC||rC;
		}
		await stoogeSort(arr,0,1,len,false);
	}
	async quadStoogeSort(len){
		async function quadStooge(A,p,ln){
			if(ln>=2&&compareIndices(A,p,p+ln-1)>0)await swap(A,p,p+ln-1,0,true);
			if(ln<=2)return;
			let ln1=ln/2|0,ln2=(ln+1)/2|0,ln3=(ln1+1)/2+(ln2+1)/2|0;
			await quadStooge(A,p,ln1);
			await quadStooge(A,p+ln1,ln2);
			await quadStooge(A,p+ln1/2|0,ln3);
			await quadStooge(A,p+ln1,ln2);
			await quadStooge(A,p,ln1);
			if(ln>3)await quadStooge(A,p+ln1/2|0,ln3);
		}
		await quadStooge(arr,0,len);
	}
	async shoveSort(len){
		for(let i=0,k=0;i<len-1;){
			if(compareIndices(arr,i,i+1)>0){
				for(let f=i;f<len-1;f++){
					swap(arr,f,f+1,0,false);
					if(++k>=sqrt(len)*8){
						markSwap(f,f+1);
						await sleep(k=0);
					}
				}
				if(i>0)i--;
				continue;
			}
			i++;
		}
	}
	async sillySort(len){
		async function sillySort(A,i,j){
			let m;
			if(i<j){
				m=i+(j-i)/2|0;
				await sillySort(A,i,m);
				await sillySort(A,m+1,j);
				if(compareIndices(A,m+1,i)<1)await swap(A,i,m+1,1,true);
				await sillySort(A,i+1,j);
			}
		}
		await sillySort(arr,0,len-1);
	}
	async slopeSort(len){
		for(let i=1,j=1;i<len;i++,j++){
			for(let k=i-1;k>=0;k--,i--)
				if(compareIndices(arr,i,k)<0)
					await swap(arr,i,k,0,true);
			i=j;
		}
	}
	async slowSort(len){
		async function sort(A,i,j){
			if(i>=j)return;
			let m=i+(j-i)/2|0;
			await sort(A,i,m);
			await sort(A,m+1,j);
			if(compareIndices(A,m,j)>0)await swap(A,m,j,1,true);
			await sort(A,i,j-1);
		}
		await sort(arr,0,len-1);
	}
	async stablePermutationSort(len){
		async function permute(A,X,l){
			if(l<2)return isArraySorted(A,len);
			for(let i=l-2;i>=0;i--){
				if(await permute(A,X,l-1))return true;
				await swap(A,X[i],X[l-1],0,true);
				swap(X,i,l-1,0,false,true);
			}
			if(await permute(A,X,l-1))return true;
			let t=X[l-1];
			for(let i=l-1;i>0;i--)
				write(X,i,X[i-1],0,false,true);
			write(X,0,t,0,false,true);
			t=A[X[0]];
			for(let i=1;i<l;i++)
				await write(A,X[i-1],A[X[i]],0,true);
			await write(A,X[l-1],t,0,true);
			return false;
		}
		let X=new Array(len);
		for(let i=0;i<len;i++)
			write(X,i,i,0,false,true);
		await permute(arr,X,len);
	}
	async stableQuickSort(len){
		async function copy(list,A,i){
			for(let j of list)
				await write(A,i++,j,0,true);
		}
		async function stablePartition(A,s,e){
			let pV=A[s];
			let leftList=[];
			let rightList=[];
			for(let i=s+1;i<=e;i++){
				if(compareValues(A[i],pV)<0){
					leftList.push(A[i]);
				}else{
					rightList.push(A[i]);
				}
			}
			await copy(leftList,A,s)
			let nPI=s+leftList.length;
			await write(A,nPI,pV,0.25,true);
			await copy(rightList,A,nPI+1);
			return nPI;
		}
		async function stableQuickSort(A,s,e){
			if(s<e){
				let pI=await stablePartition(A,s,e);
				await stableQuickSort(A,s,pI-1);
				await stableQuickSort(A,pI+1,e);
			}
		}
		await stableQuickSort(arr,0,len-1);
	}
	async stoogeSort(len){
		async function sort(A,i,j){
			if(compareIndices(A,i,j)>0)
				await swap(A,i,j,0.005,true,false);
			if(j-i+1>=3){
				let t=(j-i+1)/3|0;
				await sort(A,i,j-t);
				await sort(A,i+t,j);
				await sort(A,i,j-t);
			}
		}
		await sort(arr,0,len-1);
	}
	async swaplessBubbleSort(len){
		let l;
		for(let i=len;i>0;i=l){
			l=0;
			let p=0,c=arr[0];
			for(let j=1;j<i;j++){
				if(compareValues(c,arr[j])>0){
					await write(arr,j-1,arr[j],0,true);
					l=j;
				}else{
					if(p+1<j)
						await write(arr,j-1,c,0,true);
					p=j;
					c=arr[j];
				}
			}
			await write(arr,i-1,c,0.075,true);
		}
	}
	async tableSort(len){
		function sC(A,T,a,b){
			let c=compareIndices(A,T[a],T[b]);
			return c>0||(!c&&compareIndices(T,a,b)>0);
		}
		async function medianOfThree(A,T,a,b){
			let m=a+(b-1-a)/2;
			if(sC(A,T,a,m))
				await swap(T,a,m,1,true,true);
			if(sC(A,T,m,b-1)){
				await swap(T,m,b-1,1,true,true);
				if(sC(A,T,a,m))return;
			}
			await swap(T,a,m,1,true,true);
		}
		async function partition(A,T,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&!sC(A,T,i,p));
				do j--;while(j>=i&&sC(A,T,j,p));
				if(i<j)await swap(T,i,j,1,true,true);
				else return j;
			}
		}
		async function quickSort(A,T,a,b){
			if(b-a<3){
				if(b-a==2&&sC(A,T,a,a+1))
					await swap(T,a,a+1,1,true,true);
				return;
			}
			await medianOfThree(A,T,a,b)
			let p=await partition(A,T,a+1,b,a);
			await swap(T,a,p,1,true,true);
			await quickSort(A,T,a,p);
			await quickSort(A,T,p+1,b);
		}
		let T=new Array(len);
		for(let i=0;i<len;i++)write(T,i,i,0,false,true);
		await quickSort(arr,T,0,len);
		for(let i=0;i<T.length;i++){
			if(compareValues(i,T[i])){
				let t=arr[i],j=i,n=T[i];
				do{
					await write(arr,j,arr[n],1,true);
					write(T,j,j,0,true,true);
					j=n;
					n=T[n];
				}while(compareValues(n,i));
				await write(arr,j,t,1,true);
				write(T,j,j,0,true,true);
			}
		}
	}
	async threeSmoothCombSortIterative(len){
		async function cS(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		let p2=log(len-1)/log(2)|0;
		for(let k=p2;k>=0;k--){
			let p3=(log(len)-k*log(2))/log(3)|0;
			for(let j=p3;j>=0;j--){
				let g=pow(2,k)*pow(3,j)|0;
				for(let i=0;i+g<len;i++)
					await cS(arr,i,i+g);
			}
		}
	}
	async threeSmoothCombSortRecursive(len){
		async function recursiveComb(A,p,g,e){
			if(p+g>e)return;
			await recursiveComb(A,p,g*2,e);
			await recursiveComb(A,p+g,g*2,e);
			await powerOfThree(A,p,g,e);
		}
		async function powerOfThree(A,p,g,e){
			if(p+g>e)return;
			await powerOfThree(A,p,g*3,e);
			await powerOfThree(A,p+g,g*3,e);
			await powerOfThree(A,p+2*g,g*3,e);
			for(let i=p;i+g<e;i+=g)
				if(compareIndices(A,i,i+g)>0)
					await swap(A,i,i+g,0,true,false);
		}
		await recursiveComb(arr,0,1,len);
	}
	async unoptimizedBubbleSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let i=0;i<len-1;i++){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,0,true);
					s=false;
				}
			}
		}
	}
	async unoptimizedCocktailShakerSort(len){
		async function cocktailShaker(A,s,e){
			let i=s;
			while(i<e/2+s|0){
				for(let j=i;j<e+s-i-1;j++)
					if(compareIndices(A,j,j+1)>0)
						await swap(A,j,j+1,0,true);
				for(let j=e+s-i-1;j>i;j--)
					if(compareIndices(A,j,j-1)<0)
						await swap(A,j,j-1,0,true);
				i++
			}
		}
		await cocktailShaker(arr,0,len);
	}
	async binaryDoubleInsertionSort(len){
		await binaryDoubleInsertion(arr,0,len);
	}
	async binaryInsertSort(len){
		for(let i=0;i<len;i++){
			let n=arr[i],lo=0,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,arr[m])<0)hi=m;
				else lo=m+1;
			}
			let j=i-1;
			while(j>=lo)await write(arr,j+1,arr[j--],0,true);
			await write(arr,lo,n,0,true);
		}
	}
	async doubleInsertionSort(len){
		async function insertionSort(A,s,e){
			let l=s+(e-s)/2-1|0,r=l+1;
			if(compareIndices(A,l,r)>0)
				await swap(A,l,r,0,true);
			l--;r++;
			let lI,rI;
			while(l>=s&&r<e){
				if(compareIndices(A,l,r)>0){
					lI=A[r];
					rI=A[l];
					let p=l+1;
					while(p<=r&&compareValues(A[p],lI)<1)
						await write(A,p-1,A[p++],0,true);
					await write(A,p-1,lI,0,true);
					p=r-1;
					while(p>=l&&compareValues(rI,A[p])<1)
						await write(A,p+1,A[p--],0,true);
					await write(A,p+1,rI,0,true);
				}else{
					lI=A[l];
					rI=A[r];
					let p=l+1;
					while(compareValues(A[p],lI)<0)
						await write(A,p-1,A[p++],0,true);
					await write(A,p-1,lI,0,true);
					p=r-1;
					while(compareValues(A[p],rI)>0)
						await write(A,p+1,A[p--],0,true);
					await write(A,p+1,rI,0,true);
				}
				l--;r++;
			}
			if(r<e){
				let p=r-1,c=A[r];
				while(compareValues(A[p],c)>0)
					await write(A,p+1,A[p--],0,true);
				await write(A,p+1,c,0,true);
			}
		}
		await insertionSort(arr,0,len);
	}
	async insertionSort(len){
		await insertSort(arr,0,len);
	}
	async librarySort(len){
		let G=15;
		let R=4;
		let max;
		function shiftExt(A,a,m,b){
			let m1=a+minVal(m-a,b-m);
			while(m>a)write(A,--b,A[--m]);
			while(a<m1)write(A,a++,max);
		}
		function leftBlockSearch(A,a,b,v){
			let s=G+1;
			while(a<b){
				let m=a+(b-a)/s/2*s|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+s;
			}
			return a;
		}
		function rightBlockSearch(A,a,b,v){
			let s=G+1;
			while(a<b){
				let m=a+(b-a)/s/2*s|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+s;
			}
			return a;
		}
		function locSearch(A,a,b){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(max,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0) b=m;
				else a=m+1;
			}
			return a;
		}
		async function insertTo(A,a,b,aux){
			let t=A[a];
			while(a>b){
				if(!aux)await sleep();
				write(A,a,A[--a],0,!aux,aux);
			}
			if(!aux)await sleep();
			write(A,b,t,0,!aux,aux);
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]),false);
		}
		async function retrieve(A,T,i,p){
			let loc=i-1;
			for(let k=p-(G+1);k>G;){
				let m=locSearch(T,k-G,k)-1;k-=G+1;
				while(m>=k){
					await write(A,loc--,T[m],0,true);
					write(T,m--,max,0,false,true);
				}
			}
			let m=locSearch(T,0,G)-1;
			while(m>=0){
				await write(A,loc--,T[m],0,true);
				write(T,m--,max,0,false,true);
			}
		}
		async function sort(A,ln){
			max=ln;
			let T=new Array(ln*(G+1)-1|0).fill(max);
			let rng=new Random(),s=ln;
			while(s>=32)s=(s-1)/R+1|0;
			let i=s,j=R*i,p=(s+1)*(G+1)+G;
			await bininsert(A,0,s);
			for(let k=0;k<s;k++)write(T,k*(G+1)+G,A[k],0,false,true);
			for(;i<ln;i++){
				if(i==j){
					retrieve(A,T,s=i,p);
					p=(s+1)*(G+1)+G;
					j*=R;
					for(let k=0;k<s;k++)write(T,k*(G+1)+G,A[k],0,false,true);
				}
				let bLoc=leftBlockSearch(T,G,p-(G+1),A[i]);
				if(compareValues(A[i],T[bLoc])){
					let eqEnd=rightBlockSearch(T,bLoc+(G+1),p-(G+1),A[i]);
					bLoc+=rng.nextInt((eqEnd-bLoc)/(G+1)|0)*(G+1);
				}
				let loc=locSearch(T,bLoc-G,bLoc);
				if(loc==bLoc){
					do bLoc+=G+1;while(bLoc<p&&locSearch(T,bLoc-G,bLoc)==bLoc);
					if(bLoc==p){
						retrieve(A,T,s=i,p);
						p=(s+1)*(G+1)+G;
						j=R*i;
						for(let k=0;k<s;k++)write(T,k*(G+1)+G,A[k],1,false,true);
					}else{
						let rotP=locSearch(T,bLoc-G,bLoc),rotS=bLoc-maxVal(rotP,bLoc-G/2|0);
						shiftExt(T,loc-rotS,bLoc-rotS,bLoc);
					}
					i--;
				}else{
					write(T,loc,A[i],0,false,true);
					await insertTo(T,loc,rightBinSearch(T,bLoc-G,loc,T[loc]),true);
				}
			}
			await retrieve(A,T,ln,p);
		}
		await sort(arr,len);
	}
	async librarySort(len){
		let R=4;
		function gML(n){
			while(n>=32)n=(n-1)/R+1|0;
			return n;
		}
		function bins(ar,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,ar[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function reb(ar,t,c,l,m,b){
			for(let i=0;i<m;i++)write(c,i+1,c[i+1]+c[i]+1,0,true);
			for(let i=m,j=0;i<b;i++,j++){
				write(t,c[l[j]],ar[i],0,true);
				write(c,l[j],c[l[j]]+1,0,true);
			}
			for(let i=0;i<m;i++){
				write(t,c[i],ar[i],0,true);
				write(c,i,c[i]+1,0,true);
			}
			await arraycopy(t,0,ar,0,b,1);
			await insertSort(ar,0,c[0]-1);
			for(let i=0;i<m-1;i++)await insertSort(ar,c[i],c[i+1]-1);
			await insertSort(ar,c[m-1],c[m]);
			for(let i=0;i<m+2;i++)write(c,i,0,0,true);
		}
		if(len<32)await insertSort(arr,0,len);
		else{
			let j=gML(len),mx=j;
			await insertSort(arr,0,j);
			for(;mx*R<len;mx*=R);
			let t=new Array(len).fill(0),c=new Array(mx+2).fill(0),l=new Array(len-mx).fill(0);
			for(let i=j,k=0;i<len;i++){
				if(R*j==i){
					await reb(arr,t,c,l,j,i);
					j=i;k=0;
				}
				let o=bins(arr,0,j,arr[i]);
				write(c,o+1,c[o+1]+1,true);
				write(l,k++,o,true);
			}
			await reb(arr,t,c,l,j,len);
		}
	}
	async recursiveShellSort(len){
		async function gIns(A,a,b,g){
			for(let i=a+g;i<b;i+=g){
				let k=A[i],j=i-g;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],0.5,true);
					j-=g;
				}
				await write(A,j+g,k,0.5,true);
			}
		}
		async function recursiveShellSort(A,s,e,g){
			if(s+g<=e){
				await recursiveShellSort(A,s,e,3*g);
				await recursiveShellSort(A,s+g,e,3*g);
				await recursiveShellSort(A,s+(2*g),e,3*g);
				await gIns(A,s,e,g);
			}
		}
		await recursiveShellSort(arr,0,len,1);
	}
	async shellSort(len){
		async function sort(A,l){
			let incs=[8861,3938,1750,701,301,132,57,23,10,4,1];
			for(let k=0;k<incs.length;k++){
				if(incs[k]<l){
					for(let h=incs[k],i=h;i<l;i++){
						let v=A[i],j=i;
						while(j>=h&&compareValues(A[j-h],v)>0){
							await write(A,j,A[j-=h],1);
						}
						await write(A,j,v,1,true,0);
					}
				}
			}
		}
		await sort(arr,len);
	}
	async andreySort(len){
		async function sort(A,a,b){
			while(b>1){
				let k=0;
				for(let i=1;i<b;i++)
					if(compareIndices(A,a+k,a+i)>0)k=i;
				await swap(A,a,a+k,1,true);
				a++;b--;
			}
		}
		async function aswap(A,a,b,l){
			while(l-->0)
				await swap(A,a++,b++,1,true);
		}
		async function backmerge(A,a1,l1,a2,l2){
			let a0=a2+l1;
			for(;;){
				if(compareIndices(A,a1,a2)>0){
					await swap(A,a1--,a0--,1,true);
					if(--l1==0)return 0;
				}else{
					await swap(A,a2--,a0--,1,true);
					if(--l2==0)break;
				}
			}
			let r=l1;
			do await swap(A,a1--,a0--,1,true);while(--l1);
			return r;
		}
		async function rmerge(A,a,l,r){
			for(let i=0;i<l;i+=r){
				let q=i;
				for(let j=i+r;j<l;j+=r)
					if(compareIndices(A,a+q,a+j)>0)
						q=j;
				if(q!=i)
					await aswap(A,a+i,a+q,r)
				if(i){
					await aswap(A,a+l,a+i,r)
					await backmerge(A,a+l+r-1,r,a+i-1,r)
				}
			}
		}
		function rbnd(l){
			l=l/2|0;
			let k=0;
			for(let i=1;i<l;i*=2)k++;
			l=l/k|0;
			for(k=1;k<=l;k*=2);
			return k;
		}
		async function msort(A,a,l){
			if(l<12)return await sort(A,a,l);
			let r=rbnd(l),lr=(l/r-1|0)*r;
			for(let p=2;p<=lr;p+=2){
				if(compareIndices(A,a+p-2,a+p-1)>0)
					await swap(A,a+p-2,a+p-1,1,true);
				if(p&2)continue;
				await aswap(A,a+p-2,a+p,2);
				let m=l-p,q=2;
				for(;;){
					let q0=2*q;
					if(q0>m||(p&q0))break;
					await backmerge(A,a+p-q-1,q,a+p+q-1,q);
					q=q0;
				}
				await backmerge(A,a+p+q-1,q,a+p-q-1,q);
				let q1=q;
				q*=2;
				while(!(q&p)){
					q*=2;
					await rmerge(A,a+p-q,q,q1);
				}
			}
			let q1=0;
			for(let q=r;q<lr;q*=2){
				if((lr&q)){
					q1+=q;
					if(q1!=q)await rmerge(A,a+lr-q1,q1,r);
				}
			}
			let s=l-lr;
			await msort(A,a+lr,s);
			await aswap(A,a,a+lr,s);
			s+=await backmerge(A,a+s-1,s,a+lr-1,lr-s);
			await msort(A,a,s);
		}
		await msort(arr,0,len);
	}
	async blockSwapMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function binarySearchMid(A,s,md,e){
			let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
			while(b>a){
				if(compareIndices(A,md-m-1,md+m)>0)a=m+1;
				else b=m;
				m=a+(b-a)/2|0;
			}
			return m;
		}
		async function multiSwapMerge(A,s,md,e){
			let m=binarySearchMid(A,s,md,e);
			while(m>0){
				await multiSwap(A,md-m,md,m);
				await multiSwapMerge(A,md,md+m,e);
				e=md;
				md-=m;
				m=binarySearchMid(A,s,md,e);
			}
		}
		async function multiSwapMergeSort(A,a,b){
			let len=b-a,i;
			for(let j=1;j<len;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await multiSwapMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await multiSwapMerge(A,i,i+j,b);
			}
		}
		await multiSwapMergeSort(arr,0,len);
	}
	async bottomUpMergeSort(len){
		async function merge(A,ln,i,mS){
			let l=i;
			let m=l+mS/2|0;
			let r=m;
			let e=minVal(ln,i+mS);
			let sI=l;
			if(r<e){
				while(l<m&&r<e)
					if(compareValues(A[l],A[r])<1)write(X,sI++,A[l++],0,false,true);
					else write(X,sI++,A[r++],0,false,true);
				if(l<m)
					while(l<m)
						write(X,sI++,A[l++],0,false,true);
				if(r<e)
					while(r<e)
						write(X,sI++,A[r++],0,false,true);
			}else cL=l;
		}
		let X=new Array(len);
		let cL;
		let mS=2;
		while(mS<=len){
			cL=len;
			for(let i=0;i<len;i+=mS)
				await merge(arr,len,i,mS);
			for(let i=0;i<cL;i++)await write(arr,i,X[i],1,true);
			mS*=2;
		}
		if((mS/2|0)!=len){
			await merge(arr,len,0,mS);
			for(let i=0;i<len;i++)await write(arr,i,X[i],1,true);
		}
	}
	async bufferedStoogeSort(len){
		function compare(A,x,y){
			return compareIndices(A,x,y)
		}
		async function wrapper(A,s,e){
			if(e-s>1){
				if(e-s==2&&compare(A,s,e-1)>0)
					await swap(A,s,e-1,1,true);
				if(e-s>2){
					let th=ceil((e-s)/3)+s;
					let tth=ceil((e-s)/3*2)+s;
					if(tth-th<th)tth--;
					if((e-s-2)%3==0)tth--;
					await wrapper(A,th,tth);
					await wrapper(A,tth,e);
					let l=th;
					let r=tth;
					let bS=s;
					while(l<tth&&r<e){
						if(compare(A,l,r)>0)await swap(A,bS,r++,1,true);
						else await swap(A,bS,l++,1,true);
						bS++;
					}
					while(r<e)await swap(A,bS++,r++,1,true);
					await wrapper(A,tth,e);
					l=tth-1;
					r=e-1;
					while(r>l&&l>=s){
						if(compare(A,l,r)>0){
							for(let i=l;i<r;i++)
								await swap(A,i,i+1,0,true);
							l--;
						}
						r--;
					}
				}
			}
		}
		await wrapper(arr,0,len);
	}
	async improvedInPlaceMergeSort(len){
		async function push(A,p,a,b){
			if(a==b)return;
			let t=A[p];
			await write(A,p,A[a],0,true);
			for(let i=a+1;i<b;i++)
				await write(A,i-1,A[i],0,true);
			await write(A,b-1,t,0,true);
		}
		async function merge(A,a,m,b){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)>0)j++;
				else await push(A,i++,m,j);
			}
			while(i<m)await push(A,i++,m,b);
		}
		async function mergeSort(A,a,b){
			let m=a+(b-a)/2|0;
			if(b-a>2){
				if(b-a>3)
					await mergeSort(A,a,m);
				await mergeSort(A,m,b);
			}
			await merge(A,a,m,b);
		}
		await mergeSort(arr,0,len);
	}
	async inPlaceMergeSort(len){
		async function push(A,low,high){
			for(let i=low;i<high;i++)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,0.035,true);
		}
		async function merge(A,n,x,m){
			let i=n;
			while(i<=m){
				if(compareIndices(A,i,m+1)>0){
					await swap(A,i,m+1,0.035,true);
					await push(A,m+1,x);
				}
				i++;
			}
		}
		async function mergeSort(A,n,x){
			if(x-n==0){
			}else if(x-n==1){
				if(compareIndices(A,n,x)>0)
					await swap(A,n,x,0,true,);
			}else{
				let m=(n+x)/2|0;
				await mergeSort(A,n,m);
				await mergeSort(A,m+1,x)
				await merge(A,n,x,m);
			}
		}
		await mergeSort(arr,0,len-1);
	}
	async iterativeTopDownMergeSort(len){
		function cPOT(x){
			--x;
			for(let i=16;i>0;i>>=1)x|=x>>i;
			return++x;
		}
		async function merge(A,T,s,m,e){
			let lo=s;
			let hi=m;
			let n=s;
			for(;lo<m&&hi<e;++n){
				if(compareIndices(A,lo,hi)>0)write(T,n,A[hi++],0,false,true);
				else write(T,n,A[lo++],0,false,true);
			}
			if(lo>=m)
				while(hi<e)
					write(T,n++,A[hi++],0,false,true);
			else
				while(lo<m)
					write(T,n++,A[lo++],0,false,true);
			for(let i=s;i<e;i++)
				await write(A,i,T[i],1,true,false);
		}
		async function mergeSort(A,T,l){
			if(l<1<<15)
				for(let j=cPOT(l);j>1;j>>=1)
					for(let i=0;i<j;i+=2)
						await merge(A,T,l*i/j|0,l*(i+1)/j|0,l*(i+2)/j|0);
		}
		let T=new Array(len);
		await mergeSort(arr,T,len);
	}
	async newShuffleMergeSort(len){
		function cPOT(x){
			--x;
			for(let i=16;i>0;i>>=1)x|=x>>i;
			return++x;
		}
		async function rotateEqual(A,a,b,z){
			for(let i=0;i<z;++i)
				await swap(A,a+i,b+i,0,true);
		}
		async function rotate(A,m,a,b){
			while(a>0&&b>0){
				if(a>b){
					await rotateEqual(A,m-b,m,b);
					m-=b;
					a-=b;
				}else{
					await rotateEqual(A,m-a,m,a);
					m+=a;
					b-=a;
				}
			}
		}
		async function shuffleEasy(A,s,z){
			for(let i=1;i<z;i*=3){
				let v=A[s+i-1];
				for(let j=i*2%z;j!=i;j=j*2%z){
					let nv=A[s+j-1];
					await write(A,s+j-1,v,1,true);
					v=nv;
				}
				await write(A,s+i-1,v,1,true);
			}
		}
		async function shuffle(A,s,e){
			while(e-s>1){
				let n=(e-s)/2|0;
				let l=1;
				while(l*3-1<=2*n)l*=3;
				let m=(l-1)/2|0;
				await rotate(A,s+n,n-m,m,1);
				await shuffleEasy(A,s,l);
				s+=l-1;
			}
		}
		async function rotateShuffledEqual(A,a,b,z){
			for(let i=0;i<z;i+=2)
				await swap(A,a+i,b+i,0.25,true);
		}
		async function rotateShuffled(A,m,a,b){
			while(a>0&&b>0){
				if(a>b){
					await rotateShuffledEqual(A,m-b,m,b);
					m-=b;
					a-=b;
				}else{
					await rotateShuffledEqual(A,m-a,m,a);
					m+=a;
					b-=a;
				}
			}
		}
		async function rotateShuffledOuter(A,m,a,b){
			if(a>b){
				await rotateShuffledEqual(A,m-b,m+1,b);
				m-=b;
				a-=b;
				await rotateShuffled(A,m,a,b);
			}else{
				await rotateShuffledEqual(A,m-a,m+1,a);
				m+=a+1;
				b-=a;
				await rotateShuffled(A,m,a,b);
			}
		}
		async function unshuffleEasy(A,s,z){
			for(let i=1;i<z;i*=3){
				let pr=i;
				let v=A[s+i-1];
				for(let j=i*2%z;j!=i;j=j*2%z){
					await write(A,s+pr-1,A[s+j-1],0.25,true);
					pr=j;
				}
				await write(A,s+pr-1,v,0.25,true);
			}
		}
		async function unshuffle(A,s,e){
			while(e-s>1){
				let n=(e-s)/2|0;
				let l=1;
				while(l*3-1<=2*n)l*=3;
				let m=(l-1)/2|0;
				await rotateShuffledOuter(A,s+2*m,2*m,2*n-2*m);
				await unshuffleEasy(A,s,l);
				s+=l-1;
			}
		}
		async function mergeUp(A,s,e,tp){
			let i=s;
			let j=i+1;
			while(j<e){
				let c=compareIndices(A,i,j,0,true);
				if(c<0||!tp&&!c){
					if(++i==j){
						++j;
						tp=!tp;
					}
				}else if(e-j==1){
					await rotate(A,j,j-i,1,0.25);
					break;
				}else{
					let r=0;
					if(tp)while(j+2*r<e&&compareIndices(A,j+2*r,i)<1)++r;
					else while(j+2*r<e&&compareIndices(A,j+2*r,i)<0)++r;
					--j;
					await unshuffle(A,j,j+2*r);
					await rotate(A,j,j-i,r,0.25);
					i+=r+1;
					j+=2*r+1;
				}
			}
		}
		async function merge(A,tmp,s,m,e){
			if(m-s<=e-m){
				await shuffle(A,s,e);
				await mergeUp(A,s,e,true);
			}else{
				await shuffle(A,s+1,e);
				await mergeUp(A,s,e,false);
			}
		}
		async function mergeSort(A,T,l){
			if(l<1<<15)
				for(let j=cPOT(l);j>1;j>>=1)
					for(let i=0;i<j;i+=2)
						await merge(A,T,l*i/j|0,l*(i+1)/j|0,l*(i+2)/j|0);
		}
		await mergeSort(arr,null,len);
	}
	async PDMergeSort(len){
		async function mU(A,s,m,e){
			for(let i=0;i<m-s;i++)write(c,i,A[i+s],true);
			let P=0,l=s,r=m;
			while(l<r&&r<e)
				if(compareValues(c[P],A[r])<1)await write(A,l++,c[P++],0,true);
				else await write(A,l++,A[r++],0,true);
			while(l<r)await write(A,l++,c[P++],0,true);
		}
		async function mD(A,s,m,e){
			for(let i=0;i<e-m;i++)write(c,i,A[i+m],true);
			let P=e-m-1,l=m-1,r=e-1;
			while(r>l&&l>=s)
				if(compareValues(A[l],c[P])<1)await write(A,r--,c[P--],0,true);
				else await write(A,r--,A[l--],0,true);
			while(r>l)await write(A,r--,c[P--],0,true);
		}
		async function mr(A,l,r,e){
			if(e-r<r-l)await mD(A,l,r,e);
			else await mU(A,l,r,e);
		}
		function compare(a,b){return compareValues(a,b)<1}
		async function iR(A,i,m){
			let s=i;
			if(i>=m)return-1;
			let p=compare(A[i],A[++i]);
			while(i<m&&compare(A[i],A[i+1])==p)i++;
			if(!p)await reversal(A,s,i,0,false,true);
			if(i>=m)return-1;
			return i+1;
		}
		async function fR(A,m){
			let r=new Array(2+m/2|0);C=0;
			for(let lR=0;lR!=-1;lR=await iR(A,lR,m))write(r,C++,lR,0,false,true);
			return r;
		}
		let C,c=new Array(len/2|0),r=await fR(arr,len-1);
		while(C>1){
			for(let i=0;i<C-1;i+=2)await mr(arr,r[i],r[i+1],i+2>=C?len:r[i+2]);
			for(let i=1,j=2;i<C;i++,j+=2,C--)write(r,i,r[j],0,false,true);
		}
	}
	async rotateMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true,false);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=l?compareValues(v,A[m])<1:compareValues(v,A[m])<0;
				if(c)b=m;
				else a=m+1;
			}
			return a;
		}
		async function rotateMerge(A,a,m,b){
			let m1,m2,m3;
			if(m-a>=b-m){
				m1=a+(m-a)/2|0;
				m2=binarySearch(A,m,b,A[m1],true);
				m3=m1+(m2-m);
			}else{
				m2=m+(b-m)/2|0;
				m1=binarySearch(A,a,m,A[m2],false);
				m3=(m2++)-(m-m1);
			}
			await rotate(A,m1,m,m2);
			if(m2-m3+1>0&&b-m2>0)await rotateMerge(A,m3+1,m2,b);
			if(m1-a>0&&m3-m1>0)await rotateMerge(A,a,m1,m3);
		}
		async function rotateMergeSort(A,a,b){
			let l=b-a,i;
			for(let j=1;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await rotateMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await rotateMerge(A,i,i+j,b);
			}
		}
		await rotateMergeSort(arr,0,len);
	}
	async weavedMergeSort(len){
		async function merge(A,T,l,r,md){
			if(r+md>=l)return;
			let lo=r,hi=r+md,d=md<<1;
			await merge(A,T,l,lo,d);
			await merge(A,T,l,hi,d);
			let n=r;
			for(;lo<l&&hi<l;n+=md){
				let c=compareIndices(A,lo,hi);
				if(c>0||!c&&lo>hi){
					write(T,n,A[hi],1,false,true);
					hi+=d;
				}else{
					write(T,n,A[lo],1,false,true);
					lo+=d;
				}
			}
			if(lo>=l)while(hi<l){
				write(T,n,A[hi],1,false,true);
				n+=md;hi+=d;
			}else while(lo<l){
				write(T,n,A[lo],1,false,true);
				n+=md;lo+=d;
			}
			for(let i=r;i<l;i+=md)await write(A,i,T[i],1,true,false);
		}
		let T=new Array(len).fill(0);
		await merge(arr,T,len,0,1);
	}
	async lazyStableSort(len){
		async function grailSwap(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)
				await grailSwap(A,a++,b++);
		}
		function grailBinSearch(A,p,ln,kP,L){
			let l=-1,r=ln;
			while(l<r-1){
				let m=l+((r-l)>>1);
				if(compareIndices(A,kP,p+m)<(L?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailRotate(A,p,lA,lB){
			while(lA&&lB){
				if(lA<=lB){
					await grailMultiSwap(A,p,p+lA,lA);
					p+=lA;
					lB-=lA;
				}else{
					await grailMultiSwap(A,p+lA-lB,p+lA,lB);
					lA-=lB;
				}
			}
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2){
				while(l1){
					let o=grailBinSearch(A,p+l1,l2,p,true);
					if(o){
						await grailRotate(A,p,l1,o);
						p+=o;
						l2-=o;
					}
					if(!l2)break;
					do{
						p++;
						l1--;
					}while(l1&&compareIndices(A,p,p+l1)<1);
				}
			}else{
				while(l2){
					let o=grailBinSearch(A,p,l1,p+(l1+l2-1),false);
					if(o!=l1){
						await grailRotate(A,p+o,l1-o,l2);
						l1=o;
					}
					if(!l1)break;
					do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
				}
			}
		}
		async function grailLazyStableSort(A,p,l){
			for(let d=1;d<l;d+=2)
				if(compareIndices(A,p+d-1,p+d)>0)
					await grailSwap(A,p+(d-1),p+d);
			for(let pt=2;pt<l;pt*=2){
				let lf=0;
				let ri=l-2*pt;
				while(lf<=ri){
					await grailMergeWithoutBuffer(A,p+lf,pt,pt);
					lf+=2*pt;
				}
				let r=l-lf;
				if(r>pt)await grailMergeWithoutBuffer(A,p+lf,pt,r-pt);
			}
		}
		await grailLazyStableSort(arr,0,len);
	}
	async mergeSort(len){
		async function merge(A,T,s,m,e){
			if(s==m)return;
			await merge(A,T,s,(m+s)/2|0,m);
			await merge(A,T,m,(m+e)/2|0,e);
			let l=s;
			let h=m;
			for(let n=0;n<e-s;n++){
				if(l>=m&&h>=e)break;
				if(l<m&&h>=e)write(T,n,A[l++],1,false,true);
				else if(l>=m&&h<e)write(T,n,A[h++],1,false,true);
				else if(compareIndices(A,l,h)<1)write(T,n,A[l++],1,false,true);
				else write(T,n,A[h++],1,false,true);
			}
			for(let i=0;i<e-s;i++)
				await write(A,s+i,T[i],1,true);
		}
		let tmp=new Array(len).fill(0);
		await merge(arr,tmp,0,len/2|0,len);
	}
	async quadSort(len){
		let qSort=new QuadSorting();
		await qSort.quadSort(arr,0,len);
	}
	async fluxSort(len){
		const qds=new QuadSorting();
		async function fluxAnalyze(A,n){
			let c=n,b=0,p=0;
			while(--c>0)
				if(compareIndices(A,p,++p)>0)b++;
			if(!b)return false;
			if(b==n-1){
				await reversal(A,0,n-1,1,true);
				return false;
			}
			if(b<=(n/6|0)||b>=(n/6*5|0)){
				qds.quadSort(A,0,n);
				return false;
			}
			return true;
		}
		function medianOfFive(A,v0,v1,v2,v3,v4){
			let t=[0,0,0,0];
			let val;
			val=(compareIndices(A,v0,v1)+1)/2|0;t[0]=val;t[1]=val^1;
			val=(compareIndices(A,v0,v2)+1)/2|0;t[0]+=val;t[2]=val^1;
			val=(compareIndices(A,v0,v3)+1)/2|0;t[0]+=val;t[3]=val^1;
			val=(compareIndices(A,v0,v4)+1)/2|0;t[0]+=val;
			if(t[0]==2)return v0;
			val=(compareIndices(A,v1,v2)+1)/2|0;t[1]+=val;t[2]+=val^1;
			val=(compareIndices(A,v1,v3)+1)/2|0;t[1]+=val;t[3]+=val^1;
			val=(compareIndices(A,v1,v4)+1)/2|0;t[1]+=val;
			if(t[1]==2)return v1;
			val=(compareIndices(A,v2,v3)+1)/2|0;t[2]+=val;t[3]+=val^1;
			val=(compareIndices(A,v2,v4)+1)/2|0;t[2]+=val;
			if(t[2]==2)return v2;
			val=(compareIndices(A,v3,v4)+1)/2|0;t[3]+=val;
			return t[3]==2?v3:v4;
		}
		function medianOfThree(A,v0,v1,v2){
			let t=[0,0];
			let val;
			val=(compareIndices(A,v0,v1)+1)/2|0;t[0]=val;t[1]=val^1;
			val=(compareIndices(A,v0,v2)+1)/2|0;t[0]+=val;
			if(t[0]==1)return v0;
			val=(compareIndices(A,v1,v2)+1)/2|0;t[1]+=val;
			return t[1]==1?v1:v2;
		}
		function medianOfFifteen(A,p,n){
			let v0,v1,v2,v3,v4,d=n/16|0;
			v0=medianOfThree(A,p+d*2,p+d*1,p+d*3);
			v1=medianOfThree(A,p+d*5,p+d*4,p+d*6);
			v2=medianOfThree(A,p+d*8,p+d*7,p+d*9);
			v3=medianOfThree(A,p+d*11,p+d*10,p+d*12);
			v4=medianOfThree(A,p+d*14,p+d*13,p+d*15);
			return medianOfFive(A,v2,v0,v1,v3,v4);
		}
		function medianOfNine(A,p,n){
			let v0,v1,v2,div=n/16|0;
			v0=medianOfThree(A,p+div*2,p+div*1,p+div*4);
			v1=medianOfThree(A,p+div*8,p+div*6,p+div*10);
			v2=medianOfThree(A,p+div*14,p+div*12,p+div*15);
			return medianOfThree(A,v0,v1,v2);
		}
		async function fluxPartition(A,swp,m,s,n){
			let val;
			let aS,sS;
			let pta,pts,ptx,pte,piv;
			ptx=m==A?s:0;
			piv=m[n>1024?medianOfFifteen(m,ptx,n):medianOfNine(m,ptx,n)];
			pte=ptx+n;
			pta=s;
			pts=0;
			while(ptx<pte){
				val=(compareValues(m[ptx],piv)+1)/2|0;
				await write(A,pta,m[ptx],0.25,true);pta+=val^1;
				write(swp,pts,m[ptx],0.25,false,true);pts+=val;
				ptx++;
			}
			sS=pts;
			aS=n-sS;
			if(aS<=(sS/16|0)||sS<=24){
				await arraycopy(swp,0,A,pta,sS,0.5,true);
				await qds.quadSortSwap(A,swp,pta,sS);
			}else
				await fluxPartition(A,swp,swp,pta,sS);
			if(sS<=(aS/16|0)||aS<=24)
				await qds.quadSortSwap(A,swp,s,aS);
			else
				await fluxPartition(A,swp,A,s,aS);
		}
		if(len<32)await qds.quadSort(arr,0,len);
		else if(await fluxAnalyze(arr,len)){
			let swp=new Array(len);
			await fluxPartition(arr,swp,arr,0,len);
		}
	}
	async stacklessRotateMergeSort(len){
		async function rotate(A,a,m,b){
			await IndexedRotations.griesMills(A,a,m,b,0.5,true,false);
		}
		async function partitionMerge(A,a,m,b,c){
			let lenA=m-a,lenB=b-m;
			if(lenA<1||lenB<1)return;
			if(lenB<lenA){
				c=(lenA+lenB)-c;
				let r1=0,r2=minVal(c,lenB);
				while(r1<r2){
					let ml=(r1+r2)/2|0;
					if(compareIndices(A,m-c+ml,b-ml-1)>0)
						r2=ml;
					else
						r1=ml+1;
				}
				await rotate(A,m-c+r1,m,b-r1);
			}else{
				let r1=0,r2=minVal(c,lenA);
				while(r1<r2){
					let ml=(r1+r2)/2|0;
					if(compareIndices(A,a+ml,m+c-ml-1)>0)
						r2=ml;
					else
						r1=ml+1;
				}
				await rotate(A,a+r1,m,m+c-r1);
			}
		}
		async function rotateMerge(A,a,b,c){
			let i;
			for(i=a+1;i<b&&compareIndices(A,i-1,i)<1;i++);
			if(i<b)await partitionMerge(A,a,i,b,c);
		}
		async function rotatePartitionMergeSort(A,a,b){
			let l=b-a;
			for(let i=a+1;i<b;i+=2)
				if(compareIndices(A,i-1,i)>0)
					await swap(A,i-1,i,0.5,true);
			for(let j=2;j<l;j*=2){
				let b1=0;
				for(let i=a;i+j<b;i+=2*j){
					b1=minVal(i+2*j,b);
					await partitionMerge(A,i,i+j,b1,j);
				}
				for(let k=j/2|0;k>1;k=k/2|0)
					for(let i=a;i+k<b1;i+=2*k)
						await rotateMerge(A,i,minVal(i+2*k,b),k);
				for(let i=a+1;i<b1;i+=2)
					if(compareIndices(A,i-1,i)>0)
						await swap(A,i-1,i,0.5,true);
			}
		}
		await rotatePartitionMergeSort(arr,0,len);
	}
	async strandSort(len){
		async function mergeTo(A,T,a,m,b){
			let i=0,s=m-a;
			while(i<s&&m<b){
				if(compareValues(T[i],A[m])<0)
					await write(A,a++,T[i++],0.5,true);
				else await write(A,a++,A[m++],0.5,true);
			}
			while(i<s)
				await write(A,a++,T[i++],0.5,true);
		}
		async function sort(A,l){
			let T=new Array(l);
			let j=l,k=j;
			while(j>0){
				write(T,0,A[0],1,true,true);
				k--;
				for(let i=0,p=0,m=1;m<j;m++){
					if(compareValues(A[m],T[i])>=0){
						await write(T,++i,A[m],1,true,true);
						k--;
					}else await write(A,p++,A[m],.1,true);
				}
				await mergeTo(A,T,k,j,l);
				j=k;
			}
		}
		await sort(arr,len);
	}
	async burntPancakeSort(len){
		for(let i=len-1;i>0;i--){
			let m=0;
			for(let j=m+1;j<=i;j++)
				if(compareIndices(arr,m,j)<1)m=j;
			if(m-i){
				await reversal(arr,0,m,.025,true);
				await reversal(arr,0,i,.025,true);
				await reversal(arr,0,i-1,.025,true);
				await reversal(arr,0,m-1,.025,true);
			}
		}
	}
	async stalinSort(len){
		for(let i=1;i<len;i++)
			if(compareIndices(arr,i-1,i)>0)
				await write(arr,i,arr[i-1],0.5,true);
	}
	async pancakeInsertionSort(len){
		function monoFw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		function monoBw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)>0)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)>0)return s+1;
			return s;
		}
		function compare(A,a,b){
			return compareIndices(A,a,b,1,true);
		}
		async function flip(A,i){
			await reversal(A,0,i,0.01,true,false);
		}
		async function front(A,l){
			if(l<2)return false;
			let d=true;
			if(compare(A,0,1)>0)await flip(A,1);
			if(l>2){
				if(compare(A,1,2)>0){
					if(compare(A,0,2)>0){
						await flip(A,1);
						return false;
					}else{
						await flip(A,2);
						await flip(A,1);
					}
					return false;
				}else return true;
			}
			return d;
		}
		async function sort(A,l){
			let d=await front(A,l)
			for(let i=3;i<l;i++){
				if(d){
					if(compare(A,i-1,i)<1){continue;
					}else if(compare(A,0,i)>0){
						await flip(A,i-1);
						d=!d;
					}else{
						let x=monoFw(A,0,i,A[i]);
						await flip(A,i);
						let e=i-x;
						await flip(A,e);
						await flip(A,e-1);
						d=!d;
					}
				}else{
					if(compare(A,i-1,i)>0){continue;
					}else if(compare(A,0,i)<1){
						await flip(A,i-1);
						d=!d;
					}else{
						let x=monoBw(A,0,i,A[i]);
						await flip(A,i);
						let e=i-x;
						await flip(A,e);
						await flip(A,e-1);
						d=!d;
					}
				}
			}
			if(!d)await flip(A,l-1);
		}
		await sort(arr,len);
	}
	async pancakeSort(len){
		function fM(A,e){
			let i=0,m=-1/0;
			for(let j=0;j<=e;j++)
				if(compareValues(A[j],m)>0){
					m=A[j];
					i=j;
				}
			return i;
		}
		for(let i=len-1;i>=0;i--){
			if(!isRangeSorted(arr,0,i)){
				let j=fM(arr,i);
				if(!j)
					await reversal(arr,0,i,0.05,true);
				else if(j-i){
					await reversal(arr,0,j,0.05,true);
					await reversal(arr,0,i,0.05,true);
				}
			}else break;
		}
	}
	async ternaryLLQuickSort(len){
		function compare(A,a,b){
			return compareIndices(A,a,b);
		}
		function selectPivot(A,l,h){
			let m=(l+h)/2|0;
			if(!compare(A,l,m))return l;
			if(!compare(A,l,h-1)||!compare(A,m,h-1))return h-1;
			return compare(A,l,m)<0?compare(A,m,h-1)<0?m:compare(A,l,h-1)<0?h-1:l:compare(A,m,h-1)>0?m:compare(A,l,h-1)<0?l:h-1;
		}
		async function partitionTernaryLL(A,l,h){
			let p=selectPivot(A,l,h);
			let pv=A[p];
			await swap(A,p,h-1,1,true);
			let i=l,k=h-1;
			for(let j=l;j<k;++j){
				let cmp=compareIndexValue(A,j,pv,0.5,true);
				if(!cmp)await swap(A,--k,j--,1,true);
				else if(cmp<0)await swap(A,i++,j,1,true);
			}
			let j=i+(h-k);
			for(let s=0;s<h-k;++s)
				await swap(A,i+s,h-1-s,1,true);
			return[i,j];
		}
		async function quickSortTernaryLL(A,l,h){
			if(l+1<h){
				let m=await partitionTernaryLL(A,l,h);
				await quickSortTernaryLL(A,l,m[0]);
				await quickSortTernaryLL(A,m[1],h);
			}
		}
		await quickSortTernaryLL(arr,0,len);
	}
	async ternaryLRQuickSort(len){
		function compare(A,a,b){
			return compareIndices(A,a,b);
		}
		function selectPivot(A,l,h){
			let m=(l+h)/2|0;
			if(!compare(A,l,m))return l;
			if(!compare(A,l,h-1)||!compare(A,m,h-1))return h-1;
			return compare(A,l,m)<0?compare(A,m,h-1)<0?m:compare(A,l,h-1)<0?h-1:l:compare(A,m,h-1)>0?m:compare(A,l,h-1)<0?l:h-1;
		}
		async function quickSortTernaryLR(A,l,h){
			if(h<=l)return;
			let c,piv=selectPivot(A,l,h+1);
			await swap(A,piv,h,1,true);
			let pv=A[h],i=l,j=h-1,p=l,q=h-1;
			for(;;){
				while(i<=j&&(c=compareIndexValue(A,i,pv))<1){
					if(!c)await swap(A,i,p++,1,true);
					i++;
				}
				while(i<=j&&(c=compareValueIndex(A,pv,j))<1){
					if(!c)await swap(A,j,q--,1,true);
					j--;
				}
				if(i>j)break;
				await swap(A,i++,j--,1,true);
			}
			await swap(A,i,h,1,true);
			let ls=i-p;
			let gr=q-j;
			j=i-1;i=i+1;
			let pe=l+minVal(p-l,ls);
			for(let k=l;k<pe;k++,j--)
				await swap(A,k,j,1,true,false);
			let qe=h-1-minVal(h-1-q,gr-1);
			for(let k=h-1;k>qe;k--,i++)
				await swap(A,i,k,1,true,false);
			await quickSortTernaryLR(A,l,l+ls-1);
			await quickSortTernaryLR(A,h-gr+1,h);
		}
		await quickSortTernaryLR(arr,0,len-1);
	}
	async asynchronousSort(len){
		let ext=new Array(len);
		let n=1/0,x=-n;
		for(let i=0;i<len;i++){
			write(ext,i,arr[i],0.5,false,true);
			if(arr[i]<n)n=arr[i];
			if(arr[i]>x)x=arr[i];
		}
		n++;
		let c=n,i=0;
		while(i<len){
			for(let j=0;j<len;j++){
				if(compareValues(ext[j],c)<1){
					await write(arr,i++,ext[j],0.01,true);
					write(ext,j,x,0,false,true);
				}
			}
			c++;
		}
		await insertSort(arr,0,c);
	}
	async adaptiveGrailSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,0,true);
		}
		async function multiTriSwap(A,a,b,c,l){
			for(let i=0;i<l;i++){
				let t=A[a+i];
				write(A,a+i,A[b+i],0,true);
				write(A,b+i,A[c+i],0,true);
				await write(A,c+i,t,0,true);
			}
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],0.5,true);
			await write(A,b,t,0.5,true);
		}
		async function insertToBW(A,a,b){
			let t=A[a];
			while(a<b)await write(A,a,A[++a],0.5,true);
			await write(A,a,t,0.5,true);
		}
		async function shift(A,a,m,b){
			while(m<b)await swap(A,a++,m++,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>1&&r>1){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
			if(r==1)await insertTo(A,m,a);
			else if(l==1)await insertToBW(A,a,b-1);
		}
		function leftBinarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function buildUniqueRun(A,a,n){
			let nKeys=1,i=a+1;
			if(compareIndices(A,i-1,i)<0){
				do{i++;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)<0);
			}else if(compareIndices(A,i-1,i)>0){
				do{i++;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)>0);
				await reversal(A,a,i-1,1,true);
			}
			return nKeys;
		}
		async function buildUniqueRunBW(A,b,n){
			let nKeys=1,i=b-1;
			if(compareIndices(A,i-1,i)<0){
				do{i--;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)<0);
			}else if(compareIndices(A,i-1,i)>0){
				do{i--;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)>0);
				await reversal(A,i,b-1,1,true);
			}
			return nKeys;
		}
		async function findKeys(A,a,b,nKeys,n){
			let p=a,pEnd=a+nKeys;
			for(let i=pEnd;i<b&&nKeys<n;i++){
				let loc=leftBinarySearch(A,p,pEnd,A[i]);
				if(pEnd==loc||compareIndices(A,i,loc)){
					await rotate(A,p,pEnd,i);
					let inc=i-pEnd;
					loc+=inc;
					p+=inc;
					pEnd+=inc;
					await insertTo(A,pEnd++,loc);
					nKeys++;
				}
			}
			await rotate(A,a,p,pEnd);
			return nKeys;
		}
		async function findKeysBW(A,a,b,nKeys,n){
			let p=b-nKeys,pEnd=b;
			for(let i=p-1;i>=a&&nKeys<n;i--){
				let loc=leftBinarySearch(A,p,pEnd,A[i]);
				if(pEnd==loc||compareIndices(A,i,loc)){
					await rotate(A,i+1,p,pEnd);
					let inc=p-(i+1);
					loc-=inc;
					pEnd-=inc;
					p-=inc+1;
					nKeys++;
					await insertToBW(A,i,loc-1);
				}
			}
			await rotate(A,p,pEnd,b);
			return nKeys;
		}
		async function buildRuns(A,a,b){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)
					await insertTo(A,i,rightBinarySearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinarySearch(A,a,i,A[i]));
		}
		async function mergeWithBufRest(A,a,m,b,p,pL){
			let i=0,j=m,k=a;
			while(i<pL&&j<b){
				if(compareIndices(A,p+i,j)<1)
					await swap(A,k++,p+(i++),1,true);
				else
					await swap(A,k++,j++,1,true);
			}
			while(i<pL)await swap(A,k++,p+(i++),1,true);
		}
		async function mergeWithBuf(A,a,m,b,p){
			let l=m-a;
			await multiSwap(A,p,a,l);
			await mergeWithBufRest(A,a,m,b,p,l);
		}
		async function mergeWithBufBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareIndices(A,j,p+i)<1)
					await swap(A,k--,p+(i--),1,true);
				else
					await swap(A,k--,j--,1,true);
			}
			while(i>=0)await swap(A,k--,p+(i--),1,true);
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftBinarySearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=rightBinarySearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=(i+1)-k;
					i=k-1;
				}else j--;
			}
		}
		async function mergeWithoutBuf(A,a,m,b){
			if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMerge(A,a,m,b);
		}
		function checkSorted(A,a,m,b){
			return compareIndices(A,m-1,m)>0;
		}
		async function checkReverseBounds(A,a,m,b){
			if(compareIndices(A,a,b-1)>0){
				await rotate(A,a,m,b);
				return false;
			}
			return true;
		}
		async function checkBounds(A,a,m,b){
			return checkSorted(A,a,m,b)&&await checkReverseBounds(A,a,m,b);
		}
		function grailGetSubA(A,t,mK){
			return compareIndices(A,t,mK)<0?"L":"R";
		}
		async function blockSelectSort(A,p,t,r,d,lCount,bCount,bLen){
			let mKey=lCount;
			for(let j=0,k=lCount+1;j<k-1;j++){
				let min=j;
				for(let i=maxVal(lCount-r,j+1);i<k;i++){
					let c=compareIndices(A,p+d+i*bLen,p+d+min*bLen);
					if(c<0||(!c&&compareIndices(A,t+i,t+min)<0))min=i;
				}
				if(min!=j){
					await multiSwap(A,p+j*bLen,p+min*bLen,bLen);
					await swap(A,t+j,t+min,1,true);
					if(k<bCount&&min==k-1)k++;
				}
				if(min==mKey)mKey=j;
			}
			return t+mKey;
		}
		async function grailSortKeys(A,b,p,mKey){
			await swap(A,p,mKey,1,true);
			let i=mKey,j=i+1,k=p+1;
			while(j<b){
				if(compareIndices(A,j,p)<0)
					await swap(A,i++,j,1,true);
				else await swap(A,k++,j,1,true);
				j++;
			}
			await multiSwap(A,i,p,b-i);
		}
		async function grailSortKeysWithoutBuf(A,b,mKey){
			let i=mKey,j=i+1;
			while(j<b){
				if(compareIndices(A,j,i)<0)
					await insertTo(A,j,i++);
				j++;
			}
		}
		async function grailMergeBlocks(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			if(i>p)while(i<m)await swap(A,p++,i++,1,true);
			return j;
		}
		async function grailMergeBlocksRev(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<0)
					await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			if(i>p)while(i<m)await swap(A,p++,i++,1,true);
			return j;
		}
		async function grailBlockMerge(A,a,m,b,t,p,bLen){
			let b1=b-(b-m-1)%bLen-1,
				i=a+bLen,j=a,key=t-1,
				lCount=(m-i)/bLen|0,bCount=(b1-i)/bLen|0,l=-1,r=lCount-1;
			await multiTriSwap(A,p,m-bLen,a,bLen);
			await insertToBW(A,t,t+lCount-1);
			let mKey=await blockSelectSort(A,i,t,1,bLen-1,lCount,bCount,bLen);
			let frag="L";
			while(l<lCount&&r<bCount){
				if(frag=="L"){
					do{
						j+=bLen;
						l++;
						key++;
					}while(l<lCount&&grailGetSubA(A,key,mKey)=="L");
					if(l==lCount){
						i=await grailMergeBlocks(A,i,j,b,i-bLen);
						await mergeWithBufRest(A,i-bLen,i,b,p,bLen);
					}else i=await grailMergeBlocks(A,i,j,j+bLen-1,i-bLen);
					frag="R";
				}else{
					do{
						j+=bLen;
						r++;
						key++;
					}while(r<bCount&&grailGetSubA(A,key,mKey)=="R");
					if(r==bCount){
						await shift(A,i-bLen,i,b);
						await multiSwap(A,p,b-bLen,bLen);
					}else i=await grailMergeBlocksRev(A,i,j,j+bLen-1,i-bLen);
					frag="L";
				}
			}
			await grailSortKeys(A,t+bCount,p,mKey);
		}
		async function grailBlockMergeWithoutBuf(A,a,m,b,t,bLen){
			let a1=a+(m-a)%bLen,b1=b-(b-m)%bLen,
				i=a,j=a1,key=t,
				lCount=(m-j)/bLen+1|0,bCount=(b1-j)/bLen+1|0,l=0,r=lCount;
			let mKey=await blockSelectSort(A,j,t,0,0,lCount-1,bCount-1,bLen);
			let frag="L";
			while(l<lCount&&r<bCount){
				let next=grailGetSubA(A,key++,mKey);
				if(next==frag){
					if(frag=="L")l++;
					else r++;
					i=j;
				}else{
					let m2=j,b2=j+bLen,k;
					if(frag=="L"){
						while(i<m2&&m2<b2){
							if(compareIndices(A,i,m2)>0){
								k=leftBinarySearch(A,m2+1,b2,A[i]);
								await rotate(A,i,m2,k);
								i+=k-m2;
								m2=k;
							}else i++;
						}
					}else{
						while(i<m2&&m2<b2){
							if(compareIndices(A,m2,i)<1){
								k=rightBinarySearch(A,m2+1,b2,A[i]);
								await rotate(A,i,m2,k);
								i+=k-m2;
								m2=k;
							}else i++;
						}
					}
					if(i<m2){
						if(next=="L")l++;
						else r++;
					}else{
						if(frag=="L")l++;
						else r++;
						frag=next;
					}
				}
				j+=bLen;
			}
			if(l<lCount)await inPlaceMergeBW(A,a,b1,b);
			await grailSortKeysWithoutBuf(A,t+bCount-1,mKey);
		}
		async function smartMerge(A,a,m,b,p){
			if(await checkBounds(A,a,m,b)){
				a=rightBinarySearch(A,a,m-1,A[m]);
				await mergeWithBuf(A,a,m,b,p);
			}
		}
		async function smartMergeBW(A,a,m,b,p){
			if(await checkBounds(A,a,m,b)){
				b=leftBinarySearch(A,m+1,b,A[m-1]);
				await mergeWithBufBW(A,a,m,b,p);
			}
		}
		async function smartBlockMerge(A,a,m,b,t,p,bLen){
			if(checkBounds(A,a,m,b)){
				let n=rightBinarySearch(A,a,m-1,A[m]);
				b=leftBinarySearch(A,m+1,b,A[m-1]);
				if(await checkReverseBounds(A,n,m,b)){
					if(m-n<=bLen||b-m<=bLen){
						if(b-m<m-n)await mergeWithBufBW(A,n,m,b,p);
						else await mergeWithBuf(A,n,m,b,p);
					}else{
						n-=(n-a)%bLen;
						await grailBlockMerge(A,n,m,b,t,p,bLen);
					}
				}
			}
		}
		async function smartBlockMergeWithoutBuf(A,a,m,b,t,bLen){
			if(await checkBounds(A,a,m,b)){
				a=rightBinarySearch(A,a,m-1,A[m]);
				if(m-a<=bLen)await inPlaceMerge(A,a,m,b);
				else await grailBlockMergeWithoutBuf(A,a,m,b,t,bLen);
			}
		}
		async function smartInPlaceMerge(A,a,m,b){
			if(await checkSorted(A,a,m,b))
				await inPlaceMergeBW(A,a,m,b);
		}
		async function redistBuffer(A,a,m,b){
			let rPos=leftBinarySearch(A,m,b,A[a]);
			await rotate(A,a,m,rPos);
			let dist=rPos-m;
			a+=dist;
			m+=dist;
			let a1=a+(m-a)/2|0;
			rPos=leftBinarySearch(A,m,b,A[a1]);
			await rotate(A,a1,m,rPos);
			dist=rPos-m;
			a1+=dist;
			m+=dist;
			await mergeWithoutBuf(A,a,a1-dist,a1);
			await mergeWithoutBuf(A,a1,m,b);
		}
		async function redistBufferBW(A,a,m,b){
			let rPos=rightBinarySearch(A,a,m,A[b-1]);
			await rotate(A,rPos,m,b);
			let dist=m-rPos;
			b-=dist;
			m-=dist;
			let b1=m+(b-m)/2|0;
			rPos=rightBinarySearch(A,a,m,A[b1-1]);
			await rotate(A,rPos,m,b1);
			dist=m-rPos;
			b1-=dist;
			m-=dist;
			await mergeWithoutBuf(A,b1,b1+dist,b);
			await mergeWithoutBuf(A,a,m,b1);
		}
		async function inPlaceMergeSort(A,a,b){
			await buildRuns(A,a,b);
			let len=b-a;
			for(let i,j=mR;j<len;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await smartInPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await smartInPlaceMerge(A,i,i+j,b);
			}
		}
		async function grailAdaptiveSortWithoutBuf(A,a,b,keys,ideal,bwBuf){
			let len=b-a,bLen;
			for(bLen=minVal(keys,mR);2*bLen<=keys;bLen*=2);
			let tLen=keys-bLen;
			let i,j=mR,
				t,p,a1,b1;
			if(bwBuf){
				p=b-bLen;a1=a;b1=p-tLen;t=b1;
			}else{
				p=a+tLen;a1=p+bLen;b1=b;t=a;
			}
			await buildRuns(A,a1,b1);
			while(j<=bLen&&j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b1)
					await smartMergeBW(A,i,i+j,b1,p);
				j*=2;
			}
			if((bLen/2|0)>=mR&&(bLen/2|0)>=((keys+1)/2|0)){
				await bininsert(A,p,p+bLen);
				bLen=bLen/2|0;
				tLen=keys-bLen;
				p+=bLen;
			}
			while(tLen>=(2*j/bLen|0)-1&&j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartBlockMerge(A,i,i+j,i+2*j,t,p,bLen);
				if(i+j<b1){
					if(b1-(i+j)>bLen)
						await smartBlockMerge(A,i,i+j,b1,t,p,bLen);
					else await smartMergeBW(A,i,i+j,b1,p);
				}
				j*=2;
			}
			await bininsert(A,p,p+bLen);
			tLen=keys-keys%2;
			while(j<len){
				bLen=2*j/tLen|0;
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartBlockMergeWithoutBuf(A,i,i+j,i+2*j,t,bLen);
				if(i+j<b1){
					if(b1-(i+j)>bLen)
						await smartBlockMergeWithoutBuf(A,i,i+j,b1,t,bLen);
					else await smartInPlaceMerge(A,i,i+j,b1);
				}
				j*=2;
			}
			if(bwBuf){
				a=rightBinarySearch(A,a,b1,A[b1]);
				if(keys>=(ideal/2|0))await redistBufferBW(A,a,b1,b);
				else await mergeWithoutBuf(A,a,b1,b);
			}else{
				b=leftBinarySearch(A,a1,b,A[a1-1]);
				if(keys>=(ideal/2|0))await redistBuffer(A,a,a1,b);
				else await mergeWithoutBuf(A,a,a1,b);
			}
		}
		async function grailAdaptiveSort(A,a,b){
			let len=b-a;
			if(len<31){
				await bininsert(A,a,b);
				return;
			}
			if(len<63){
				mR=(len+1)/2|0;
				await buildRuns(A,a,b);
				let m=a+mR;
				if(await checkBounds(A,a,m,b))
					await redistBufferBW(A,a,m,b);
				return;
			}
			for(mR=len;mR>=32;mR=(mR+1)/2|0);
			let bLen;
			for(bLen=mR;bLen*bLen<len;bLen*=2);
			let tLen=len/bLen-2|0,
				ideal=tLen+bLen;
			let bwBuf;
			let rRun=await buildUniqueRunBW(A,b,ideal),lRun=0;
			if(rRun==ideal)bwBuf=true;
			else{
				lRun=await buildUniqueRun(A,a,ideal);
				if(lRun==ideal)bwBuf=false;
				else bwBuf=(rRun<16&&lRun<16)||rRun>=lRun;
			}
			let keys=bwBuf?await findKeysBW(A,a,b,rRun,ideal):await findKeys(A,a,b,lRun,ideal);
			if(keys<ideal){
				if(keys==1)return;
				else if(keys<=4)await inPlaceMergeSort(A,a,b);
				else await grailAdaptiveSortWithoutBuf(A,a,b,keys,ideal,bwBuf);
				return;
			}
			let i,j=mR,
				t,p,a1,b1;
			if(bwBuf){
				p=b-bLen;a1=a;b1=p-tLen;t=b1;
			}else{
				p=a+tLen;a1=p+bLen;b1=b;t=a;
			}
			await buildRuns(A,a1,b1);
			while(j<=bLen&&j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b1)
					await smartMergeBW(A,i,i+j,b1,p);
				j*=2;
			}
			while(j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartBlockMerge(A,i,i+j,i+2*j,t,p,bLen);
				if(i+j<b1){
					if(b1-(i+j)>bLen)
						await smartBlockMerge(A,i,i+j,b1,t,p,bLen);
					else await smartMergeBW(A,i,i+j,b1,p);
				}
				j*=2;
			}
			await bininsert(A,p,p+bLen);
			if(bwBuf){
				a=rightBinarySearch(A,a,b1,A[b1]);
				await redistBufferBW(A,a,b1,b);
			}else{
				b=leftBinarySearch(A,a1,b,A[a1-1]);
				await redistBuffer(A,a,a1,b);
			}
		}
		let mR;
		await grailAdaptiveSort(arr,0,len);
	}
	async binaryMergeSort(len){
		async function merge(A,T,s,m,e){
			if(s==m)return;
			if(e-s<32)return;
			else if(e-s<64)await binaryInsertion(A,s,e);
			else{
				await merge(A,T,s,(m+s)/2|0,m);
				await merge(A,T,m,(m+e)/2|0,e);
				let lo=s;
				let hi=m;
				for(let n=0;n<e-s;n++){
					if(lo>=m&&hi>=e)break;
					if(lo<m&&hi>=e)write(T,n,A[lo++],0,false,true);
					else if(lo>=m&&hi<e)write(T,n,A[hi++],0,false,true);
					else if(compareIndices(A,lo,hi)<1)write(T,n,A[lo++],0,false,true);
					else write(T,n,A[hi++],0,false,true);
				}
				for(let i=0;i<e-s;i++)
					await write(A,s+i,T[i],1,true);
			}
		}
		async function mergeSort(A,l){
			if(l<32)return await binaryInsertion(A,0,l);
			let T=new Array(l).fill(0);
			await merge(A,T,0,l/2|0,len);
		}
		await mergeSort(arr,len);
	}
	async bufferPartitionMergeSort(len){
		async function shiftBW(A,a,m,b){
			while(m>a)await swap(A,--b,--m,1,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=j;
					while(++k<b&&compareIndices(A,i,k)>0);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j;
			let ad=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s);
					await swap(A,j++,i+s/2,1,false);
				}
				if(i<e){
					await insertSort(A,i,e);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,1);
					if((e-i)%2==0)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)>0);
				do j--;while(j>=i&&compareIndices(A,j,a)<0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function quickSelect(A,a,b,m){
			let bp=false,med=false;
			let m1=(m+b+1)/2|0;
			while(1){
				if(bp){
					await medianOfMedians(A,a,b,5);
					med=true;
				}else await medianOfThree(A,a,b);
				let p=await partition(A,a,b);
				await swap(A,a,p,1,true);
				let l=maxVal(1,p-a);
				let r=maxVal(1,b-p-1);
				bp=!med&&((l/r|0)>=16||(r/l|0)>=16);
				if(p>=m&&p<m1)return p;
				else if(p<m)a=p+1;
				else b=p;
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			}
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		async function mergeFW(A,p,a,m,b){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			}
			if(i<m)return i;
			else return j;
		}
		function getMinLevel(n){
			while(n>=32)n=(n+3)/4|0;
			return n;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,ps,j=getMinLevel(l);
			for(i=a;i+j<=b;i+=j)
				await binaryInsertion(A,i,i+j);
			await binaryInsertion(A,i,b);
			while(j<l){
				ps=p;
				for(i=a;i+2*j<=b;i+=2*j,ps+=2*j)
					await merge(A,i,i+j,i+2*j,ps);
				if(i+j<b)
					await merge(A,i,i+j,b,ps);
				else
					while(i<b)await swap(A,i++,ps++,1,true);
				j*=2;
				ps=a;
				for(i=p;i+2*j<=p+l;i+=2*j,ps+=2*j)
					await merge(A,i,i+j,i+2*j,ps);
				if(i+j<p+l)
					await merge(A,i,i+j,p+l,ps);
				else
					while(i<p+l)await swap(A,i++,ps++,1,true);
				j*=2;
			}
		}
		async function sort(A,a,b){
			let mn=sqrt(b-a)|0;
			let m=(a+b+1)/2|0;
			await mergeSort(A,m,b,a);
			while(m-a>mn){
				let m1=(a+m+1)/2|0;
				m1=await quickSelect(A,a,m,m1);
				await mergeSort(A,m1,m,a);
				let bS=m1-a;
				let m2=minVal(m1+bS,b);
				m1=await mergeFW(A,a,m1,m,m2);
				while(m1<m){
					await shiftBW(A,m1,m,m2);
					m1=m2-m+m1;
					a=m1-bS;
					m=m2;
					if(m==b)break;
					m2=minVal(m2+bS,b);
					m1=await mergeFW(A,a,m1,m,m2);
				}
				m=m1;
				a=m1-bS;
			}
			await binaryInsertion(A,a,m);
			await inPlaceMerge(A,a,m,b);
		}
		await sort(arr,0,len);
	}
	async circularGrailSort(len){
		async function circSwap(A,a,b){
			await swap(A,a%n,b%n,1,true);
		}
		function circCompareIndices(A,a,b){
			return compareIndices(A,a%n,b%n);
		}
		async function shiftFW(A,a,m,b){
			while(m<b)await circSwap(A,a++,m++);
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await circSwap(A,--b,--m);
		}
		async function insert(A,a,b){
			for(let i=a+1;i<b;i++)
				while(i>a&&circCompareIndices(A,i-1,i)>0)
					await circSwap(A,i,--i);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await circSwap(A,a+i,b+i);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(circCompareIndices(A,i,j)>0){
					k=j;
					while(++k<b&&circCompareIndices(A,i,k)>0);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function merge(A,p,a,m,b,f){
			let i=a,j=m;
			while(i<m&&j<b){
				if(circCompareIndices(A,i,j)<1)
					await circSwap(A,p++,i++);
				else
					await circSwap(A,p++,j++);
			}
			if(i<m){
				if(i>p) await shiftFW(A,p,i,m);
			}else if(f)
				await shiftFW(A,p,j,b);
			return i<m?i:j;
		}
		function blockLessThan(A,a,b,bL){
			let c=circCompareIndices(A,a,b);
			return c<0||(!c&&circCompareIndices(A,a+bL-1,b+bL-1)<0);
		}
		async function blockMerge(A,a,m,b,bL){
			let b1=b-(b-m-1)%bL-1;
			if(b1>m){
				let b2=b1;
				for(let i=m-bL;i>a&&blockLessThan(A,b1,i,bL);i-=bL,b2-=bL);
				for(let j=a;j<b1-bL;j+=bL){
					let mn=j;
					for(let i=mn+bL;i<b1;i+=bL)
						if(blockLessThan(A,i,mn,bL))mn=i;
					if(mn!=j)await multiSwap(A,j,mn,bL);
				}
				let f=a;
				for(let i=a+bL;i<b2;i+=bL){
					f=await merge(A,f-bL,f,i,i+bL,false);
					if(f<i){
						await shiftBW(A,f,i,i+bL);
						f+=bL;
					}
				}
				await merge(A,f-bL,f,b1,b,true);
			}else await merge(A,a-bL,a,m,b,true);
		}
		let n=len;
		async function sort(A,l){
			if(l<17)return await insert(A,0,l);
			let bL=1;
			for(;bL*bL<l;bL*=2);
			let i=bL,j=1,ln=l-i,b=l;
			while(j<=bL){
				for(;i+2*j<b;i+=2*j)
					await merge(A,i-j,i,i+j,i+2*j,true);
				if(i+j<b)
					await merge(A,i-j,i,i+j,b,true);
				else
					await shiftFW(A,i-j,i,b);
				i=b+bL-j;
				b=i+ln;
				j*=2;
			}
			while(j<ln){
				for(;i+2*j<b;i+=2*j)
					await blockMerge(A,i,i+j,i+2*j,bL);
				if(i+j<b)
					await blockMerge(A,i,i+j,b,bL);
				else
					await shiftFW(A,i-bL,i,b);
				i=b;
				b+=ln;
				j*=2;
			}
			await insert(A,i-bL,i);
			await inPlaceMerge(A,i-bL,i,b);
			await rotate(A,0,(i-bL)%n,l);
		}
		await sort(arr,len);
	}
	async badSort(len){
		for(let i=0;i<len;i++){
			let s=i;
			for(let j=i;j<len;j++){
				let S=true;
				for(let k=j+1;k<len;k++){
					if(compareIndices(arr,j,k)>0){
						S=false;
						break;
					}
				}
				if(S){
					s=j;
					break;
				}
			}
			await swap(arr,i,s,0,true);
		}
	}
	async ectaSort(len){
		function getMinRun(n){
			let m=n;
			for(;m>=32;m=(m+1)/2|0);
			return m;
		}
		async function shift(A,a,m,b){
			while(m<b)await write(A,a++,A[m++],1,true);
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await write(A,--b,A[--m],1,true);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await write(A,p++,A[i++],1,true);
				else
					await write(A,p++,A[j++],1,true);
			}
			while(i<m)await write(A,p++,A[i++],1,true);
			while(j<b)await write(A,p++,A[j++],1,true);
		}
		async function pingPongMerge(A,a,m1,m2,m3,b,p){
			let p1=p+m2-a,pE=p+b-a;
			await mergeTo(A,a,m1,m2,p);
			await mergeTo(A,m2,m3,b,p1);
			await mergeTo(A,p,p1,pE,a);
		}
		async function merge(A,a,m,b,p){
			let ln=b-m,pE=p+ln-1;
			await arraycopy(A,m--,A,p,ln,1,true);
			while(m>=a&&pE>=p){
				if(compareIndices(A,m,pE)>0)
					await write(A,--b,A[m--],1,true);
				else await write(A,--b,A[pE--],1,true);
			}
			while(pE>=p)
				await write(A,--b,A[pE--],1,true);
		}
		async function mergeFromBuf(A,bf,a,m,b,bL){
			let i=0;
			while(i<bL&&m<b){
				if(compareValues(bf[i],A[m])<1)
					await write(A,a++,bf[i++],1,true);
				else
					await write(A,a++,A[m++],1,true);
			}
			while(i<bL)
				await write(A,a++,bf[i++],1,true);
		}
		async function dualMergeFromBufBW(A,buf,a,a1,m,b,bfL){
			let i=bfL-1;
			bfL-=b-(m--);
			while(i>=bfL&&m>=a1){
				if(compareValues(buf[i],A[m])>0)
					await write(A,--b,buf[i--],1,true);
				else
					await write(A,--b,A[m--],1,true);
			}
			if(m<a1)
				while(i>=0)await write(A,--b,buf[i--],1,true);
			else
				await mergeFromBuf(A,buf,a,a1,b,bfL);
		}
		async function mergeSort(A,a,b,p,mRun,bfL){
			let smallSort=binaryDoubleInsertion;
			let i=a,j=mRun;
			for(;i+j<=b;i+=j)
				await smallSort(A,i,i+j);
			await smallSort(A,i,b);
			while(4*j<=bfL){
				for(i=a;i+4*j<=b;i+=4*j)
					await pingPongMerge(A,i,i+j,i+2*j,i+3*j,i+4*j,p);
				if(i+3*j<b)
					await pingPongMerge(A,i,i+j,i+2*j,i+3*j,b,p);
				else if(i+2*j<b)
					await pingPongMerge(A,i,i+j,i+2*j,b,b,p);
				else if(i+j<b)
					await merge(A,i,i+j,b,p);
				j*=4;
			}
			while(j<=bfL){
				for(i=a;i+2*j<=b;i+=2*j)
					await merge(A,i,i+j,i+2*j,p);
				if(i+j<b)
					await merge(A,i,i+j,b,p);
				j*=2;
			}
			return j;
		}
		async function blockCycle(A,keys,a,bLen,t,p,excl,fw){
			let s=fw?bLen:-bLen;
			for(let i=0;i<t;i++){
				if(compareValues(i,keys[i])){
					await arraycopy(A,a+i*s,A,p,bLen,1,true);
					let j=i,next=keys[i];
					do{
						if(!(excl&&j==t-1))
							await arraycopy(A,a+next*s,A,a+j*s,bLen,1,true);
						write(keys,j,j,1,false,true);
						j=next;
						next=keys[next];
					}while(compareValues(next,i));
					await arraycopy(A,p,A,a+j*s,bLen,1,true);
					write(keys,j,j,1,false,true);
				}
			}
		}
		async function ectaMergeFW(A,tags,a,m,b,bLen){
			let i=a,j=m,t=0,tc=0;
			let s=[2*bLen,0];
			let p=[a-2*bLen,m];
			do{
				let c=s[0]<bLen?1:0;
				for(let k=0;k<bLen;k++){
					if(i<m&&j<b){
						if(compareIndices(A,i,j)<1){
							await write(A,p[c]+k,A[i++],1,true);
							s[0]++;
						}else{
							await write(A,p[c]+k,A[j++],1,true);
							s[1]++;
						}
					}else if(i<m){
						await write(A,p[c]+k,A[i++],1,true);
						s[0]++;
					}else{
						await write(A,p[c]+k,A[j++],1,true);
						s[1]++;
					}
				}
				p[c]+=bLen;
				s[c]-=bLen;
				write(tags,tc++,!c?t++:-1,1,false,true);
			}while(i<m||j<b);
			if(s[0]>0)write(tags,tc,t++,1,false,true);
			for(let k=2;k<tc;k++)
				if(tags[k]==-1)
					write(tags,k,t++,1,false,true);
			await blockCycle(A,tags,a-2*bLen,bLen,t,b-bLen,s[0]>0,true);
		}
		async function ectaMergeBW(A,tags,a,m,b,bLen){
			let i=b-1,j=m-1,t=0,tc=0;
			let s=[2*bLen,0];
			let p=[b+2*bLen,m];
			do{
				let c=s[0]<bLen?1:0;
				for(let k=1;k<=bLen;k++){
					if(i>=m&&j>=a){
						if(compareIndices(A,j,i)<1){
							await write(A,p[c]-k,A[i--],1,true);
							s[0]++;
						}else{
							await write(A,p[c]-k,A[j--],1,true);
							s[1]++;
						}
					}else if(i>=m){
						await write(A,p[c]-k,A[i--],1,true);
						s[0]++;
					}else{
						await write(A,p[c]-k,A[j--],1,true);
						s[1]++;
					}
				}
				p[c]-=bLen;
				s[c]-=bLen;
				write(tags,tc++,!c?t++:-1,1,false,true);
			}while(i>=m||j>=a);
			if(s[0]>0)write(tags,tc,t++,1,false,true);
			for(let k=2;k<tc;k++)
				if(tags[k]==-1)
					write(tags,k,t++,1,false,true);
			await blockCycle(A,tags,b+bLen,bLen,t,a,s[0]>0,false);
		}
		async function main(A,l){
			if(l<256){
				if(l<=32){
					let smallSort=binaryDoubleInsertion;
					smallSort(A,0,l);
				}else{
					let mRun=getMinRun(l),bfL=l/2|0;
					let buf=new Array(bfL);
					arraycopy(A,bfL,buf,0,bfL,0,true,true);
					await mergeSort(A,0,bfL,bfL,mRun,bfL);
					await arraycopy(buf,0,A,bfL,bfL,1,true,false);
					arraycopy(A,0,buf,0,bfL,0,true,true);
					await mergeSort(A,bfL,l,0,mRun,bfL);
					await mergeFromBuf(A,buf,0,bfL,l,bfL);
				}
				return;
			}
			let mRun=getMinRun(l),bLen=mRun;
			for(;bLen*bLen<l/2|0;bLen*=2);
			let bfL=2*bLen+l%bLen;
			let a=bfL,b=l,ln=b-a;
			let buf=new Array(bfL);
			let tags=new Array(ln/bLen+1|0);
			arraycopy(A,a,buf,0,bfL,0,true,true);
			await mergeSort(A,0,a,a,getMinRun(bfL),bfL);
			await arraycopy(buf,0,A,a,bfL,1,true,false);
			arraycopy(A,0,buf,0,bfL,0,true,true);
			let i=a,j=await mergeSort(A,a,b,0,mRun,bfL);
			let bw=false;
			while(j<ln){
				for(i=a;i+2*j<=b;i+=2*j)
					await ectaMergeFW(A,tags,i,i+j,i+2*j,bLen);
				if(i+j<b)await ectaMergeFW(A,tags,i,i+j,b,bLen);
				else await shift(A,i-2*bLen,i,b);
				j*=2;
				a-=2*bLen;
				b-=2*bLen;
				if(j>=ln){
					bw=true;
					break;
				}
				for(i=a;i+2*j<=b;i+=2*j);
				if(i+j<b)await ectaMergeBW(A,tags,i,i+j,b,bLen);
				else await shiftBW(A,i,b,b+2*bLen);
				for(i-=2*j;i>=a;i-=2*j)
					await ectaMergeBW(A,tags,i,i+j,i+2*j,bLen);
				j*=2;
				a+=2*bLen;
				b+=2*bLen;
			}
			if(bw)await dualMergeFromBufBW(A,buf,0,a,b,l,bfL);
			else await mergeFromBuf(A,buf,0,a,b,bfL);
		}
		await main(arr,len);
	}
	async improvedBlockSelectionSort(len){
		function sqr(n){
			let i=1;
			for(;i*i<n;i*=2);
			return i;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=j;
					do k++;while(k<b&&compareIndices(A,i,k)>0);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
			return i;
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=i;
					do k--;while(k>=a&&compareIndices(A,k,j)>0);
					await rotate(A,k+1,i+1,j+1);
					j-=i-k;
					i=k;
				}else j--;
			}
		}
		function selectRange(A,a,b,bL){
			let n=a;a+=bL;
			while(a<b){
				let c=compareIndices(A,a,n);
				if(c<0||(!c&&compareIndices(A,a+bL-1,n+bL-1)<0))n=a;
				a+=bL;
			}
			return n;
		}
		async function blockSelect(A,a,m,b,bL){
			let k=a,j=m;
			while(k<m&&compareIndices(A,k,m)<1)k+=bL;
			if(k==m)return;
			let i=m;
			await multiSwap(A,k,j,bL);
			k+=bL;
			j+=bL;
			while(k<j&&j<b){
				if(compareIndices(A,i,j)<1){
					if(k!=i)await multiSwap(A,k,i,bL);
					k+=bL;
					i=selectRange(A,maxVal(m,k),j,bL);
				}else{
					if(i==k)i=j;
					if(k!=j)await multiSwap(A,k,j,bL);
					k+=bL;j+=bL;
				}
			}
			while(k<j){
				i=selectRange(A,k,b,bL);
				if(k!=i)await multiSwap(A,k,i,bL);
				k+=bL;
			}
		}
		for(let i,j=1;j<len;j*=2){
			let bL=sqr(j),n=j,b=len-len%bL;
			while(n>16){
				for(i=0;i+j<b;i+=2*j)
					for(let k=i;k+n<minVal(i+2*j,b);k+=n)
						await blockSelect(arr,k,k+n,minVal(k+2*n,b),bL);
				n=bL;
				bL=sqr(bL);
			}
			for(i=0;i+j<b;i+=2*j)
				for(let k=i,f=i;k+n<minVal(i+2*j,b);k+=n)
					f=await inPlaceMerge(arr,f,k+n,minVal(k+2*n,b));
			await inPlaceMergeBW(arr,len-len%(2*j),b,len);
		}
	}
	async kotaSort(len){
		let T,C,bfP,blL,tL,bfL,eM,ext;
		async function rotate(A,st,sp,e){
			let t;
			while(sp<e&&sp>st){
				if(e-sp<sp-st){
					if(e-sp==1){
						t=A[sp];
						await shift(A,st,sp,e,true,true);
						await write(A,st,t,1,true,false);
						return;
					}else{
						await shift(A,2*sp-e,sp,e,true,false);
						t=e;
						e=sp;
						sp-=t-sp;
					}
				}else{
					if(sp-st==1){
						t=A[st];
						await shift(A,st,sp,e,false,true);
						await write(A,e-1,t,1,true);
						return;
					}else{
						await shift(A,st,sp,2*sp-st,false,false);
						t=st;
						st=sp;
						sp+=sp-t;
					}
				}
			}
		}
		async function kotaSwap(A,a,b,x){
			if(x)await write(A,a,A[b],1,true);
			else await swap(A,a,b,1,true);
		}
		function binarySearch(A,st,e,v,l){
			let a=st,b=e;
			while(a<b){
				let m=(a+b)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function findKeys(A,st,e,n){
			let nK=1,p=st,pE=st+1;
			for(let i=st+1;i<e&&nK<n;i++){
				let l=binarySearch(A,p,pE,A[i],true);
				if(i==l||compareIndices(A,i,l)){
					await rotate(A,p,pE,i);
					let c=i-pE;
					l+=c;p+=c;pE+=c;nK++;
					await rotate(A,l,pE++,pE);
				}
			}
			await rotate(A,st,p,pE);
			return nK;
		}
		async function swapToTags(A,a,i,x){
			if(x){
				let t=T[i];
				write(T,i,A[a],0,false,true);
				await write(A,a,t,1,false);
			}else await kotaSwap(A,bfP+i,a,false);
		}
		async function shift(A,a,m,b,l,x){
			if(l){
				if(m==b)return;
				while(m>a)
					await kotaSwap(A,--b,--m,x);
			}else{
				if(m==a)return;
				while(m<b)
					await kotaSwap(A,a++,m++,x);
			}
		}
		async function multiSwap(A,a,b,l,x){
			for(let i=0;i<l;i++)
				await kotaSwap(A,a+i,b+i,x);
		}
		async function multiSwapBW(A,a,b,l,x){
			for(let i=0;i<l;i++)
				await kotaSwap(A,a-i,b-i,x);
		}
		async function blockSelect(A,p,c){
			for(let j=0;j<c;j++){
				let st=p+j*blL,n=st;
				for(let i=j+1;i<c;i++){
					let s=p+i*blL;
					if(compareIndices(A,s,n)<0)n=s;
				}
				if(st!=n)await multiSwap(A,st,n,blL,false);
				await swapToTags(A,st,j,false);
			}
		}
		async function blockSelectBW(A,p,c){
			for(let j=0;j<c;j++){
				let st=p-j*blL,n=st;
				for(let i=j+1;i<c;i++){
					let s=p-i*blL;
					if(compareIndices(A,s,n)<0)n=s;
				}
				if(st!=n)await multiSwapBW(A,st,n,blL,false);
				await swapToTags(A,st,j,false);
			}
		}
		async function blockCycle(A,ps,c,p){
			for(let j=0;j<c;j++){
				let st=ps+j*blL;
				if(j!=A[st]){
					let f=A[st];
					let v=j;
					await multiSwap(A,p,st,blL,true);
					while(v!=f){
						let vst=ps+v*blL;
						let k=j+1,nx=ps+k*blL;
						while(compareValues(A[nx],v))
							nx=ps+(++k)*blL;
						v=k;
						await multiSwap(A,vst,nx,blL,true);
					}
					f=ps+f*blL;
					await multiSwap(A,f,p,blL,true);
				}
				await swapToTags(A,st,j,true);
			}
		}
		async function blockCycleBW(A,ps,c,p){
			for(let j=0;j<c;j++){
				let st=ps-j*blL;
				if(j!=A[st]){
					let f=A[st];
					let v=j;
					await multiSwapBW(A,p,st,blL,true);
					while(v!=f){
						let vst=ps-v*blL;
						let k=j+1,nx=ps-k*blL;
						while(compareValues(A[nx],v))
							nx=ps-(++k)*blL;
						v=k;
						await multiSwapBW(A,vst,nx,blL,true);
					}
					f=ps-f*blL;
					await multiSwapBW(A,f,p,blL,true);
				}
				await swapToTags(A,st,j,true);
			}
		}
		async function blockMerge(A,a,m,b,auxTag){
			if(b-m<=2*bfL){
				await dualMerge(A,a,m,b,bfL);
				return;
			}
			let i=a,j=m,k,f;
			let leftAD=bfL,rightAD=0;
			let left=i-bfL,right=j;
			let tC=0;
			while(i<m&&leftAD>=rightAD){
				k=0;
				while(i<m&&k<blL){
					if(compareIndices(A,i,j)<1){
						await kotaSwap(A,left++,i++,ext);
					}else{
						await kotaSwap(A,left++,j++,ext);
						rightAD++;
						leftAD--;
					}
					k++;
				}
			}
			let selst=left
			while(i<m&&j<b){
				while(i<m&&j<b&&rightAD>leftAD){
					f=right;
					k=0;
					while(i<m&&j<b&&k<blL){
						if(compareIndices(A,i,j)<1){
							await kotaSwap(A,right++,i++,ext);
							rightAD--;
							leftAD++;
						}else{
							await kotaSwap(A,right++,j++,ext);
						}
						k++;
					}
					while(i<m&&k<blL){
						await kotaSwap(A,right++,i++,ext);
						rightAD--;
						leftAD++;
						k++;
					}
					while(j<b&&k<blL){
						await kotaSwap(A,right++,j++,ext);
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await shift(A,f,f+k,b,true,ext);
						j=b-k;
						right=f;
					}
				}
				while(i<m&&j<b&&leftAD>=rightAD){
					f=left;
					k=0;
					while(i<m&&j<b&&k<blL){
						if(compareIndices(A,i,j)<1){
							await kotaSwap(A,left++,i++,ext);
						}else{
							await kotaSwap(A,left++,j++,ext);
							rightAD++;
							leftAD--;
						}
						k++;
					}
					while(i<m&&k<blL){
						await kotaSwap(A,left++,i++,ext);
						k++;
					}
					while(j<b&&k<blL){
						await kotaSwap(A,left++,j++,ext);
						rightAD++;
						leftAD--;
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await rotate(A,f,m,right);
						left+=right-m;
						leftAD=0;
					}
				}
			}
			if(i>=m&&leftAD==blL&&tC>0){	
				await multiSwap(A,left,right-blL,blL,ext)
			}else{
				if(i<m){							
					await rotate(A,left,m,right)
					left+=right-m;
				}
				await shift(A,left,left+leftAD,right,false,ext)
			}
			if(j<b)await shift(A,j-bfL,j,b,false,ext);
			if(auxTag)await blockCycle(A,selst,tC,b-bfL);
			else await blockSelect(A,selst,tC);
		}
		async function blockMergeBW(A,a,m,b,auxTag){
			let i=m-1,j=b-1,k,f;
			let leftAD=0,rightAD=bfL;
			let left=i,right=j+bfL;
			let tC=0;
			while(j>=m&&rightAD>=leftAD){
				k=0;
				while(j>=m&&k<blL){
					if(compareIndices(A,i,j)>0){
						await kotaSwap(A,right--,i--,ext);
						leftAD++;
						rightAD--;
					}else{
						await kotaSwap(A,right--,j--,ext);
					}
					k++;
				}
			}
			let selst=right;
			while(j>=m&&i>=a){
				while(j>=m&&i>=a&&leftAD>rightAD){
					f=left;
					k=0;
					while(j>=m&&i>=a&&k<blL){
						if(compareIndices(A,i,j)>0){
							await kotaSwap(A,left--,i--,ext);
						}else{
							await kotaSwap(A,left--,j--,ext);
							rightAD++;
							leftAD--;
						}
						k++;
					}
					while(j>=m&&k<blL){
						await kotaSwap(A,left--,j--,ext);
						rightAD++;
						leftAD--;
						k++;
					}
					while(i>=a&&k<blL){
						await kotaSwap(A,left--,i--,ext);
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await shift(A,a,f+1-k,f+1,false,ext);
						i=a-1+k;
						left=f;
					}
				}
				while(j>=m&&i>=a&&rightAD>=leftAD){
					f=right;
					k=0;
					while(j>=m&&i>=a&&k<blL){
						if(compareIndices(A,i,j)>0){
							await kotaSwap(A,right--,i--,ext);
							leftAD++;
							rightAD--;
						}else{
							await kotaSwap(A,right--,j--,ext);
						}
						k++;
					}
					while(j>=m&&k<blL){
						await kotaSwap(A,right--,j--,ext);
						k++;
					}
					while(i>=a&&k<blL){
						await kotaSwap(A,right--,i--,ext);
						leftAD++;
						rightAD--;
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await rotate(A,left+1,m,f+1);
						right-=m-(left+1);
						rightAD=0;
					}
				}
			}
			if(j<m&&rightAD==blL&&tC>0){
				await multiSwapBW(A,right,left+blL,blL,ext);
			}else{
				if(j>=m){
					await rotate(A,left+1,m,right+1);
					right-=m-(left+1);
				}
				await shift(A,left+1,right+1-rightAD,right+1,true,ext);
			}
			if(i>=a)await shift(A,a,i+1,i+1+bfL,true,ext);
			if(auxTag)await blockCycleBW(A,selst,tC,a-1+bfL);
			else await blockSelectBW(A,selst,tC);
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=binarySearch(A,j,b,A[i],true);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,j,i)<1){
					k=binarySearch(A,a,i+1,A[j],true);
					await rotate(A,k,i+1,j+1);
					j-=(i+1)-k;
					i=k-1;
				}else j--;
			}
		}
		async function inPlaceMerge2(A,st,mid,end){
			let i=st,m=mid,k=mid,q;
			while(m<end){
				if(compareIndices(A,m-1,m)<1)
					return;
				while(i<m-1&&compareIndices(A,i,m)<1)i++;
				await swap(A,i++,k++,1,true);
				while(i<m){
					while(i<m&&k<end&&compareIndices(A,m,k)>0)
						await swap(A,i++,k++,1,true,false);
					if(i>=m)break;
					else if(k>=end){
						await rotate(A,i,m,end);
						return;
					}else if(k-m>=m-i){
						await rotate(A,i,m,k);
						break;
					}
					q=m;
					while(i<m&&q<k&&compareIndices(A,q,k)<1)
						await swap(A,i++,q++,1,true,false);
					await rotate(A,m,q,k);
				}
				m=k;
			}
		}
		async function inPlaceMergeSort2(A,st,end){
			let ln=end-st,j;
			for(let i=1;i<ln;i*=2){
				for(j=st;j+2*i<end;j+=2*i)
					await inPlaceMerge2(A,j,j+i,j+2*i);
				if(j+i<end)
					await inPlaceMerge2(A,j,j+i,end);
			}
		}
		async function mergeWithBuf(A,a,m,b,l){
			let i=a,j=m,k=a-l;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await kotaSwap(A,k++,i++,ext);
				else
					await kotaSwap(A,k++,j++,ext);
			}
			while(j<b)
				await kotaSwap(A,k++,j++,ext);
			await shift(A,k,i,m,false,ext);
		}
		async function dualMerge(A,a,m,b,l){
			if(b-m<=l){
				await mergeWithBuf(A,a,m,b,l);
			}else{
				let i=a,j=m,k=a-l;
				while(k<i&&i<m){
					if(compareIndices(A,i,j)<1)
						await kotaSwap(A,k++,i++,ext);
					else
						await kotaSwap(A,k++,j++,ext);
				}
				if(k<i)
					await shift(A,j-l,j,b,false,ext);
				else{
					let i2=m-1,j2=b-1;k=(m-1)+(b-j);
					while(i2>=i&&j2>=j){
						if(compareIndices(A,i2,j2)>0)
							await kotaSwap(A,k--,i2--,ext);
						else
							await kotaSwap(A,k--,j2--,ext);
					}
					while(j2>=j)
						await kotaSwap(A,k--,j2--,ext);
				}
			}
		}
		async function dualMergeBW(A,a,m,b,l){
			let i=m-1,j=b-1,k=b-1+l;
			while(k>j&&j>=m){
				if(compareIndices(A,i,j)>0)
					await kotaSwap(A,k--,i--,ext);
				else
					await kotaSwap(A,k--,j--,ext);
			}
			if(j<m)
				await shift(A,a,i+1,i+1+l,true,ext);
			else{
				let i2=a,j2=m;
				i++;j++;k=m-(i-a);
				while(i2<i&&j2<j){
					if(compareIndices(A,i2,j2)<1)
						await kotaSwap(A,k++,i2++,ext);
					else
						await kotaSwap(A,k++,j2++,ext);
				}
				while(i2<i)
					await kotaSwap(A,k++,i2++,ext);
			}
		}
		async function mergeWithBufStatic(A,a,m,b,p,bw){
			if(m-a<1||b-m<1)
				return;
			let i,j,k,q;
			if(bw){
				i=(b-m)-1;j=m-1;k=b-1;
				while(i>=0&&j>=a){
					if(compareIndices(A,p+i,j)<1){
						q=binarySearch(A,a,j+1,A[p+i],true);
						while(j>=q)await swap(A,k--,j--,1,true,false);
					}
					await swap(A,k--,p+(i--),1,true,false);
				}
				while(i>=0){
					await swap(A,k--,p+(i--),1,true,false);
				}
			}else{
				i=0;j=m;k=a;
				while(i<m-a&&j<b){
					if(compareIndices(A,j,p+i)<0){
						q=binarySearch(A,j,b,A[p+i],true);
						while(j<q)await swap(A,k++,j++,1,true,false);
					}
					await swap(A,k++,p+(i++),1,true,false);
				}
				while(i<m-a){
					await swap(A,k++,p+(i++),1,true,false);
				}
			}
		}
		async function mergeExtBuf(A,a,b,bw){
			let i,j,k,m;
			if(bw){
				i=bfL-1;j=(b-1)-bfL;k=b-1;
				while(i>=0&&j>=a){
					if(compareValues(C[i],A[j])<1){
						m=binarySearch(A,a,j+1,C[i],true);
						while(j>=m)await write(A,k--,A[j--],1,true,false);
					}
					await write(A,k--,C[i--],1,true,false);
				}
				while(i>=0){
					await write(A,k--,C[i--],1,true,false);
				}
			}else{
				i=0;j=a+bfL;k=a;
				while(i<bfL&&j<b){
					if(compareValues(A[j],C[i])<0){
						m=binarySearch(A,j,b,C[i],true);
						while(j<m)await write(A,k++,A[j++],1,true,false);
					}
					await write(A,k++,C[i++],1,true,false);
				}
				while(i<bfL){
					await write(A,k++,C[i++],1,true,false);
				}
			}
		}
		async function kotaIterator(A,st,end,auxTag){
			let i=1,j,effst=st+bfL,ln=end-effst;
			if(!ext){
				while(i<16){
					for(j=effst;j+2*i<end;j+=2*i)
						await inPlaceMerge2(A,j,j+i,j+2*i);
					if(j+i<end)
						await inPlaceMerge2(A,j,j+i,end);
					i*=2;
				}
			}
			while(i<=bfL){
				let l=i;
				for(j=effst;j+2*i<end;j+=2*i)
					await mergeWithBuf(A,j,j+i,j+2*i,l);
				if(j+i<end)
					await mergeWithBuf(A,j,j+i,end,l);
				else
					await shift(A,j-l,j,end,false,ext);
				i*=2;
				for(j=effst-l;j+2*i<end-l;j+=2*i);
				if(j+i<end-l)
					await dualMergeBW(A,j,j+i,end-l,l);
				else
					await shift(A,j,end-l,end,true,ext);
				for(j-=2*i;j>=effst-l;j-=2*i)
					await dualMergeBW(A,j,j+i,j+2*i,l);
				i*=2;
				if(ext&&eM<minVal(i,bfL)){
					await arraycopy(C,0,A,effst-eM,eM,1,true);
					ext=false;
				}
			}
			while(i<ln){
				for(j=effst;j+2*i<end;j+=2*i)
					await blockMerge(A,j,j+i,j+2*i,auxTag);
				if(j+i<end)
					await blockMerge(A,j,j+i,end,auxTag);
				else
					await shift(A,j-bfL,j,end,false,ext);
				i*=2;
				if(i>=ln)return true;
				for(j=st;j+2*i<end-bfL;j+=2*i);
				if(j+i<end-bfL)
					await blockMergeBW(A,j,j+i,end-bfL,auxTag);
				else
					await shift(A,j,end-bfL,end,true,ext);
				for(j-=2*i;j>=st;j-=2*i)
					await blockMergeBW(A,j,j+i,j+2*i,auxTag);
				i*=2;
			}
			return false;
		}
		async function kotaSort(A,st,end){
			let ln=end-st;
			if(ln<=128){
				await inPlaceMergeSort2(A,st,end);
				return;
			}
			ext=false;
			bfP=st;
			for(blL=1;blL*blL<ln;blL*=2);
			let ideal=blL*2;
			bfL=await findKeys(A,st,end,ideal);
			if(bfL<ideal){
				if(bfL==1){
					return;
				}else if(bfL<=16){
					await inPlaceMergeSort2(A,st,end);
					return;
				}else{
					await inPlaceMergeSort2(A,st,end);
					return;
				}
			}
			ideal=ln/blL|0;
			tL=await findKeys(A,st+bfL,end,ideal);
			if(tL<ideal){
				if(tL<=16){
					await inPlaceMergeSort2(A,st,end);
					return;
				}else{
					await inPlaceMergeSort2(A,st,end);
					return;
				}
			}
			let bufst=st+tL;
			let effst=bufst+bfL;
			let bufEnd=st+bfL;
			await shift(A,st,bufEnd,effst,false,false);
			let bw=await kotaIterator(A,bufst,end,false);
			if(bw){
				let endst=end-bfL;
				await multiSwap(A,st,endst,tL,false);
				await mergeWithBufStatic(A,st,bufst,endst,endst,false);
				await inPlaceMergeSort2(A,endst,end);
				let mid=endst+blL;
				let pos=binarySearch(A,st,endst,A[mid-1],true);
				await rotate(A,pos,endst,mid);
				pos+=blL;
				await multiSwapBW(A,end-1,pos-1,blL,false);
				await mergeWithBufStatic(A,st,pos-blL,pos,mid,true);
				await inPlaceMergeSort2(A,mid,end);
				await inPlaceMergeBW(A,pos,mid,end);
			}else{
				await mergeWithBufStatic(A,bufEnd,effst,end,st,false);
				await inPlaceMergeSort2(A,st,bufEnd);
				let mid=st+blL;
				let pos=binarySearch(A,bufEnd,end,A[mid],true);
				await rotate(A,mid,bufEnd,pos);
				pos-=blL;
				await multiSwap(A,st,pos,blL,false);
				await mergeWithBufStatic(A,pos,pos+blL,end,st,false);
				await inPlaceMergeSort2(A,st,mid);
				await inPlaceMerge(A,st,mid,pos);
			}
		}
		await kotaSort(arr,0,len);
	}
	async baseNMaxHeapSort(len){
		let base=askForBase(4);
		async function siftDown(A,b,n,s){
			let l=n*b+1;
			if(l<s){
				let mx=l;
				for(let i=l+1;i<l+b;i++){
					if(i>=s)
						break;
					if(compareIndices(A,mx,i)<0)
						mx=i;
				}
				if(compareIndices(A,n,mx)<0){
					await swap(A,n,mx,0,true);
					await siftDown(A,b,mx,s);
				}
			}
		}
		for(let i=len-1;i>-1;i--)
			await siftDown(arr,base,i,len);
		for(let i=len-1;i>0;i--){
			await swap(arr,0,i,1,true);
			await siftDown(arr,base,0,i);
		}
	}
	async bingoSort(len){
		let mx=len-1;
		let nx=arr[mx];
		for(let i=mx-1;i>=0;i--)
			if(arr[i]>nx)
				nx=arr[i];
		while(mx>0&&arr[mx]==nx)mx--;
		while(mx>0){
			let v=nx;
			nx=arr[mx];
			for(let j=mx-1;j>=0;j--){
				if(!compareValues(arr[j],v))
					await swap(arr,j,mx--,2*sleep,true);
				else
					if(arr[j]>nx)
						nx=arr[j];
			}
			while(mx>0&&arr[mx]==nx)mx--;
		}
	}
	async cycleSort(len){
		function countLesser(A,a,b,t){
			let r=a;
			for(let i=a+1;i<b;i++)r+=compareValues(A[i],t)<0?1:0;
			return r;
		}
		for(let i=0;i<len-1;i++){
			let t=arr[i];
			let r=countLesser(arr,i,len,t);
			if(r-i){
				do{
					while(!compareIndexValue(arr,r,t))r++;
					let t1=arr[r];
					await write(arr,r,t,0.02,true);
					t=t1;
					r=countLesser(arr,i,len,t);
				}while(r-i);
				await write(arr,i,t,0.02,true);
			}
		}
	}
	async unstableGrailSort(len){
		async function grailSwap(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)
				await grailSwap(A,a++,b++);
		}
		async function grailRotate(A,p,lA,lB){
			while(lA&&lB){
				if(lA<=lB){
					await grailMultiSwap(A,p,p+lA,lA);
					p+=lA;
					lB-=lA;
				}else{
					await grailMultiSwap(A,p+lA-lB,p+lA,lB);
					lA-=lB;
				}
			}
		}
		function grailBinSearch(A,p,ln,kP,iL){
			let l=-1,r=ln;
			while(l<r-1){
				let m=l+((r-l)>>1);
				if(compareIndices(A,kP,p+m)<(iL?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2){
				while(l1){
					let o=grailBinSearch(A,p+l1,l2,p,true);
					if(o){
						await grailRotate(A,p,l1,o);
						p+=o;
						l2-=o;
					}
					if(!l2)break;
					do{
						p++;l1--;
					}while(l1&&compareIndices(A,p,p+l1)<1);
				}
			}else{
				while(l2){
					let o=grailBinSearch(A,p,l1,p+l1+l2-1,false);
					if(o-l1){
						await grailRotate(A,p+o,l1-o,l2);
						l1=o;
					}
					if(!l1)break;
					do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
				}
			}
		}
		async function grailMergeBuffersLeft(A,p,blC,bL,aBC,lL){
			if(!blC)return await grailMergeLeft(A,p,aBC*bL,lL,0-bL);
			let lOL=bL;
			let pI=bL;
			let rTP;
			for(let kI=1;kI<blC;kI++,pI+=bL){
				rTP=pI-lOL;
				lOL=await grailSmartMergeWithBuffer(A,p+rTP,lOL,bL);
			}
			rTP=pI-lOL;
			if(lL){
				lOL+=bL*aBC;
				await grailMergeLeft(A,p+rTP,lOL,lL,-bL);
			}else
				await grailMultiSwap(A,p+rTP,p+(rTP-bL),lOL);
		}
		async function grailMergeLeft(A,p,lL,rL,ds){
			let l=0;
			let r=lL;
			rL+=lL;
			while(r<rL){
				if(l==lL||compareIndices(A,p+l,p+r)>0)
					await grailSwap(A,p+(ds++),p+(r++));
				else await grailSwap(A,p+(ds++),p+(l++));
			}
			if(ds-l)await grailMultiSwap(A,p+ds,p+l,lL-l);
		}
		async function grailMergeRight(A,p,lL,rL,ds){
			let mP=lL+rL+ds-1;
			let r=lL+rL-1;
			let l=lL-1;
			while(l>=0){
				if(r<lL||compareIndices(A,p+l,p+r)>0)
					await grailSwap(A,p+(mP--),p+(l--));
				else await grailSwap(A,p+(mP--),p+(r--));
			}
			if(r-mP)
				while(r>=lL)await grailSwap(A,p+(mP--),p+(r--));
		}
		async function grailSmartMergeWithBuffer(A,p,lOL,bL){
			let ds=0-bL,l=0,r=lOL,lE=r,rE=r+bL;
			while(l<lE&&r<rE){
				if(compareIndices(A,p+l,p+r)<1)
					await grailSwap(A,p+(ds++),p+(l++));
				else await grailSwap(A,p+(ds++),p+(r++));
			}
			let ln;
			if(l<lE){
				ln=lE-l;
				while(l<lE)await grailSwap(A,p+(--lE),p+(--rE));
			}else
				ln=rE-r;
			return ln;
		}
		async function grailBuildBlocks(A,p,ln,uL){
			let eD,pt;
			for(let ds=1;ds<ln;ds+=2){
				eD=0;
				if(compareIndices(A,p+ds-1,p+ds)>0)eD=1;
				await grailSwap(A,p+ds-3,p+ds-1+eD);
				await grailSwap(A,p+ds-2,p+ds-eD);
			}
			if(ln%2!=0)await grailSwap(A,p+ln-1,p+ln-3);
			p-=2;pt=2;
			for(;pt<uL;pt*=2){
				let l=0;
				let r=ln-2*pt;
				while(l<=r){
					await grailMergeLeft(A,p+l,pt,pt,0-pt);
					l+=2*pt;
				}
				let rs=ln-l;
				if(rs>pt)
					await grailMergeLeft(A,p+l,pt,rs-pt,0-pt);
				else
					await grailRotate(A,p+l-pt,pt,rs);
				p-=pt;
			}
			let rTB=ln%(2*uL);
			let lOP=ln-rTB;
			if(rTB<=uL)await grailRotate(A,p+lOP,rTB,uL);
			else await grailMergeRight(A,p+lOP,uL,rTB-uL,uL);
			while(lOP>0){
				lOP-=2*uL;
				await grailMergeRight(A,p+lOP,uL,uL,uL);
			}
		}
		async function grailCombineBlocks(A,p,l,uL,rBL){
			let cL=l/(2*uL)|0;
			let lO=l%(2*uL);
			if(lO<=uL){
				l-=lO;
				lO=0;
			}
			for(let i=0;i<=cL;i++){
				if(i==cL&&!lO)break;
				let blP=p+i*2*uL;
				let blC=(i==cL?lO:2*uL)/rBL;
				for(let j=1;j<blC;j++){
					let lI=j-1;
					for(let rI=j;rI<blC;rI++){
						let rC=compareIndices(A,blP+lI*rBL,blP+rI*rBL);
						if(rC>0||(!rC&&compareIndices(A,blP+(lI+1)*rBL-1,blP+(rI+1)*rBL-1)>0))
							lI=rI;
					}
					if(lI!=j-1)
						await grailMultiSwap(A,blP+(j-1)*rBL,blP+lI*rBL,rBL);
				}
				let aBC=0;
				let lL=0;
				if(i==cL)lL=lO%rBL;
				if(lL)
					while(aBC<blC&&compareIndices(A,blP+blC*rBL,blP+(blC-aBC-1)*rBL)<0)
						await aBC++;
				await grailMergeBuffersLeft(A,blP,blC-aBC,rBL,aBC,lL);
			}
			while(--l>=0)
				await grailSwap(A,p+l,p+l-rBL);
		}
		async function grailCommonSort(A,p,l){
			if(l<=16)return await insertSort(A,p,l);
			let bL=1;
			while(bL*bL<l)bL*=2;
			let uL=bL;
			await grailBuildBlocks(A,p+bL,l-bL,uL);
			while(l-bL>(uL*=2))
				await grailCombineBlocks(A,p+bL,l-bL,uL,bL);
			await insertSort(A,p,bL);
			await grailMergeWithoutBuffer(A,p,bL,l-bL);
		}
		await grailCommonSort(arr,0,len);
	}
	async binomialHeapSort(len){
		let mN,f,i,d;
		for(i=2;i<=len;i+=2){
			mN=i;
			do{
				f=mN;
				for(d=1;(f&d)==0;d*=2)
					if(compareIndices(arr,f-d-1,mN-1)>0)
						mN=(f-d);
				if(f-mN)
					await swap(arr,f-1,mN-1,1,true);
			}while(f-mN);
		}
		for(i=len;i>2;i--){
			mN=f=i;
			for(d=1;f;d*=2){
				if(f&d){
					if(compareIndices(arr,f-1,mN-1)>0)
						mN=f;
					f-=d;
				}
			}
			if(mN-i){
				f=i;
				do{
					await swap(arr,f-1,mN-1,1,true);
					f=mN;
					for(d=1;(f&d)==0;d*=2)
						if(compareIndices(arr,f-d-1,mN-1)>0)
							mN=(f-d);
				}while(f-mN);
			}
		}
	}
	async binomialSmoothSort(len){
		function h(n){
			let c=0;
			while((n>>c)%2)c++;
			return c;
		}
		async function thrift(A,n,p,r){
			r=r&&(n>=(1<<h(n)));
			if(!r&&!p)return;
			let c=h(n)-(r?0:1);
			if(p)
				for(let j=c-1;j>=0;j--)
					if(compareIndices(A,n-(1<<c),n-(1<<j))<1)
						c=j;
			if(compareIndices(A,n-(1<<c),n)<1)return;
			await swap(A,n,n-(1<<c),.65,true);
			await thrift(A,n-(1<<c),(n-(1<<c))%2==1,c==h(n));
		}
		let n;
		for(n=1;n<len;n++)
			await thrift(arr,n,n%2==1,(n+(1<<h(n))>=len));
		for(n-=(n-1)%2;n>2;n-=2)
			for(let j=h(n)-1;j>=0;j--)
				await thrift(arr,n-(1<<j),false,true);
	}
	async bottomUpHeapSort(len){
		async function siftDown(A,i,b){
			let j=i;
			for(;2*j+1<b;j=2*j+2<b?(compareIndices(A,2*j+2,2*j+1)>0?2*j+2:2*j+1):2*j+1);
			for(;compareIndices(A,i,j)>0;j=(j-1)/2|0);
			for(;j>i;j=(j-1)/2|0)await swap(A,i,j,1,true);
		}
		for(let i=(len-1)/2|0;i>=0;i--)
			await siftDown(arr,i,len);
		for(let i=len-1;i>0;i--){
			await swap(arr,0,i,1,true);
			await siftDown(arr,0,i);
		}
	}
	async doubleSelectionSort(len){
		let l=0,r=len-1,s=0,b=0;
		while(l<=r){
			for(let i=l;i<=r;i++){
				if(compareIndices(arr,i,b)>0)
					b=i;
				if(compareIndices(arr,i,s)<0)
					s=i;
			}
			if(b==l)b=s;
			await swap(arr,l++,s,0.02,true);
			await swap(arr,r--,b,0.02,true);
			s=l;b=r;
		}
	}
	async flippedMinHeapSort(len){
		async function siftDown(A,l,r,d){
			while(r<=(d/2|0)){
				let f=2*r;
				if(f<d&&compareIndices(A,l-f,l-f-1)>0)
					f++;
				if(compareIndices(A,l-r,l-f)>0){
					await swap(A,l-r,l-f,0,true);
					r=f;
				}else break;
			}
		}
		for(let i=len/2|0;i>=1;i--)
			await siftDown(arr,len,i,len);
		for(let i=len;i>1;i--){
			await swap(arr,len-1,len-i,1,true);
			await siftDown(arr,len,1,i-1);
		}
	}
	async lazyHeapSort(len){
		async function maxToFront(A,a,b){
			let m=a;
			for(let i=a+1;i<b;i++)if(compareIndices(A,i,m)>0)m=i;
			await swap(A,m,a,1,true);
		}
		async function sort(A,l){
			let s=sqrt(l-1)+1|0;
			for(let i=0;i<l;i+=s)
				await maxToFront(A,i,minVal(i+s,l));
			for(let j=l;j>0;){
				let m=0;
				for(let i=m+s;i<j;i+=s)
					if(compareIndices(A,m,i)<1)m=i;
				await swap(A,m,--j,1,true);
				await maxToFront(A,m,minVal(m+s,j));
			}
		}
		await sort(arr,len);
	}
	async maxHeapSort(len){
		const hs=new HeapSorting(true);
		await hs.sort(arr,0,len);
	}
	async minHeapSort(len){
		const hs=new HeapSorting();
		await hs.sort(arr,0,len);
	}
	async minMaxHeapSort(len){
		function compare(x,y,g){
			if(g)[x,y]=[y,x];
			return compareValues(x,y)<0;
		}
		async function sw(i,j){
			await swap(a,i,j,1,true);
		}
		function isMin(i){
			i=i-s+1;
			return((32-clz32(i))&1)==1;
		}
		async function downheap(i){
			let cf=!isMin(i);
			let lf=2*i+1;
			while(lf<e){
				let ri=lf+1;
				let nx=lf;
				for(let c of[ri,2*lf+1,2*lf+2,2*ri+1,2*ri+2]){
					if(c>=e)break;
					if(compare(a[c],a[nx],cf))
						nx=c;
				}
				if(nx<=ri){
					if(compare(a[nx],a[i],cf))
						await sw(nx,i);
					return;
				}else{
					if(compare(a[nx],a[i],cf)){
						await sw(nx,i);
						let p=(nx-1)/2|0;
						if(compare(a[p],a[nx],cf))
							await sw(nx,p);
					}else return;
				}
				i=nx;
				lf=2*i+1;
			}
		}
		async function heapify(){
			for(let i=(e-1)/2|0;i>=s;i--)
				await downheap(i);
		}
		async function store(){
			if(e<=s+1)return;
			let im=s+1;
			if(e>im+1&&compare(a[im],a[im+1],false))
				im++;
			await sw(im,--e);
			if(im<e)
				await downheap(im);
		}
		let a=arr;
		let s=0,e=len;
		await heapify();
		for(let i=e-1;i>s;i--)
			await store();
	}
	async outOfPlaceHeapSort(len){
		async function siftDown(A,i,b){
			let j=i;
			for(;2*j+1<b;j=2*j+2<b?(compareIndices(A,2*j+2,2*j+1)>0?2*j+2:2*j+1):2*j+1);
			for(;compareIndices(A,i,j)>0;j=(j-1)/2|0);
			for(;j>i;j=(j-1)/2|0)await swap(A,i,j,1,true);
		}
		async function findNext(A,b){
			let i=0,l=1,r=2;
			while(r<b&&!(A[l]==-1&&A[r]==-1)){
				if(A[l]==-1){
					await swap(A,i,r,1,true);
					i=r;
				}else if(A[r]==-1){
					await swap(A,i,l,1,true);
					i=l;
				}else if(compareValues(A[r],A[l])>0){
					await swap(A,i,r,1,true);
					i=r;
				}else{
					await swap(A,i,l,1,true);
					i=l;
				}
				l=2*i+1;
				r=l+1;
			}
			if(l<b&&A[l]!=-1)
				await swap(A,i,l,1,true);
		}
		for(let i=(len-1)/2|0;i>=0;i--)
			await siftDown(arr,i,len);
		let tmp=new Array(len);
		for(let i=len-1;i>=0;i--){
			write(tmp,i,arr[0],0,false,true);
			await write(arr,0,-1,1,true);
			await findNext(arr,len);
		}
		await arraycopy(tmp,0,arr,0,len,1,true);
	}
	async poplarHeapSort(len){
		function hyperfloor(n){
			return pow(2,log(n)/log(2)|0);
		}
		async function insertion(A,f,l){
			for(let c=f+1;c!=l;++c){
				let s0=c,s1=c-1;
				if(compareIndices(A,s0,s1)<0){
					let tmp=A[s0];
					do await write(A,s0,A[s1],0.25,true);while(--s0!=f&&compareValues(tmp,A[--s1])<0);
					await write(A,s0,tmp,0.25,true);
				}
			}
		}
		async function insSort(A,f,l){
			if(f-l)await insertion(A,f,l);
		}
		async function sift(A,f,z){
			if(z<2)return;
			let r=f+(z-1);
			let c1=r-1;
			let c2=f+z/2-1|0;
			while(1){
				let mr=r;
				if(compareIndices(A,mr,c1)<0)mr=c1;
				if(compareIndices(A,mr,c2)<0)mr=c2;
				if(mr==r)return;
				await swap(A,r,mr,0.75,true);
				z=z/2|0;
				if(z<2)return;
				r=mr;
				c1=r-1;
				c2=mr-z+z/2|0;
			}
		}
		async function popHeap(A,f,l,z){
			let pz=hyperfloor(z+1)-1;
			let l_r=l-1;
			let bg=l_r;
			let bgz=pz;
			let it=f;
			while(1){
				let r=it+pz-1;
				if(r==l_r)break;
				if(compareValues(A[bg],A[r])<0){
					bg=r;
					bgz=pz;
				}
				it=r+1;
				z-=pz;
				pz=hyperfloor(z+1)-1;
			}
			if(bg-l_r){
				await swap(A,bg,l_r,0.75,true);
				await sift(A,bg-bgz+1,bgz);
			}
		}
		async function heapify(A,f,l){
			let z=l-f;
			if(z<2)return;
			let smPop=15;
			if(z<16){
				await insertion(A,f,l);
				return;
			}
			let pl=1;
			let it=f;
			let nx=it+smPop;
			while(1){
				await insertion(A,it,nx);
				let pz=smPop;
				for(let i=(pl&(0-pl))>>1;i;i>>=1){
					it-=pz;
					pz=2*pz+1;
					await sift(A,it,pz);
					++nx;
				}
				if((l-nx)<=smPop){
					await insSort(A,nx,l);
					return;
				}
				it=nx;
				nx+=smPop;
				++pl;
			}
		}
		async function sort(A,f,l){
			let z=l-f;
			if(z<2)return;
			do await popHeap(A,f,l--,z--);while(z>1);
		}
		await heapify(arr,0,len);
		await sort(arr,0,len);
	}
	async selectionSort(len){
		for(let i=0;i<len-1;i++){
			let li=i;
			for(let j=i+1;j<len;j++)
				if(compareIndices(arr,j,li)<0)
					li=j;
			await swap(arr,i,li,0.02,true);
		}
	}
	async smoothSort(len){
		let LP=[1,1,3,5,9,15,25,41,67,109,177,287,465,753,1219,1973,3193,5167,8361,13529,21891];
		async function sift(A,psh,h){
			let v=A[h];
			while(psh>1){
				let rt=h-1;
				let lf=h-1-LP[psh-2];
				if(compareValues(A[lf],v)<1&&compareValues(A[rt],v)<1)break;
				if(compareIndices(A,rt,lf)<1){
					await write(A,h,A[lf],0.65,true);
					h=lf;
					psh--;
				}else{
					await write(A,h,A[rt],0.65,true);
					h=rt;
					psh-=2;
				}
			}
			await write(A,h,v,0.65,true);
		}
		async function trinkle(A,p,psh,h,T){
			let v=A[h];
			while(p!=1){
				let ss=h-LP[psh];
				if(compareValues(A[ss],v)<1)break;
				if(!T&&psh>1){
					let rt=h-1;
					let lf=h-1-LP[psh-2];
					if(compareIndices(A,ss,rt)<1||compareIndices(A,ss,lf)<1)break;
				}
				await write(A,h,A[ss],0.65,true);
				h=ss;
				let tr=ctz(p&~1);
				p>>=tr;
				psh+=tr;
				T=false;
			}
			if(!T){
				await write(A,h,v,0.65,true);
				await sift(A,psh,h);
			}
		}
		async function smoothSort(A,lo,hi,F){
			let h=lo;
			let p=1;
			let psh=1;
			while(h<hi){
				if((p&3)==3){
					await sift(A,psh,h);
					p>>=2;
					psh+=2;
				}else{
					if(LP[psh-1]>=hi-h){
						await trinkle(A,p,psh,h,false);
					}else{
						await sift(A,psh,h);
					}
					if(psh==1){
						p<<=1;
						psh--;
					}else{
						p<<=(psh-1);
						psh=1;
					}
				}
				p|=1;
				h++;
			}
			if(F){
				await trinkle(A,p,psh,h,false);
				while(psh!=1||p!=1){
					if(psh<=1){
						let t=ctz(p&~1);
						p>>=t;
						psh+=t;
					}else{
						p<<=2;
						p^=7;
						psh-=2;
						await trinkle(A,p>>1,psh+1,h-LP[psh]-1,true);
						await trinkle(A,p,psh,h-1,true);
					}
					h--;
				}
			}
		}
		await smoothSort(arr,0,len-1,true);
	}
	async stableCycleSort(len){
		function getBit(t,i){
			let b=(t[i>>3])>>(i&((1<<3)-1))&1;
			return b==1;
		}
		function flag(t,i){
			write(t,i>>3,t[i>>3]|(1<<(i&((1<<3)-1))),0.02,false,true);
		}
		function dest(A,T,a,b1,b){
			let d=a,e=0;
			for(let i=a+1;i<b;i++){
				let c=compareIndices(A,i,a);
				if(c<0)d++;
				else if(i<b1&&!getBit(T,i)&&!c)e++;
			}
			while(getBit(T,d)||e-->0)d++;
			return d;
		}
		let bits=new Array(((len-1)>>3)+1);
		for(let i=0;i<len-1;i++){
			if(!getBit(bits,i)){
				let j=i;
				do{
					let k=dest(arr,bits,i,j,len);
					await swap(arr,i,k,0.02,true);
					flag(bits,k);
					j=k;
				}while(j-i);
			}
		}
	}
	async stableSelectionSort(len){
		for(let i=0;i<len-1;i++){
			let n=i;
			for(let j=i+1;j<len;j++)
				if(compareIndices(arr,j,n)<0)
					n=j;
			let t=arr[n];
			let p=n;
			while(p>i)
				await write(arr,p,arr[--p],0,true);
			await write(arr,p,t,0,true);
		}
	}
	async ternaryHeapSort(len){
		let hS;
		async function heapify(A,i){
			let lC=3*i+1;
			let rC=3*i+3;
			let mC=3*i+2;
			let lr;
			lr=lC<=hS&&compareIndices(A,lC,i)>0?lC:i;
			if(rC<=hS&&compareIndices(A,rC,lr)>0)
				lr=rC;
			if(mC<=hS&&compareIndices(A,mC,lr)>0)
				lr=mC;
			if(lr-i){
				await swap(A,i,lr,1,true);
				await heapify(A,lr);
			}
		}
		async function buildHeap(A,l){
			hS=l-1;
			for(let i=l-1;i>=0;i--)
				await heapify(A,i);
		}
		await buildHeap(arr,len);
		for(let i=len-1;i>=0;i--){
			await swap(arr,0,i,1,true);
			hS--;
			await heapify(arr,0);
		}
	}
	async tournamentSort(len){
		async function tC(a,b){
			draw();
			markSwap(a,b);
			await sleep();
			return compareValues(a,b);
		}
		function isPlayer(i){
			return i<=0;
		}
		function setWinner(r,w){
			write(aux,r,w,0,false,true);
		}
		function setWinners(r,w){
			write(aux,r+1,w,0,false,true);
		}
		function setLosers(r,l){
			write(aux,r+2,l,0,false,true);
		}
		function getWinner(r){
			return aux[r];
		}
		function getWinners(r){
			return aux[r+1];
		}
		function getLosers(r){
			return aux[r+2];
		}
		function setMatch(r,w,s,l){
			setWinner(r,w);
			setWinners(r,s);
			setLosers(r,l);
		}
		function getPlayer(i){
			return i<=0?abs(i):getWinner(i);
		}
		async function pop(A){
			let r=A[getPlayer(t)];
			t=isPlayer(t)?0:await rebuild(arr,t);
			return r;
		}
		function makePlayer(i){
			return-i;
		}
		async function makeMatch(A,t,b,r){
			let tw=getPlayer(t);
			let bw=getPlayer(b);
			if(await tC(A[tw],A[bw])<1)
				setMatch(r,tw,t,b);
			else
				setMatch(r,bw,b,t);
			return r;
		}
		async function knockout(A,i,k,r){
			if(i==k)return makePlayer(i);
			let j=(i+k)/2|0;
			return await makeMatch(A,await knockout(A,i,j,2*r),await knockout(A,j+1,k,(2*r)+3),r);
		}
		async function rebuild(A,r){
			if(isPlayer(getWinners(r)))
				return getLosers(r);
			setWinners(r,await rebuild(A,getWinners(r)));
			if(await tC(A[getPlayer(getLosers(r))],A[getPlayer(getWinners(r))])<0){
				setWinner(r,getPlayer(getLosers(r)));
				let tm=getLosers(r);
				setLosers(r,getWinners(r));
				setWinners(r,tm);
			}else{
				setWinner(r,getPlayer(getWinners(r)));
			}
			return r;
		}
		async function sort(A,l){
			let c=new Array(l);
			for(let i=0;i<l;i++){
				let r=await pop(A);
				draw();
				write(c,i,r,1,false,true);
			}
			await arraycopy(c,0,A,0,l,1,true);
		}
		let aux=new Array(6*len);
		let t=await knockout(arr,0,len-1,3);
		await sort(arr,len);
	}
	async triangularHeapSort(len){
		function triangularRoot(v){
			return(sqrt(8*v+1)-1|0)/2|0;
		}
		async function sift(A,e,r){
			let tm=A[r];
			let ln=triangularRoot(r);
			let lo=r+ln+1;
			let hi=lo+1;
			while(lo<e){
				if(hi>=e){
					if(compareValues(A[lo],tm)>0)
						await write(A,r,A[lo],0,true);
					break;
				}
				let x=compareIndices(A,hi,lo)<1?lo:hi;
				if(compareValues(A[x],tm)>0){
					await write(A,r,A[x],0,true);
					r=x;
					ln=triangularRoot(r);
					lo=r+ln+1;
					hi=lo+1;
					continue;
				}
				break;
			}
			await write(A,r,tm,0,true);
		}
		async function heapify(A,l){
			for(let i=l-1;i>=0;i--)
				await sift(A,l,i);
		}
		await heapify(arr,len);
		for(let i=1;i<len-1;i++){
			await swap(arr,0,len-i,0.5,true);
			await sift(arr,len-i,0);
		}
		if(compareIndices(arr,0,1)>0)swap(arr,0,1,0.5,true);
	}
	async weakHeapSort(len){
		function flag(T,x){
			return(T[x>>3]>>(x&7))&1;
		}
		function toggle(T,x){
			let flag=T[x>>3];
			flag^=1<<(x&7);
			write(T,(x)>>3,flag,0,true,true);
		}
		async function heapMerge(A,T,i,j){
			if(compareIndices(A,i,j)<0){
				toggle(T,j);
				await swap(A,i,j,1,true);
			}
		}
		let n=len;
		let i,j,x,y,gp;
		let T=new Array((n+7)/8|0);
		for(i=0;i<n/8|0;++i)
			await write(T,i,0,0,false,true);
		for(i=n-1;i>0;--i){
			j=i;
			while((j&1)==flag(T,j>>1))j>>=1;
			gp=j>>1;
			await heapMerge(arr,T,gp,i);
		}
		for(i=n-1;i>=2;--i){
			await swap(arr,0,i,1,true,false);
			x=1;
			while((y=2*x+flag(T,x))<i)x=y;
			while(x>0){
				await heapMerge(arr,T,0,x);
				x>>=1;
			}
		}
		await swap(arr,0,1,1,true);
	}
	async chaliceSort(len){
		const bms=new BlockMergeSorting();
		const hs=new HeapSorting(true);
		function ceilCbrt(n){
			let a=0,b=11;
			while(a<b){
				let m=(a+b)/2|0;
				if((1<<3*m)>=n)b=m;
				else a=m+1;
			}
			return 1<<a;
		}
		function calcKeys(bL,n){
			let a=1,b=n/4|0;
			while(a<b){
				let m=(a+b)/2|0;
				if(((n-4*m-1)/bL|0)-2<m)b=m;
				else a=m+1;
			}
			return a;
		}
		async function laziestSortExt(A,T,a,b){
			for(let i=a,s=T.length;i<b;i+=s){
				let j=minVal(b,i+s);
				await bms.binaryInsertion(A,i,j);
				if(i>a)await bms.mergeBWExt(A,T,a,i,j);
			}
		}
		async function findKeysSm(A,a,b,a1,b1,f,n){
			let p=a,pE=0;
			if(f){
				for(;p<b;p++){
					let o=bms.leftBinSearch(A,a1,b1,A[p]);
					if(o==b1||compareIndices(A,p,o)){
						pE=p+1;
						break;
					}
				}
				if(pE){
					for(let i=pE;i<b&&pE-p<n;i++){
						let o=bms.leftBinSearch(A,a1,b1,A[i]);
						if(o==b1||compareIndices(A,i,o)){
							o=bms.leftBinSearch(A,p,pE,A[i]);
							if(o==pE||compareIndices(A,i,o)){
								await bms.rotate(A,p,pE,i);
								let l1=i-pE;
								p+=l1;o+=l1;pE=i+1;
								await bms.insertTo(A,i,o);
							}
						}
					}
				}else pE=p;
			}else{
				pE=p+1;
				for(let i=pE;i<b&&pE-p<n;i++){
					let o=bms.leftBinSearch(A,p,pE,A[i]);
					if(o==pE||compareIndices(A,i,o)){
						await bms.rotate(A,p,pE,i);
						let l1=i-pE;
						p+=l1;o+=l1;pE=i+1;
						await bms.insertTo(A,i,o);
					}
				}
			}
			return[p,pE];
		}
		async function findKeys(A,T,a,b,n,s){
			let t=await findKeysSm(A,a,b,0,0,false,minVal(n,s));
			let p=t[0],pE=t[1];
			if(s<n&&pE-p==s){
				for(n-=s;;n-=s){
					t=await findKeysSm(A,pE,b,p,pE,true,minVal(s,n));
					let ks=t[1]-t[0];
					if(ks==0)break;
					if(ks<s||n==s){
						await bms.rotate(A,pE,t[0],t[1]);
						t[0]=pE;
						pE+=ks;
						await bms.mergeBWExt(A,T,p,t[0],pE);
						break;
					}else{
						await bms.rotate(A,p,pE,t[0]);
						p+=t[0]-pE;
						pE=t[1];
						await bms.mergeBWExt(A,T,p,t[0],pE);
					}
				}
			}
			await bms.rotate(A,a,p,pE);
			return pE-p;
		}
		async function findBitsSM(A,a,b,a1,bw,n){
			let p=a,pE,cmp=bw?-1:1;
			while(p<b&&compareIndices(A,p,a1)!=cmp)p++;
			a1++;
			if(p<b){
				pE=p+1;
				for(let i=pE;i<b&&pE-p<n;i++){
					if(compareIndices(A,i,a1)==cmp){
						await bms.rotate(A,p,pE,i);
						p+=i-pE;pE=i+1;a1++;
					}
				}
			}else pE=p;
			return[p,pE];
		}
		async function findBits(A,T,a,b,n,s){
			await laziestSortExt(A,T,a,a+n);
			let a0=a,a1=a+n,c=0,c0=0;
			for(let i=0;c<n&&i<2;i++){
				let p=a1,pE=p;
				while(1){
					let t=await findBitsSM(A,pE,b,a0,i==1,minVal(s,n-c));
					let bs=t[1]-t[0];
					if(!bs)break;
					a0+=bs;
					c+=bs;
					if(bs<s||c==n){
						await bms.rotate(A,pE,t[0],t[1]);
						t[0]=pE;
						pE+=bs;
						break;
					}else{
						await bms.rotate(A,p,pE,t[0]);
						p+=t[0]-pE;
						pE=t[1];
					}
				}
				await bms.rotate(A,a1,p,pE);
				a1+=pE-p;
				if(!i)c0=c;
			}
			if(c<n)return-1;
			else{
				await bms.multiSwap(A,a+c0,a+n+c0,n-c0);
				return c0;
			}
		}
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		async function unshuffle(A,a,b){
			let l=(b-a)>>1,c=0;
			for(let n=2;l>0;l>>=1,n*=2){
				if((l&1)==1){
					let a1=a+c;
					await bitReversal(A,a1,a1+n);
					await bitReversal(A,a1,a1+n/2|0);
					await bitReversal(A,a1+n/2|0,a1+n);
					await bms.rotate(A,a+c/2|0,a1,a1+n/2|0);
					c+=n;
				}
			}
		}
		async function redistBuffer(A,T,a,m,b){
			let s=T.length;
			while(m-a>s&&m<b){
				let i=bms.leftBinSearch(A,m,b,A[a+s]);
				await bms.rotate(A,a+s,m,i);
				let t=i-m;
				m=i;
				await bms.mergeFWExt(A,T,a,a+s,m);
				a+=t+s;
			}
			if(m<b)await bms.mergeFWExt(A,T,a,m,b);
		}
		async function dualMergeBW(A,a,m,b,p){
			let i=m-1;b--;
			while(p>b+1&&b>=m){
				if(compareIndices(A,i,b)<1)
					await swap(A,--p,b--,1,true);
				else
					await swap(A,--p,i--,1,true);
			}
			if(b<m)await bms.shiftBW(A,a,i+1,p);
			else{
				i++;b++;p=m-i+a;
				while(a<i&&m<b){
					if(compareIndices(A,a,m)<1)
						await swap(A,p++,a++,1,true);
					else
						await swap(A,p++,m++,1,true);
				}
				while(a<i)await swap(A,p++,a++,1,true);
			}
		}
		async function dualMergeBWEXT(A,a,m,b,p){
			let i=m-1;b--;
			while(p>b+1&&b>=m){
				if(compareIndices(A,i,b)<1)
					await write(A,--p,A[b--],1,true);
				else
					await write(A,--p,A[i--],1,true);
			}
			if(b<m)await bms.shiftBWExt(A,a,i+1,p);
			else{
				i++;b++;p=m-i+a;
				while(a<i&&m<b){
					if(compareIndices(A,a,m)<1)
						await write(A,p++,A[a++],1,true);
					else
						await write(A,p++,A[m++],1,true);
				}
				while(a<i)await write(A,p++,A[a++],1,true);
			}
		}
		async function smartMerge(A,p,a,m,r){
			let i=m,cmp=r?0:1;
			while(a<m){
				if(compareIndices(A,a,i)<cmp)
					await write(A,p++,A[a++],1,true);
				else
					await write(A,p++,A[i++],1,true);
			}
			return i;
		}
		async function smartTailMerge(A,T,p,a,m,b){
			let i=m,bL=T.length;
			while(a<m&&i<b){
				if(compareIndices(A,a,i)<1)
					await write(A,p++,A[a++],1,true);
				else
					await write(A,p++,A[i++],1,true);
			}
			if(a<m){
				if(a>p)await bms.shiftFWExt(A,p,a,m);
				await arraycopy(T,0,A,b-bL,bL,1,true);
			}else{
				a=0;
				while(a<bL&&i<b){
					if(compareValues(T[a],A[i])<1)
						await write(A,p++,T[a++],1,true);
					else
						await write(A,p++,A[i++],1,true);
				}
				while(a<bL)await write(A,p++,T[a++],1,true);
			}
		}
		async function blockCycle(A,a,t,tIdx,tLen,bL){
			for(let i=0;i<tLen-1;i++){
				if(compareIndices(A,t+i,tIdx+i)>0||(i>0&&compareIndices(A,t+i,tIdx+i-1)<0)){
					await arraycopy(A,a+i*bL,A,a-bL,bL,1,true);
					let val=i,next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					do{
						await arraycopy(A,a+next*bL,A,a+val*bL,bL,1,true);
						await swap(A,t+i,t+next,1,true);
						val=next;
						next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					}while(next!=i);
					await arraycopy(A,a-bL,A,a+val*bL,bL,1,true);
				}
			}
		}
		async function blockMerge(A,T,a,m,b,tl,tLen,t,tIdx,bp1,bp2,bL){
			if(b-m<=bL){
				await bms.mergeBWExt(A,T,a,m,b);
				return;
			}
			await bms.insertTo(A,t+tl-1,t);
			let i=a+bL-1,j=m+bL-1,ti=t,tj=t+tl,tp=tIdx;
			while(ti<t+tl&&tj<t+tLen){
				if(compareIndices(A,i,j)<1){
					await swap(A,tp++,ti++,1,true);
					i+=bL;
				}else{
					await swap(A,tp++,tj++,1,true);
					await swap(A,bp1,bp2,1,true);
					j+=bL;
				}
				bp1++;bp2++;
			}
			while(ti<t+tl){
				await swap(A,tp++,ti++,1,true);
				bp1++;bp2++;
			}
			while(tj<t+tLen){
				await swap(A,tp++,tj++,1,true);
				await swap(A,bp1++,bp2++,1,true);
			}
			t^=tIdx;tIdx^=t;t^=tIdx;
			await hs.sort(A,tIdx,tIdx+tLen);
			arraycopy(A,m-bL,T,0,bL,0,false,true);
			await arraycopy(A,a,A,m-bL,bL,1,true);
			await blockCycle(A,a+bL,t,tIdx,tLen,bL);
			await bms.multiSwap(A,t,tIdx,tLen);
			bp1-=tLen;bp2-=tLen;
			let f=a+bL,a1=f,bp3=bp2+tLen;
			let rev=compareIndices(A,bp1,bp2)>0;
			while(1){
				do{
					if(rev)await swap(A,bp1,bp2,1,true);
					bp1++;bp2++;
					a1+=bL;
				}
				while(bp2<bp3&&compareIndices(A,bp1,bp2)==(rev?1:-1));
				if(bp2==bp3){
					await smartTailMerge(A,T,f-bL,f,rev?f:a1,b);
					return;
				}
				f=await smartMerge(A,f-bL,f,a1,rev);
				rev=!rev;
			}
		}
		async function blockCycleEasy(A,a,t,tIdx,tLen,bL){
			for(let i=0;i<tLen-1;i++){
				if(compareIndices(A,t+i,tIdx+i)>0||(i>0&&compareIndices(A,t+i,tIdx+i-1)<0)){
					let next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					do{
						await bms.multiSwap(A,a+i*bL,a+next*bL,bL);
						await swap(A,t+i,t+next,1,true);
						next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					}while(next!=i);
				}
			}
		}
		async function inPlaceMergeBW(A,a,m,b,rev){
			let f=rev?bms.rightBinSearch(A,m,b,A[m-1]):bms.leftBinSearch(A,m,b,A[m-1]);
			b=f;
			while(b>m&&m>a){
				let i=rev?bms.leftBinSearch(A,a,m,A[b-1]):bms.rightBinSearch(A,a,m,A[b-1]);
				await bms.rotate(A,i,m,b);
				let t=m-i;
				m=i;
				b-=t+1;
				if(m==a)break;
				b=rev?bms.rightBinSearch(A,m,b,A[m-1]):bms.leftBinSearch(A,m,b,A[m-1]);
			}
			return f;
		}
		async function blockMergeEasy(A,a,m,b,lA,lB,tl,tLen,t,tIdx,bp1,bp2,bL){
			if(b-m<=bL){
				await inPlaceMergeBW(A,a,m,b,false);
				return;
			}
			let a1=a+lA,b1=b-lB;
			let i=a1+bL-1,j=m+bL-1,ti=tIdx,tj=tIdx+tl,tp=t;
			while(ti<tIdx+tl&&tj<tIdx+tLen){
				if(compareIndices(A,i,j)<1){
					await swap(A,ti++,tp++,1,true);
					i+=bL;
				}else{
					await swap(A,tj++,tp++,1,true);
					await swap(A,bp1,bp2,1,true);
					j+=bL;
				}
				bp1++;bp2++;
			}
			while(ti<tIdx+tl){
				await swap(A,ti++,tp++,1,true);
				bp1++;bp2++;
			}
			while(tj<tIdx+tLen){
				await swap(A,tj++,tp++,1,true);
				await swap(A,bp1++,bp2++,1,true);
			}
			t^=tIdx;tIdx^=t;t^=tIdx;
			await hs.sort(A,tIdx,tIdx+tLen);
			await blockCycleEasy(A,a1,t,tIdx,tLen,bL);
			await bms.multiSwap(A,t,tIdx,tLen);
			bp1-=tLen;bp2-=tLen;
			let f=a1,a2=f,bp3=bp2+tLen;
			let rev=compareIndices(A,bp1,bp2)>0;
			while(1){
				do{
					if(rev)await swap(A,bp1,bp2,1,true);
					bp1++;bp2++;
					a2+=bL;
				}while(bp2<bp3&&compareIndices(A,bp1,bp2)==(rev?1:-1));
				if(bp2==bp3){
					if(!rev)await inPlaceMergeBW(A,a1,b1,b,false);
					await bms.inPlaceMerge(A,a,a1,b);
					return;
				}
				f=await inPlaceMergeBW(A,f,a2,a2+bL,rev);
				rev=!rev;
			}
		}
		async function sort(A,l){
			let a=0,b=l,n=b-a;
			if(n<128){
				if(n<32)await bms.binaryInsertion(A,a,b);
				else await Sorts.prototype.fifthMergeSort(l);
				return;
			}
			let cbr=2*ceilCbrt(n/4|0),bL=2*cbr;
			let kL=calcKeys(bL,n);
			let T=new Array(bL);
			let ks=await findKeys(A,T,a,b,2*kL,cbr);
			if(ks<8){
				for(let j=1;j<n;j*=2)
					for(let i=a+j;i<b;i+=2*j)
						await inPlaceMergeBW(A,i-j,i,minVal(i+j,b),false);
				return;
			}else if(ks<2*kL){
				ks-=ks%4;
				kL=ks/2|0;
			}
			let a1=a+ks,a2=a1+ks,bSep=await findBits(A,T,a1,b,kL,cbr);
			if(bSep==-1){
				await laziestSortExt(A,T,a,a2);
				await bms.inPlaceMerge(A,a,a2,b);
				return;
			}
			let a3=a2+bL,i,j=1;n=b-a3;
			await bms.binaryInsertion(A,a2,a3);
			arraycopy(A,a2,T,0,bL,0,false,true);
			for(;j<cbr;j*=2){
				let p=maxVal(2,j);
				for(i=a3;i+2*j<b;i+=2*j)
					await bms.mergeWithBufFWExt(A,i,i+j,i+2*j,i-p);
				if(i+j<b)await bms.mergeWithBufFWExt(A,i,i+j,b,i-p);
				else await bms.shiftFWExt(A,i-p,i,b);
				a3-=p;b-=p;
			}
			i=b-n%(2*j);
			if(i+j<b)await bms.mergeWithBufBWExt(A,i,i+j,b,b+j);
			else await bms.shiftBWExt(A,i,b,b+j);
			for(i-=2*j;i>=a3;i-=2*j)
				await bms.mergeWithBufBWExt(A,i,i+j,i+2*j,i+3*j);
			a3+=j;b+=j;j*=2;
			for(i=a3;i+2*j<b;i+=2*j)
				await bms.mergeWithBufFWExt(A,i,i+j,i+2*j,i-j);
			if(i+j<b)await bms.mergeWithBufFWExt(A,i,i+j,b,i-j);
			else await bms.shiftFWExt(A,i-j,i,b);
			a3-=j;b-=j;j*=2;
			i=b-n%(2*j);
			if(i+j<b)await dualMergeBWEXT(A,i,i+j,b,b+j/2|0);
			else await bms.shiftBWExt(A,i,b,b+j/2|0);
			for(i-=2*j;i>=a3;i-=2*j)
				await dualMergeBWEXT(A,i,i+j,i+2*j,i+2*j+j/2|0);
			a3+=j/2|0;b+=j/2|0;j*=2;
			if(ks>=j){
				await bms.rotate(A,a,a1,a3);
				a2=a1+bL;
				if(kL>=j){
					for(let mLvl=2*j;j<kL;j*=2){
						let p=maxVal(mLvl,j);
						for(i=a3;i+2*j<b;i+=2*j)
							await bms.mergeWithBufFW(A,i,i+j,i+2*j,i-p);
						if(i+j<b)await bms.mergeWithBufFW(A,i,i+j,b,i-p);
						else await bms.shiftFW(A,i-p,i,b);
						a3-=p;b-=p;
					}
					i=b-n%(2*j);
					if(i+j<b)await bms.mergeWithBufBW(A,i,i+j,b,b+j);
					else await bms.shiftBW(A,i,b,b+j);
					for(i-=2*j;i>=a3;i-=2*j)
						await bms.mergeWithBufBW(A,i,i+j,i+2*j,i+3*j);
					a3+=j;b+=j;j*=2;
				}
				if(ks>=j){
					for(i=a3;i+2*j<b;i+=2*j)
						await bms.mergeWithBufFW(A,i,i+j,i+2*j,i-j);
					if(i+j<b)await bms.mergeWithBufFW(A,i,i+j,b,i-j);
					else await bms.shiftFW(A,i-j,i,b);
					a3-=j;b-=j;j*=2;
					i=b-n%(2*j);
					if(i+j<b)await dualMergeBW(A,i,i+j,b,b+j/2|0);
					else await bms.shiftBW(A,i,b,b+j/2|0);
					for(i-=2*j;i>=a3;i-=2*j)
						await dualMergeBW(A,i,i+j,i+2*j,i+2*j+j/2|0);
					a3+=j/2|0;b+=j/2|0;j*=2;
				}
				await bms.rotate(A,a,a2,a3);
				a2=a1+ks;
				await hs.sort(A,a,a1);
			}
			await arraycopy(T,0,A,a2,bL,1,true);
			await unshuffle(A,a,a1);
			let limit=bL*(kL+2);
			for(let k=j/bL-1;j<n&&minVal(2*j,n)<=limit;j*=2,k=2*k+1){
				for(i=a3;i+2*j<=b;i+=2*j)
					await blockMerge(A,T,i,i+j,i+2*j,k,2*k,a,a+kL,a1,a1+kL,bL);
				if(i+j<b)
					await blockMerge(A,T,i,i+j,b,k,(b-i-1)/bL-1|0,a,a+kL,a1,a1+kL,bL);
			}
			for(;j<n;j*=2){
				bL=(2*j)/kL|0;
				let lA=j%bL,lB=lA;
				for(i=a3;i+2*j<=b;i+=2*j)
					await blockMergeEasy(A,i,i+j,i+2*j,lA,lB,kL/2|0,kL,a,a+kL,a1,a1+kL,bL);
				if(i+j<b)
					await blockMergeEasy(A,i,i+j,b,lA,(b-i-j)%bL,kL/2|0,(kL/2|0)+(b-i-j)/bL|0,a,a+kL,a1,a1+kL,bL);
			}
			await bms.multiSwap(A,a1+bSep,a1+kL+bSep,kL-bSep);
			await laziestSortExt(A,T,a,a3);
			await redistBuffer(A,T,a,a3,b);
		}
		await sort(arr,len);
	}
	async fifthMergeSort(len){
		async function mergeInPlaceForwards(A,b,s,m,e){
			let l=s,r=m;
			while(l<m&&r<e)
				if(compareIndices(A,l,r)<1)await write(A,b++,A[l++],0.5,true);
				else await write(A,b++,A[r++],0.5,true);
			while(l<m)
				await write(A,b++,A[l++],0.5,true);
			while(r<e)
				await write(A,b++,A[r++],0.5,true);
		}
		async function mergeInPlaceBackwards(A,b,bfL,m,e){
			let l=m-1,r=e-1;
			while(b>r&&r>=m)
				if(compareIndices(A,l,r)>0)await write(A,b--,A[l--],0.5,true);
				else await write(A,b--,A[r--],0.5,true);
			if(r==l)
				while(r>=0)
					await write(A,b--,A[r--],0.5,true);
			else if(r<m)
				while(l>=0)
					await write(A,b--,A[l--],0.5,true);
			return[l+1,r+1];
		}
		async function mergeForwardsWithBuffer(A,b,d,l,lE,m,e){
			let r=m;
			while(l<lE&&r<e)
				if(compareValueIndex(A,b[l],r)<1)await write(A,d++,b[l++],0.5,true);
				else await write(A,d++,A[r++],0.5,true);
			while(l<lE)
				await write(A,d++,b[l++],0.5,true);
		}
		async function merge(A,b,co,s,m,e,fr){
			let f,t;
			let w;
			if(fr){
				f=b;t=A;w=s;s-=co;m-=co;e-=co;
			}else{
				f=A;t=b;w=s-co;
			}
			let l=s,r=m;
			while(l<m&&r<e)
				if(compareIndices(f,l,r)<1){
					write(t,w++,f[l++],0.5,fr,!fr);
					if(fr)await sleep();
				}else{
					write(t,w++,f[r++],0.5,fr,!fr);
					if(fr)await sleep();
				}
			while(l<m){
				write(t,w++,f[l++],0.5,true,!fr);
				if(fr)await sleep();
			}
			while(r<e){
				write(t,w++,f[r++],0.5,true,!fr);
				if(fr)await sleep();
			}
		}
		async function pingPong(A,b,s,e){
			let i;
			for(i=s;i+8<e;i+=8)
				await binaryInsertion(A,i,i+8);
			if(e-i>1)
				await binaryInsertion(A,i,e);
			let l=e-s;
			let fr=false;
			for(let g=8;g<l;g*=2){
				let fm=g*2;
				for(i=s;i+fm<e;i+=fm)
					await merge(A,b,s,i,i+g,i+fm,fr);
				if(i+g<e)await merge(A,b,s,i,i+g,e,fr);
				else
					if(fr)
						await arraycopy(b,i-s,A,i,e-i,0.5,true);
					else
						await arraycopy(A,i,b,i-s,e-i,0.5,true);
				fr=!fr;
			}
			if(fr)
				await arraycopy(b,0,A,s,l,0.5,true);
		}
		async function fifthMergeSort(A,l){
			let fL=len/5|0;
			let bfL=len-fL*4;
			let b=new Array(bfL);
			await pingPong(A,b,0,bfL);
			for(let i=0,s=bfL;i<4;i++,s+=fL)
				await pingPong(A,b,s,s+fL);
			arraycopy(A,0,b,0,bfL,0,false,true);
			let tF=2*fL;
			for(let i=0,s=bfL;i<2;i++,s+=tF)
				await mergeInPlaceForwards(A,s-bfL,s,s+fL,s+tF);
			let fm=await mergeInPlaceBackwards(A,l-1,bfL,tF,2*tF);
			if(fm[1]>0)
				await mergeForwardsWithBuffer(A,A,bfL,0,fm[0],tF,l);
			await mergeForwardsWithBuffer(A,b,0,0,bfL,bfL,l);
		}
		await fifthMergeSort(arr,len);
	}
	async flanSort(len){
		const mwms=new MultiWayMergeSorting();
		const G=14;
		const R=4;
		function medianOfThree(A,a,m,b){
			if(compareIndices(A,m,a)>0){
				if(compareIndices(A,m,b)<0)return m;
				if(compareIndices(A,a,b)>0)return a;
				else return b;
			}else{
				if(compareIndices(A,m,b)>0)return m;
				if(compareIndices(A,a,b)<0)return a;
				else return b;
			}
		}
		function ninther(A,a,b){
			let s=(b-a)/9|0;
			return medianOfThree(A,medianOfThree(A,a,a+s,a+2*s),medianOfThree(A,a+3*s,a+4*s,a+5*s),medianOfThree(A,a+6*s,a+7*s,a+8*s));
		}
		function medianOfThreeNinthers(A,a,b){
			let s=(b-a)/3|0;
			return medianOfThree(A,ninther(A,a,a+s),ninther(A,a+s,a+2*s),ninther(A,a+2*s,b));
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await swap(A,--b,--m,1,true);
		}
		function leftBlockSearch(A,a,b,v){
			let s=G+1;
			while(a<b){
				let m=a+(((b-a)/s|0)/2|0)*s;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+s;
			}
			return a;
		}
		function rightBlockSearch(A,a,b,v){
			let s=G+1;
			while(a<b){
				let m=a+(((b-a)/s|0)/2|0)*s;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+s;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v,w){
			let c=w?1:-1;
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])==c)b=m;
				else a=m+1;
			}
			return a;
		}
		async function insertTo(A,t,a,b){
			while(a>b)await write(A,a,A[--a],0.5,true);
			await write(A,b,t,0.5,true);
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,A[i],i,rightBinSearch(A,a,i,A[i],false));
		}
		async function kWayMerge(A,h,t,s,b,p,z){
			if(z<2){
				if(z)while(t[0]<b)await swap(A,p++,t[0]++,1,true);
				return;
			}
			let a=t[0];
			for(let i=0;i<z;i++)
				write(h,i,i,0,false,true);
			for(let i=(z-1)/2|0;i>=0;i--)
				mwms.siftDown(A,h,t,h[i],i,z);
			while(z>0){
				let m=h[0];
				await swap(A,p++,t[m],0,true);
				write(t,m,t[m]+1,0,false,true);
				if(t[m]==minVal(a+(m+1)*s,b))
					mwms.siftDown(A,h,t,h[--z],0,z);
				else
					mwms.siftDown(A,h,t,h[0],0,z);
			}
		}
		async function retrieve(A,i,p,pE,v,w){
			let j=i-1,m;
			for(let k=pE-G-1;k>p+G;){
				m=rightBinSearch(A,k-G,k,v,w)-1;
				k-=G+1;
				while(m>=k)await swap(A,j--,m--,1,true);
			}
			m=rightBinSearch(A,p,p+G,v,w)-1;
			while(m>=p)await swap(A,j--,m--,1,true);
		}
		async function librarySort(A,a,b,p,v,w){
			let l=b-a;
			if(l<32){
				await bininsert(A,a,b);
				return;
			}
			let rng=new Random();
			let s=l;
			while(s>=32)s=(s-1)/R+1|0;
			let i=a+s,j=a+R*s,pE=p+(s+1)*(G+1)+G;
			await bininsert(A,a,i);
			for(let k=0;k<s;k++)
				await swap(A,a+k,p+k*(G+1)+G,1,true);
			while(i<b){
				if(i==j){
					await retrieve(A,i,p,pE,v,w);
					s=i-a;
					pE=p+(s+1)*(G+1)+G;
					j=a+(j-a)*R;
					for(let k=0;k<s;k++)
						await swap(A,a+k,p+k*(G+1)+G,1,true);
				}
				let bL=leftBlockSearch(A,p+G,pE-G-1,A[i]);
				if(compareIndices(A,i,bL)){
					let qE=rightBlockSearch(A,bL+G+1,pE-G-1,A[i]);
					bL+=rng.nextInt((qE-bL)/(G+1)|0)*(G+1);							
				}
				let o=rightBinSearch(A,bL-G,bL,v,w);
				if(o==bL){
					do bL+=G+1;while(bL<pE&&rightBinSearch(A,bL-G,bL,v,w)==bL);
					if(bL==pE){
						await retrieve(A,i,p,pE,v,w);
						s=i-a;
						pE=p+(s+1)*(G+1)+G;
						j=a+(j-a)*R;
						for(let k=0;k<s;k++)
							await swap(A,a+k,p+k*(G+1)+G,1,true);
					}else{
						let rp=rightBinSearch(A,bL-G,bL,v,w);
						let rs=bL-maxVal(rp,bL-G/2|0);
						await shiftBW(A,o-rs,bL-rs,bL);
					}
				}else{
					let t=A[i];
					await write(A,i++,A[o],1,true);
					await insertTo(A,t,o,rightBinSearch(A,bL-G,o,t,false));
				}
			}
			await retrieve(A,b,p,pE,v,w);
		}
		async function sort(A,l){
			let t=new Array(G+2).fill(0);
			let h=new Array(G+2).fill(0);
			let a=0,b=l;
			while(b-a>=32){
				let v=A[medianOfThreeNinthers(A,a,b)];
				let i1=a,i=a-1,j=b,j1=b;
				for(;;){
					while(++i<j){
						let c=compareIndexValue(A,i,v);
						if(!c)await swap(A,i1++,i,1,true);
						else if(c<0)break;
					}
					while(--j>i){
						let c=compareIndexValue(A,j,v);
						if(!c)await swap(A,--j1,j,1,true);
						else if(c>0)break;
					}
					if(i<j)await swap(A,i,j,1,true);
					else{
						if(i1==b)return;
						else if(j<i)j++;
						while(i1>a)await swap(A,--i,--i1,1,true);
						while(j1<b)await swap(A,j++,j1++,1,true);
						break;
					}
				}
				let lo=i-a,hi=b-j,m,kC=0;
				if(lo<=hi){
					m=b-lo;
					lo=maxVal((hi+1)/(G+1)|0,16);
					for(let k=a;k<i;k+=lo){
						await librarySort(A,k,minVal(k+lo,i),j,v,true);
						write(t,kC++,k,0,false,true);
					}
					await kWayMerge(A,h,t,lo,i,m,kC);
					if(j-i<m-j){
						while(i<j)await swap(A,i++,--m,1,true);
						b=m;
					}else{
						while(m>j)await swap(A,i++,--m,1,true);
						b=i;
					}
				}else{
					m=a+hi;
					hi=maxVal((lo+1)/(G+1)|0,16);
					for(let k=j;k<b;k+=hi){
						await librarySort(A,k,minVal(k+hi,b),a,v,false);
						write(t,kC++,k,0,false,true);
					}
					await kWayMerge(A,h,t,hi,b,a,kC);
					if(i-m<j-i){
						while(m<i)await swap(A,m++,--j,1,true);
						a=j;
					}else{
						while(j>i)await swap(A,m++,--j,1,true);
						a=m;
					}
				}
			}
			await bininsert(A,a,b);
		}
		await sort(arr,len);
	}
	async weaveMergeSort(len){
		async function weaveInsert(A,s,e){
			let p;
			for(let j=s;j<e;j++){
				p=j;
				while(p>s&&compareIndices(A,p,p-1)<1)
					await swap(A,p,--p,0.2,true);
			}
		}
		async function weaveMerge(A,n,x,m){
			let i=1;
			let t=m-n;
			for(;i<=t;i++)
				await multiSwap(A,m+i,n+i*2-1,.25,true);
			await weaveInsert(A,n,x+1);
		}
		async function weaveMergeSort(A,n,x){
			if(x-n==0){	
			}else if(x-n==1){
				if(compareIndices(A,n,x)>0)
					await swap(A,n,x,0.01,true);
			}else{
				let m=(n+x)/2|0;
				await weaveMergeSort(A,n,m);	
				await weaveMergeSort(A,m+1,x);
				await weaveMerge(A,n,x,m);	
			}
		}
		await weaveMergeSort(arr,0,len-1);
	}
	async remiSort(len){
		const mwms=new MultiWayMergeSorting();
		function ceilCbrt(n){
			let a=0,b=minVal(1291,n);
			while(a<b){
				let m=(a+b)/2|0;
				if(m*m*m>=n)b=m;
				else a=m+1;
			}
			return a;
		}
		function siftDown(A,k,r,l,a,t){
			let j=r;
			while(2*j+1<l){
				j=2*j+1;
				if(j+1<l){
					let c=compareIndices(A,a+k[j+1],a+k[j],0.2,true);
					if(c>0||(!c&&compareIndices(k,j+1,j)>0))j++;
				}
			}
			for(let c=compareIndices(A,a+t,a+k[j]);c>0||(!c&&compareValues(t,k[j])>0);j=(j-1)/2|0,c=compareIndices(A,a+t,a+k[j]));
			for(let t2;j>r;j=(j-1)/2|0){
				t2=k[j];
				write(k,j,t,0,false,true);
				t=t2;
			}
			write(k,r,t,0,false,true);
		}
		async function tableSort(A,k,a,b){
			let l=b-a;
			for(let i=(l-1)/2|0;i>=0;i--)
				siftDown(A,k,i,l,a,k[i]);
			for(let i=l-1;i>0;i--){
				let t=k[i];
				write(k,i,k[0],1,false,true);
				siftDown(A,k,0,i,a,t);
			}
			for(let i=0;i<l;i++){
				if(compareValues(i,k[i])){
					let t=A[a+i];
					let j=i,n=k[i];
					do{
						await write(A,a+j,A[a+n],1,true);
						write(k,j,j,0,false,true);
						j=n;
						n=k[n];
					}while(compareValues(n,i));
					await write(A,a+j,t,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		async function blockCycle(A,b,k,a,bL,bC){
			for(let i=0;i<bC;i++){
				if(compareValues(i,k[i])){
					arraycopy(A,a+i*bL,b,0,bL,1,true,true);
					let j=i,n=k[i];
					do{
						await arraycopy(A,a+n*bL,A,a+j*bL,bL,1,true);
						write(k,j,j,1,false,true);
						j=n;
						n=k[n];
					}while(compareValues(n,i));
					await arraycopy(b,0,A,a+j*bL,bL,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		async function kWayMerge(A,r,y,h,b,d,p,bL,rL){
			let k=p.length,z=k,a=d[0],a1=d[1];
			for(let i=0;i<k;i++)
				write(h,i,i,0,false,true);
			for(let i=(k-1)/2|0;i>=0;i--)
				mwms.siftDown(A,h,d,h[i],i,k);
			for(let i=0;i<rL;i++){
				let n=h[0];
				await write(r,i,A[d[n]],0,false,true);
				await write(d,n,d[n]+1,1,false,true);
				if(d[n]==minVal(a+(n+1)*rL,b))
					mwms.siftDown(A,h,d,h[--z],0,z);
				else
					mwms.siftDown(A,h,d,h[0],0,z);
			}
			let t=0,cnt=0,c=0;
			while(d[c]-p[c]<bL)c++;
			do{
				let n=h[0];
				write(A,p[c],A[d[n]],0);
				write(d,n,d[n]+1,0,false,true);
				write(p,c,p[c]+1,1,false,true);
				if(d[n]==minVal(a+(n+1)*rL,b))
					mwms.siftDown(A,h,d,h[--z],0,z);
				else
					mwms.siftDown(A,h,d,h[0],0,z);
				if(++cnt==bL){
					await write(y,t++,(c>0)?p[c]/bL-bL-1|0:-1,0,false,true);
					c=cnt=0;
					while(d[c]-p[c]<bL)c++;
				}
			}while(z>0);
			while(cnt-->0){
				write(p,c,p[c]-1,0,false,true);
				await write(A,--b,A[p[c]],1,true);
			}
			write(d,k-1,b,0,false,true);
			write(y,y.length-1,-1,0,false,true);
			t=0;
			while(y[t]!=-1)t++;
			for(let i=1,j=a;j<p[0];i++){
				while(p[i]<d[i]){
					write(y,t++,p[i]/bL-bL|0,0,false,true);
					while(y[t]!=-1)t++;
					await arraycopy(A,j,A,p[i],bL,1,true);
					write(p,i,p[i]+bL,0,false,true);
					j+=bL;
				}
			}
			await arraycopy(r,0,A,a,rL,1,true);
			await blockCycle(A,r,y,a1,bL,(b-a1)/bL|0);
		}
		async function sort(A,l){
			let a=0,b=l;
			let bL=ceilCbrt(l);
			let rL=bL*bL;
			let rC=(l-1)/rL+1|0;
			if(rC<2){
				let k=new Array(l);
				for(let i=0;i<k.length;i++)
					write(k,i,i,1,false,true);
				await tableSort(A,k,a,b);
				return;
			}
			let k=new Array(rL);
			let r=new Array(rL);
			let h=new Array(rC).fill(0);
			let p=new Array(rC).fill(0);
			let pa=new Array(rC).fill(0);
			for(let i=0;i<k.length;i++)
				write(k,i,i,1,false,true);
			for(let i=a,j=0;i<b;i+=rL,j++){
				await tableSort(A,k,i,minVal(i+rL,b));
				write(pa,j,i,0,false,true);
			}
			arraycopy(pa,0,p,0,rC,0,false,true);
			await kWayMerge(A,r,k,h,b,pa,p,bL,rL);
		}
		await sort(arr,len);
	}
	async fireSort(len){
		let i=1,t1=0,t2=0,t3=-1,t4=1,t5=false,t6=false,t7=false;
		let j=0;
		while(!t5){
			if(t2<1){
				t1+=len;t2=t1;t3*=-1;
			}else t2--;
			t7=false;
			while(i+1<=len&&i>=1&&!t7){
				if(compareIndices(arr,i-1,i)*t3>0){
					swap(arr,i-1,i,0);
					if(++j>len*2){
						mark(i-1);
						await sleep(j=0);
					}
					i-=t3;t7=true;
				}else i+=t3;
			}
			if(i<1){
				i=len-1;t4=1;t5=true;
				while(t4-len&&t5){
					if(compareIndices(arr,t4-1,t4)<1)t4++;
					else{
						t4=1;t5=false;t6=true;
						while(t4-len&&t6){
							if(compareIndices(arr,t4,t4-1)<1)t4++;
							else t6=false;
						}
					}
				}
				if(t6){
					i=1;t2=0;
				}
			}
			if(i+1>len){
				i=1;t4=1;t5=true;
				while(t4!=len&&t5){
					if(compareIndices(arr,t4-1,t4)<1)t4++;
					else{
						t4=1;t5=false;t6=true;
						while(t4!=len&&t6){
							if(compareIndices(arr,t4,t4-1)<1)t4++;
							else t6=false;
						}
					}
				}
				if(t6){
					i=len-1;t2=0;
				}
			}
		}
	}
	async mergeInsertionSort(len){
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a--,b--,0,true);
		}
		async function blockInsert(A,a,b,s){
			while(a-s>=b){
				await blockSwap(A,a-s,a,s);
				a-=s;
			}
		}
		async function blockReversal(A,a,b,s){
			b-=s;
			while(b>a){
				await blockSwap(A,a,b,s);
				a+=s;
				b-=s;
			}
		}
		function blockSearch(A,a,b,s,v){
			while(a<b){
				let m=a+(((b-a)/s|0)/2|0)*s;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+s;
			}
			return a;
		}
		async function order(A,a,b,s){
			for(let i=a,j=i+s;j<b;i+=s,j+=2*s)
				await blockInsert(A,j,i,s);
			let m=a+(((b-a)/s|0)/2|0)*s;
			await blockReversal(A,m,b,s,1);
		}
		async function sort(A,l){
			let k=1;
			while(2*k<=l){
				for(let i=2*k-1;i<l;i+=2*k)
					if(compareIndices(A,i-k,i)>0)
						await blockSwap(A,i-k,i,k,1);
				k*=2;
			}
			while(k>0){
				let a=k-1,i=a+2*k,g=2,p=4;
				while(i+2*k*g-k<=l){
					await order(A,i,i+2*k*g-k,k);
					let b=a+k*(p-1);
					i+=k*g-k;
					for(let j=i;j<i+k*g;j+=k)
						await blockInsert(A,j,blockSearch(A,a,b,k,A[j]),k);
					i+=k*g+k;
					g=p-g;
					p*=2;
				}
				while(i<l){
					await blockInsert(A,i,blockSearch(A,a,i,k,A[i]),k);
					i+=2*k;
				}
				k=k/2|0;
			}
		}
		await sort(arr,len);
	}
	async yujisBufferedMergeSort2(len){
		function ceilLog(n){
			let i;
			for(i=0;(1<<i)<n;i++);
			return i;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],0.5,true);
			await write(A,b,t,0.5,true);
		}
		function binarySearch(A,s,e,v,l){
			let a=s,b=e;
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,binarySearch(A,a,i,A[i],false));
		}
		async function mergeWithBufStatic(A,a,m,b,p,u){
			let i=0,j=m,k=a;
			if(u){
				while(i<m-a&&j<b){
					if(compareIndices(A,j,p+i)<0){
						let q=binarySearch(A,j,b,A[p+i],true);
						while(j<q)await swap(A,k++,j++,1,true);
					}
					await swap(A,k++,p+(i++),1,true);
				}
				while(i<m-a){
					await swap(A,k++,p+(i++),1,true);
				}
			}else{
				while(i<m-a&&j<b){
					if(compareIndices(A,p+i,j)<1)
						await swap(A,k++,p+(i++),1,true);
					else
						await swap(A,k++,j++,1,true);
				}
				while(i<m-a)
					await swap(A,k++,p+(i++),1,true);
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			}
			let lO=0;
			while(i<m)
				await swap(A,p++,i++,1,true);
			while(j<b){
				await swap(A,p++,j++,1,true);
				lO++;
			}
			return lO;
		}
		async function mergeSort(A,a,p,l){
			let i,j=16,cL=ceilLog(l);
			let ps=l>16&&(cL&1)==1?p:a
			for(i=ps;i+16<=ps+l;i+=16)
				await bininsert(A,i,i+16);
			await binaryInsertion(A,i,ps+l);
			let nx=ps,pn;
			while(j<l){
				ps=nx;
				nx^=a^p;
				pn=nx;
				for(i=ps;i+2*j<=ps+l;i+=2*j,pn+=2*j)
					await merge(A,i,i+j,i+2*j,pn);
				if(i+j<ps+l)
					await merge(A,i,i+j,ps+l,pn);
				else
					while(i<ps+l)await swap(A,i++,pn++,1,true);
				j*=2;
			}
		}
		async function bufferedMerge(A,a,b){
			if(b-a<=16){
				await bininsert(A,a,b);
				return;
			}
			let m=(a+b+1)/2|0;
			await mergeSort(A,m,2*m-b,b-m);
			let n=(a+m+1)/2|0;
			let lm=(b-a)/16|0;
			while(m-a>lm){
				await mergeSort(A,2*n-m,n,m-n);
				await mergeWithBufStatic(A,n,m,b,2*n-m,((b-m)/(m-n)|0)>=ceilLog(n-a));
				m=n;
				n=(a+m+1)/2|0;
			}
			await bufferedMerge(A,a,m);
			await multiSwap(A,a,b-m+a,m-a);
			let s=await merge(A,m,b-m+a,b,a);
			await bufferedMerge(A,b-m+a-s,b);
		}
		await bufferedMerge(arr,0,len);
	}
	async sqrtSort(len){
		async function msw(ar,a,b,l,x){
			while(l--!=0)await swap(ar,a++,b++,1,true,x);
		}
		async function sqmr(ar,p,lL,rL,d,x){
			let mP=lL+rL+d-1,r=lL+rL-1,l=lL-1;
			while(l>=0)
				if(r<lL||compareIndices(ar,p+l,p+r)>0)await write(ar,p+mP--,ar[p+l--],1,true,x);
				else await write(ar,p+mP--,ar[p+r--],1,true,x);
			if(r!=mP)while(r>=lL)await write(ar,p+mP--,ar[p+r--],1,true,x);
		}
		async function sqmlwb(ar,p,lE,rE,d,x){
			let l=0,r=lE;rE+=lE;
			while(r<rE)
				if(l==lE||compareIndices(ar,p+l,p+r)>0)await write(ar,p+d++,ar[p+r++],1,true,x);
				else await write(ar,p+d++,ar[p+l++],1,true,x)
			if(d!=l)while(l<lE)await write(ar,p+d++,ar[p+l++],1,true,x);
		}
		async function sqmd(ar,aP,buf,bP,lL,rL,x){
			let aM=0,bM=0,d=-rL;
			while(bM<rL)
				if(aM==lL||compareValues(ar[aP+aM],buf[bP+bM])>=0)await write(ar,aP+d++,buf[bP+bM++],1,true,x);
				else await write(ar,aP+d++,ar[aP+aM++],1,true,x);
			if(d!=aM)while(aM<lL)await write(ar,aP+d++,ar[aP+aM++],1,true,x);
		}
		async function sqsmwb(ar,p,lol,lof,bL,x){
			let d=-bL,l=0,r=lol,lE=r,rE=r+bL,tF=1-lof;
			while(l<lE&&r<rE)
				if(compareIndices(ar,p+l,p+r)-tF<0)await write(ar,p+d++,ar[p+l++],1,true,x);
				else await write(ar,p+d++,ar[p+r++],1,true,x);
			let ln,fr=lof;
			if(l<lE){
				ln=lE-l;
				while(l<lE)await write(ar,p+--rE,ar[p+--lE],1,true,x);
			}else{ln=rE-r;fr=tF;}
			return[ln,fr];
		}
		async function smbflwb(keys,mK,ar,p,bC,rBL,aBC,lL,x){
			if(bC==0)return sqmlwb(ar,p,aBC*rBL,lL,-rBL,x);
			let lol=rBL,lof=compareValues(keys[0],mK)<0?0:1,pI=rBL,rTP;
			for(let kI=1;kI<bC;kI++,pI+=rBL){
				rTP=pI-lol;
				let nF=compareValues(keys[kI],mK)<0?0:1;
				if(nF==lof){
					await arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,1,true,x);
					rTP=pI;lol=rBL;
				}else[lol,lof]=await sqsmwb(ar,p+rTP,lol,lof,rBL,x);
			}
			rTP=pI-lol;
			if(lL!=0){
				if(lof!=0){
					await arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,1,true,x);
					rTP=pI;lol=rBL*aBC;lof=0;
				}else lol+=rBL*aBC;
				await sqmlwb(ar,p+rTP,lol,lL,-rBL,x);
			}else await arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,1,true,x);
		}
		async function sBBls(ar,p,ln,bL,x){
			let eD,pt;
			for(let d=1;d<ln;d+=2){
				eD=compareIndices(ar,p+(d-1),p+d)>0?1:0;
				await write(ar,p+d-3,ar[p+d-1+eD],1,true,x);
				await write(ar,p+d-2,ar[p+d-eD],1,true,x);
			}
			if(ln%2!=0)await write(ar,p+ln-3,ar[p+ln-1],1,true,x);
			p-=2;
			for(pt=2;pt<bL;pt*=2){
				let lf=0,rh=ln-2*pt;
				while(lf<=rh){
					await sqmlwb(ar,p+lf,pt,pt,-pt,x);
					lf+=2*pt;
				}
				let rs=ln-lf;
				if(rs>pt)await sqmlwb(ar,p+lf,pt,rs-pt,-pt,x);
				else while(lf<ln)await write(ar,p+lf-pt,ar[p+lf++],1,true,x);
				p-=pt;
			}
			let rTB=ln%(2*bL),loP=ln-rTB;
			if(rTB<=bL)await arraycopy(ar,p+loP,ar,p+loP+bL,rTB,1,true,x);
			else await sqmr(ar,p+loP,bL,rTB-bL,bL,x);
			while(loP>0){
				loP-=2*bL;
				await sqmr(ar,p+loP,bL,bL,bL,x);
			}
		}
		async function sqCmBl(ar,p,ln,bL,rBL,tags,x){
			let cmL=ln/(2*bL)|0,lO=ln%(2*bL),lI=0;
			if(lO<=bL){ln-=lO;lO=0}
			for(let i=0;i<=cmL;i++){
				if(i==cmL&&lO==0)break;
				let bP=p+i*2*bL,bC=(i==cmL?lO:2*bL)/rBL|0,tI=bC+(i==cmL?1:0),mK=bL/rBL|0;
				for(let j=0;j<=tI;j++)write(tags,j,j,true);
				for(tI=1;tI<bC;tI++){
					lI=tI-1;
					for(let rI=tI;rI<bC;rI++){
						let rC=compareIndices(ar,bP+lI*rBL,bP+rI*rBL);
						if(rC>0||(rC==0&&tags[lI]>tags[rI]))lI=rI;
					}
					if(lI!=tI-1){
						await msw(ar,bP+(tI-1)*rBL,bP+lI*rBL,rBL,x);
						swap(tags,tI-1,lI,0,false,true);
					}
				}
				let aBC=0,lL=0;
				if(i==cmL)lL=lO%rBL;
				if(lL!=0)while(aBC<bC&&compareIndices(ar,bP+bC*rBL,bP+(bC-aBC-1)*rBL)<0)aBC++;
				await smbflwb(tags,mK,ar,bP,bC-aBC,rBL,aBC,lL,x);
			}
			for(lI=ln-1;lI>=0;lI--)await write(ar,p+lI,ar[p+lI-rBL],1,true,x);
		}
		async function sqSort(ar,p,ln,eB,eBP,tags,x){
			if(ln<=16)return await insertSort(ar,p,ln,1,x);
			let bL=1;
			while(bL*bL<ln)bL*=2;
			await arraycopy(ar,p,eB,eBP,bL,1,true,x);
			await sqSort(eB,eBP,bL,ar,p,tags,!x);
			await sBBls(ar,p+bL,ln-bL,bL,x);
			let bL2=bL;
			while(ln>(bL2*=2))await sqCmBl(ar,p+bL,ln-bL,bL2,bL,tags,x);
			await sqmd(ar,p+bL,eB,eBP,ln-bL,bL,x);
		}
		let bL=1;
		while(bL*bL<len)bL*=2;
		let nK=(len-1)/bL+2|0,eB=new Array(bL),t=new Array(nK);
		await sqSort(arr,0,len,eB,0,t,false);
	}
	async introSort(len){
		const hs=new HeapSorting(true);
		function floorLog(a){
			return floor(log(a)/log(2));
		}
		async function m3(A,a,m,b){
			if(compareIndices(A,b,a)<0)await swap(A,a,b,1,true);
			if(compareIndices(A,m,a)<0)await swap(A,m,a,1,true);
			if(compareIndices(A,b,m)<0)await swap(A,b,m,1,true);
			return A[m];
		}
		async function partition(a,lo,hi,x){
			let i=lo,j=hi;
			while(1){
				while(compareValues(a[i],x)<0)i++;
				do j--;while(compareValues(x,a[j])<0);
				if(i>=j)return i;
				await swap(a,i++,j,1,true);
			}
		}
		async function introsortLoop(a,lo,hi,d){
			while(hi-lo>16){
				if(!d)return hs.sort(a,lo,hi);
				let p=await partition(a,lo,hi,await m3(a,lo,lo+(hi-lo)/2|0,hi-1));
				await introsortLoop(a,p,hi,--d);
				hi=p;
			}
		}
		await introsortLoop(arr,0,len,2*floorLog(len));
		await insertSort(arr,0,len);
	}
	async lazierestSort(len){
		function ceilCbrt(n){
			let a=0,b=minVal(1291,n);
			while(a<b){
				let m=(a+b)/2|0;
				if(m*m*m>=n)b=m;
				else a=m+1;
			}
			return a;
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],0.5,true);
			await write(A,b,t,0.5,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertion(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMergeFW(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await IndexedRotations.cycleReverse(A,i,j,k,.75,true);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=rightExpSearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=i+1-k;i=k-1;
				}else j--;
			}
		}
		async function inPlaceMerge(A,a,m,b){
			if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function fragmentedMerge(A,a,m,b,s){
			let i=a+(m-a)%s;
			while(i<m){
				let j=leftExpSearch(A,m,b,A[i]);
				await IndexedRotations.cycleReverse(A,i,m,j,.75,true);
				let rL=j-m;
				j=i;i+=rL;m+=rL;
				await inPlaceMerge(A,a,j,a=i);
				i+=s;
			}
			await inPlaceMerge(A,maxVal(a,i-s),i,b);
		}
		async function lazierestStableSort(A,a,b){
			let l=b-a,s=ceilCbrt(l),s1=s*s;
			for(let i=l%s;i<=b;i+=s)
				await insertion(A,maxVal(a,i-s),i);
			for(let i=b-s,j=b;i>a;i-=s){
				if(j-i==s1){
					j-=s1;i-=s;
				}
				await inPlaceMergeFW(A,maxVal(a,i-s),i,j);
			}
			for(let i=b-s1;i>a;i-=s1)
				await fragmentedMerge(A,maxVal(a,i-s1),i,b,s);
		}
		if(len<17)await insertion(arr,0,len);
		else await lazierestStableSort(arr,0,len);
	}
	async laziestSort(len){
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],0.5,true);
			await write(A,b,t,0.5,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function sort(A,s,e){
			let l=e-s;
			if(l<17)return await bininsert(A,s,e);
			let i,bL=maxVal(16,sqrt(len)|0);
			for(i=s;i+2*bL<e;i+=bL)
				await bininsert(A,i,i+bL);
			await bininsert(A,i,e);
			for(;i-bL>=s;i-=bL)
				await inPlaceMerge(A,i-bL,i,e);
		}
		await sort(arr,0,len);
	}
	async introCircleSortIterative(len){
		let th=0,n=1,i=0;
		for(;n<len;n*=2,th++);th=th/2|0;
		do{
			if(++i>=th){
				await binaryInsertion(arr,0,len);
				break;
			}
		}while(await iterativeCircleSortRoutine(arr,n,1));
	}
	async introCircleSortRecursive(len){
		let th=0,n=1,i=0;
		for(;n<len;n*=2,th++);th=th/2|0;
		do{
			if(++i>=th){
				await binaryInsertion(arr,0,len);
				break;
			}
		}while(await recursiveCircleSortRoutine(arr,0,n-1,0));
	}
	async medianMergeSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j;
			let ad=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s);
					await swap(A,j++,i+s/2,1,false);
				}
				if(i<e){
					await insertSort(A,i,e);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,1);
					if((e-i)%2==0)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		function getMinLevel(n){
			while(n>=32)n=(n+3)/4|0;
			return n;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,ps,j=getMinLevel(l);
			for(i=a;i+j<=b;i+=j)
				await binaryInsertion(A,i,i+j);
			await binaryInsertion(A,i,b);
			while(j<l){
				ps=p;
				for(i=a;i+2*j<=b;i+=2*j,ps+=2*j)await merge(A,i,i+j,i+2*j,ps);
				if(i+j<b)await merge(A,i,i+j,b,ps);
				else while(i<b)await swap(A,i++,ps++,1,true);
				j*=2;ps=a;
				for(i=p;i+2*j<=p+l;i+=2*j,ps+=2*j)await merge(A,i,i+j,i+2*j,ps);
				if(i+j<p+l)await merge(A,i,i+j,p+l,ps);
				else while(i<p+l)await swap(A,i++,ps++,1,true);
				j*=2;
			}
		}
		async function medianMergeSort(A,a,b){
			let s=a,e=b;
			let bP=false,med=false;
			while(e-s>16){
				if(bP){
					await medianOfMedians(A,s,e,5);
					med=true;
				}else await medianOfThree(A,s,e);
				let p=await partition(A,s+1,e,s);
				await swap(A,s,p,1,true);
				let l=p-s;
				let r=e-p-1;
				bP=!med&&((!l||!r)||((l/r|0)>=16||(r/l|0)>=16));
				if(l<=r){
					await mergeSort(A,s,p,p+1);
					s=p+1;
				}else{
					await mergeSort(A,p+1,e,2*p+1-e);
					e=p;
				}
			}
			await binaryInsertion(A,s,e);
		}
		await medianMergeSort(arr,0,len);
	}
	async grailSort(len){
		async function grailSwap(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)
				await grailSwap(A,a++,b++);
		}
		async function grailRotate(A,p,lA,lB){
			while(lA&&lB)if(lA<=lB){
				await grailMultiSwap(A,p,p+lA,lA);
				p+=lA;lB-=lA;
			}else{
				await grailMultiSwap(A,p+lA-lB,p+lA,lB);
				lA-=lB;
			}
		}
		function grailBinSearch(A,p,ln,kP,iL){
			let l,r;
			for(l=-1,r=ln;l<r-1;){
				let m=l+(r-l>>1);
				if(compareIndices(A,kP,p+m)<(iL?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailFindKeys(A,p,l,nK){
			let fK=1,frK=0;
			for(let d=1;d<l&&fK<nK;d++){
				let o=grailBinSearch(A,p+frK,fK,p+d,true);
				if(o==fK||compareIndices(A,p+d,p+frK+o)){
					await grailRotate(A,p+frK,fK,d-frK-fK);
					frK=d-fK;
					await grailRotate(A,p+frK+o,fK++-o,1);
				}
			}
			await grailRotate(A,p,frK,fK);
			return fK;
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2)while(l1){
				let o=grailBinSearch(A,p+l1,l2,p,true);
				if(o){
					await grailRotate(A,p,l1,o);
					p+=o;l2-=o;
				}
				if(!l2)break;
				do{p++;l1--;}while(l1&&compareIndices(A,p,p+l1)<1);
			}else while(l2){
				let o=grailBinSearch(A,p,l1,p+l1+l2-1,false);
				if(o-l1){
					await grailRotate(A,p+o,l1-o,l2);
					l1=o;
				}
				if(!l1)break;
				do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
			}
		}
		async function grailMergeBuffersLeft(A,kP,mk,p,blC,blL,hb,alC,lL){
			if(!blC)return await grailMergeLeft(A,p,alC*blL,lL,0-blL);
			let lOL=blL,lOF=compareIndices(A,kP,mk)<0?0:1;
			let pI=blL,rTP;
			for(let kI=1;kI<blC;kI++,pI+=blL){
				rTP=pI-lOL;
				let nF=compareIndices(A,kP+kI,mk)<0?0:1;
				if(nF==lOF){
					if(hb)await grailMultiSwap(A,p+rTP-blL,p+rTP,lOL);
					rTP=pI;lOL=blL;
				}else[lOL,lOF]=await grailSmartMergeWithBuffer(A,p+rTP,lOL,lOF,blL);
			}
			rTP=pI-lOL;
			if(lL){
				if(lOF){
					await grailMultiSwap(A,p+rTP-blL,p+rTP,lOL);
					rTP=pI;lOL=blL*alC;lOF=0;
				}else lOL+=blL*alC;
				await grailMergeLeft(A,p+rTP,lOL,lL,-blL);
			}else await grailMultiSwap(A,p+rTP,p+rTP-blL,lOL);
		}
		async function grailMergeLeft(A,p,lL,rL,d){
			let l=0,r=lL;rL+=lL;
			while(r<rL)
				if(l==lL||compareIndices(A,p+l,p+r)>0)await grailSwap(A,p+d++,p+r++);
				else await grailSwap(A,p+d++,p+l++);
			if(d-l)await grailMultiSwap(A,p+d,p+l,lL-l);
		}
		async function grailMergeRight(A,p,lL,rL,d){
			let mP=lL+rL+d-1,r=lL+rL-1,l=lL-1;
			while(l>=0)
				if(r<lL||compareIndices(A,p+l,p+r)>0)await grailSwap(A,p+mP--,p+l--);
				else await grailSwap(A,p+mP--,p+r--);
			if(r-mP)while(r>=lL)await grailSwap(A,p+mP--,p+r--);
		}
		async function grailSmartMergeWithBuffer(A,p,lOL,lOF,blL){
			let d=0-blL,l=0,r=lOL,lE=r,rE=r+blL,tF=1-lOF;
			while(l<lE&&r<rE)
				if(compareIndices(A,p+l,p+r)-tF<0)await grailSwap(A,p+d++,p+l++);
				else await grailSwap(A,p+d++,p+r++);
			let ln,fr=lOF;
			if(l<lE){
				ln=lE-l;
				while(l<lE)await grailSwap(A,p+--lE,p+--rE);
			}else{
				ln=rE-r;
				fr=tF;
			}
			return[ln,fr];
		}
		async function grailBuildblocks(A,p,ln,buL,eB,bfP,eBL){
			let eD,pt,bB=buL<eBL?buL:eBL;
			while((bB&(bB-1)))bB&=bB-1;
			for(let d=1;d<ln;d+=2){
				eD=0;
				if(compareIndices(A,p+d-1,p+d)>0)eD=1;
				await grailSwap(A,p+d-3,p+d-1+eD);
				await grailSwap(A,p+d-2,p+d-eD);
			}
			if(ln%2)await grailSwap(A,p+ln-1,p+ln-3);
			p-=2;pt=2;
			for(;pt<buL;pt*=2){
				let l=0,r=ln-2*pt;
				while(l<=r){
					await grailMergeLeft(A,p+l,pt,pt,-pt);
					l+=2*pt;
				}
				let rs=ln-l;
				if(rs>pt)await grailMergeLeft(A,p+l,pt,rs-pt,-pt);
				else await grailRotate(A,p+l-pt,pt,rs);
				p-=pt;
			}
			let rTB=ln%(2*buL),lOP=ln-rTB;
			if(rTB<=buL)await grailRotate(A,p+lOP,rTB,buL);
			else await grailMergeRight(A,p+lOP,buL,rTB-buL,buL);
			while(lOP>0){
				lOP-=2*buL;
				await grailMergeRight(A,p+lOP,buL,buL,buL);
			}
		}
		async function grailCombineblocks(A,kP,p,ln,buL,rBL,hb,br,bfP){
			let cL=ln/(2*buL)|0,lO=ln%(2*buL);
			if(lO<=buL){
				ln-=lO;
				lO=0;
			}
			for(let i=0;i<=cL;i++){
				if(i==cL&&!lO)break;
				let blP=p+i*2*buL,blC=(i==cL?lO:2*buL)/rBL|0;
				await insertSort(A,kP,blC+(i==cL?1:0));
				let mk=buL/rBL|0;
				for(let i=1;i<blC;i++){
					let lI=i-1;
					for(let rI=i;rI<blC;rI++){
						let rC=compareIndices(A,blP+lI*rBL,blP+rI*rBL);
						if(rC>0||(!rC&&compareIndices(A,kP+lI,kP+rI)>0))lI=rI;
					}
					if(lI-i+1){
						await grailMultiSwap(A,blP+(i-1)*rBL,blP+lI*rBL,rBL);
						await grailSwap(A,kP+i-1,kP+lI);
						if(mk==i-1||mk==lI)mk^=(i-1)^lI;
					}
				}
				let alC=0,lL=0;
				if(i==cL)lL=lO%rBL;
				if(lL)while(alC<blC&&compareIndices(A,blP+blC*rBL,blP+(blC-alC-1)*rBL)<0)alC++;
				await grailMergeBuffersLeft(A,kP,kP+mk,blP,blC-alC,rBL,hb,alC,lL);
			}
			while(--ln>=0)await grailSwap(A,p+ln,p+ln-rBL);
		}
		async function grailCommonSort(A,p,ln,br,bfP,bL){
			if(ln<17)return await insertSort(A,p,ln);
			let blL=1;
			while(blL*blL<ln)blL*=2;
			let nK=(ln-1)/blL+1|0,kF=await grailFindKeys(A,p,ln,nK+blL),bE=true;
			if(kF<nK+blL){
				nK=blL;
				while(nK>kF)nK=nK/2|0;
				bE=false;
				blL=0;
			}
			let d=blL+nK,buL=bE?blL:nK;
			await grailBuildblocks(A,p+d,ln-d,buL,br,bfP,bL);
			while(ln-d>(buL*=2)){
				let rBL=blL,bBE=bE;
				await grailCombineblocks(A,p,p+d,ln-d,buL,rBL,bBE,bBE&&rBL<=bL?br:null,bfP);
			}
			await insertSort(A,p,d);
			await grailMergeWithoutBuffer(A,p,d,ln-d);
		}
		await grailCommonSort(arr,0,len,null,0,0);
	}
	async optimizedLazyStableSort(len){
		async function insertionSort(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let c=A[i];
				let p=i-1;
				while(p>=a&&compareValues(A[p],c)>0)
					await write(A,p+1,A[p--],1,true);
				await write(A,p+1,c,1,true);
				i++;
			}
		}
		async function grailSwap(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)
				await grailSwap(A,a++,b++);
		}
		function grailBinSearch(A,p,ln,kP,L){
			let l=-1,r=ln;
			while(l<r-1){
				let m=l+((r-l)>>1);
				if(compareIndices(A,kP,p+m)<(L?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailRotate(A,p,lA,lB){
			while(lA&&lB){
				if(lA<=lB){
					await grailMultiSwap(A,p,p+lA,lA);
					p+=lA;
					lB-=lA;
				}else{
					await grailMultiSwap(A,p+lA-lB,p+lA,lB);
					lA-=lB;
				}
			}
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2){
				while(l1){
					let o=grailBinSearch(A,p+l1,l2,p,true);
					if(o!=0){
						await grailRotate(A,p,l1,o);
						p+=o;
						l2-=o;
					}
					if(!l2)break;
					do{
						p++;
						l1--;
					}while(l1&&compareIndices(A,p,p+l1)<1);
				}
			}else{
				while(l2){
					let o=grailBinSearch(A,p,l1,p+(l1+l2-1),false);
					if(o!=l1){
						await grailRotate(A,p+o,l1-o,l2);
						l1=o;
					}
					if(!l1)break;
					do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
				}
			}
		}
		async function grailLazyStableSort(A,p,ln){
			let d;
			for(d=0;d+16<ln;d+=16)
				await insertionSort(A,p+d,p+d+16);
			if(d<ln)
				await insertionSort(A,p+d,p+ln,1);
			for(let pt=16;pt<ln;pt*=2){
				let l=0;
				let r=ln-2*pt;
				while(l<=r){
					await grailMergeWithoutBuffer(A,p+l,pt,pt);
					l+=2*pt;
				}
				let rs=ln-l;
				if(rs>pt)await grailMergeWithoutBuffer(A,p+l,pt,rs-pt);
			}
		}
		await grailLazyStableSort(arr,0,len);
	}
	async optimizedWeaveMergeSort(len){
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.25,true);
			await write(A,b,t,.25,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
			}
		}
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		async function weaveInsert(A,a,b,r){
			let i=a,j=i+1;
			while(j<b){
				while(i<j&&compareIndices(A,i,j)<(r?1:0))i++;
				if(i-j){
					await insertTo(A,j,i++);
					j+=2;
				}else{
					r=!r;
					j++;
				}
			}
		}
		async function weaveMerge(A,a,m,b){
			if(b-a<2)return;
			let a1=a,b1=b,r=true;
			if((b-a)%2){
				if(m-a<b-m){
					a1--;
					r=false;
				}else b1++;
			}
			for(let e=b1,f;e-a1>2;e=f){
				m=(a1+e)/2|0;
				let p=1<<(log(m-a1)/log(2)|0);
				await rotate(A,m-p,m,e-p);
				m=e-p;
				f=m-p;
				await bitReversal(A,f,m);
				await bitReversal(A,m,e);
				await bitReversal(A,f,e);
			}
			await weaveInsert(A,a,b,r);
		}
		let n=len,d=1<<(log(n-1)/log(2)+1|0);
		while(d>1){
			let i=0,c=0;
			while(i<n){
				let j=i;
				c+=n;
				while(c>=d){
					c-=d;j++;
				}
				let k=j;
				c+=n;
				while(c>=d){
					c-=d;k++;
				}
				await weaveMerge(arr,i,j,k);
				i=k;
			}
			d=d/2|0;
		}
	}
	async optimizedRotateMergeSort(len){
		/**/
		async function rotateInPlace(A,p,lA,lB){
			if(lA<1||lB<1)return;
			let a=p,b=p+lA-1,c=p+lA,d=p+lA+lB-1;
			let t;
			while(a<b&&c<d){
				t=A[b];
				await write(A,b--,A[a],.5,true);
				await write(A,a++,A[c],.5,true);
				await write(A,c++,A[d],.5,true);
				await write(A,d--,t,.5,true);
			}
			while(a<b){
				t=A[b];
				await write(A,b--,A[a],.5,true);
				await write(A,a++,A[d],.5,true);
				await write(A,d--,t,.5,true);
			}
			while(c<d){
				t=A[c];
				await write(A,c++,A[d],.5,true);
				await write(A,d--,A[a],.5,true);
				await write(A,a++,t,.5,true);
			}
			if(a<d)await reversal(A,a,d,1,true);
		}
		async function rotate(A,p,l,r){
			if(l<1||r<1)return;
			let pa=p,pb=p+l,pc=p+r,pd=pb+r;
			if(l<r){
				let br=r-l;
				if(br<l){
					let o=l;
					if(br>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					arraycopy(A,pb,tmp,0,br,0,false,true);
					while(o-->0){
						await write(A,--pc,A[--pd],0.5,true);
						await write(A,pd,A[--pb],0.5,true);
					}
					await arraycopy(tmp,0,A,pa,br,1,true);
				}else{
					if(l>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					arraycopy(A,pa,tmp,0,l,0,false,true);
					await arraycopy(A,pb,A,pa,r,1,true);
					await arraycopy(tmp,0,A,pc,l,1,true);
				}
			}else if(r<l){
				let br=l-r;
				if(br<r){
					if(br>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					let o=r;
					arraycopy(A,pc,tmp,0,br,0,false,true);
					while(o-->0){
						await write(A,pc++,A[pa],0.5,true);
						await write(A,pa++,A[pb++],0.5,true);
					}
					await arraycopy(tmp,0,A,pd-br,br,1,true);
				}else{
					if(r>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					arraycopy(A,pb,tmp,0,r,0,false,true);
					while(l-->0)
						await write(A,--pd,A[--pb],1,true);
					await arraycopy(tmp,0,A,pa,r,1,true);
				}
			}else{
				while(l-->0)
					await swap(A,pa++,pb++,1,true);
			}
		}
		async function mergeUp(A,s,m,e){
			for(let i=0;i<m-s;i++)
				write(tmp,i,A[i+s],0,false,true);
			let bP=0;
			let l=s;
			let r=m;
			while(l<r&&r<e){
				if(compareValues(tmp[bP],A[r])<1)
					await write(A,l++,tmp[bP++],1,true);
				else
					await write(A,l++,A[r++],1,true);
			}
			while(l<r)
				await write(A,l++,tmp[bP++],0.5,true);
		}
		async function mergeDown(A,s,m,e){
			for(let i=0;i<e-m;i++)
				write(tmp,i,A[i+m],0,false,true);
			let bP=e-m-1;
			let l=m-1;
			let r=e-1;
			while(r>l&&l>=s){
				if(compareValues(tmp[bP],A[l])>=0)
					await write(A,r--,tmp[bP--],1,true);
				else
					await write(A,r--,A[l--],1,true);
			}
			while(r>l)
				await write(A,r--,tmp[bP--],0.5,true);
		}
		function monoboundLeft(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		function monoboundRight(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)<1)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)<1)return s+1;
			return s;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValueIndex(A,v,a-1+i)>=0)i*=2;
			return monoboundRight(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValueIndex(A,v,b-i)<1)i*=2;
			return monoboundLeft(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function merge(A,s,m,e){
			if(s>=m)return;
			e=rightExpSearch(A,m,e,A[m-1]);
			if(e<m)return;
			s=leftExpSearch(A,s,m,A[m]);
			if(compareIndices(A,s,e-1)>0){
				await rotate(A,s,m-s,e-m);
				return;
			}
			let lL=m-s,rL=e-m;
			if(((lL<rL)?lL:rL)>tmp.length){
				let m1,m2,m3;
				if(m-s>=e-m){
					m1=s+(m-s)/2|0;
					m2=monoboundLeft(A,m,e,A[m1]);
					m3=m1+(m2-m);
				}else{
					m2=m+(e-m)/2|0;
					m1=monoboundRight(A,s,m,A[m2]);
					m3=(m2++)-(m-m1);
				}
				await rotate(A,m1,m-m1,m2-m);
				await merge(A,m3+1,m2,e);
				await merge(A,s,m1,m3);
			}else{
				if(e-m<m-s){
					await mergeDown(A,s,m,e);
				}else{
					await mergeUp(A,s,m,e);
				}
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let d=monoboundRight(A,a,i,A[i]);
				let t=A[i];
				await arraycopy(A,d,A,d+1,i-d,0.5,true);
				await write(A,d,t,.5,true);
				i++;
			}
		}
		let tmp=new Array(64).fill(0);
		let i;
		for(i=0;i+32<len;i+=32)await insertion(arr,i,i+32);
		if(i+1<len)await insertion(arr,i,len);
		let g,fM;
		for(g=32;g<len;g=fM){
			fM=g*2;
			for(i=0;i+fM<len;i+=fM)await merge(arr,i,i+g,i+fM);
			if(i+g<len)await merge(arr,i,i+g,len);
		}
		await insertSort(arr,0,len);
	}
	async optimizedDualPivotQuickSort(len){
		async function dualPivot(A,l,r,dv){
			let ln=r-l;
			if(ln<17)return insertSort(A,l,r+1);
			let th=ln/dv|0;
			let m1=l+th;
			let m2=r-th;
			if(m1<=l)m1=l+1;
			if(m2>=r)m2=r-1;
			if(compareIndices(A,m1,m2)<0){
				await swap(A,m1,l,1,true);
				await swap(A,m2,r,1,true);
			}else{
				await swap(A,m1,r,1,true);
				await swap(A,m2,l,1,true);
			}
			let p1=A[l],p2=A[r];
			let ls=l+1,gr=r-1;
			for(let k=ls;k<=gr;k++){
				if(compareIndexValue(A,k,p1)<0){
					await swap(A,k,ls++,0.5,true);
				}else if(compareIndexValue(A,k,p2)>0){
					while(k<gr&&compareIndexValue(A,gr,p2)>0)gr--;
					await swap(A,k,gr--,0.5,true);
					if(compareIndexValue(A,k,p1)<0)
						await swap(A,k,ls++,0.5,true);
				}
			}
			let d=gr-ls;
			if(d<13)dv++;
			await swap(A,ls-1,l,1,true);
			await swap(A,gr+1,r,1,true);
			await dualPivot(A,l,ls-2,dv);
			await dualPivot(A,gr+2,r,dv);
			if(d>ln-13&&p1!=p2){
				for(let k=ls;k<=gr;k++){
					if(!compareIndexValue(A,k,p1))await swap(A,k,ls++,0.5);
					else if(!compareIndexValue(A,k,p2)){
						await swap(A,k,gr--,0.5,true);
						if(!compareIndexValue(A,k,p1))
							await swap(A,k,ls++,0.5,true);
					}
				}
			}
			if(p1<p2)await dualPivot(A,ls,gr,dv);
		}
		await dualPivot(arr,0,len-1,3);
	}
	async optimizedBottomUpMergeSort(len){
		async function merge(c,d,lt,md,rt,x){
				let i=lt,j=md+1,k=lt;	
			while(i<=md&&j<=rt){
				if(compareIndices(c,i,j)<1){
					if(x)write(d,k++,c[i++],0,false,true);
					else await write(d,k++,c[i++],0.5,true);
				}else{
					if(x)write(d,k++,c[j++],0,false,true);
					else await write(d,k++,c[j++],0.5,true);
				}
			}
			while(i<=md)await write(d,k++,c[i++],1,true,x);
			while(j<=rt)await write(d,k++,c[j++],1,true,x);
		}
		async function mergePass(x,y,s,n,d){
			let i=0;
			while(i<=n-2*s){
				await merge(x,y,i,i+s-1,i+2*s-1,d);
				i=i+2*s;
			}
			if(i+s<n)await merge(x,y,i,i+s-1,n-1,d);
			else for(let j=i;j<=n-1;j++)
				await write(y,j,x[j],1,false,d);
		}
		async function stableSort(a,n){
			let s=16,i;
			if(n<s)return await binaryInsertion(a,0,s);
			let b=new Array(n);
			for(i=0;i<=n-s;i+=s)await binaryInsertion(a,i,i+s);
			await binaryInsertion(a,i,n);
			while(s<n){
				await mergePass(a,b,s,n,true);
				s+=s;				
				await mergePass(b,a,s,n,false);
				s+=s;				
			}
		}
		await stableSort(arr,len);
	}
	async synchronousSqrtSort(len){
		const bms=new BlockMergeSorting();
		async function smartMergeBW(A,a,m,b,p,r){
			let i=m-1,j=b-1;
			let c=r?-1:0;
			while(i>=a&&j>=m){
				if(compareIndices(A,i,j)>c)
					await write(A,--p,A[i--],1,true);
				else
					await write(A,--p,A[j--],1,true);
			}
			return++i;
		}
		async function blockSelection(A,tags,a,b,bL,t,tj){
			for(let i=0;i<minVal(tj+1,tags.length-t);i++)
				write(tags,t+i,i+(i<=(tj/2|0)?0:tags.length),1,false,true);
			for(let j=a,p=a;j<b-bL;j+=bL){
				let n=p==j?j+bL:j;
				for(let i=n+bL;i<b;i+=bL){
					if(i-p){
						let c=compareIndices(A,i,n);
						if(c<0||(!c&&compareIndices(tags,t+(i-a)/bL|0,t+(n-a)/bL|0)<0))
							n=i;
					}
				}
				if(n>j){
					if(p==j){
						await arraycopy(A,n,A,j,bL,1,true);
						await write(tags,t+(j-a)/bL|0,tags[t+(n-a)/bL|0],1,true,false);
						p=n;
					}else{
						await bms.multiSwap(A,j,n,bL);
						await swap(tags,t+(j-a)/bL|0,t+(n-a)/bL|0,1,true,false);
					}
				}
			}
		}
		async function mergeBlocksBW(A,tags,a,b,ti,tb,bL){
			let tj=tb-1,mkv=tags.length;
			let f=b,a1=f-bL;
			let r=compareValues(tags[tj],mkv)<0;
			while(1){
				do{
					tj--;
					a1-=bL;
				}while(tj>=ti&&(r?compareValues(tags[tj],mkv)<0:compareValues(tags[tj],mkv)>=0));
				if(tj<ti){
					await bms.shiftBWExt(A,a,f,f+bL);
					break;
				}
				f=await smartMergeBW(A,a1,a1+bL,f,f+bL,r);
				r=!r;
			}
		}
		async function sort(A,l){
			if(l<17)return await bms.binaryInsertion(A,0,l);
			let bL=1;
			while(bL*bL<l)bL*=2;
			let mod=l%bL;
			let a=bL+mod,b=l,ln=b-a;
			let i,j=1;
			let temp=new Array(bL+mod);
			let tags=new Array((l-1)/bL+1|0);
			await bms.binaryInsertion(A,0,a);
			arraycopy(A,0,temp,0,a,0,false,true);
			for(;j<bL;j*=2){
				let p=maxVal(2,j);
				for(i=a;i+2*j<b;i+=2*j)
					await bms.mergeWithBufFWExt(A,i,i+j,i+2*j,i-p);
				if(i+j<b)await bms.mergeWithBufFWExt(A,i,i+j,b,i-p);
				else await bms.shiftFWExt(A,i-p,i,b);
				a-=p;b-=p;
			}
			let p=ln%(2*j);
			i=b-p;
			if(i+j<b)await bms.mergeWithBufBWExt(A,i,i+j,b,b+j);
			else await bms.shiftBWExt(A,i,b,b+j);
			for(i-=2*j;i>=a;i-=2*j)
				await bms.mergeWithBufBWExt(A,i,i+j,i+2*j,i+3*j);
			a+=j;b+=j;j*=2;
			for(let ti,tj=4;j<len;j*=2,tj*=2){
				for(i=a,ti=0;i+2*j<b;i+=2*j,ti+=tj)
					await blockSelection(A,tags,i-bL,i+2*j,bL,ti,tj);
				let nF=i+j<b;
				p=(b-i)/bL|0;
				if(nF)await blockSelection(A,tags,i-bL,b,bL,ti,tj);
				a-=bL;b-=bL;i-=bL;
				if(nF)await mergeBlocksBW(A,tags,i,b,ti,ti+p,bL);
				for(i-=2*j,ti-=tj;i>=a;i-=2*j,ti-=tj)
					await mergeBlocksBW(A,tags,i,i+2*j,ti,ti+tj,bL);
				a+=bL;b+=bL;
			}
			p=0;i=0;j=a;
			while(i<a&&j<b){
				if(compareValues(temp[i],A[j])<1)
					await write(A,p++,temp[i++],1,true);
				else
					await write(A,p++,A[j++],1,true);
			}
			while(i<a)
				await write(A,p++,temp[i++],1,true);
		}
		await sort(arr,len);
	}
	async stacklessDualPivotQuickSort(len){
		async function partition(A,a,b,p){
			let m1=(a+a+b)/3|0,m2=(a+b+b)/3|0;
			if(compareIndices(A,m1,m2)>0){
				await swap(A,m1,a,1,true);
				await swap(A,m2,--b,1,true);
			}else{
				await swap(A,m2,a,1,true);
				await swap(A,m1,--b,1,true);
			}
			let i=a,j=b;
			for(let k=i+1;k<j;k++){
				if(compareIndices(A,k,b)<0)
					await swap(A,k,++i,1,true);
				else if(compareIndices(A,a,k)<1){
					do j--;while(j>k&&compareIndices(A,a,j)<1);
					await swap(A,k,j,1,true);
					if(compareIndices(A,k,b)<0)
						await swap(A,k,++i,1,true);
				}
			}
			await swap(A,a,i,1,true);
			let t=A[b];
			await write(A,b,A[j],1,true);
			await write(A,j,A[p],1,true);
			await write(A,p,t,1,true);
			return i;
		}
		function leftBinSearch(A,a,b,p){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,p,m)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function quickSort(A,a,b){
			let x=A[a];
			for(let i=a+1;i<b;i++)if(compareValues(A[i],x)>0)x=A[i];
			for(let i=b-1;i>=0;i--)
				if(!compareValues(A[i],x))
					await swap(A,i,--b,1,true);
			let b1=b;
			let m=true;
			do{
				while(b1-a>24){
					if(!m)await swap(A,a,(a+a+b1)/3|0,1,true);
					b1=await partition(A,a,b1,b);
				}
				await binaryInsertion(A,a,b1);
				a=b1+1;
				if(a>=b){
					if(a-1<b)await swap(A,a-1,b,1,true);
					return;
				}
				b1=leftBinSearch(A,a,b,a-1);
				await swap(A,a-1,b,1,true,false);
				m=true;
				while(a<b1&&!compareIndices(A,a-1,a)){
					m=false;
					a++;
				}
				if(a==b1)m=true;
			}while(1);
		}
		await quickSort(arr,0,len);
	}
	async stacklessHybridQuickSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function partition(A,a,b){
			let i=a,j=b;
			await medianOfThree(A,a,b);
			do{
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,a,j)<1);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,a,j,1,true);
					return j;
				}
			}while(1);
		}
		function leftBinSearch(A,a,b,p){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,p,m)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function quickSort(A,a,b){
			let x=A[a];
			for(let i=a+1;i<b;i++)if(compareValues(A[i],x)>0)x=A[i];
			for(let i=b-1;i>=0;i--)
				if(!compareValues(A[i],x))
					await swap(A,i,--b,1,true);
			let b1=b;
			let m=true;
			do{
				while(b1-a>16){
					if(m)await medianOfThree(A,a,b1);
					let p=await partition(A,a,b1);
					await swap(A,b1=p,b,1,true);
				}
				await binaryInsertion(A,a,b1,0.25);
				a=b1+1;
				if(a>=b){
					if(a-1<b)await swap(A,a-1,b,1,true);
					return;
				}
				b1=leftBinSearch(A,a,b,a-1);
				await swap(A,a-1,b,1,true);
				m=true;
				while(a<b1&&!compareIndices(A,a-1,a)){
					m=false;
					a++;
				}
				if(a==b1)m=true;
			}while(1);
		}
		await quickSort(arr,0,len);
	}
	async PDQBranchedSort(len){
		const pdq=new PDQSorting();
		await pdq.pdqLoop(arr,0,len,false,pdq.pdqLog(len));
	}
	async PDQBranchlessSort(len){
		const pdq=new PDQSorting();
		await pdq.pdqLoop(arr,0,len,true,pdq.pdqLog(len));
	}
	async wikiSort(len){
		class Range{
			constructor(s=0,e=0){
				this.s=s;
				this.e=e;
			}
			set(s,e){
				this.s=s;
				this.e=e;
			}
			l(){return this.e-this.s}
		}
		class Pull{
			r=new Range(0,0);
			reset(){
				this.r.set(0,0);
				this.f=this.t=this.c=0;
			}
		}
		class Iterator{
			constructor(s,m){
				this.s=s;
				let x=s;
				for(let i=0;i<5;i++)x|=x>>2**i;
				this.d=(x-(x>>1))/m|0;
				this.ns=s%this.d;
				this.ds=s/this.d|0;
				this.b();
			}
			b(){this.n=this.dc=0}
			nR(){
				let s=this.dc;
				this.dc+=this.ds;this.n+=this.ns;
				if(this.n>=this.d){
					this.n-=this.d;
					this.dc++;
				}
				return new Range(s,this.dc);
			}
			dn(){return this.dc>=this.s}
			nL(){
				this.ds*=2;this.ns*=2;
				if(this.ns>=this.d){
					this.ns-=this.d;
					this.ds++;
				}
				return this.ds<this.s;
			}
			l(){return this.ds}
		}
		let bt=ask(`Cache Size\n0:  0\n1:  32\n2:  ${(len+1)/2|0}\n3:  ${sqrt((len+1)/2+1)|0}`,0),csz=0;
		switch(Number(bt)){
			case 1:csz=32;break;
			case 2:csz=len/2|0;break;
			case 3:csz=sqrt((len+1)/2+1)|0;break;
		}
		let ref=csz!=0?new Array(csz):null;
		function binF(A,v,r){
			let{s,e}=r;e--;
			while(s<e){
				let m=s+(e-s)/2|0;
				if(compareValues(A[m],v)<0)s=m+1;
				else e=m;
			}
			if(s==r.e-1&&compareValues(A[s],v)<0)s++;
			return s;
		}
		function binL(A,v,r){
			let{s,e}=r;e--;
			while(s<e){
				let m=s+(e-s)/2|0;
				if(compareValues(A[m],v)<1)s=m+1;
				else e=m;
			}
			if(s==r.e-1&&compareValues(A[s],v)<1)s++;
			return s;
		}
		function findFF(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.s+sk;compareValues(A[i-1],v)<0;i+=sk)
				if(i>=r.e-sk)return binF(A,v,new Range(i,r.e));
			return binF(A,v,new Range(i-sk,i));
		}
		function findLF(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.s+sk;compareValues(A[i-1],v)<1;i+=sk)
				if(i>=r.e-sk)return binL(A,v,new Range(i,r.e));
			return binL(A,v,new Range(i-sk,i));
		}
		function findFB(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.e-sk;i>r.s&&compareValues(v,A[i-1])<1;i-=sk)
				if(i<r.s+sk)return binF(A,v,new Range(r.s,i));
			return binF(A,v,new Range(i,i+sk));
		}
		function findLB(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.e-sk;i>r.s&&compareValues(v,A[i-1])<0;i-=sk)
				if(i<r.s+sk)return binL(A,v,new Range(r.s,i));
			return binL(A,v,new Range(i,i+sk));
		}
		async function insertion(A,r){
			await insertSort(A,r.s,r.e);
		}
		async function reverse(A,r){
			await reversal(A,r.s,r.e-1,1,true);
		}
		async function blockSwap(A,s1,s2,b){
			for(let i=0;i<b;i++)
				await swap(A,s1+i,s2+i,1,true);
		}
		async function rotate(A,am,r,u){
			if(!r.l())return;
			let spl=am>=0?r.s+am:r.e+am;
			let r1=new Range(r.s,spl),r2=new Range(spl,r.e);
			if(u){
				if(r1.l()<=r2.l()){
					if(r1.l()<=csz){
						if(ref!=null){
							arraycopy(A,r1.s,ref,0,r1.l(),0,false,true);
							await arraycopy(A,r2.s,A,r1.s,r2.l(),1,true);
							await arraycopy(ref,0,A,r1.s+r2.l(),r1.l(),1,true);
						}
						return;
					}
				}else{
					if(r2.l()<=csz){
						if(ref!=null){
							arraycopy(A,r2.s,ref,0,r2.l(),0,false,true);
							await arraycopy(A,r1.s,A,r2.e-r1.l(),r1.l(),1,true);
							await arraycopy(ref,0,A,r1.s,r2.l(),1,true);
						}
						return;
					}
				}
			}
			await reverse(A,r1);
			await reverse(A,r2);
			await reverse(A,r);
		}
		async function merge(f,A,B,to,ati,x){
			let A1=A.s,B1=B.s;
			let insi=ati;
			let A2=A.e,B2=B.e;
			while(1){
				if(compareIndices(f,A1,B1)<1){
					await write(to,insi++,f[A1++],1,false,x);
					if(A1==A2){
						await arraycopy(f,B1,to,insi,B2-B1,1,false,x);
						break;
					}
				}else{
					await write(to,insi++,f[B1++],1,false,x);
					if(B1==B2){
						await arraycopy(f,A1,to,insi,A2-A1,1,true,x);
						break;
					}
				}
			}
		}
		async function mergeExt(a,A,B){
			let A1=0,B1=B.s;
			let insi=A.s;
			let A2=A.l(),B2=B.e;
			if(B.l()>0&&A.l()>0){
				while(1){
					if(compareValues(ref[A1],a[B1])<1){
						await write(a,insi++,ref[A1++],1,true);
						if(A1==A2)break;
					}else{
						await write(a,insi++,a[B1++],1,true);
						if(B1==B2)break;
					}
				}
			}
			if(ref!=null)
				await arraycopy(ref,A1,a,insi,A2-A1,1,true);
		}
		async function mergeInt(a,A,B,b){
			let Ac=0,Bc=0,ins=0;
			if(B.l()>0&&A.l()>0){
				while(1){
					if(compareIndices(a,b.s+Ac,B.s+Bc)<1){
						await swap(a,A.s+ins++,b.s+Ac++,0,true);
						if(Ac>=A.l())break;
					}else{
						await swap(a,A.s+ins++,B.s+Bc++,0,true);
						if(Bc>=B.l())break;
					}
				}
			}
			await blockSwap(a,b.s+Ac,A.s+ins,A.l()-Ac);
		}
		async function mergeInPlace(a,A,B){
			if(!A.l()||!B.l())return;
			A=new Range(A.s,A.e);
			B=new Range(B.s,B.e);
			while(1){
				let m=binF(a,a[A.s],B);
				let am=m-A.e;
				await rotate(a,-am,new Range(A.s,m),true);
				if(B.e==m)break;
				A.set(A.s+am,B.s=m);
				A.s=binL(a,a[A.s],A);
				if(!A.l())break;
			}
		}
		async function netSwap(A,o,r,x,y){
			let c=compareIndices(A,r.s+x,r.s+y);
			if(c>0||(compareIndices(o,x,y)>0&&!c)){
				await swap(A,r.s+x,r.s+y,1,true);
				await swap(o,x,y,0);
			}
		}
		async function sort(A,len){
			let z=len;
			if(z<4){
				if(z>2){
					if(compareIndices(A,1,0)<0)
						await swap(A,0,1,1,true);
					if(compareIndices(A,2,1)<0){
						await swap(A,1,2,1,true);
						if(compareIndices(A,1,0)<0)
							await swap(A,0,1,1,true);
					}
				}else if(z>1)
					if(compareIndices(A,1,0)<0)
						await swap(A,0,1,1,true);
				return;
			}
			let itr=new Iterator(z,4);
			while(!itr.dn()){
				let r=itr.nR(),sws=[];
				switch(r.l()){
					case 8:sws=[[0,1],[2,3],[4,5],[6,7],[0,2],[1,3],[4,6],[5,7],[1,2],[5,6],[0,4],[3,7],[1,5],[2,6],[1,4],[3,6],[2,4],[3,5],[3,4]];break;
					case 7:sws=[[1,2],[3,4],[5,6],[0,2],[3,5],[4,6],[0,1],[4,5],[2,6],[0,4],[1,5],[0,3],[2,5],[1,3],[2,4],[2,3]];break;
					case 6:sws=[[1,2],[4,5],[0,2],[3,5],[0,1],[3,4],[2,5],[0,3],[1,4],[2,4],[1,3],[2,3]];break;
					case 5:sws=[[0,1],[3,4],[2,4],[2,3],[1,4],[0,3],[0,2],[1,3],[1,2]];break;
					case 4:sws=[[0,1],[2,3],[0,2],[1,3],[1,2]];break;
				}
				for(let i=0;i<sws.length;i++)
					await netSwap(A,[0,1,2,3,4,5,6,7],r,...sws[i]);
			}
			if(z<8)return;
			let br1=new Range(),br2=new Range();
			let blA=new Range(),blB=new Range();
			let lsA=new Range(),lsB=new Range();
			let fA=new Range();
			let rA=new Range(),rB=new Range();
			let pl=[new Pull(),new Pull()];
			while(1){
				if(itr.l()<csz){
					if(itr.l()*4+4<=csz&&itr.l()*4<=z){
						itr.b();
						while(!itr.dn()){
							let A1=itr.nR(),B1=itr.nR();
							let A2=itr.nR(),B2=itr.nR();
							if(compareValues(A[B1.e-1],A[A1.s])<0){
								arraycopy(A,A1.s,ref,B1.l(),A1.l(),0,false,true);
								arraycopy(A,B1.s,ref,0,B1.l(),0,false,true);
							}else if(compareIndices(A,B1.s,A1.e-1)<0){
								await merge(A,A1,B1,ref,0,true);
							}else{
								if(compareIndices(A,A2.e-1,B2.s)<1&&compareIndices(A,B1.e-1,A2.s)<1)continue;
								arraycopy(A,A1.s,ref,0,A1.l(),0,false,true);
								arraycopy(A,B1.s,ref,A1.l(),B1.l(),0,false,true);
							}
							A1.set(A1.s,B1.e);
							if(compareIndices(A,B2.e-1,A2.s)<0){
								arraycopy(A,A2.s,ref,A1.l()+B2.l(),A2.l(),0,false,true);
								arraycopy(A,B2.s,ref,A1.l(),B2.l(),0,false,true);
							}else if(compareIndices(A,B2.s,A2.e-1)<0){
								await merge(A,A2,B2,ref,A1.l(),true);
							}else{
								arraycopy(A,A2.s,ref,A1.l(),A2.l(),0,false,true);
								arraycopy(A,B2.s,ref,A1.l()+A2.l(),B2.l(),0,false,true);
							}
							A2.set(A2.s,B2.e);
							let A3=new Range(0,A1.l());
							let B3=new Range(A1.l(),A1.l()+A2.l());
							if(compareIndices(ref,B3.e-1,A3.s)<0){
								await arraycopy(ref,A3.s,A,A1.s+A2.l(),A3.l(),1,true);
								await arraycopy(ref,B3.s,A,A1.s,B3.l(),1,true);
							}else if(compareIndices(ref,B3.s,A3.e-1)<0){
								await merge(ref,A3,B3,A,A1.s,false);
							}else{
								await arraycopy(ref,A3.s,A,A1.s,A3.l(),1,true);
								await arraycopy(ref,B3.s,A,A1.s+A1.l(),B3.l(),1,true);
							}
						}
						itr.nL();
					}else{
						itr.b();
						while(!itr.dn()){
							rA=itr.nR();
							rB=itr.nR();
							if(compareIndices(A,rB.e-1,rA.s)<0)await rotate(A,rA.l(),new Range(rA.s,rB.e),true);
							else if(compareIndices(A,rB.s,rA.e-1)<0){
								arraycopy(A,rA.s,ref,0,rA.l(),0,false,true);
								await mergeExt(A,rA,rB);
							}
						}
					}
				}else{
					let blz=sqrt(itr.l())|0;
					let brz=itr.l()/blz+1|0;
					let i,ls,cn,pl_i=0;
					br1.set(0,0);
					br2.set(0,0);
					pl[0].reset();
					pl[1].reset();
					let f=brz+brz;
					let fs=false;
					if(blz<=csz){
						f=brz;
					}else if(f>itr.l()){
						f=brz;
						fs=true;
					}
					itr.b();
					while(!itr.dn()){
						rA=itr.nR();
						rB=itr.nR();
						for(ls=rA.s,cn=1;cn<f;ls=i,cn++){
							i=findLF(A,A[ls],new Range(ls+1,rA.e),f-cn);
							if(i==rA.e)break;
						}
						i=ls;
						if(cn>=brz){
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rA.s;
							pl_i=1;
							if(cn==2*brz){
								br1.set(rA.s,rA.s+brz);
								br2.set(rA.s+brz,rA.s+cn);
								break;
							}else if(f==2*brz){
								br1.set(rA.s,rA.s+cn);
								f=brz;
							}else if(blz<=csz){
								br1.set(rA.s,rA.s+cn);
								break;
							}else if(fs){
								br1=new Range(rA.s,rA.s+cn);
								fs=false;
							}else{
								br2.set(rA.s,rA.s+cn);
								break;
							}
						}else if(!pl_i&&cn>br1.l()){
							br1.set(rA.s,rA.s+cn);
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rA.s;
						}
						for(ls=rB.e-1,cn=1;cn<f;ls=i-1,cn++){
							i=findFB(A,A[ls],new Range(rB.s,ls),f-cn);
							if(i==rB.s)break;
						}
						i=ls;
						if(cn>=brz){
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rB.e;
							pl_i=1;
							if(cn==2*brz){
								br1.set(rB.e-cn,rB.e-brz);
								br2.set(rB.e-brz,rB.e);
								break;
							}else if(f==2*brz){
								br1.set(rB.e-cn,rB.e);
								f=brz;
							}else if(blz<=csz){
								br1.set(rB.e-cn,rB.e);
								break;
							}else if(fs){
								br1=new Range(rB.e-cn,rB.e);
								fs=false;
							}else{
								if(pl[0].r.s==rA.s)pl[0].r.e-=pl[1].c;
								br2.set(rB.e-cn,rB.e);
								break;
							}
						}else if(!pl_i&&cn>br1.l()){
							br1.set(rB.e-cn,rB.e);
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rB.e;
						}
					}
					for(pl_i=0;pl_i<2;pl_i++){
						let l=pl[pl_i].c;
						if(pl[pl_i].t<pl[pl_i].f){
							i=pl[pl_i].f;
							for(cn=1;cn<l;cn++){
								i=findFB(A,A[i-1],new Range(pl[pl_i].t,pl[pl_i].f-(cn-1)),l-cn);
								let r=new Range(i+1,pl[pl_i].f+1);
								await rotate(A,r.l()-cn,r,true);
								pl[pl_i].f=i+cn;
							}
						}else if(pl[pl_i].t>pl[pl_i].f){
							i=pl[pl_i].f+1;
							for(cn=1;cn<l;cn++){
								i=findLF(A,A[i],new Range(i,pl[pl_i].t),l-cn);
								let r=new Range(pl[pl_i].f,i-1);
								await rotate(A,cn,r,true);
								pl[pl_i].f=i-1-cn;
							}
						}
					}
					brz=br1.l();
					blz=itr.l()/brz+1|0;
					itr.b();
					while(!itr.dn()){
						rA=itr.nR();
						rB=itr.nR();
						let st=rA.s;
						if(st==pl[0].r.s){
							if(pl[0].f>pl[0].t){
								rA.s+=pl[0].c;
								if(!rA.l())continue;
							}else if(pl[0].f<pl[0].t){
								rB.e-=pl[0].c;
								if(rB.l()==0)continue;
							}
						}
						if(st==pl[1].r.s){
							if(pl[1].f>pl[1].t){
								rA.s+=pl[1].c;
								if(!rA.l())continue;
							}else if(pl[1].f<pl[1].t){
								rB.e-=pl[1].c;
								if(!rB.l())continue;
							}
						}
						if(compareValues(A[rB.e-1],A[rA.s])<0){
							await rotate(A,rA.l(),new Range(rA.s,rB.e),true);
						}else if(compareIndices(A,rA.e,rA.e-1)<0){
							blA.set(rA.s,rA.e);
							fA.set(rA.s,rA.s+blA.l()%blz);
							let iA=br1.s;
							for(i=fA.e;i<blA.e;i+=blz){
								await swap(A,iA,i,10,true);
								iA++;
							}
							lsA.set(fA.s,fA.e);
							lsB.set(0,0);
							blB.set(rB.s,rB.s+minVal(blz,rB.l()));
							blA.s+=fA.l();
							iA=br1.s;
							if(lsA.l()<=csz&&ref!=null){
								arraycopy(A,lsA.s,ref,0,lsA.l(),0,false,true);
							}else if(br2.l()>0)
								await blockSwap(A,lsA.s,br2.s,lsA.l());
							if(blA.l()>0){
								while(1){
									if((lsB.l()>0&&compareIndices(A,iA,lsB.e-1)<1)||!blB.l()){
										let B_sp=binF(A,A[iA],lsB);
										let B_rm=lsB.e-B_sp;
										let minA=blA.s;
										for(let fA=minA+blz;fA<blA.e;fA+=blz)
											if(compareIndices(A,fA,minA)<0)
												minA=fA;
										await blockSwap(A,blA.s,minA,blz);
										await swap(A,blA.s,iA++,1,true);
										if(lsA.l()<=csz)
											await mergeExt(A,lsA,new Range(lsA.e,B_sp));
										else if(br2.l()>0)
											await mergeInt(A,lsA,new Range(lsA.e,B_sp),br2);
										else
											await mergeInPlace(A,lsA,new Range(lsA.e,B_sp));
										if(br2.l()>0||blz<=csz){
											if(blz<=csz)
												arraycopy(A,blA.s,ref,0,blz,0,false,true);
											else
												await blockSwap(A,blA.s,br2.s,blz);
											await blockSwap(A,B_sp,blA.s+blz-B_rm,B_rm);
										}else
											await rotate(A,blA.s-B_sp,new Range(B_sp,blA.s+blz),true);
										lsA.set(blA.s-B_rm,blA.s-B_rm+blz);
										lsB.set(lsA.e,lsA.e+B_rm);
										blA.s+=blz;
										if(!blA.l())break;
									}else if(blB.l()<blz){
										await rotate(A,-blB.l(),new Range(blA.s,blB.e),false);
										lsB.set(blA.s,blA.s+blB.l());
										blA.s+=blB.l();
										blA.e+=blB.l();
										blB.e=blB.s;
									}else{
										await blockSwap(A,blA.s,blB.s,blz);
										lsB.set(blA.s,blA.s+blz);
										blA.s+=blz;
										blA.e+=blz;
										blB.s+=blz;
										blB.e+=blz;
										if(blB.e>rB.e)
											blB.e=rB.e;
									}
								}
							}
							if(lsA.l()<=csz)
								await mergeExt(A,lsA,new Range(lsA.e,rB.e));
							else if(br2.l()>0)
								await mergeInt(A,lsA,new Range(lsA.e,rB.e),br2);
							else
								await mergeInPlace(A,lsA,new Range(lsA.e,rB.e));
						}
					}
					await insertion(A,br2);
					for(pl_i=0;pl_i<2;pl_i++){
						let u=pl[pl_i].c*2;
						if(pl[pl_i].f>pl[pl_i].t){
							let br=new Range(pl[pl_i].r.s,pl[pl_i].r.s+pl[pl_i].c);
							while(br.l()>0){
								i=findFF(A,A[br.s],new Range(br.e,pl[pl_i].r.e),u);
								let am=i-br.e;
								await rotate(A,br.l(),new Range(br.s,i),true);
								br.s+=am+1;
								br.e+=am;
								u-=2;
							}
						}else if(pl[pl_i].f<pl[pl_i].t){
							let br=new Range(pl[pl_i].r.e-pl[pl_i].c,pl[pl_i].r.e);
							while(br.l()>0){
								i=findLB(A,A[br.e-1],new Range(pl[pl_i].r.s,br.s),u);
								let am=br.s-i;
								await rotate(A,am,new Range(i,br.e),true);
								br.s-=am;
								br.e-=am+1;
								u-=2;
							}
						}
					}
				}
				if(!itr.nL())break;
			}
		}
		await sort(arr,len);
	}
	async apollyonSort(len){
		let dir=!Number(ask("0: Forward\n1: Backward",0));
		function gPOT(n){
			let k=1;
			while(k<n)k=k<<1;
			return k>>1;
		}
		async function compare(A,i,j,d){
			let c=compareIndices(A,i,j);
			if(d==(c>0))await swap(A,i,j,0.5,true);
		}
		async function apollyonMerge(A,lo,n,d){
			if(n>1){
				let m=gPOT(n);
				for(let i=lo;i<lo+n-m;i++)await compare(A,i,i+m,d);
				await apollyonMerge(A,lo,m,d);
				await apollyonMerge(A,lo+m,n-m,d);
			}
		}
		async function apollyonSort(A,lo,n,d){
			if(n>1){
				let m=n/2|0;
				await apollyonSort(A,lo,m,!d);
				await apollyonMerge(A,lo,n,d);
			}
		}
		let th=0,n=1;
		for(;n<len;n*=2,th++);
		th=th/2|0;
		let it=0;
		await apollyonSort(arr,0,len,dir);
		while(await recursiveCircleSortRoutine(arr,0,len-1,0)){
			if(++it>=th){
				await insertSort(arr,0,len);
				break;
			}
		}
	}
	async optimizedOddEvenMergeSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function compRange(A,a,m,s){
			for(let i=s;a+i<m;i++)
				await compSwap(A,a+i,m+i);
		}
		async function compRangeExtd(A,a,m,p){
			let l=m-a;
			if(l>p){
				let i=a,j,d=l-p;
				for(j=0;j<d;j++,i++)await compSwap(A,i,i+p);
				for(j=0;j<p-d;j++,i++)await compSwap(A,i,i+l);
				for(j=0;j<d;j++,i++)await compSwap(A,i+d,i+l);
			}else await compRange(A,a,m,0);
		}
		async function merge(A,a,b){
			let m,s=(b-a)%2;
			a-=s;
			m=(a+b)/2|0;
			await compRange(A,a,m,s);
			let l=b-a;
			if(l<4)return;
			let p;
			for(p=1;2*p<l;p*=2);
			while(p>0){
				let i=a+p;
				while(i+2*p<=m){
					await compRange(A,i,i+p,0);
					i+=2*p;
				}
				await compRangeExtd(A,i,m,p);
				i=2*m-i;
				while(i<b-p){
					await compRange(A,i,i+p,0);
					i+=2*p;
				}
				p=p/2|0;
			}
		}
		async function mergeSort(A,a,b){
			let m=(a+b)/2|0;
			if(m-a>1)await mergeSort(A,a,m);
			if(b-m>1)await mergeSort(A,m,b);
			await merge(A,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async inPlaceMSDRadixSort(len){
		let base=askForBase(10);
		async function radixMSD(A,l,n,x,r,p){
			if(n>=x||p<0)return;
			let ids=new Array(r).fill(0);
			for(let i=0;i<r;i++)
				ids[i]=n;
			for(let i=n;i<x;i++){
				let t=A[i];
				let d=getDigit(t,p,r);
				for(let j=r-1;j>d;j--){
					if(ids[j]-ids[j-1])
						await write(A,ids[j],A[ids[j-1]],0,true);
					write(ids,j,ids[j]+1,0,false,true);
				}
				await write(A,ids[d],t,0,true);
				write(ids,d,ids[d]+1,0,false,true);
			}
			for(let i=0;i<r;i++){
				let sn=!i?n:ids[i-1];
				await radixMSD(A,l,sn,ids[i],r,p-1);
			}
		}
		let hp=analyzeMaxLog(arr,len,base);
		await radixMSD(arr,len,0,len,base,hp);
	}
	async LMSDRadixSort(len){
		let base=askForBase(10);
		async function radixSort(A,s,e,p){
			let rgs=new Array(base);
			for(let i=0;i<base;i++)rgs[i]=[];
			for(let i=s;i<e;i++){
				let d=getDigit(A[i],p,base);
				rgs[d].push(A[i]);
			}
			let c=s;
			for(let i=0;i<base;i++)
				for(let j=0;j<rgs[i].length;j++)
					await write(A,c++,rgs[i][j],1,true);
			return rgs;
		}
		async function lmsdRadixSort(A,na,xa,p,mp){
			if(mp<p||xa-na<2)return;
			let rgs=await radixSort(A,na,xa,p);
			if(p-mp){
				rgs=await radixSort(A,na,xa,mp);
				let s=0;
				for(let i=0;i<rgs.length;i++){
					await lmsdRadixSort(A,s+na,s+na+rgs[i].length,p+1,mp-1);
					s+=rgs[i].length;
					rgs[i]=[];
				}
			}
		}
		let hp=analyzeMaxLog(arr,len,base);
		await lmsdRadixSort(arr,0,len,0,hp);
	}
	async quickBinaryRadixSort(len){
		let base=askForBase(10);
		async function partition(A,a,b,t){
			let i=a-1;
			let j=b;
			while(1){
				do i++;while(i<b&&!getBit(A[i],t));
				do j--;while(j>=a&&getBit(A[j],t));
				if(i<j)await swap(A,i,j,1,true);
				else return i;
			}
		}
		async function radixLSD(A,a,b,p,t){
			let m=p;
			for(let i=a;i<b;i++)
				if(!getBit(A[i],t))m++;
			for(let i=a;i<b;i++){
				if(getBit(A[i],t))
					await swap(A,i,m++,0.5,true);
				else
					await swap(A,i,p++,0.5,true);
			}
		}
		async function radixLSDSort(A,a,b,p,mb){
			let pw=0,l=b-a;
			while(pw<mb){
				await radixLSD(A,a,b,p,pw++);
				if(pw>=mb){
					for(let i=0;i<l;i++)
						await swap(A,a+i,p+i,0.5,true);
					return;
				}else await radixLSD(A,p,p+l,a,pw++);
			}
		}
		async function quickRadixSort(A,a,b,mb){
			let s=a,e=b;
			while(mb>=0){
				let p=await partition(A,s,e,mb);
				let l=p-s,r=e-p;
				if(l<r){
					await radixLSDSort(A,s,p,p,mb);
					s=p;
				}else{
					await radixLSDSort(A,p,e,p-r,mb);
					e=p;
				}
				mb--;
			}
		}
		let mb=analyzeBit(arr,len);
		await quickRadixSort(arr,0,len,mb);
	}
	async optimizedIndexSort(len){
		let n=minVal(...arr);
		for(let i=0;i<len;i++){
			let c=arr[i];
			let cm=0;
			while(compareValues(i,c-n)&&cm<len){
				let t=arr[c-n];
				await write(arr,c-n,c,0.5,true);
				c=t;cm++;
			}
			if(cm>=len-1)break;
			if(cm>0)
				await write(arr,i,c,0.5,true);
		}
	}
	async divisorSort(len){
		let base=askForBase(10);
		async function safePush(aL,i,v){
			while(aL.length<=i)
				aL.push([]);
			aL[i].push(v);
		}
		async function divisorLoop(A,s,l,b,lg){
			let dv=b**lg;
			let bc=[];
			for(let i=s;i<s+l;i++)
				safePush(bc,(A[i]-s)/dv|0,A[i]);
			let cr=s;
			for(let i=0;i<bc.length;i++){
				let z=bc[i].length;
				for(let j=0;j<z;j++)
					await write(A,cr+j,bc[i][j],1,true);
				if(z>1)
					await divisorLoop(A,cr,z,b,lg/2|0);
				cr+=z;
			}
		}
		let hl=analyzeMaxCeilingLog(arr,len,base);
		await divisorLoop(arr,0,len,base,hl/2|0);
	}
	async cospoSort(len){
		function sortexternal(A,cr,l){
			let min=1/0;
			let max=-1/0;
			for(let i=0;i<len;i++){
				if(A[i]<min)min=A[i];
				if(A[i]>max)max=A[i];
			}
			let mi=min;
			let z=max-mi+1;
			let h=new Array(z).fill(0);
			for(let x=0;x<l;x++)
				write(h,A[x]-mi,h[A[x]-mi]+1,1,false,true);
			let j=0;
			for(let cn=0;cn<z;cn++)
				for(let i=0;i<h[cn];i++)
					write(cr,j++,cn+mi,1,false,true);
		}
		async function sort(A,l){
			let cr=new Array(l);
			sortexternal(A,cr,l);
			let s1=0,s2=0,vL=0;
			let vR=len-1;
			while(!compareValues(A[vL],cr[vL])){
				vL++;
				if(vL==vR)break;
			}
			if(vL-vR)
				while(!compareValues(A[vR],cr[vR]))
					vR--;
			while(vL<vR){
				let s1f=false;
				while(!s1f){
					s1=randInt(vL,vR+1);
					s1f=compareValues(A[s1],cr[s1]);
				}
				let s2f=false;
				while(!s2f){
					s2=randInt(vL,vR+1);
					if(s1-s2)
						s2f=compareValues(A[s2],cr[s2]);
				}
				await swap(A,s1,s2,0,true);
				while(!compareValues(A[vL],cr[vL])){
					vL++;
					if(vL==vR)break;
				}
				if(vL!=vR)
					while(!compareValues(A[vR],cr[vR]))
						vR--;
			}
		}
		await sort(arr,len);
	}
	async bovoSort(len){
		let p=1,j=0;
		while(!isArraySorted(arr,len)){
			p=randInt(0,len-1);
			let mp=p;
			while(p>=0)
				swap(arr,p+1,p--,0);
			mark(mp);
			if(++j>=sqrt(len))await sleep(j=0);
		}
	}
	async sliceBogoSort(len){
		let j=0;
		while(!isArraySorted(arr,len)){
			let i1=randInt(0,len),i2=randInt(0,len);
			if(i1<i2)bogoSwap(arr,i1,i2+1);
			else bogoSwap(arr,i2,i1+1);
			if(++j>=sqrt(len))await sleep(j=0);
		}
	}
	async optimizedPigeonholeSort(len){
		let n=1/0;
		let x=-1/0;
		for(let i=0;i<len;i++){
			if(arr[i]<n)n=arr[i];
			if(arr[i]>x)x=arr[i];
		}
		let mi=n;
		let z=x-mi+1;
		let h=new Array(z).fill(0);
		for(let i=0;i<len;i++){
			draw();
			await write(h,arr[i]-mi,h[arr[i]-mi]+1,1,true,true);
		}
		let j=0;
		for(let c=0;c<z;c++)
			for(let i=0;i<h[c];i++)
				await write(arr,j++,c+mi,1,false);
	}
	async asteraceaeSort(len){
		let i=1,fs=2,j=0;
		let as=true,ls=false;
		while(as){
			if(fs==1)i=1;
			else i=fs-1;
			as=ls=false;
			while(i<len){
				if(compareIndices(arr,i-1,i)>0){
					swap(arr,i-1,i++,0,true);
					if(++j>=sqrt(len)/2)await sleep(j=0);
					if(!as)fs=i-1;
					as=ls=true;
				}else{
					if(ls)i+=sqrt(len)|0;
					else i++;
					ls=false;
				}
			}
		}
	}
	async awkwardSort(len){
		let j=0;
		async function awkward(A,l,p){
			if(l<2)return;
			await awkward(A,l/2|0,p);
			await awkward(A,l/2+l%2|0,p+l/2|0);
			for(let i=0;i<l/2|0;i++){
				let a=p+i,b=p+l/2+l%2+i|0;
				let sl=false
				if(++j>=sqrt(len)){
					markSwap(a,b);
					await sleep(j=0);
					draw();
					sl=true;
				}
				if(compareIndices(A,a,b)>0){
					swap(A,a,b,0);
					if(sl)await sleep();
				}
			}
			await awkward(A,l/2+l%2|0,p+l/4|0);
			await awkward(A,l/2|0,p);
			await awkward(A,l/2+l%2|0,p+l/2|0);
		}
		await awkward(arr,len,0);
	}
	async chinottoSort(len){
		let d=false,g=1;
		while(!d){
			let i=0;
			d=true;
			while(i+g<len){
				if(compareIndices(arr,i,i+g)>0){
					d=false;
					await multiSwap(arr,i,i+g++,.5,true);
				}else if(g>1)g--;
				i++;
			}
			while(i-g>0){
				if(compareValues(arr,i-g,i)>0){
					d=false;
					await multiSwap(arr,i,i-g++,.5,true);
				}else if(g>1)g--;
				i--;
			}
		}
	}
	async circleMergeSort(len){
		let n=1;
		for(;n<=len;n*=2)
			while(await iterativeCircleSortRoutine(arr,n));
	}
	async clamberSort(len){
		let k=0;
		for(let i=1;i<len;i++)
			for(let j=0;j<i;j++)
				if(compareIndices(arr,i,j)<0){
					swap(arr,i,j,0.1,true);
					if(++k>=sqrt(len)/2)await sleep(k=0);
				}
	}
	async XSort(len){
		let g=len;
		let i=1,xl=1,xr=1;
		let as=false,d=false;
		while(!d){
			as=false;
			i=1;
			while((i-1)+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					swap(arr,i-1,i-1+g,0);
					as=true;
					xl=i+1;xr=i+g-1;
					if(g-1){
						for(let r=0;r<g-1;r++){
							if(compareIndices(arr,xl-1,xr-1)>0)
								swap(arr,xl-1,xr-1,0);
							xl++;xr--;
						}
					}
					await sleep();
				}
				i++;
			}
			if(g==1&&!as)d=true;
			else if(g-1&&!as)g--;
		}
	}
	async floatSort(len){
		let s=false;
		while(!s){
			let h=0;
			s=true;
			for(let g=len-1;g>0;g--){
				let i=h;
				let j=h+1;
				while(i>=0&&compareIndices(arr,i,j)>0){
					await swap(arr,i--,j--,0.5,true);
					s=false;
				}
				if(i>=0){
					i++;
					j++;
					while(j<len&&compareIndices(arr,i,j)>0){
						await swap(arr,i++,j++,0.5,true);
						s=false;
					}
				}
				h++;
			}
		}
	}
	async reflectionSort(len){
		let as=true,i=0;
		while(as){
			i=0;
			as=false;
			while(i<len){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,0.125,true);
					i=len-1-i;
					as=true;
				}else i++;
			}
			i=len;
			as=false;
			while(i>1){
				if(compareIndices(arr,i-1,i)>0){
					await swap(arr,i-1,i,0.125,true);
					i=len-1-i;
					as=true;
				}else i--;
			}
		}
	}
	async splitCenterSort(len){
		let d=1,i=1;
		for(let r=1;r<len;r++){
			i=len/2|0;
			while(i<len&&i>0){
				if(compareIndices(arr,i-1,i)>0)
					await swap(arr,i-1,i,0.005,true);
				i+=d;
			}
			d*=-1;
		}
	}
	async merryGoRoundSort(len){
		let i=1,v=1,d=1,j=0;
		let csp=false,str=false;
		while(!str){
			i=v;
			csp=false;
			while(i<len){
				let mi=i;
				if(compareIndices(arr,i-1,i)>0){
					csp=true;
					d=i;
					while(d+1<=len){
						swap(arr,d-1,d,0);
						d+=2;
						if(++j>=len){
							mark(mi);
							await sleep(j=0);
						}
					}
					if(i>1)i--;
				}else i+=2;
			}
			if(!csp){
				v=1;
				str=true;
				while(v-len&&str)
					if(compareIndices(arr,v-1,v)<1)v++;
					else str=false;
			}
		}
		draw();
	}
	async indexQuickSort(len){
		async function indexSort(A,x,a,b){
			for(;a<b;a++){
				if(compareValues(a,x[a])){
					let t=A[a];
					let i=a,n=x[a];
					do{
						await write(A,i,A[n],0,true);
						write(x,i,i,0,false,true);
						i=n;
						n=x[n];
					}while(compareValues(n,a));
					await write(A,i,t,0,true);
					write(x,i,i,0,false,true);
				}
			}
		}
		async function partition(A,x,a,b){
			let c0=a,c1=c0,i,p;
			let r=new Random();
			let m=a+r.nextInt(b-a)|0;
			for(i=a;i<m;i++)if(compareIndices(A,i,m)<1)c1++;
			for(i++,c1++;i<b;i++)if(compareIndices(A,i,m)<0)c1++;
			for(p=c1-1,i=a;i<m;i++)
				if(compareIndices(A,i,m)<1)write(x,c0++,i,0,false,true);
				else write(x,c1++,i,0,false,true);
			write(x,p,i++,0,false,true);
			for(;i<b;i++)
				if(compareIndices(A,i,m)<0)write(x,c0++,i,0,false,true);
				else write(x,c1++,i,0,false,true);
			await indexSort(A,x,a,b);
			return p;
		}
		async function sort(A,i,a,b){
			if(b-a<2)return;
			let p=await partition(A,i,a,b);
			await sort(A,i,a,p);
			await sort(A,i,p+1,b);
		}
		await sort(arr,new Array(len),0,len);
	}
	async pushSort(len){
		let as=true;
		let i=1,g=1;
		while(as){
			as=false;
			i=g=1;
			while(i+g<=len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					mark(i);
					await sleep();
					for(let j=1;j<=g;j++)
						swap(arr,i-1,i-1+j,0);
					as=true;
					g++;
				}else i++;
			}
		}
	}
	async playgroundSort(len){
		function selectLowest(A,l){
			let li=0;
			for(let j=0;j<l;j++)if(compareIndices(A,j,li)<0)li=j;
			return li;
		}
		function selectNext(A,l,t){
			let lh=-1,r=0;
			while(r<l){
				if(compareIndices(A,t,r)<0){
					if(lh==-1)lh=r;
					else if(compareIndices(A,lh,r)>0)lh=r;
				}
				r++;
			}
			return lh;
		}
		async function chase(A,i,t){
			let d=0,c=0;
			if(abs(t-i)-1){
				if(t-i>0)d=1;
				else d=-1;
				c=i;
				while(abs(t-c)-1){
					swap(A,c,c+d,0);
					c+=d;
				}
			}
		}
		async function quit(A,b,i){
			let p=i;
			while(p+1<b)
				swap(A,p,++p,0);
		}
		let b=len;
		let lt=0,t=0,j=0;
		while(b>1){
			lt=selectLowest(arr,b);
			t=lt;
			while(t+1){
				t=selectNext(arr,b,lt);
				if(++j>=sqrt(len)){
					mark(t);
					await sleep(j=0);
				}
				if(t+1)chase(arr,lt,lt=t);
				else quit(arr,b,lt);
			}
			b--;
		}
	}
	async zipperSort(len){
		let i=0,g=2,f=0;
		while(g>1){
			g=1;
			i=f>1?f-1:0;
			while(i+g<len){
				if(compareIndices(arr,i,i+g)>0){
					await swap(arr,i,i+g,0.1,true);
					if(g++==1)f=i;
				}else i++;
			}
		}
	}
	async wiggleSort(len){
		async function sort(A,l,s,e){
			if(e-s<2)return;
			let lP=s,rP=e,mP=(lP+rP)/2|0;
			let sL=true,j=mP;
			for(let i=lP;i<mP;i++){
				for(let k=mP;k<e;k++){
					if(compareIndices(A,j,i)<1)
						await swap(A,i,j,1,true);
					j+=sL?1:-1;
				}
				j-=sL?1:-1;
				sL=!sL;
			}
			await sort(A,l,s,mP);
			await sort(A,l,mP,e);
		}
		await sort(arr,len,0,len);
	}
	async pancakeQuickSort(len){
		async function flip(A,i,s){
			await reversal(A,0,i,s,true);
		}
		async function rotate(A,a,b,s){
			await flip(A,a-1,s/3);
			await flip(A,b-1,s/3);
			await flip(A,b-a-1,s/3);
		}
		function medOf3(A,a,b,c){
			if(a==b)return a;
			if(b==c)return b;
			if(compareIndices(A,a,b)<1){
				if(compareIndices(A,b,c)<1)return b;
				if(compareValues(A,a,c)<1)return c;
				return a;
			}
			if(compareIndices(A,b,c)<1)return b;
			if(compareIndices(A,a,c)<1)return a;
			return c;
		}
		async function pancakeLLQS(A,l,s){
			if(l<3){
				if(compareIndices(A,0,1)>0)
					await flip(A,l-1,s*10);
				return;
			}else if(l<2)return;
			let j=0,m=(l-1)/2|0,p=A[medOf3(A,0,m,l-1)];
			for(let i=0;i<l;i++){
				let k=i;
				while(k<l&&compareValues(p,A[k])+1){
					k++;
					j++;
				}
				if(k>i){
					await flip(A,i-1,s/4);
					await flip(A,k-1,s/4);
					i=k-1;
				}
			}
			await pancakeLLQS(A,j,s);
			await rotate(A,j,l,s);
			await pancakeLLQS(A,l-j,s);
			await rotate(A,l-j,l,s);
		}
		await pancakeLLQS(arr,len,.5);
	}
	async timSort(len){
		await TimSorting.sort(new TimSorting(arr,len),arr,0,len);
	}
	async cocktailMergeSort(len){
		let mRL=new TimSorting().minRunLength(len);
		if(len==mRL){
			await cocktailShaker(arr,0,len);
		}else{
			let i=0;
			for(;i<=len-mRL;i+=mRL)
				await cocktailShaker(arr,i,i+mRL);
			if(i+mRL>len)await cocktailShaker(arr,i,len);
			await TimSorting.sort(new TimSorting(arr,len),arr,0,len);
		}
	}
	async gritSort(len){
		limitArraySize(297);
		function productLog(n){
			let r=1;
			while((r<<r)+r-1<n)r++;
			return r;
		}
		function log2(n){
			return 31-clz32(n);
		}
		function calcSLen(n,m){
			let a=2,b=n;
			let logN=log2(maxVal(n,2)-1)+1;
			while(a<b){
				let ms=(a+b)/2|0,mq=n/(ms+1)|0;
				let m1=m-mq*logN;
				let logS=log2(ms-1)+1;
				let qf=((m1/mq|0)/(mq+1)|0)/logS|0;
				console.log(qf,m1,mq,logS);
				if(qf>=1)b=ms;
				else a=ms+1;
			}
			return a;
		}
		class BitArray{
			constructor(A,pa,pb,z,w){
				this.A=A;
				this.pa=pa;
				this.pb=pb;
				this.z=z;
				this.w=w;
				this.l=z*w;
			}
			async flipBit(a,b){
				await swap(this.A,a,b,0.5,true);
			}
			getBit(a,b){
				return compareIndices(this.A,a,b)>0;
			}
			async setBit(a,b,bit){
				if(this.getBit(a,b)^bit)
					await this.flipBit(a,b);
			}
			async free(){
				let i1=this.pa+this.l;
				for(let i=this.pa,j=this.pb;i<i1;i++,j++)
					await this.setBit(i,j,false);
			}
			async set(idx,uInt){
				if(idx>=0&&idx<this.z){
					let s=idx*this.w,i1=this.pa+s+this.w;
					for(let i=this.pa+s,j=this.pb+s;i<i1;i++,j++,uInt>>=1)
						await this.setBit(i,j,(uInt&1)==1);
				}
			}
			get(idx){
				if(idx<0||idx>=this.z)return;
				let r=0,s=idx*this.w;
				for(let k=0,i=this.pa+s,j=this.pb+s;k<this.w;k++,i++,j++)
					r|=(this.getBit(i,j)?1:0)<<k;
				return r;
			}
			async incr(idx){
				if(idx<0||idx>=this.z)return;
				let s=idx*this.w,i1=this.pa+s+this.w;
				for(let i=this.pa+s,j=this.pb+s;i<i1;i++,j++){
					await this.flipBit(i,j);
					if(this.getBit(i,j))return;
				}
			}
		}
		class BitArray2D{
			constructor(A,pa,pb,x,y,w){
				this.bits=new BitArray(A,pa,pb,x*y,w);
				this.x=x;
			}
			async free(){
				await this.bits.free();
			}
			async set(i,j,uInt){
				await this.bits.set(j*this.x+i,uInt);
			}
			get(i,j){
				return this.bits.get(j*this.x+i);
			}
			async incr(i,j){
				await this.bits.incr(j*this.x+i);
			}
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		async function rotate(A,a,m,b){
			await IndexedRotations.cycleReverse(A,a,m,b,1,true);
		}
		function getRank(A,a,b,r){
			let c=0,ce=0;
			for(let i=a;i<b;i++){
				if(i==r)continue;
				let cmp=compareIndices(A,i,r);
				c+=cmp==-1?1:0;
				ce+=cmp<=0?1:0;
			}
			return toLong(ce)<<toLong(32)|toLong(c);
		}
		function isCandidate(A,i,min,max){
			return compareIndices(A,i,min)>0&&compareIndices(A,i,max)<0;
		}
		function selectBlockMedian(A,a,b,med,min,max){
			let lMin=min,lMax=max;
			for(let i=a;;i++){
				if(isCandidate(A,i,lMin,lMax)){
					let c=0,ce=0;
					for(let j=a;j<b;j++){
						if(j==i)continue;
						if(isCandidate(A,j,min,max)){
							let cmp=compareIndices(A,j,i);
							c+=cmp==-1?1:0;
							ce+=cmp<=0?1:0;
						}
					}
					if(med>=c&&med<=ce)return i;
					else if(ce<med)lMin=i;
					else lMax=i;
				}
			}
		}
		function selectRank(A,a,b,med,min,max){
			let rank=getRank(A,a,b,min);
			let r=toInt(rank),re=toInt(rank>>toLong(32));
			if(med>=r&&med<=re)return min;
			let cand=re+1;
			rank=getRank(A,a,b,max);
			r=toInt(rank);re=toInt(rank>>toLong(32));
			if(med>=r&&med<=re)return max;
			let n=b-a,a1=0,b1=0;
			cand=r-cand;
			while(cand>3){
				let sqr=sqrt(cand)|0,s=(n-1)/sqr+1|0,j=a;
				for(;j+s<b;j+=s){
					let i=j,fCnt=0;
					while(!isCandidate(A,i,min,max)&&++fCnt<=s-sqr)i++;
					if(fCnt>s-sqr)continue;
					else{
						a1=i++;
						let found=false;
						let cCnt=1;
						for(;fCnt<=s-sqr;i++)
							if(isCandidate(A,i,min,max)){
								if(++cCnt==sqr){
									found=true;
									break;
								}
							}else fCnt++;
						if(found){
							b1=i+1;
							break;
						}
					}
				}
				if(j+s>=b){
					let i=j;
					while(!isCandidate(A,i,min,max))i++;
					a1=i++;
					for(let cCnt=1;cCnt<sqr;i++)
						if(isCandidate(A,i,min,max))cCnt++;
					b1=i+1;
				}
				let bMed=selectBlockMedian(A,a1,b1,sqr/2|0,min,max);
				r=0;re=0;
				let c=0,ce=0;
				for(let i=a;i<b;i++){
					if(i==bMed)continue;
					let cmp=compareIndices(A,i,bMed);
					r+=cmp==-1?1:0;
					re+=cmp<=0?1:0;
					if(isCandidate(A,i,min,max)){
						c+=cmp==-1?1:0;
						ce+=cmp<=0?1:0;
					}
				}
				if(med>=r&&med<=re)return bMed;
				else if(re<med){
					min=bMed;
					cand-=ce+1;
				}else{
					max=bMed;
					cand-=cand-c;
				}
			}
			for(let i=a;i<b;i++){
				if(isCandidate(A,i,min,max)){
					if(--cand==0)return i;
					rank=getRank(A,a,b,i);
					r=toInt(rank);re=toInt(rank>>toLong(32));
					if(med>=r&&med<=re)
						return i;
				}
			}
			return-1;
		}
		function pivCmp(v,piv,pCmp){
			return compareValues(v,piv)<pCmp;
		}
		async function pivBufXor(A,pa,pb,v,wLen){
			while(wLen-->0){
				if((v&1)==1)await swap(A,pa+wLen,pb+wLen,1,true);
				v>>=1;
			}
		}
		function pivBufGet(A,pa,piv,pCmp,wLen,bit){
			let r=0;
			while(wLen-->0){
				r<<=1;
				r|=(pivCmp(A[pa++],piv,pCmp)?0:1)^bit;
			}
			return r;
		}
		async function blockCycle(A,p,n,p1,bLen,wLen,piv,pCmp,bit){
			for(let i=0;i<n;i++){
				let dest=pivBufGet(A,p+i*bLen,piv,pCmp,wLen,bit);
				while(dest!=i){
					await blockSwap(A,p+i*bLen,p+dest*bLen,bLen);
					dest=pivBufGet(A,p+i*bLen,piv,pCmp,wLen,bit);
				}
				await pivBufXor(A,p+i*bLen,p1+i*bLen,i,wLen);
			}
		}
		async function partitionEasy(A,aux,a,b,piv,pCmp){
			let j=0;
			for(let i=a;i<b;i++){
				if(pivCmp(A[i],piv,pCmp))
					await write(A,a++,A[i],0,true);
				else
					write(aux,j++,A[i],0,false,true);
			}
			await arraycopy(aux,0,A,a,j,0.5,true);
			return a;
		}
		async function blockPartition(A,aux,a,b,bLen,piv,pCmp){
			if(b-a<=bLen)return await partitionEasy(A,aux,a,b,piv,pCmp);
			let p=a;
			let l=0,r=0;
			let lb=0,rb=0;
			for(let i=a;i<b;i++){
				if(pivCmp(A[i],piv,pCmp)){
					await write(A,p+l++,A[i],0.25,true);
					if(l==bLen){
						l=0;
						lb++;
						p+=bLen;
					}
				}else{
					write(aux,r++,A[i],0,false,true);
					if(r==bLen){
						await arraycopy(A,p,A,p+bLen,l,0.5,true);
						await arraycopy(aux,0,A,p,bLen,0.5,true);
						r=0;
						rb++;
						p+=bLen;
					}
				}
			}
			let min=minVal(lb,rb);
			let m=a+lb*bLen;
			if(min>0){
				let bCnt=lb+rb;
				let wLen=log2(min-1)+1;
				for(let i=0,j=0,k=0;i<min;i++){
					while(!pivCmp(A[a+j*bLen+wLen],piv,pCmp))j++;
					while(pivCmp(A[a+k*bLen+wLen],piv,pCmp))k++;
					await pivBufXor(A,a+(j++)*bLen,a+(k++)*bLen,i,wLen);
				}
				if(lb<rb){
					for(let i=bCnt-1,j=0;j<rb;i--)
						if(!pivCmp(A[a+i*bLen+wLen],piv,pCmp))
							await blockSwap(A,a+i*bLen,a+(bCnt-(++j))*bLen,bLen);
					await blockCycle(A,a,lb,m,bLen,wLen,piv,pCmp,0);
				}else{
					for(let i=0,j=0;j<lb;i++)
						if(pivCmp(A[a+i*bLen+wLen],piv,pCmp))
							await blockSwap(A,a+i*bLen,a+(j++)*bLen,bLen);
					await blockCycle(A,m,rb,a,bLen,wLen,piv,pCmp,1);
				}
			}
			await arraycopy(aux,0,A,b-r,r,1,true);
			if(l>0){
				arraycopy(A,b-r-l,aux,0,l,0,false,true);
				await arraycopy(A,a+lb*bLen,A,a+lb*bLen+l,rb*bLen,1,true);
				await arraycopy(aux,0,A,a+lb*bLen,l,1,true);
			}
			return a+lb*bLen+l;
		}
		async function mergeFWExt(A,tmp,a,m,b){
			let s=m-a;
			arraycopy(A,a,tmp,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b){
				if(compareValues(tmp[i],A[j])<1)
					await write(A,a++,tmp[i++],1,true);
				else
					await write(A,a++,A[j++],1,true);
			}
			while(i<s)await write(A,a++,tmp[i++],1,true);
		}
		async function mergeBWExt(A,tmp,a,m,b){
			let s=b-m;
			arraycopy(A,m,tmp,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a){
				if(compareValues(tmp[i],A[j])+1)
					await write(A,--b,tmp[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			}
			while(i>=0)write(A,--b,tmp[i--],1,true);
		}
		async function blockMergeHelper(A,swp,a,m,b,p,bLen,piv,pCmp,bit){
			if(b-m<=2*bLen){
				await mergeBWExt(A,swp,a,m,b);
				return;
			}
			if(m-a<=2*bLen){
				await mergeFWExt(A,swp,a,m,b);
				return;
			}
			let bCnt=0,wLen=log2((b-a)/bLen-3|0)+1;
			let i=a,j=m,k=0;
			let l=0,r=0;
			let c=0;
			while(c++<2*bLen){
				if(compareIndices(A,i,j)<1){
					write(swp,k++,A[i++],0,false,true);
					l++;
				}else{
					write(swp,k++,A[j++],0,false,true);
					r++;
				}
			}
			let t=0,pc=p;
			let left=l>=r;
			k=left?i-l:j-r;
			c=0;
			do{
				if(j==b||compareIndices(A,i,j)<1){
					await write(A,k++,A[i++],1,true);
					l++;
				}else{
					await write(A,k++,A[j++],1,true);
					r++;
				}
				if(++c==bLen){
					await pivBufXor(A,k-bLen,pc,t++,wLen);
					pc+=bLen;
					if(left)l-=bLen;
					else r-=bLen;
					left=l>=r;
					k=left?i-l:j-r;
					c=0;
					bCnt++;
				}
			}while(i<m);
			let b1=j-c;
			await arraycopy(A,k-c,A,b1,c,1,true);
			r-=c;
			l=minVal(l,m-a-l);
			await arraycopy(A,a,A,m-l,l,1,true);
			await arraycopy(A,a+l,A,b1-r,r,1,true);
			await arraycopy(swp,0,A,a,2*bLen,1,true);
			await blockCycle(A,a+2*bLen,bCnt,p,bLen,wLen,piv,pCmp,bit);
		}
		async function blockMerge(A,swp,a,m,b,p,bLen,piv,pCmp,bit){
			if(b-a<74)return;
			let a1=a+(m-a)%bLen;
			await blockMergeHelper(A,swp,a1,m,b,p,bLen,piv,pCmp,bit);
			await mergeFWExt(A,swp,a,a1,b);
		}
		async function stableCycleDest(A,a,a1,b1,b,p,piv,cmp){
			let d=a1,e=0;
			for(let i=a1+1;i<b;i++){
				let bit=compareValues(A[i],piv)==cmp;
				let val=bit?A[i]:A[p+i-a];
				let vCmp=compareValues(val,A[a1]);
				if(vCmp==-1)d++;
				else if(i<b1&&bit&&vCmp==0)e++;
			}
			while(1){
				if(compareValues(A[d],piv)==cmp&&e--==0)break;
				d++;
			}
			return d;
		}
		async function stableCycle(A,a,b,p,piv,cmp){
			for(let i=a;i<b;i++){
				if(compareValues(A[i],piv)==cmp){
					let j=i;
					while(true){
						let k=await stableCycleDest(A,a,i,j,b,p,piv,cmp);
						if(k==i)break;
						let t=A[i];
						await write(A,i,A[k],0.1,true);
						await write(A,k,A[p+(k-a)],0.1,true);
						await write(A,p+(k-a),t,0.1,true);
						j=k;
					}
					await swap(A,i,p+(i-a),0.2,true);
				}
			}
		}
		async function gritSortRuns(A,a,b,p,s1,s2,piv,cmp){
			if(b-a<74){
				await stableCycle(A,a,b,p,piv,cmp);
				return;
			}
			let m=(a+b)/2|0;
			for(let i=a;i<m;i+=s1)
				await stableCycle(A,i,minVal(i+s1,m),p+(i-a),piv,cmp);
			for(let i=m;i<b;i+=s2)
				await stableCycle(A,i,minVal(i+s2,b),p+(i-a),piv,cmp);
		}
		async function findPivots(A,qIdx,a,p,q,piv,cmp){
			let f=a,fKeys=0;
			for(let i=a;fKeys<q;i++){
				if(compareIndexValue(A,i,piv)!=cmp){
					await rotate(A,f,f+fKeys,i);
					await swap(A,p+(i-a),i,1,true);
					f=i-fKeys;
					await qIdx.set(fKeys,i-a-(fKeys++));
				}
			}
			await rotate(A,a,f,f+q);
		}
		async function sortPivots(A,qIdx,a,b){
			for(let i=a;i<b-1;i++){
				let min=i,iIdx=qIdx.get(i-a),mIdx=iIdx;
				for(let j=min+1;j<b;j++){
					let cmp=compareIndices(A,j,min);
					if(cmp<0){
						min=j;
						mIdx=qIdx.get(j-a);
					}else if(cmp==0){
						let jIdx=qIdx.get(j-a);
						if(jIdx<mIdx){
							min=j;
							mIdx=jIdx;
						}
					}
				}
				if(min>i){
					await swap(A,i,min,1,true);
					await qIdx.set(i-a,mIdx);
					await qIdx.set(min-a,iIdx);
				}
			}
		}
		function pivEq(val,vPos,pivL,pivR,ql,qr){
			let cmpL=ql==-1? 1:compareValues(val,pivL);
			let cmpR=qr==-1?-1:compareValues(val,pivR);
			return(cmpL>0||(cmpL==0&&vPos>=ql))&&(cmpR<0||(cmpR==0&&vPos<qr));
		}
		function pivBinSearch(A,qIdx,a,b,val,vPos){
			let a1=a;
			while(a1<b){
				let m=a1+(b-a1)/2|0;
				let cmp=compareValues(val,A[m]);
				if(cmp<0||(cmp==0&&vPos<qIdx.get(m-a)))
					b=m;
				else
					a1=m+1;
			}
			return a1;
		}
		async function gritPartitionHelper(A,a,b,pa,pb,p,s,piv,cmp){
			let n=b-a;
			let rCnt=(n-1)/s+1|0,c=0,q=n/(s+1)|0,logS=log2(s-1)+1;
			let runs=new BitArray(A,pa+rCnt,pb+rCnt,rCnt,logS);
			while(true){
				let min=-1,mPos=-1;
				for(let i=0;i<rCnt;i++){
					if(compareValues(A[pa+i],A[pb+i])<0){
						let rMin=a+i*s+runs.get(i);
						if(min==-1||compareIndices(A,rMin,mPos)<0){
							min=i;
							mPos=rMin;
						}
					}
				}
				if(min==-1)break;
				if(mPos==minVal(a+(min+1)*s,b)-1)
					await swap(A,pa+min,pb+min,1,true);
				else
					await runs.incr(min);
				if(c++==s){
					await swap(A,mPos,p+(mPos-a),1,true);
					c=0;
				}
			}
			await blockSwap(A,pa,pb,rCnt);
			await runs.free();
			let qIdx=new BitArray(A,pa,pb,q,log2(n-1)+1);
			await findPivots(A,qIdx,a,p,q,piv,cmp);
			let a1=a+q;
			await sortPivots(A,qIdx,a,a1);
			let counts=new BitArray2D(A,pa+qIdx.l,pb+qIdx.l,q,q+1,logS);
			for(let i=0;i<q;i++){
				if(i>0)
					for(let j=0;j<q+1;j++)
						await counts.set(i,j,counts.get(i-1,j));
				let k=a1+i*s;
				for(let j=0;j<s;j++){
					let loc=pivBinSearch(A,qIdx,a,a1,A[k+j],k+j-a1)-a;
					await counts.incr(i,loc);
				}
			}
			for(let i=a1;i<b;i++){
				if(compareValues(A[i],piv)==cmp){
					let j=i;
					while(true){
						let loc=pivBinSearch(A,qIdx,a,a1,A[i],j-a1)-a;
						let curS=(j-a1)/s|0;
						let pivL=loc>0?A[a+loc-1]:-1,pivR=loc<q?A[a+loc]:-1;
						let ql=loc>0?qIdx.get(loc-1):-1,qr=loc<q?qIdx.get(loc):-1;
						let cntA=curS>0?counts.get(curS-1,loc):0;
						let cntB=0;
						for(let i1=maxVal(i+1,a1+curS*s);i1<j;i1++)
							if(compareValues(A[i1],piv)==cmp&&pivEq(A[i1],i1-a1,pivL,pivR,ql,qr))
								cntB++;
						let k=a1+loc*s+cntA;
						while(true){
							if(compareIndexValue(A,k,piv)==cmp&&cntB--==0)break;
							k++;
						}
						if(k==i)break;
						let t=A[i];
						await write(A,i,A[k],0.33,true);
						await write(A,k,A[p+(k-a)],0.33,true);
						await write(A,p+(k-a),t,0.34,true);
	
						j=k;
					}
					await swap(A,i,p+(i-a),1,true);
				}
			}
			await qIdx.free();
			await counts.free();
			await blockSwap(A,a,p,q);
			while(q>0){
				await rotate(A,p,p+q,p+s+(q--));
				p+=s+1;
			}
		}
		async function gritPartition(A,a,b,p,s1,s2,piv,cmp){
			if(b-a<74){
				await blockSwap(A,a,p,b-a);
				return;
			}
			let m=(a+b)/2|0,p1=p+(m-a);
			if(cmp==-1){
				await gritPartitionHelper(A,a,m,m,p1,p,s1,piv,cmp);
				await gritPartitionHelper(A,m,b,p,a,p1,s2,piv,cmp);
			}else{
				await gritPartitionHelper(A,a,m,p1,m,p,s1,piv,cmp);
				await gritPartitionHelper(A,m,b,a,p,p1,s2,piv,cmp);
			}
		}
		async function gritSortBuckets(A,a,b,p,s1,s2,piv,cmp){
			if(b-a<74){
				await blockSwap(A,a,p,b-a);
				return;
			}
			let m=(a+b)/2|0;
			for(let i=a;i<m;i+=s1+1){
				await stableCycle(A,i,minVal(i+s1,m),p+(i-a),piv,cmp);
				if(i+s1<m)await swap(A,i+s1,p+(i+s1-a),1,true);
			}
			for(let i=m;i<b;i+=s2+1){
				await stableCycle(A,i,minVal(i+s2,b),p+(i-a),piv,cmp);
				if(i+s1<b)await swap(A,i+s1,p+(i+s1-a),1,true);
			}
		}
		async function sort(A,l){
			let a=0,b=l;
			let n=b-a;
			if(n<=32){
				await binaryInsertion(A,a,b);
				return;
			}
			let min=a,max=min;
			for(let i=a+1;i<b;i++){
				if(compareIndices(A,i,min)<0)
					min=i;
				else if(compareIndices(A,i,max)>0)
					max=i;
			}
			let m1=(a+b)/2|0;
			let med=A[selectRank(A,a,b,m1,min,max)];
			let lgBLen=productLog(l);
			let tmp=new Array(2*lgBLen);
			await blockPartition(A,tmp,a,await blockPartition(A,tmp,a,b,2*lgBLen,med,1),2*lgBLen,med,0);
			if(compareIndices(A,a,b-1)==0)return;
			let m2=m1+n%2;
			while(compareIndices(A,m1-1,m2)==0){
				m1--;m2++;
			}
			if(compareValues(A[m2],med)==0){
				let m3=m2,bSize=1;
				while(++m3<b&&compareIndexValue(A,m3,med)==0)
					bSize++;
				let a1=a+bSize;
				let len1=m1-a;
				let s1=calcSLen(len1/2|0,(len1+1)/2|0);
				let s2=calcSLen((len1+1)/2|0,len1/2|0);
				let len2=len1-bSize;
				let s3=calcSLen(len2/2|0,(len2+1)/2|0);
				let s4=calcSLen((len2+1)/2|0,len2/2|0);
				await gritSortRuns(A,a,m1,m2,s1,s2,med,-1);
				await blockSwap(A,a,m2,bSize);
				await gritSortRuns(A,a1,m1,m3,s3,s4,med,1);
				if(maxVal(len1,len2)>=74){
					await gritPartition(A,a,m1,m2,s1,s2,med,-1);
					await blockSwap(A,a,m2,bSize);
					await gritPartition(A,a1,m1,m3,s3,s4,med,1);
					await gritSortBuckets(A,a,m1,m2,s1,s2,med,-1);
					await blockSwap(A,a,m2,bSize);
					await gritSortBuckets(A,a1,m1,m3,s3,s4,med,1);
					await blockMerge(A,tmp,a,(a+m1)/2|0,m1,m2,lgBLen,med,0,0);
					await blockMerge(A,tmp,m3,(m3+b)/2|0,b,a,lgBLen,med,0,1);
				}
			}else if(compareValues(A[m1-1],med)==0){
				let m3=m1,bSize=1;
				while(--m3>a&&compareIndexValue(A,m3-1,med)==0)
					bSize++;
				let b1=b-bSize;
				let len1=m3-a;
				let s1=calcSLen(len1/2|0,(len1+1)/2|0);
				let s2=calcSLen((len1+1)/2|0,len1/2|0);
				let len2=len1+bSize;
				let s3=calcSLen(len2/2|0,(len2+1)/2|0);
				let s4=calcSLen((len2+1)/2|0,len2/2|0);
				await gritSortRuns(A,a,m3,m2,s1,s2,med,-1);
				await blockSwap(A,m3,b1,bSize);
				await gritSortRuns(A,a,m1,m2,s3,s4,med,1);
				if(maxVal(len1,len2)>=74){
					await gritPartition(A,a,m3,m2,s1,s2,med,-1);
					await blockSwap(A,m3,b1,bSize);
					await gritPartition(A,a,m1,m2,s3,s4,med,1);
					await gritSortBuckets(A,a,m3,m2,s1,s2,med,-1);
					await blockSwap(A,m3,b1,bSize);
					await gritSortBuckets(A,a,m1,m2,s3,s4,med,1);
					await blockMerge(A,tmp,a,(a+m3)/2|0,m3,m2,lgBLen,med,0,0);
					await blockMerge(A,tmp,m2,(m2+b)/2|0,b,a,lgBLen,med,1,1);
				}
			}else{
				let len1=m1-a;
				let s1=calcSLen(len1/2|0,(len1+1)/2|0);
				let s2=calcSLen((len1+1)/2|0,len1/2|0);
				await gritSortRuns(A,a,m1,m2,s1,s2,med,-1);
				await gritSortRuns(A,a,m1,m2,s1,s2,med,1);
				if(len1>=74){
					await gritPartition(A,a,m1,m2,s1,s2,med,-1);
					await gritPartition(A,a,m1,m2,s1,s2,med,1);
					await gritSortBuckets(A,a,m1,m2,s1,s2,med,-1);
					await gritSortBuckets(A,a,m1,m2,s1,s2,med,1);
					await blockMerge(A,tmp,a,(a+m1)/2|0,m1,m2,lgBLen,med,0,0);
					await blockMerge(A,tmp,m2,(m2+b)/2|0,b,a,lgBLen,med,0,1);
				}
				
			}
		}
		await sort(arr,len);
		restoreArraySize();
	}
	async LLQuickSortMiddlePivot(len){
		async function partition(A,a,b){
			let i=a,j=i,m=(a+b)/2|0;
			while(j<m){
				if(compareValues(A[j],A[m])<1)
					await swap(A,i++,j,1,true);
				j++;
			}
			await swap(A,i,m,1,true);
			j=m+1;
			m=i++;
			while(j<b){
				if(compareValues(A[j],A[m])<0)
					await swap(A,i++,j,1,true);
				j++;
			}
			await swap(A,--i,m,1,true);
			return i;
		}
		async function quickSort(A,a,b){
			if(b-a>1){
				let p=await partition(A,a,b);
				await quickSort(A,a,p);
				await quickSort(A,p+1,b);
			}
		}
		await quickSort(arr,0,len);
	}
	async dandelionSort(len){
		let j=0;
		for(let b=0;b<len;){
			let p=b;
			let as=false;
			while(p<len-1&&compareIndices(arr,p+1,p)<0){
				swap(arr,p,++p,0.5,true);
				if(++j>=sqrt(len))await sleep(j=0);
				as=true;
			}
			if(as){
				if(b>0)b--;
				continue;
			}
			b++;
		}
	}
	async cocktailGrateSort(len){
		let s=false;
		while(!s){
			s=true;
			let i;
			for(i=0;i<len-1;i++){
				for(let j=len-1;j>i;j--){
					if(compareIndices(arr,i,j)>0){
						s=false;
						await swap(arr,i,j,0.1,true);
						break;
					}
				}
			}
			if(s)break;
			for(i=0;i<len-1;i++){
				for(let j=i+1;j<len;j++){
					if(compareIndices(arr,i,j)>0){
						await swap(arr,i,j,0.1,true);
						break;
					}
				}
			}
		}
	}
	async cocktailPushSort(len){
		let as=true,i=1,g=1;
		while(as){
			as=false;
			i=g=1;
			while(i+g<=len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					mark(i-1);
					await sleep();
					for(let j=1;j<=g;j++)swap(arr,i-1,i-1+j,0.01);
					as=true;
					g++;
				}else i++;
			}
			i=len;
			g=1;
			while(i-g>0){
				if(compareIndices(arr,i-1-g,i-1)>0){
					mark(i-1);
					await sleep();
					for(let j=1;j<=g;j++)swap(arr,i-1,i-1-j,0.01);
					as=true;
					g++;
				}else i--;
			}
		}
	}
	async fibonacciGnomeSort(len){
		function fibonacciSearch(A,s,e,i){
			let fM2=0,fM1=1,fM=1;
			while(fM<=e-s){
				fM2=fM1;
				fM1=fM;
				fM=fM2+fM1;
			}
			let o=s-1;
			while(fM>1){
				let j=minVal(o+fM2,e);
				if(compareValues(A[j],i)<1){
					fM=fM1;
					fM1=fM2;
					fM2=fM-fM1;
					o=j;
				}else{
					fM=fM2;
					fM1-=fM2;
					fM2=fM-fM1;
				}
			}
			let p=++o;
			if(compareValues(A[p],i)<1)p++;
			return p;
		}
		async function sort(A,l){
			let k=0;
			for(let i=1;i<l;i++){
				let t=A[i],p=fibonacciSearch(A,0,i-1,t);
				let j=i;
				while(j>p){
					swap(A,j,--j,0,true);
					if(++k>=sqrt(len))await sleep(k=0);
				}
			}
		}
		await sort(arr,len);
	}
	async noisySort(len){
		let base=askForBase(16);
		async function sort(A,ln){
			let l=1,r=1,vi=1,vp=false;
			while(!vp){
				r=vi+1;
				while(r<=ln){
					l=vi;
					while(l<=r&&r<=ln){
						if(compareIndices(A,l-1,r-1)>0){
							await swap(A,l-1,r-1,.005,true);
							if(r-1>vi)r--;
							l=vi;
						}else l++;
					}
					r+=base;
				}
				if(vi-1>0)vi--;
				vp=true;
				while(vi<ln&&vp){
					if(compareValues(A[vi-1],A[vi])<=0)vi++;
					else vp=false;
				}
			}
		}
		await sort(arr,len);
	}
	async gambitGnomeSort(len){
		function binSearch(A,b,e,t){
			while(true){
				let d=e-b;
				if(d<1)break;
				let p=b+d/2|0;
				if(!compareIndices(A,p,t))return p;
				if(compareIndices(A,p,t)>0){
					e=p;
					continue;
				}
				b=p+1;
			}
			return e;
		}
		async function binInsert(A,l,s,e){
			let o=1;
			for(;o*o<l;o*=2);
			for(let bs=0,be=e,i=s+o;i<e;i++){
				let t=binSearch(A,bs,be,i);
				let tm=A[i],j=i;
				while(j>t&&A[j]>=tm)
					await swap(A,j--,j,0,true);
			}
		}
		await binInsert(arr,len,0,len);
		await insertSort(arr,0,len,1/3);
	}
	async headPullSort(len){
		let i=1,p=1;
		i=1;
		while(i+1<=len){
			if(compareIndices(arr,i-1,i)>0){
				p=i;
				while(p>0)
					await swap(arr,p--,p,0.1,true);
				i=1;
			}else i++;
		}
	}
	async markovSort(len){
		let j=0;
		for(let i=0;i<len-1;++i){
			let w=i+1;
			while((!w?0:compareIndices(arr,w-1,w)>0)||(w>i?0:compareIndices(arr,w,w+1)>0)){
				let c=(!w||w<=i&&randBool())?1:-1;
				swap(arr,w,w+c,0,true);
				if(++j>=len)await sleep(j=0);
				w+=c;
			}
		}
	}
	async meanQuickSort(len){
		function compare(a,b){
			return compareValues(a,b);
		}
		async function partition(A,s,e,sm){
			let l=s,r=e;
			let c=r-l+1;
			if(c<2)return;
			let m=sm/c;
			let lsm=0,rsm=0;
			while(l<=r){
				while(compare(A[l],m)<0)
					lsm+=A[l++];
				while(compare(A[r],m)>0)
					rsm+=A[r--];
				if(l<=r){
					await swap(A,l,r,1,true);
					lsm+=A[l++];
					rsm+=A[r--];
				}
			}
			if(s<r)await partition(A,s,r,lsm);
			if(l<e)await partition(A,l,e,rsm);
		}
		let s=0;
		for(let i=0;i<len;i++)s+=arr[i];
		await partition(arr,0,len-1,s);
	}
	async cupcakeWrapperSort(len){
		let r;
		for(let l=len-1;l+1;l--){
			for(r=l;r>0;r--)
				if(compareIndices(arr,0,r)>0)
					await reversal(arr,0,r,0.1,true);
			await reversal(arr,0,len-1,0.1,true);
			await reversal(arr,0,len-2,0.1,true);
		}
	}
	async pancakeBogoSort(len){
		for(let i=len-1;i>=0;i--)
			while(!isMaxSorted(arr,0,i+1))
				await reversal(arr,0,randInt(0,i+1),1/len,true);
	}
	async cubeRootQuickSort(len){
		async function sort(A,s,e){
			let l=e-s;
			if(l>=2){
				let r=cbrt(l)|0;
				let nS=s+r;
				await sort(A,s,nS);
				let pv=new Array(r).fill(0);
				for(let i=0;i<r;i++)
					write(pv,i,i+s,0,false,true);
				for(let i=nS;i<e;i++){
					let a=0,b=r;
					while(a<b){
						let m=(b-a)/2+a|0;
						if(compareIndices(A,pv[m],i)>0)b=m;
						else a=m+1;
					}
					let p=i;
					for(let j=r-1;j>=a;j--){
						await swap(A,pv[j]+1,p,0,true);
						await swap(A,p=pv[j],pv[j]+1,0,true);
						write(pv,j,pv[j]+1,0,false,true);
					}
				}
				await sort(A,s,pv[0]);
				for(let i=1;i<r;i++)
					await sort(A,pv[i-1]+1,pv[i]);
				await sort(A,pv[r-1]+1,e);
			}
		}
		await sort(arr,0,len);
	}
	async magneticaQuickSort(len){
		let random=new Random();
		let rpv=false,mpv=false,none=false,ins=false;
		async function magnetica(A,l,r){
			let th=ins?17:0;
			let i,j,pl,pr,p,mm,cmp;
			let ln=r-l+1;
			let T=new Array(ln).fill(0);
			let spr=2,gr=0;
			let lb=l,rb=r;
			write(T,1,l,0,false,true);
			write(T,2,r,0,false,true);
			do{
				r=T[spr];
				l=T[spr-1];
				spr-=2;
				for(;l+th<r;){
					j=r;
					pl=pr=l;
					if(mpv||(mpv&&ins&&r-l>31)){
						mm=l+((r-l)>>2);
						if(!gr){
							await insertSort(A,mm,mm+3,0.5);
							await swap(A,mm+1,pr,2,true);
						}else{
							await insertSort(A,mm,mm+7,0.5);
							await swap(A,mm+3,pr,2,true);
						}
					}else if(rpv)await swap(A,random.nextInt(r-l)+l,pr,2,true);
					else await swap(A,(l+r)>>1,pr,2,true);
					p=A[pr];
					for(;pr<j;){
						cmp=compareValues(p,A[++pr]);
						if(cmp>0)await swap(A,pl++,pr,2,true);
						else if(cmp<0){
							for(;compareValues(p,A[j])<0;)j--;
							if(pr<j)await swap(A,pr,j,2,true);
							j--;
							pr--;
						}
					}
					j=pl-1;
					i=pr+1;
					if(ins)
						gr=maxVal(r-i,j-l)>(minVal(r-i,j-l)<<6)?1:0;
					if(i+th<r){
						spr+=2;
						write(T,spr-1,i,0,false,true);
						write(T,spr,r,0,false,true);
						if(ins){
							spr*=spr+2<ln?1:0;
							r*=spr+2<ln?1:0;
						}
					}
					r=j;
				}
			}while(spr);
			if(ins)
				await insertSort(A,lb,rb+1,.5);
		}
		let t=ask("Enter variant:\n1: Mid Pivot Standalone\n2: Mid Pivot + Insertion\n3: Mo3/7 Pivot Standalone\n4: Mo3/7 Pivot + Insertion\n5: Random Pivot Standalone\n6: Random Pivot + Insertion",4);
		if(t==3||t==4)mpv=true;
		if(t==5||t==6)rpv=true;
		if(t==1||t==3||t==5)none=true;
		else ins=true;
		await magnetica(arr,0,len-1);
	}
	async shellUnstableSingularityQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function unstablepd(A,s,e){
			let r=s;
			let d=false;
			let c=compareIndices(A,r,r+1);
			while(c+1&&r+1<e){
				if(c>0)d=true;
				c=compareIndices(A,++r,r+1);
			}
			if(r>s&&d){
				if(r<s+4)await swap(A,s,r,1,true);
				else await reversal(A,s,r,1,true);
			}
			return r;
		}
		async function shellPass(A,s,e,g){
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],0.25,w=true);
				if(w)await write(A,j,v,0.25,true);
			}
		}
		async function shell(A,s,e){
			let g=(e-s)/2|0;
			while(g>=2){
				await shellPass(A,s,e,g);
				g=g/2|0;
			}
			await shellPass(A,s,e,1);
		}
		async function singularityQuick(A,s,o,e,d,rp){
			if(d==dlim||rp==4)return await shell(A,s-1,e);
			if(e-s>ilim){
				let l=o;
				while(compareIndices(A,l-1,l)<1&&l<e)l++;
				if(l<e){
					let pvp=l-1;
					let pv=A[pvp];
					let op=pvp;
					let r=l+1;
					let i=1;
					let bl=false,bc=false,f=false;
					while(r<=e){
						if(compareValues(pv,A[r-1])>0){
							if(r-l==1){
								if(!f)i=A[l-1];
								f=true;
								await write(A,l-1,A[l],0.1,true);
							}else bl=true;
							if(bl&&!bc){
								await write(A,l-1,i,0.5,true);
								bc=true;
							}
							if(r-l>1)await swap(A,l-1,r-1,0.5,true);
							if(pvp==l-1)pvp=r-1;
							l++;
						}
						r++;
					}
					if(r>e&&!bl)await write(A,l-1,i,0.5,true);
					if(pvp-l+1)await swap(A,pvp,l-1,0.5,true);
					let lsm=l-s<e-(l+1);
					if(lsm&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
					if(e-l-1>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,l+1,l+1,e,d+1,rp+1);
						else await singularityQuick(A,l+1,l+1,e,d+1,0);
					}
					if(!lsm&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
				}
			}else await shell(A,s-1,e);
		}
		let dlim=minVal(sqrt(len),2*log2(len))|0;
		let ilim=maxVal(dlim/2-1,15)|0;
		let rlim=maxVal(dlim/4,2)|0;
		let rs=await unstablepd(arr,0,len);
		if(rs+1<len)
			await singularityQuick(arr,1,rs+1,len,0,0);
	}
	async singularityQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,0.075,true);
			else await reversal(A,s,e,0.05,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,0.75,true);
					else await reversal(A,l,r,0.75,true);
				}
				i++;
			}
		}
		async function pd(A,s,e){
			let r=s;
			let ls=false;
			let d=false;
			let c=compareIndices(A,r,r+1);
			while(c>=0&&r+1<e){
				if(c==0)ls=true;
				else d=true;
				c=compareIndices(A,++r,r+1);
			}
			if(r>s&&d){
				if(ls)await stableSegmentReversal(A,s,r);
				else if(r<s+3)await swap(A,s,r,0.75,true);
				else await reversal(A,s,r,0.75,true);
			}
			return r;
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binsert(A,s,e){
			await binaryInsertion(A,s-1,e,.1);
		}
		async function singularityQuick(A,s,o,e,d,rep){
			if(e-s>ilim&&d<dlim&&rep<4){
				let l=o;
				while(compareIndices(A,l-1,l)<1&&l<e)l++;
				if(l<e){
					let r=l+1;
					let p=1;
					let op=l-1;
					let pv=A[op];
					let bl=false,bc=false;
					while(r<=e){
						if(compareValues(pv,A[r-1])>0){
							if(r-l==1)await write(A,l-1,A[l],0.1,true);
							else bl=true;
							if(bl&&!bc)await write(A,l-1,pv,0.1,bc=true);
							if(r-l>1){
								p=r-1;
								let i=A[p];
								while(p>=l)await write(A,p,A[--p],0.1,true);
								await write(A,p,i,0.1,true);
							}
							l++;
						}
						r++;
					}
					if(r>e&&!bl)await write(A,l-1,pv,0.1,true,false);
					let ls=l-s<e-(l+1);
					if(ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rep+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
					if(e-(l+1)>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,l+1,l+1,e,d+1,rep+1);
						else await singularityQuick(A,l+1,l+1,e,d+1,0);
					}
					if(!ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rep+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
				}
			}else await binsert(A,s,e);
		}
		let dlim=minVal(sqrt(len),2*log2(len))|0;
		let ilim=maxVal(dlim/2-1,15)|0;
		let rlim=maxVal(dlim/4,2)|0;
		let rs=await pd(arr,0,len);
		if(rs+1<len)await singularityQuick(arr,1,rs+1,len,0,0);
	}
	async unboundedUnstableSingularityQuickSort(len){
		async function singularityQuick(A,s,o,e,d){
			let l=o;
			while(compareIndices(A,l-1,l,0.05,true)<=0&&l<e)l++;
			if(l<e&&d<2048&&!sorted){
				let pv=A[l-1];
				let pvp=l-1,op=l-1,r=l+1,i=1;
				let bl=false,bc=false,f=false;
				while(r<=e){
					if(compareValues(pv,A[r-1])>0){
						if(r-l==1){
							if(!f)i=A[l-1];
							f=true;
							await write(A,l-1,A[l],0.1,true);
						}else bl=true;
						if(bl&&!bc){
							await write(A,l-1,i,0.5,true);
							bc=true;
						}
						if(r-l>1)await swap(A,l-1,r-1,0.5,true);
						if(pvp==l-1)pvp=r-1;
						l++;
					}
					r++;
				}
				if(r>e&&!bl)await write(A,l-1,i,0.5,true);
				if(pvp-l+1)await swap(A,pvp,l-1,0.5,true);
				let ls=l-s<e-(l+1);
				if(ls&&(l-1)-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
				if(e-(l+1)>0)await singularityQuick(A,l+1,l+1,e,d+1);
				if(!ls&&(l-1)-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
			}else if(d==2048&&!sorted){
				await Sorts.prototype.unstableSingularityQuickSort(len);
				sorted=true;
			}
		}
		let full=len;
		let sorted=false
		await singularityQuick(arr,1,1,len,0);
	}
	async unboundedSingularityQuickSort(len){
		async function singularityQuick(A,s,o,e,d){
			let l=o;
			while(compareIndices(A,l-1,l)<1&&l<e)l++;
			if(l<e&&d<2047&&!sorted){
				let r=l+1,p=1,op=l-1;
				let pv=A[op];
				let bl=false,bc=false;
				while(r<=e){
					if(compareValues(pv,A[r-1])>0){
						if(r-l==1)await write(A,l-1,A[l],0.1,true);
						else bl=true;
						if(bl&&!bc)await write(A,l-1,pv,0.1,bc=true);
						if(r-l>1){
							p=r-1;
							let i=A[p];
							while(p>=l)await write(A,p,A[--p],0.1,true);
							await write(A,p,i,0.1,true);
						}
						l++;
					}
					r++;
				}
				if(r>e&&!bl)await write(A,l-1,pv,0.1,true);
				let ls=l-s<e-l-1;
				if(ls&&l-1-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
				if(e-l-1>0)await singularityQuick(A,l+1,l+1,e,d+1);
				if(!ls&&l-1-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
			}else if(!sorted){
				await Sorts.prototype.singularityQuickSort(len);
				sorted=true;
			}
		}
		let full=len;
		let sorted=false;
		await singularityQuick(arr,1,1,len,0);
	}
	async unstableSingularityQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function unstablepd(A,s,e){
			let r=s;
			let d=false;
			let c=compareIndices(A,r,r+1);
			while(c+1&&r+1<e){
				if(c>0)d=true;
				c=compareIndices(A,++r,r+1);
			}
			if(r>s&&d){
				if(r<s+3)await swap(A,s,r,0.75,true);
				else await reversal(A,s,r,0.75,true);
			}
			return r;
		}
		async function shuffle(A,s,e,x){
			let random=new Random(x*(x-s));
			for(let i=s;i<e;i++){
				let rI=random.nextInt(e-i)+i;
				if(rI-i)await swap(A,i,rI,0.1,true);
			}
		}
		async function binsert(A,s,e){
			await binaryInsertion(A,s-1,e,0.1);
		}
		async function singularityQuick(A,s,o,e,d,rd,rp){
			if(e-s>ilim&&(d==dlim||rp==4)){
				await shuffle(A,s-1,e-1,o);
				o=s;
				d=0;rp=0;
			}
			if(e-s>ilim&&d<dlim){
				let l=o;
				while(compareIndices(A,l-1,l)<1&&l<e)l++;
				if(l<e){
					let op=l-1,pvp=op,r=l+1,i=1;
					let pv=A[op];
					let bl=false,bc=false,f=false;
					while(r<=e){
						if(compareValues(pv,A[r-1])>0){
							if(r-l==1){
								if(!f)i=A[l-1];
								f=true;
								await write(A,l-1,A[l],0.1,true);
							}else bl=true;
							if(bl&&!bc)await write(A,l-1,i,0.5,bc=true);
							if(r-l>1)await swap(A,l-1,r-1,0.5,true);
							if(pvp==l-1)pvp=r-1;
							l++;
						}
						r++;
					}
					if(r>e&&!bl)await write(A,l-1,i,0.5,true);
					if(pvp!=l-1)await swap(A,pvp,l-1,0.5,true);
					let ls=l-s<e-(l+1);
					if(ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,0);
					}
					if(e-(l+1)>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,l+1,l+1,e,d+1,rd+1,rp+1);
						else await singularityQuick(A,l+1,l+1,e,d+1,rd+1,0);
					}
					if(!ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,0);
					}
				}
			}else await binsert(A,s,e);
		}
		let dlim=minVal(sqrt(len),2*log2(len))|0;
		let ilim=maxVal(dlim/2-1,15)|0;
		let rlim=maxVal(dlim/4,2)|0;
		let rs=await unstablepd(arr,0,len);
		if(rs+1<len)
			await singularityQuick(arr,1,rs+1,len,0,0,0);
	}
	async californiumSort(len){
		function sqrtrnd(v){
			let p=0;
			while(++p*p<v);
			return p;
		}
		async function californium(A,a,b,d){
			if(b-a==2)
				if(compareIndices(A,a,a+1)>0)
					await swap(A,a,a+1,1,true);
			if(--d<1){
				for(let i=a;++i<b;){
					if(compareIndices(A,i-1,i)>0){
						await swap(A,i-1,i,1,true);
						i=a;
					}
				}
				return;
			}
			if(a>=b-2)return;
			let R=[],M=[];
			let i=b,j,k,m,me=0,b0=b;
			let shd=false;
			bndchk:while(i>a+1){
				R.unshift(i=b0);
				M=[];
				for(k=sqrtrnd(i-a);k-->0;){
					shd=M.length&&compareIndexValue(A,a,M[0])+1;
					me=0;
					for(j=(m=a)+1;j<i;j++){
						let p=compareIndices(A,m,j);
						if(!p)me++;
						if(p<0||shd)
							if(M.length<1||compareIndexValue(A,j,M[0],1,true)<0){
								m=j;
								shd=false;
								me=0;
							}
					}
					if(shd)break bndchk;
					M.unshift(A[m]);
					k-=me;
				}
				cnt:for(j=b0=a;j<i;j++){
					for(let v of M){
						if(!compareIndexValue(A,j,v)){
							await reversal(A,b0,j-1,0.1,true);
							continue cnt;
						}
					}
					await reversal(A,b0,j-1,0.1,true);
					await reversal(A,a,b0-1,0.1,true);
					await multiSwap(A,j,b0++,0.1,true);
				}
			}
			if(me==b-a-1)return;
			j=a;
			for(k=0;k<R.length;k++)
				await californium(A,j,j=R[k],d);
		}
		await californium(arr,0,len,(32-clz32(len-1))/2|0);
	}
	async ternarySlowSort(len){
		async function cswap(A,s,e){
			if(compareIndices(A,s,e)>0)
				await swap(A,s,e,1,true);
		}
		async function sort(A,s,e){
			if(e-s==1)return await cswap(A,s,e,1);
			if(e-s+1>2){
				let t=(e-s+1)/3|0;
				let m1=s+t,m2=s+2*t;
				await sort(A,s,m1-1);
				await sort(A,m1,m2-1);
				await sort(A,m2-1,e);
				await cswap(A,m1-1,e,1);
				await cswap(A,m1-1,m2-1,1);
				await cswap(A,m2-1,e,1);
				await sort(A,s,e-1);
			}
		}
		await sort(arr,0,len-1);
	}
	async napoleonSort(len){
		async function tilsit(A,l){
			for(let i=0,j=l-1;i<l/2|0;i++,j--)
				if(compareIndices(A,i,j)>0)
					await swap(A,i,j,0.01,true);
		}
		async function napoleon(A,e){
			let lo=0;
			let hi=e;
			let p=A[0];
			let g=true;
			let n=false;
			while(hi>lo){
				if(g){
					let nx=lookEast(A,p,lo+1,hi);
					if(nx==lo){
						if(n){
							lo++;
							hi--;
						}
						p=A[(g=n)?lo:hi];
						n=!n;
					}else if(nx==hi){
						p=A[hi];
						await conquer(A,hi,lo);
						n=false;
					}else{
						p=A[nx];
						await conquer(A,nx,hi);
						n=g=false;
					}
				}else{
					let nx=lookWest(A,p,hi-1,lo);
					if(nx==hi){
						if(n){
							lo++;
							hi--;
						}
						p=A[lo];
						g=true;
						n=!n;
					}else if(nx==lo){
						p=A[lo];
						await conquer(A,lo,hi);
						n=false;
					}else{
						p=A[nx];
						await conquer(A,nx,lo);
						n=false;
						g=true;
					}
				}
			}
		}
		function lookEast(A,p,s,e){
			for(let i=s;i<=e;i++){
				if(compareValues(A[i],p)<0)
					return i;
			}
			return s-1;
		}
		function lookWest(A,p,s,e){
			for(let i=s;i>=e;i--){
				if(compareValues(A[i],p)>0)
					return i;
			}
			return s+1;
		}
		async function conquer(A,i,t){
			let bZ=1;
			while(i+bZ-1<t){
				let mT=recruit(A,A[i],i+bZ,t);
				let s=mT-i-bZ+1;
				await march(A,i,bZ,s);
				i+=s;
				bZ++;
			}
			while(i-bZ+1>t){
				let mT=recruit(A,A[i],i-bZ,t);
				let s=i-bZ-mT+1;
				await march(A,mT,s,bZ);
				i-=s;
				bZ++;
			}
		}
		function recruit(A,iT,s,e){
			if(s<e){
				for(let i=s;i<=e;i++)
					if(!compareValues(A[i],iT))
						return i-1;
				return e;
			}
			for(let i=s;i>=e;i--)
				if(!compareValues(A[i],iT))
					return i+1;
			return e;
		}
		async function march(A,i,l1,l2){
			while(l1&&l2){
				if(l1<=l2){
					await attack(A,i,i+l1,l1);
					i+=l1;
					l2-=l1;
				}else{
					await attack(A,i+l1,i+l1-l2,l2);
					l1-=l2;
				}
			}
		}
		async function attack(A,a,b,l){
			while(l--)
				await swap(A,a++,b++,1,true);
		}
		await tilsit(arr,len);
		await napoleon(arr,len-1);
	}
	async gnomeWeaveHighSort(len){
		let g=len;
		let ic=1,i=1,b=1,ti=2,tr=1;
		let t=false,f=false;
		while(!f){
			i=b=ic;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await swap(arr,i-1,i-1+g,0.25,true);
					if(i-g>0)i-=g;
				}else{
					b+=g;
					i=b;
				}
			}
			f=g==1;
			if(ic+1>g&&!f){
				tr=g;
				while(tr-1){
					t=false;
					ti=2;
					while(!t){
						if((tr/ti|0)==tr/ti){
							tr=tr/ti;
							t=true;
						}else ti++;
					}
				}
				g=g/ti|0;
				ic=1;
			}else ic++;
		}
	}
	async gnomeWeaveLowSort(len){
		let g=len;
		let ic=1,i=1,b=1,ti=2,tr=1;
		let t=false,f=false;
		while(!f){
			i=b=ic;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await swap(arr,i-1,i-1+g,0.25,true);
					if(i-g>0)i-=g;
				}else{
					b+=g;
					i=b;
				}
			}
			f=g==1;
			if(ic+1>g&&!f){
				tr=g;
				while(tr==g){
					t=false;
					ti=2;
					while(!t){
						if((tr/ti|0)==tr/ti){
							tr=tr/ti;
							t=true;
						}else ti++;
					}
				}
				g=g/ti|0;
				ic=1;
			}else ic++;
		}
	}
	async grateSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let i=0;i<len-1;i++){
				for(let j=len-1;j>i;j--){
					if(compareIndices(arr,i,j)>0){
						s=false;
						await swap(arr,i,j,0.1,true);
						break;
					}
				}
			}
		}
	}
	async inOrderShoveSort(len){
		let l=0,p=0,r,j=0;
		while(l<len){
			r=l+1;
			while(r<len){
				if(compareIndices(arr,l,r)>0){
					p=l;
					while(p+1<len){
						swap(arr,p,++p,0.125);
						if(++j>=len){
							mark(p-1);
							await sleep(j=0);
						}
					}
					r=l+1;
				}else r++;
			}
			l++;
		}
	}
	async iterativeQuickSort(len){
		async function partition(A,l,h){
			let p=A[h],i=l-1;
			for(let j=l;j<=h-1;j++)
				if(compareValues(A[j],p)<1)
					await swap(A,++i,j,1,true);
			await swap(A,i+1,h,1,true);
			return i+1;
		}
		async function quickSort(A,s,e){
			let l=e-s+1,S=new Array(l),t=-1;
			write(S,++t,s,0,false,true);
			write(S,++t,e,0,false,true);
			while(t>=0){
				e=S[t--];
				s=S[t--];
				let p=await partition(A,s,e);
				if(compareValues(p-1,s)>0){
					write(S,++t,s,0,false,true);
					write(S,++t,p-1,0,false,true);
				}
				if(compareValues(p+1,e)<0){
					write(S,++t,p+1,0,false,true);
					write(S,++t,e,0,false,true);
				}
			}
		}
		await quickSort(arr,0,len-1);
	}
	async swapMapSort(len){
		let map=[],j=0;
		while(1){
			for(let i=0;i<len-1;i++)
				if(compareIndices(arr,i,i+1)>0)
					map.push(i);
			if(!map.length)break;
			for(let i=0;i<map.length;i++){
				swap(arr,map[i],map[i]+1);
				if(++j>=len){
					mark(map[i]);
					await sleep(j=0);
				}
			}
			map=[];
		}
	}
	async triSearchGnomeSort(len){
		function triSearch(A,l,h,v){
			let m=l+(h-l)/2|0;
			if(compareValues(v,A[l])<0)return l;
			else{
				if(compareValues(v,A[h])<0){
					if(compareValues(v,A[m])<0)
						return triSearch(A,l+1,m-1,v);
					else
						return triSearch(A,m+1,h-1,v);
				}else return h+1;
			}
		}
		async function triGnomeSort(A,s,e){
			for(let i=s+1;i<e;i++){
				let o=triSearch(A,s,i-1,A[i]);
				let j=i;
				while(j>o)
					await swap(A,j,--j,1,true);
			}
		}
		await triGnomeSort(arr,0,len);
	}
	async moreOptimizedBubbleSort(len){
		let c=1,s,f=1,a=false;
		for(let j=len-1;j>0;j-=c){
			s=f<1?0:f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,1,true);
					if(!a)f=i;
					a=true;
					c=1;
				}else c++;
			}
		}
	}
	async oddEvenWeaveHighSort(len){
		let c=1,lb=2,lm=len,m=len,ns=0,g=len,ti=2,i=1,bi=1,tr=1;
		let t=false,as=false,tp=false,v=true;
		while(!tp){
			i=c;
			as=false;
			while((i-1)+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0)
					await swap(arr,i-1,(i-1)+g,0.25,as=true);
				i+=m;
			}
			if(!as&&g-1){
				if(++ns==m){
					ns=0;
					lm=tr=m;
					if(!v){
						while(tr-1){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						m=m/ti|0;
					}
					v=false;
					if(m-1){
						tr=m;
						while(tr-1){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						g=m/ti|0;
					}else{
						m=lm;
						g=1;
					}
					c=0;
				}
			}else ns=0;
			if(g==1){
				bi=lb>1?lb-1:1;
				tp=true;
				while(bi<len&&tp){
					if(compareIndices(arr,bi-1,bi)<1)bi++;
					else{
						tp=false;
						lb=c=bi;
					}
				}
			}else c=c%m+1;
		}
	}
	async oddEvenWeaveLowSort(len){
		let c=1,lb=2,lm=len,m=len,ns=0,g=len,ti=2,i=1,bi=1,tr=1;
		let t=false,as=false,tp=false,v=true;
		while(!tp){
			i=c;
			as=false;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0)
					await swap(arr,i-1,i-1+g,0.25,as=true);
				i+=m;
			}
			if(!as&&g-1){
				if(++ns==m){
					ns=0;
					lm=tr=m;
					if(!v){
						while(tr==m){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						m=m/ti|0;
					}
					v=false;
					if(m-1){
						tr=m;
						while(tr==m){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						g=m/ti|0;
					}else{
						m=lm;
						g=1;
					}
					c=0;
				}
			}else ns=0;
			if(g==1){
				if(lb>1)bi=lb-1;
				else bi=1;
				tp=true;
				while(bi<len&&tp){
					if(compareIndices(arr,bi-1,bi)<1)bi++;
					else{
						tp=false;
						lb=c=bi;
					}
				}
			}else c=c%m+1;
		}
	}
	async stableStoogeSort(len){
		async function stableStooge(A,s,e){
			if(e-s+1==2){
				if(compareIndices(A,s,e)>0)
					await swap(A,s,e,0.005,true);
			}else if(e-s+1>2){
				let t=(e-s+1)/3|0;
				await stableStooge(A,s,e-t);
				await stableStooge(A,s+t,e);
				await stableStooge(A,s,e-t);
			}
		}
		await stableStooge(arr,0,len-1);
	}
	async indexMergeSort(len){
		async function indexSort(A,I,a,b){
			while(a<b){
				if(compareValues(a,I[a])){
					let t=A[a];
					let i=a,n=I[a];
					do{
						await write(A,i,A[n],0,true);
						write(I,i,i,0,false,true);
						n=I[i=n];
					}while(compareValues(n,a));
					await write(A,i,t,0,true);
					write(I,i,i,0,false,true);
				}
				a++;
			}
		}
		function merge(A,I,a,m,b){
			let i=a,j=m,c=a;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)write(I,c++,i++,0,false,true);
				else write(I,c++,j++,0,false,true);
			while(i<m)write(I,c++,i++,0,false,true);
			while(j<b)write(I,c++,j++,0,false,true);
			return indexSort(A,I,a,b);
		}
		async function sort(A,I,a,b){
			if(b-a<2)return;
			let m=(a+b)/2|0;
			await sort(A,I,a,m);
			await sort(A,I,m,b);
			await merge(A,I,a,m,b);
		}
		await sort(arr,new Array(len),0,len);
	}
	async fallSort(len){
		let j=0,h=0,l=1,r=2;
		while(l<=len){
			r=l+1;
			h=0;
			while(r<=len){
				if(compareIndices(arr,l-1,r-1)>0){
					if(!h)h=r;
					else if(compareIndices(arr,h-1,r-1)<0)h=r;
				}
				r++;
			}
			if(!h)l++;
			else{
				swap(arr,l-1,h-1,0);
				if(++j>=sqrt(len)){
					mark(l-1);
					await sleep(j=0);
				}
			}
		}
	}
	async ecoloSort(len){
		let l=1,r=len,w=1,i=1;
		while(l<=r){
			if(w>0)i=l;
			else i=r;
			while(w>0&&i<r||w<0&&i>l){
				if(compareIndices(arr,l-1,i-1)>0)await swap(arr,l-1,i-1,0.05,true);
				if(compareIndices(arr,i-1,r-1)>0)await swap(arr,i-1,r-1,0.05,true);
				i+=w;
			}
			l++;r--;w=-w;
		}
	}
	async stupidFireSort(len){
		let i=1,j=0,a=0,b=0,c=-1,d=1;
		let p=false,r=false,s=false;
		while(!p){
			if(b<1){
				b=++a;c=-c;
			}else b--;
			s=false;
			while(i<len&&i>0&&!s){
				if(compareIndices(arr,i-1,i)*c>0){
					swap(arr,i-1,i,0);
					s=true;
					if(++j>=len){
						mark(i-1);
						await sleep(j=0);
					}
					i-=c;
				}else i+=c;
			}
			if(i<1){
				i=len-1;
				d=1;p=true;
				while(d-len&&p){
					if(compareIndices(arr,d-1,d)<1)d++;
					else{
						p=false;d=1;r=!p;
						while(d-len&&r){
							if(compareIndices(arr,d,d-1)<1)d++;
							else r=false;
						}
					}
				}
				if(r){
					i=1;b=0;
				}
			}
			if(i>=len){
				i=d=1;
				p=true;
				while(d-len&&p){
					if(compareIndices(arr,d-1,d)<1)d++;
					else{
						p=false;d=1;r=!p;
						while(d-len&&r){
							if(compareIndices(arr,d-1,d)+1)d++;
							else r=false;
						}
					}
				}
				if(r){
					i=len-1;
					b=0;
				}
			}
		}
	}
	async stacklessQuickSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function partition(A,a,b){
			let i=a,j=b;
			await medianOfThree(A,a,b);
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)+1);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,a,j,1,true);
					return j;
				}
			}
		}
		function leftBinSearch(A,a,b,p){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,p,m)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function quickSort(A,a,b){
			let x=A[a];
			for(let i=a+1;i<b;i++)
				if(compareValues(A[i],x)>0)x=A[i];
			for(let i=b-1;i+1;i--)
				if(!compareValues(A[i],x))
					await swap(A,i,--b,1,true);
			let b1=b;
			while(1){
				while(b1-a>2){
					let p=await partition(A,a,b1);
					await swap(A,b1=p,b,1,true);
				}
				if(b1-a==2&&compareIndices(A,a,a+1)>0)
					await swap(A,a,a+1,1,true);
				a=b1+1;
				if(a>=b){
					if(a-1<b)await swap(A,a-1,b,1,true);
					return;
				}
				b1=leftBinSearch(A,a,b,a-1);
				await swap(A,a-1,b,1,true);
				while(a<b1&&!compareIndices(A,a-1,a))a++;
			}
		}
		await quickSort(arr,0,len);
	}
	async stableQuickSortMiddlePivot(len){
		async function copy(l,A,i){
			for(let n of l)
				await write(A,i++,n,0,true);
		}
		async function stablePartition(A,s,e){
			let p=s+(e-s)/2|0;
			let pV=A[p];
			let lL=[],rL=[];
			for(let i=s;i<=e;i++){
				if(i==p)continue;
				if(compareValues(A[i],pV)<0)lL.push(A[i]);
				else rL.push(A[i]);
			}
			await copy(lL,A,s);
			let nP=s+lL.length;
			await write(A,nP,pV,0.25);
			await copy(rL,A,nP+1);
			return nP;
		}
		async function stableQuickSort(A,s,e){
			if(s<e){
				let p=await stablePartition(A,s,e);
				await stableQuickSort(A,s,p-1);
				await stableQuickSort(A,p+1,e);
			}
		}
		await stableQuickSort(arr,0,len-1);
	}
	async optimizedZipperSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function ending(A,f,ln){
			let r=f;
			if(r<1)r++;
			while(r<ln){
				if(compareIndices(A,r-1,r)>0){
					let l=binarySearch(A,0,r-1,A[r]);
					while(l<r)await swap(A,l++,r,0.05,true);
				}
				r++;
			}
		}
		let i=0,f=0,g=len;
		while(g>maxVal(2*log2(len),sqrt(len)|0)){
			g=1;
			i=f>1?f-1:0;
			while(i+g<len){
				if(compareIndices(arr,i,i+g)>0){
					await swap(arr,i,i+g,0.1,true);
					if(g++==1)f=i;
				}else i++;
			}
		}
		if(g-1)await ending(arr,f,len);
	}
	async reverseBubbleSort(len){
		for(let i=0;i<len-1;i++){
			let s=true;
			for(let j=len-1;j>i;j--){
				if(compareIndices(arr,j-1,j)>0){
					await swap(arr,j-1,j,0.075,true);
					s=false;
				}
			}
			if(s)break;
		}
	}
	async optimizedGrateSort(len){
		let b=len-1,l=0,r=len-1,fs=0,ls=0,t=len-1;
		let s=false,h=false;
		while(!s){
			if(!s){
				while(!h){
					if(t<l){
						t=r;
						if(--b<r)h=true;
					}else{
						if(compareIndices(arr,t,b)>0)h=true;
						else t--;
					}
				}
			}
			s=true;
			for(let i=l;i<r;i++){
				for(let j=b;j>i;j--){
					if(compareIndices(arr,i,j)>0){
						if(s)fs=i;
						ls=i;
						s=false;
						await swap(arr,i,j,0.125,true);
						break;
					}
				}
			}
			b--;t=r;l=fs;r=ls+1;h=false;
		}
	}
	async pseudoHeapSort(len){
		async function sd(A,s,l,r){
			let w=false,j=r;
			while(2*j<l){
				let k=2*j;
				if(k<l&&compareIndices(A,s+k-1,s+k)>0)k++;
				if(compareIndices(A,s+j-1,s+k-1)>0){
					await swap(A,s+j-1,s+k-1,1,true);
					j=k;
					w=true;
					continue;
				}
				break;
			}
			return w;
		}
		function sift(A,s,e){
			return sd(A,s,e-s+1,1);
		}
		let s=true;
		while(s){
			s=false;
			for(let i=len-2;i+1;i--)if(await sift(arr,i,len))s=true;
		}
	}
	async split16MergeSort(len){
		let meds=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
		async function cS1(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function cS2(A,a,b,g,s){
			if(compareIndices(A,s+a*g,s+b*g)>0){
				await swap(A,s+a*g,s+b*g,0.5,true);
			}
		}
		async function medianOfSixteen(A,a,g){
			for(let i=0;i<meds.length;i+=2)
				await cS2(A,meds[i]-1,meds[i+1]-1,g,a);
		}
		async function merge(A,s,z){
			let g=z/16|0;
			for(let i=0;i<g;i++)
				await medianOfSixteen(A,s+i,g);
			for(let h=g/2|0;h>0;h=h/2|0)
				for(let i=0;i<z-h;i++)
					await cS1(A,s+i,s+i+h);
		}
		for(let i=0;i<len-15;i+=16)
			await medianOfSixteen(arr,i,1);
		let g;
		for(g=32;g<=len;g*=2)
			for(let i=0;i+g<=len;i+=g)
				await merge(arr,i,g);
	}
	async moduloMergeSort(len){
		async function merge(A,s,m,e,xE){
			let l=s;
			let r=m+1;
			let f=s;
			while(l<=m&&r<=e){
				if(compareValues(A[l]%xE,A[r]%xE)<1)
					await write(A,f,A[f]+(A[l++]%xE)*xE,1,true);
				else
					await write(A,f,A[f]+(A[r++]%xE)*xE,1,true);
				f++;
			}
			while(l<=m)await write(A,f,A[f++]+(A[l++]%xE)*xE,1,true);
			while(r<=e)await write(A,f,A[f++]+(A[r++]%xE)*xE,1,true);
			for(let i=s;i<=e;i++)
				await write(A,i,A[i]/xE,1,true);
		}
		async function mergeSort(A,s,e,xE){
			if(s<e){
				let m=s+(e-s)/2|0;
				await mergeSort(A,s,m,xE);
				await mergeSort(A,m+1,e,xE);
				await merge(A,s,m,e,xE);
			}
		}
		await mergeSort(arr,0,len-1,maxVal(...arr)+1);
	}
	async partialMergeSort(len){
		async function merge(A,c,lS,rS,e){
			arraycopy(A,lS,c,0,rS-lS,0,false,true);
			let l=lS,r=rS;
			for(let n=0;n<e-lS;n++){
				if(l>=rS&&r>=e)break;
				if(l<rS&&r>=e)await write(A,n+lS,c[l++-lS],1,true);
				else if(l>=rS&&r<e)await write(A,n+lS,A[r++],1,true);
				else if(compareValues(c[l-lS],A[r])<1)await write(A,n+lS,c[(l++)-lS],1,true);
				else await write(A,n+lS,A[r++],1,true);
			}
		}
		async function mergeRun(A,c,s,m,e){
			if(s==m)return;
			await mergeRun(A,c,s,(m+s)/2|0,m);
			await mergeRun(A,c,m,(m+e)/2|0,e);
			await merge(A,c,s,m,e);
		}
		let m=len/2|0;
		await mergeRun(arr,new Array(m),0,m,len);
	}
	async mobMergeSort(len){
		async function bubble(A,st,e){
			let c=1,s,f=st+(e-st)/2|0;
			let a=false;
			for(let j=e-1;j>0;j-=c){
				s=f-1<st?st:f-1;
				a=false;
				c=1;
				for(let i=s;i<j;i++){
					if(compareIndices(A,i,i+1)>0){
						await swap(A,i,i+1,0.075,true);
						if(!a)f=i;
						a=true;
						c=1;
					}else c++;
				}
			}
		}
		async function sort(A,ln){
			let l=2,i=0;
			while(l<=ln){
				i=0;
				while(i+l<=ln){
					if(l==2){
						if(compareIndices(A,i,i+1)>0)await swap(A,i,i+1,0.075,true);
					}else await bubble(A,i,i+l);
					i+=l;
				}
				if(i-ln)await bubble(A,i,ln);
				l*=2;
			}
			await bubble(A,0,ln);
		}
		await sort(arr,len);
	}
	async optimizedPancakeSort(len){
		async function flip(A,i){
			await reversal(A,0,i,0.1,true);
		}
		async function cursedRotate(A,a,m,b){
			await flip(A,a-1);
			await flip(A,m-1);
			await flip(A,b-1);
			await flip(A,b-m+a-1);
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function pancakeMerge(A,m,b){
			let m1,m2,m3;
			if(m>=b-m){
				m1=m/2|0;
				m2=binarySearch(A,m,b,A[m1],false);
				m3=m1+(m2-m);
			}else{
				m2=m+(b-m)/2|0;
				m1=binarySearch(A,0,m,A[m2],true);
				m3=(m2++)-(m-m1);
			}
			await cursedRotate(A,m1,m,m2);
			if(m1>0&&m3>m1)await pancakeMerge(A,m1,m3);
			m3++;
			if(m2>m3&&b>m2){
				await cursedRotate(A,0,m3,b);
				await pancakeMerge(A,m2-m3,b-m3);
				await cursedRotate(A,0,b-m3,b);
			}
		}
		async function pancakeMergeSort(A,n){
			if(n>1){
				if(compareIndices(A,0,1)<1){
					let i=2;
					for(;i<n&&compareIndices(A,i-1,i)<1;i++);
					if(i==n)return;
				}else{
					let i=2;
					for(;i<n&&compareIndices(A,i-1,i)>0;i++);
					if(i==n){
						await flip(A,n-1);
						return;
					}
				}
				let m=n/2|0;
				await pancakeMergeSort(A,m);
				await cursedRotate(A,0,m,n);
				m=n-m;
				await pancakeMergeSort(A,m);
				await pancakeMerge(A,m,n);
			}
		}
		await pancakeMergeSort(arr,len);
	}
	async transposeModuloWeaveMergeSort(len){
		async function weave(A,p,s,l,b){
			let v=0;
			for(let i=0;i<b;i++)
				for(let j=i;j<l;j+=b)
					write(p,v++,A[s+j],0,false,true);
			await arraycopy(p,0,A,s,l,0.25,true);
		}
		async function circle(A,a,b){
			let l=a,r=b;
			while(l<r){
				if(compareIndices(A,l,r)>0)await swap(A,l,r,0.25,true);
				l++;r--;
			}
		}
		async function circlepass(A,s,l){
			let g=l;
			while(g>1){
				for(let o=0;o+g-1<l;o+=g)
					await circle(A,s+o,s+o+g-1);
				g=g/2|0;
			}
		}
		async function method(A,s,l){
			let p=new Array(l);
			if(compareIndices(A,s+l/2-1|0,s+l/2|0)>0){
				await weave(A,p,s,l,l/2|0);
				await circlepass(A,s,l);
			}
		}
		async function sort(A,ln){
			let l=2,i=0;
			while(l<ln){
				i=0;
				while(i+l-1<ln){
					if(l==2){
						if(compareIndices(A,i,i+1)>0)await swap(A,i,i+1,0.25,true);
					}else await method(A,i,l);
					i+=l;
				}
				l*=2;
			}
			if(l-ln)await Sorts.prototype.quadSort(len);
			else await method(A,0,ln);
		}
		await sort(arr,len);
	}
	async reverseLazyStableSort(len){
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function merge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function sort(A,l){
			for(let i=0;i<l-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,0,true);
			let g;
			for(g=4;g<=l;g*=2)
				for(let i=0;i+g<=l;i+=g)
					await merge(A,i,i+g/2|0,i+g);
			if((l-g/2|0)>0)
				await merge(A,0,g/2|0,l);
		}
		await sort(arr,len);
	}
	async lazyStableQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function findPivot(A,s,m,e){
			if(compareIndices(A,s,m)<0){
				if(compareIndices(A,m,e)<0)return m;
				else if(compareIndices(A,s,e)<0)return e;
				return s;
			}else{
				if(compareIndices(A,m,e)>0)return m;
				else if(compareIndices(A,s,e)<0)return s;
				return e;
			}
		}
		async function stablePartition(A,s,e){
			let m=s+(e-s)/2|0;
			let pvp=findPivot(A,s,m,e-1);
			while(1){
				let pv=A[pvp];
				let ltL=s;
				let r=s;
				let z=0;
				let qC=0;
				for(let i=s;i<e;i++){
					let c=compareValues(A[i],pv);
					if(c<0){
						z++;
						continue;
					}else if(!c)qC++;
					if(z>0&&r>s)await rotateSmart(A,r,ltL,z);
					ltL+=z;
					r=i+1;
					z=0;
				}
				if(qC==e-s)return-1;
				if(z>0){
					await rotateSmart(A,r,ltL,z);
					ltL+=z;
				}
				if(ltL==s){
					if(++pvp==e)pvp=s;
					while(!compareValueIndex(A,pv,pvp))
						if(++pvp==e)pvp=s;
					continue;
				}
				return ltL;
			}
		}
		async function stableQuickSort(A,s,e,d){
			while(e-s>16){
				if(!d)return await binaryDoubleInsertion(A,s,e);
				let i=await stablePartition(A,s,e);
				if(i==-1)return;
				let l=i-s,r=e-i;
				if(l>r){
					await stableQuickSort(A,i,e,--d);
					e=i;
				}else await stableQuickSort(A,s,s=i,--d);
			}
			await insertSort(A,s,e,.25);
		}
		await stableQuickSort(arr,0,len,2*log2(len));
	}
	async optimizedBubbleBogoSort(len){
		let s=0,e=len-1,j=0;
		while(compareIndices(arr,s,s+1)<1&s<=e)s++;
		while(compareIndices(arr,e-1,e)<1&&s<=e)e--;
		while(s<=e){
			let i=randInt(s,e);
			if(compareIndices(arr,i,i+1)>0){
				swap(arr,i,i+1,1);
				if(++j>=sqrt(len)){
					markSwap(i,i+1);
					await sleep(j=0);
				}
				if(i==s){
					if(s>0)s--;
					while(compareIndices(arr,s,s+1)<1&&s<=e)s++;
				}
				if(i==e-1){
					if(e<len-1)e++;
					while(compareIndices(arr,e-1,e)<1&&s<=e)e--;
				}
			}
		}
	}
	async reversePushSort(len){
		let as=true,i=len,g=1;
		while(as){
			as=false;i=len;g=1;
			while(i-g>0){
				if(compareIndices(arr,i-1-g,i-1)>0){
					mark(i);
					await sleep();
					for(let j=1;j<=g;j++)
						swap(arr,i-1,i-1-j,0);
					as=true;
					g++;
				}else i--;
			}
		}
	}
	async reverseGrateSort(len){
		let s=false,k=0;
		while(!s){
			s=true;
			for(let i=0;i<len-1;i++){
				for(let j=i+1;j<len;j++){
					if(compareIndices(arr,i,j)>0){
						s=false;
						swap(arr,i,j,1);
						if(++k>=sqrt(len)){
							markSwap(i,j);
							await sleep(k=0);
						}
						break;
					}
				}
			}
		}
	}
	async optimizedCocktailGrateSort(len){
		let aB=len-1,aR=len-1,aT=len-1,bB=len-1;
		let l=0,aF=0,aL=0,bF=0,bL=0;
		let s=false,aH=false;
		while(!s){
			if(!s)
				while(!aH)
					if(aT<l){
						aB--;aT=aR;
						if(aB<aR)aH=true;
					}else{
						if(compareIndices(arr,aT,aB)>0)aH=true;
						else aT--;
					}
			s=true;
			for(let i=l;i<aR;i++)
				for(let j=aB;j>i;j--)
					if(compareIndices(arr,i,j)>0){
						if(s)aF=i;
						aL=i;s=false;
						await swap(arr,i,j,0.125,true);
						break;
					}
			bB--;aT=aR;aH=false;l=aF;aR=aL+1;
			if(s)break;
			s=true;
			for(let i=l;i<bB;i++)
				for(let j=i+1;j<=bB;j++)
					if(compareIndices(arr,i,j)>0){
						if(s)bF=i;
						bL=i;s=false;
						await swap(arr,i,j,0.125,true);
						break;
					}
			bB=bL;l=bF;aB=bB;
		}
	}
	async PDGnomeSort(len){
		async function gnomeSort(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let p=i++;
				while(p>a&&compareIndices(A,p-1,p)>0)
					await swap(A,p--,p,1,true);
			}
		}
		await gnomeSort(arr,0,len);
	}
	async reverseGnomeSort(len){
		async function reverseGnomeSort(A,l,u){
			let p=l;
			while(p<u&&compareIndices(A,p,p+1)>0)
				await swap(A,p++,p,1,true);
		}
		for(let i=len-1;i>=0;i--)
			await reverseGnomeSort(arr,i,len-1);
	}
	async optimizedReverseGrateSort(len){
		let b=len-1,l=0,f=0,t=0,k=0;
		let s=false;
		while(!s){
			s=true;
			for(let i=l;i<b;i++){
				for(let j=i+1;j<=b;j++){
					if(compareIndices(arr,i,j)>0){
						if(s)f=i;
						t=i;s=false;
						swap(arr,i,j,0);
						if(++k>=sqrt(len)){
							markSwap(i,j);
							await sleep(k=0);
						}
						break;
					}
				}
			}
			b=t;l=f;
		}
	}
	async strangePushSort(len){
		let base=askForBase(2);
		let as=true;
		let i=1,g=1;
		while(as){
			as=false;
			i=g=1;
			while(i+g<=len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					mark(i);
					await sleep();
					for(let j=1;j<=g;j++)
						swap(arr,i-1,i-1+j,0);
					as=true;
					g*=base;
				}else i++;
			}
		}
	}
	async safeBogoSort(len){
		function minSorted(A,l){
			let i=1;
			for(;i<l&&compareIndices(A,i-1,i)<1;i++);
			return i-1;
		}
		let r=new Random();
		let p=minSorted(arr,len),j=0;
		while(p<len-1){
			swap(arr,p,p+r.nextInt(len-p),0);
			if(++j>=sqrt(len)){
				mark(p);
				await sleep(j=0);
			}
			p=minSorted(arr,len);
		}
	}
	async heavyHeapSort(len){
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		let d=true;
		for(let i=0;i<len;i++)
			await new HeapSorting(d=!d).heapify(arr,i,len,.1);
		for(let i=1,j=len-1;i<j;i+=2,j-=2)
			await swap(arr,i,j,1,true);
		await bitReversal(arr,0,len);
		await bitReversal(arr,0,len/2|0);
		await bitReversal(arr,len/2|0,len);
	}
	async unbelievableSort(len){
		for(let i=0,k=0;i<len;i++)
			for(let j=0;j<len;j++)
				if(compareIndices(arr,i,j)<0){
					swap(arr,i,j,0);
					if(++k>=len/4){
						markSwap(i,j);
						await sleep(k=0);
					}
				}
	}
	async naturalMergeSort(len){
		async function merge(A,l,r,e){
			let f=true,i=0,s=0,oR=r,oL=l;
			while(l<oR&&r<e)
				if(compareIndices(A,l,r)>0)
					write(mr,i++,A[r++],0,f=false,true);
				else
					if(f){
						s++;i++;l++;
					}else write(mr,i++,A[l++],0,false,true);
			while(l<oR)write(mr,i++,A[l++],0,false,true);
			for(let j=s;j<i;j++)
				await write(A,j+oL,mr[j],1,true);
		}
		let mr=new Array(len);
		async function sort(A,l){
			let d=false,s=0,e=l-1;
			while(!d){
				let p=0,f=-1;
				d=true;
				for(let i=s;i<e;i++)
					if(compareIndices(A,i,i+1)>0){
						if(f+1){
							await merge(A,f,p,p=i+1);
							if(d)s=i;
							f=-1;
							d=false;
						}else{
							f=p;
							p=i+1;
						}
					}
				if(f+1){
					await merge(A,e=f,p,l);
					d=false;
				}
			}
		}
		await sort(arr,len);
	}
	async outOfPlaceWeaveMergeSort(len){
		async function weave(A,T,s,e){
			let s2=s/2|0,e2=e/2|0;
			for(let i=0;i<=e-s;i+=2)
				await write(A,s+i,T[s+i/2|0],0.25,true);
			for(let i=1;i<=e-s;i+=2)
				await write(A,s+i,T[s2+i/2+e2+1|0],0.25,true);
		}
		function merge(A,T,s,e){
			let i=s,j=s+1,p=s;
			while(i<=e&&j<=e){
				if(compareIndices(A,i,j)>0){
					write(T,p,A[j],0,false,true);
					j+=2;
				}else{
					write(T,p,A[i],0,false,true);
					i+=2;
				}
				p++;
			}
			let k=i<j?i:j;
			console.log(k==minVal(i,j));
			while(k<=e){
				write(T,p++,A[k],0,false,true);
				k+=2;
			}
		}
		async function controller(A,T,s,e){
			if(e-s>=2){
				await controller(A,T,s,(e+s-1)/2|0);
				await controller(A,T,(e+s+1)/2|0,e);
			}
			await weave(A,T,s,e);
			merge(A,T,s,e);
		}
		let T=new Array(len);
		for(let i=0;i<len;i++)write(T,i,arr[i],0,false,true);
		await controller(arr,T,0,len-1);
		for(let i=0;i<len;i++)
			await write(arr,i,T[i],0,true);
	}
	async tumbleweedSort(len){
		let l=1,h=1,r=2,p=1,j=0;
		let a=false;
		while(l-len){
			h=l;
			r=l+1;
			while(r<=len){
				if(compareIndices(arr,l-1,r-1)<1){
					if(h==l)h=r;
					else{
						if(compareIndices(arr,h-1,r-1)>0)h=r;
					}
				}
				r++;
			}
			p=l;
			if(h==l)
				while(p<len){
					swap(arr,p-1,p++,0);
					if(++j>=len){
						mark(p-2);
						await sleep(j=0);
					}
				}
			else{
				if(h==l+1){
					r=l+1;
					a=false;
					while(r<=len&&!a)
						if(compareIndices(arr,l-1,r-1)>0)a=true;
						else r++;
					if(!a)l++;
					else
						while(p<len){
							swap(arr,p-1,p++,0);
							if(++j>=len){
								mark(p-2);
								await sleep(j=0);
							}
						}
				}else
					while(p+1-h){
						swap(arr,p-1,p++,0);
						if(++j>=len){
							mark(p-2);
							await sleep(j=0);
						}
					}
			}
		}
	}
	async peelSort(len){
		let j=0;
		for(let l=0;l<len;l++){
			let s=0;
			for(let r=len-1;r>l;r--){
				if(compareIndices(arr,l,r+s)>0){
					let i=arr[r+s];
					for(let p=r+s;p>l;p--){
						if(++j>=sqrt(len)){
							mark(p);
							await sleep(j=0);
						}
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,0.05,true);
					s++;
				}
			}
		}
	}
	async stableFallSort(len){
		let l=1,r=2,h=0,i=0,p=0,s=0,j=0;
		while(l<=len){
			r=l+1+s;h=0;
			while(r<=len){
				if(compareIndices(arr,l-1,r-1)>0)
					if(!h)h=r;
					else if(compareIndices(arr,h-1,r-1)<0)h=r;
				r++;
			}
			if(!h){
				l++;
				s=0;
			}else{
				i=arr[h-1];p=h;
				while(p>l){
					if(++j>=sqrt(len)){
						mark(p-1);
						await sleep(j=0);
					}
					write(arr,--p,arr[p-1],0);
				}
				await write(arr,l-1,i,0.01,true);
				s++;
			}
		}
	}
	async sandpaperSort(len){
		let k=0;
		for(let i=0;i<len-1;i++)
			for(let j=i+1;j<len;j++)
				if(compareIndices(arr,i,j)>0){
					if(++k>=sqrt(len)){
						markSwap(i,j);
						await sleep(k=0);
					}
					swap(arr,i,j,0);
				}
	}
	async optimizedLazyHeapSort(len){
		function fM(A,p,a,b,s){
			let m=p;
			for(let i=a;i<b;i+=s)
				if(compareIndices(A,i,m)<0)m=i;
			return m;
		}
		async function sort(A,l){
			let s=sqrt(l-1)+1|0;
			let a=(l-1)%s+1;
			let f=fM(A,0,1,a,1);
			for(let j=a;j<l;j+=s){
				let m=fM(A,j,j+1,j+s,1);
				if(j-m)await swap(A,j,m,1,true);
			}
			for(let j=0;j<l;){
				let m=fM(A,f,a,l,s);
				if(m==f){
					if(j-m)await swap(A,j,m,1,true);
					if(++j==a)a=s;
					f=fM(A,j,j+1,a,1);
				}else{
					if(j==f)f=fM(A,j+1,j+2,a,1);
					let n=fM(A,j,m+1,m+s,1);
					if(n==j)await swap(A,j,m,1,true);
					else{
						let t=A[j];
						await write(A,j,A[m],.5,true);
						await write(A,m,A[n],.5,true,false);
						await write(A,n,t,.5,true);
					}
					if(++j==a)a+=s;
				}
			}
		}
		await sort(arr,len);
	}
	async cocktailPeelSort(len){
		let s=0,k=0;
		for(let l=0;l<len;l++){
			s=0;
			for(let r=len-1;r>l;r--){
				if(compareIndices(arr,l,r+s)>0){
					let i=arr[r+s];
					for(let p=r+s;p>l;p--){
						if(++k>=sqrt(len)){
							mark(p);
							await sleep(k=0);
						}
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,0.05,true);
					s++;
				}
			}
			l++;
			for(let r=l+1;r<len;r++){
				if(compareIndices(arr,l,r)>0){
					let i=arr[r];
					for(let p=r;p>l;p--){
						if(++k>=sqrt(len)){
							mark(p);
							await sleep(k=0);
						}
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,0.05,true);
				}
			}
		}
	}
	async forcedStableHeapSort(len){
		function stableComp(A,k,a,b){
			let c=compareIndices(A,a,b,0.0,true);
			return c>0||(!c&&compareIndices(k,a,b)>0);
		}
		async function stableSwap(A,k,a,b){
			await swap(A,a,b,1,true);
			swap(k,a,b,0,false,true);
		}
		async function siftDown(A,k,r,d,s){
			while(r<=(d/2|0)){
				let l=2*r;
				if(l<d&&stableComp(A,k,s+l,s+l-1))l++;
				if(stableComp(A,k,s+l-1,s+r-1)){
					await stableSwap(A,k,s+l-1,s+r-1);
					r=l;
				}else break;
			}
		}
		async function heapify(A,k,a,b){
			let l=b-a;
			for(let i=l/2|0;i>0;i--)
				await siftDown(A,k,i,l,a);
		}
		async function heapSort(A,k,s,l){
			await heapify(A,k,s,l);
			for(let i=l-s;i>1;i--){
				await stableSwap(A,k,s,s+i-1);
				await siftDown(A,k,1,i-1,s);
			}
		}
		let k=new Array(len);
		for(let i=0;i<len;i++)
			write(k,i,i,0,false,true);
		await heapSort(arr,k,0,len);
	}
	async optimizedReverseSandpaperSort(len){
		let ae=true,s=1,le=len-1,e=len-1,ll=0,h;
		while(ae){
			let f=ae=false;
			h=0;
			for(let i=s>1?s-1:0;i<le;i++){
				if(compareIndices(arr,i,i+1)>0){
					if(!f)s=i;
					f=ae=true;
					ll=i;
					for(let j=e;j>i;j--){
						if(compareIndices(arr,i,j)>0){
							await swap(arr,i,j,0,true);
							if(j>h)h=j;
						}
					}
				}
			}
			le=ll;
			e=h-1;
		}
	}
	async reversePeelSort(len){
		let s=0,k=0;
		for(let l=0;l<len;l++){
			for(let r=l+s+1;r<len;r++){
				if(r==l+s+1)s=0;
				if(compareIndices(arr,l,r)>0){
					let i=arr[r];
					for(let p=r;p>l;p--){
						if(++k>=sqrt(len)){
							mark(p);
							await sleep(k=0);
						}
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,0.05,true);
					s++;
				}
			}
		}
	}
	async reverseSandpaperSort(len){
		for(let i=0;i<len-1;i++)
			for(let j=len-1;j>i;j--)
				if(compareIndices(arr,i,j)>0)
					await swap(arr,i,j,0.05,true);
	}
	async reverseSelectionSort(len){
		for(let i=len-1;i>=0;i--){
			let h=0;
			for(let j=1;j<i+1;j++)
				if(compareIndices(arr,j,h)>0)
					h=j;
			await swap(arr,i,h,0.02,true);
		}
	}
	async reverseInsertionSort(len){
		let k=0;
		for(let i=len-1;i>=0;i--){
			let c=arr[i],p=i+1;
			while(p<=len-1&&compareValues(arr[p],c)<0){
				if(++k>=sqrt(len)){
					mark(p-1);
					await sleep(k=0);
				}
				write(arr,p-1,arr[p++],0);
			}
			await write(arr,p-1,c,0,true);
		}
	}
	async unstableInsertionSort(len){
		async function unstableInsertionSort(A,s,e){
			for(let i=s+1;i<e;++i){
				if(compareIndices(A,i,s)<0)
					await swap(A,i,s,1,true);
				let t=A[i],j=i-1;
				for(;compareValues(A[j],t)>0;--j)
					await write(A,j+1,A[j],1,true);
				await write(A,j+1,t,1,true);
			}
		}
		await unstableInsertionSort(arr,0,len);
	}
	async patternDefeatingInsertionSort(len){
		async function insert(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let c=A[i];
				let p=i-1;
				while(p>=a&&compareValues(A[p],c)>0){
					await write(A,p+1,A[p--],1,true);
				}
				await write(A,p+1,c,1,true);
				i++;
			}
		}
		await insert(arr,0,len);
	}
	async pairwiseCircleSort(len){
		async function pairs(A,l,r,g){
			if(l+g>=r)return;
			let a=l;
			while(a+g<=r){
				if(compareIndices(A,a,a+g)>0)
					await swap(A,a,a+g,1,true);
				a+=g*2;
			}
			await pairs(A,l,r,g*2);
			await pairs(A,l+g,r,g*2);
		}
		async function circle(A,l,r){
			for(let a=l,b=r;a<b;a++,b--)
				if(compareIndices(A,a,b)>0)
					await swap(A,a,b,1,true);
		}
		async function pairCircle(A,l,r){
			if(l>=r)return;
			let m=(l+r)/2|0;
			await pairs(A,l,r,1);
			await circle(A,l,r);
			await pairCircle(A,l,m);
			await pairCircle(A,m+1,r);
		}
		await pairCircle(arr,0,len-1);
		await insertSort(arr,0,len,.1);
	}
	async sinkingMergeSortRecursive(len){
		async function bubbleSort(A,s,e){
			let cS=1;
			for(let i=e-1;i>s;i-=cS){
				cS=1;
				for(let j=s;j<i;j++){
					if(compareIndices(A,j,j+1)>0){
						await swap(A,j,j+1,1,true);
						cS=1;
					}else cS++;
				}
			}
		}
		async function sort(A,s,e){
			if(e-s>16){
				let m=s+(e-s)/2|0;
				await sort(A,s,m);
				await sort(A,m,e);
				await bubbleSort(A,s,e);
			}else
				await bubbleSort(A,s,e);
		}
		await sort(arr,0,len);
	}
	async introPseudoHeapSort(len){
		async function sift(A,s,l,r){
			let sw=false,j=r;
			while(2*j<l){
				let k=2*j;
				if(k<l&&compareIndices(A,s+k-1,s+k)>0)k++;
				if(compareIndices(A,s+j-1,s+k-1)>0){
					await swap(A,s+j-1,s+k-1,1,sw=true);
					j=k;
					continue;
				}
				break;
			}
			return sw;
		}
		async function sort(A,l){
			let th=0,n=1;
			for(;n<l;n*=2,th++);
			th=th/2|0;
			let it=0,sw=true;
			while(sw){
				sw=false;it++;
				if(it>=th){
					await insertSort(A,0,l,.5);
					break;
				}
				for(let i=l-2;i>=0;i--)
					if(await sift(A,i,l-i+1,1))
						sw=true;
			}
		}
		await sort(arr,len);
	}
	async sinkingMergeSortIterative(len){
		async function bubbleSort(A,s,e){
			let cS=1;
			for(let i=e-1;i>s;i-=cS){
				cS=1;
				for(let j=s;j<i;j++){
					if(compareIndices(A,j,j+1)>0){
						await swap(A,j,j+1,1,true);
						cS=1;
					}else
						cS++;
				}
			}
		}
		async function sort(A,s,e){
			let m=e-s,i;
			for(;m>31;m=(m+1)/2|0);
			for(i=s;i+m<e;i+=m)
				await bubbleSort(A,i,i+m);
			await bubbleSort(A,i,e);
			for(let j=m;j<e-s;j*=2){
				for(i=s;i+2*j<=e;i+=2*j)
					await bubbleSort(A,i,i+2*j);
				if(i+j<e)
					await bubbleSort(A,i,e);
			}
		}
		await sort(arr,0,len);
	}
	async bufferedBlockSelectionMergeSort(len){
		function sqr(n){
			return sqrt(n-1)+1|0;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function blockLesser(A,a,b,l){
			let c=compareIndices(A,a,b);
			return c<0||(!c&&compareIndices(A,a+l-1,b+l-1)<0);
		}
		async function mergeAboveBW(A,a1,b1,a,b){
			let p=(b1--)+(b--)-a;
			while(b>=a&&b1>=a1){
				if(compareIndices(A,b,b1)+1)
					await swap(A,--p,b--,1,true);
				else
					await swap(A,--p,b1--,1,true);
			}
			while(b>=a)await swap(A,--p,b--,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareIndices(A,p+i,j)+1)
					await swap(A,k--,p+(i--),1,true);
				else
					await swap(A,k--,j--,1,true);
			}
			while(i+1)await swap(A,k--,p+(i--),1,true);
		}
		async function inPlaceMergeUnstable(A,a,m,b){
			let bL=sqr(b-a),a1=a+(m-a-1)%bL+1,b1=b-(b-m)%bL;
			await multiSwap(A,a1,blockLesser(A,m-bL,b1-bL,bL)?b1-bL:m-bL,bL);
			for(a1+=bL;a1<b1;a1+=bL){
				let m=a1;
				for(let i=a1+bL;i<b1;i+=bL)
					if(blockLesser(A,i,m,bL))m=i;
				if(m>a1)await multiSwap(A,m,a1,bL);
				await mergeAboveBW(A,a,a1-bL,a1,a1+bL);
			}
			await mergeAboveBW(A,a,a1-bL,a1,b);
			await binaryInsertion(A,b-bL,b,.25);
			await mergeBW(A,a+bL,b-bL,b,a);
			await binaryInsertion(A,a,a+bL,.25);
		}
		async function mergeSort(A,a,b){
			if(b-a<32)return await binaryInsertion(A,a,b,.25);
			let m=(a+b)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await inPlaceMergeUnstable(A,a,m,b);
		}
		await mergeSort(arr,0,len);
	}
	async bubbleMergeSort(len){
		async function bubbleSort(a,s,e){
			for(let i=e-1;i>s;i--){
				let as=true;
				for(let j=s;j<i;j++){
					if(compareIndices(a,j,j+1)>0){
						await swap(a,j,j+1,1,true);
						as=false;
					}
				}
				if(as)break;
			}
		}
		let mRL=new TimSorting().minRunLength(len);
		if(len==mRL)await bubbleSort(arr,0,len);
		else{
			let i=0;
			for(;i<=len-mRL;i+=mRL)await bubbleSort(arr,i,i+mRL);
			if(i+mRL>len)await bubbleSort(arr,i,len);
			await TimSorting.sort(new TimSorting(arr,len),arr,0,len);
		}
	}
	async quarterMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function binarySearchMid(A,s,md,e){
			let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
			while(b>a){
				if(compareIndices(A,md-m-1,md+m)>0)a=m+1;
				else b=m;
				m=a+(b-a)/2|0;
			}
			return m;
		}
		async function multiSwapMerge(A,s,md,e){
			let m=binarySearchMid(A,s,md,e);
			while(m>0){
				await multiSwap(A,md-m,md,m);
				await multiSwapMerge(A,md,md+m,e);
				e=md;
				md-=m;
				m=binarySearchMid(A,s,md,e);
			}
		}
		async function merge(A,bL,s,m,e){
			await multiSwap(A,0,s,m-s);
			let bP=0;
			let l=s,r=m;
			while(l<r&&r<e)
				if(compareIndices(A,bP,r)<1)
					await swap(A,bP++,l++,0.5,true);
				else
					await swap(A,l++,r++,0.5,true);
			while(l<r)
				await swap(A,bP++,l++,0.5,true);
		}
		function pow2lte(n){
			let v;
			for(v=1;v<=n;v<<=1);
			return v>>1;
		}
		async function quarterMergeSort(A,l){
			if(l<33)return await binaryInsertion(A,0,l,1/3);
			let qL=l/4|0;
			let uL=qL*4;
			for(let i=qL;i<uL-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,0.5,true);
			let sS,sE=uL,sL=uL-qL,g;
			for(let pr=sL;pr>1;pr=sE-qL){
				sL=pow2lte(pr);
				sS=sE-sL;
				for(g=4;g<=sL;g*=2)
					for(let i=sS;i+g<=sE;i+=g)
						await merge(A,qL,i,i+g/2|0,i+g);
				if(pr-uL+qL)
					await merge(A,qL,sS,sE,uL);
				sE=sS;
			}
			let ex=l-uL;
			if(ex>0){
				if(ex>1&&compareIndices(A,l-2,l-1)>0)
					await swap(A,l-2,l-1,0.5,true);
				await multiSwapMerge(A,qL,uL,l);
			}
			await quarterMergeSort(A,qL);
			await multiSwapMerge(A,0,qL,l);
		}
		await quarterMergeSort(arr,len);
	}
	async multiSelectionSort(len){
		function monoboundBw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)>0)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)>0)return s+1;
			return s;
		}
		function monoboundFw(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		async function moveFront(A,s,m,e){
			let st=maxVal(m,s+(e-s)/2|0);
			while(e>st)
				await swap(A,s++,e--,1,true);
		}
		async function moveBack(A,s,m,e){
			while(m>s)
				await swap(A,m--,e--,1,true);
		}
		async function selectSmallest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)<1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE-rS&&compareIndices(A,i,rS)<0)
					rS=monoboundBw(A,rS,rE+1,A[i]);
				i++;
			}
			await moveFront(A,l,rS-1,rE);
			return l+(rE-rS+1);
		}
		async function selectLargest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)+1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE!=rS&&compareIndices(A,i,rS)>0)
					rS=monoboundFw(A,rS,rE+1,A[i]);
				i++;
			}
			if(rE-r+1)await moveBack(A,rS-1,rE,r-1);
			return r-rE+rS-1;
		}
		let l=0,r=len;
		while(l<r-1){
			if(compareIndices(arr,l,l+1)>0)l=await selectSmallest(arr,l,l+1,r);
			else r=await selectLargest(arr,l,l+1,r);
		}
	}
	async improvedMultiSelectionSort(len){
		function monoboundBw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)>0)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)>0)return s+1;
			return s;
		}
		function monoboundFw(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		async function moveFront(A,s,m,e){
			let st=maxVal(m,s+(e-s)/2|0);
			while(e>st)
				await swap(A,s++,e--,1,true);
		}
		async function moveBack(A,s,m,e){
			while(m>s)
				await swap(A,m--,e--,1,true);
		}
		async function selectSmallest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)<1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE-rS&&compareIndices(A,i,rS)<0)
					rS=monoboundBw(A,rS,rE+1,A[i]);
				i++;
			}
			await moveFront(A,l,rS-1,rE);
			return l+(rE-rS+1);
		}
		async function selectLargest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)+1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE!=rS&&compareIndices(A,i,rS)>0)
					rS=monoboundFw(A,rS,rE+1,A[i]);
				i++;
			}
			if(rE-r+1)await moveBack(A,rS-1,rE,r-1);
			return r-rE+rS-1;
		}
		let l=0,r=len;
		let d=compareIndices(arr,l,l+1)>0;
		if(compareIndices(arr,l,l+1)>0)
			l=await selectSmallest(arr,l,l+1,r);
		else
			r=await selectLargest(arr,l,l+1,r);
		let sD=d,sDC=1,sDM=1;
		while(sDM*sDM<len)sDM*=2;
		while(l<r-1){
			let rE=l+1;
			d=compareIndices(arr,l,l+1)>0;
			if(d==sD){
				sDC++;
				if(sDC==sDM){
					sDC=0;
					d=!d;
					rE--;
				}
			}else{
				sDC=0;
			}
			if(d)l=await selectSmallest(arr,l,rE,r);
			else r=await selectLargest(arr,l,rE,r);
		}
	}
	async adaptiveShuffleQuickSort(len){
		const hs=new HeapSorting(true);
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function shuffle(A,a,b){
			let r=new Random();
			for(let i=a;i<b;i++){
				let j=i+r.nextInt(b-i);
				if(i-j)
					await swap(A,i,j,.75,true);
			}
		}
		async function partition(A,a,b){
			let pv=A[a];
			let f=a;
			let l=b;
			while(compareValues(A[++f],pv)<0);
			if(f-1==a)
				while(f<l&&compareValues(A[--l],pv)>0);
			else
				while(compareValues(A[--l],pv)>0);
			let aP=f>=l;
			while(f<l){
				await swap(A,f,l,1,true);
				while(compareValues(A[++f],pv)<0);
				while(compareValues(A[--l],pv)>0);
			}
			let pvp=f-1;
			await write(A,a,A[pvp],1,true);
			await write(A,pvp,pv,1,true);
			return[pvp,aP];
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,bA){
			while(b-a>16){
				await medianOfThree(A,a,b);
				let[p,aP]=await partition(A,a,b);
				let l=p-a,r=b-(p+1);
				if(l<((b-a)/16|0)||r<((b-a)/16|0)){
					if(!--bA)return await hs.sort(A,a,b);
					if(l>16)await shuffle(A,a,p);
					if(r>16)await shuffle(A,p+1,b);
				}else if(aP&&await partialInsert(A,a,p)&&await partialInsert(A,p+1,b))return;
				if(l>r){
					await quickSort(A,p+1,b,bA);
					b=p;
				}else{
					await quickSort(A,a,p,bA);
					a=p+1;
				}
			}
			await insertSort(A,a,b,0.5);
		}
		await quickSort(arr,0,len,floorLog(len));
	}
	async quickSPSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,--a,--b)>0)
				await swap(A,a,b,0,true);
		}
		async function grailSwap(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)
				await grailSwap(A,a++,b++);
		}
		function grailBinSearch(A,p,ln,kP,L){
			let l=-1,r=ln;
			while(l<r-1){
				let m=l+((r-l)>>1);
				if(compareIndices(A,kP,p+m)<(L?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailRotate(A,p,lA,lB){
			while(lA&&lB){
				if(lA<=lB){
					await grailMultiSwap(A,p,p+lA,lA);
					p+=lA;
					lB-=lA;
				}else{
					await grailMultiSwap(A,p+lA-lB,p+lA,lB);
					lA-=lB;
				}
			}
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2){
				while(l1){
					let o=grailBinSearch(A,p+l1,l2,p,true);
					if(o){
						await grailRotate(A,p,l1,o);
						p+=o;
						l2-=o;
					}
					if(!l2)break;
					do{
						p++;
						l1--;
					}while(l1&&compareIndices(A,p,p+l1)<1);
				}
			}else{
				while(l2){
					let o=grailBinSearch(A,p,l1,p+(l1+l2-1),false);
					if(o!=l1){
						await grailRotate(A,p+o,l1-o,l2);
						l1=o;
					}
					if(!l1)break;
					do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
				}
			}
		}
		function ipMerge(A,a,m,b){
			return grailMergeWithoutBuffer(A,a,m-a,b-m);
		}
		async function quickSPSort2(A,l,r){
			if(r-l<12){
				for(let i=l;i<=r;i++)
					for(let j=i;j<=r;j++)
						await compSwap(A,i,j);
			}else{
				let rb=l+ceil(sqrt(1+r-l)),m,j;
				for(let i=l;i<=rb;i++)
					for(j=i;j<=r;j++)
						await compSwap(A,i,j);
				m=A[rb];
				j=1+rb;
				for(let i=1+rb;i<=r;i++){
					if(compareValues(A[i-1],m)<0){
						m=A[i-1];
						await swap(A,i-1,j++,0.125,true);
					}
				}
				await reversal(A,rb,j-1,1,true);
				await quickSPSort2(A,1+j,r);
				await ipMerge(A,rb,j,r);
			}
		}
		await quickSPSort2(arr,1,len);
	}
	async lazierSort(len){
		const hs=new HeapSorting(true);
		function cbrt(n){
			let r=1;
			for(;r*r*r<n;r++);
			return r;
		}
		async function shift(A,a,m,b){
			while(m<b)await swap(A,a++,m++,1,true);
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await swap(A,--b,--m,1,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],0.5,true);
			await write(A,b,t,0.5,true);
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function findKeys(A,a,b,n){
			let nK=1,p=a,pE=a+nK;
			for(let i=pE;i<b&&nK<n;i++){
				let o=leftBinSearch(A,p,pE,A[i]);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,p,pE,i);
					let inc=i-pE;
					p+=inc;
					pE+=inc;
					await insertTo(A,pE++,o+=inc);
					nK++;
				}
			}
			await rotate(A,a,p,pE);
			return nK;
		}
		async function insertion(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function lazierBlockMerge(A,a,m,b,bL){
			while(m-bL>=a)
				await inPlaceMerge(A,m-=bL,m,b);
			await inPlaceMerge(A,a,m,b);
		}
		async function inPlaceMergeSort(A,a,b){
			let l=b-a,i,j;
			for(j=l;j>31;j=(j+1)/2|0);
			for(i=a;i+j<=b;i+=j)
				await insertion(A,i,i+j);
			await insertion(A,i,b);
			for(;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await inPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await inPlaceMerge(A,i,i+j,b);
			}
		}
		async function lazierBlockMergeSort(A,a,b,k){
			let a1=a+k,b1=b,l=b-a1,i,j;
			for(j=l;j>31;j=(j+1)/2|0);
			for(i=a1;i+j<=b;i+=j)
				await insertion(A,i,i+j);
			await insertion(A,i,b);
			if(k>=2*j){
				for(i=a1;i+2*j<=b;i+=2*j)
					await mergeTo(A,i,i+j,i+2*j,i-2*j);
				if(i+j<b)await mergeTo(A,i,i+j,b,i-2*j);
				else await shift(A,i-2*j,i,b);
				j*=2;a1-=j;b1-=j;
				while(a1-j>=a){
					for(i=a1;i+2*j<=b1;i+=2*j)
						await mergeTo(A,i,i+j,i+2*j,i-j);
					if(i+j<b1)await mergeTo(A,i,i+j,b1,i-j);
					else await shift(A,i-j,i,b1);
					a1-=j;b1-=j;j*=2;
				}
				for(i=a1;i+2*j<=b1;i+=2*j);
				if(i+j<b1)await mergeToBW(A,i,i+j,b1,b);
				else await shiftBW(A,i,b1,b);
				for(;i>a1;i-=2*j)await mergeToBW(A,i-2*j,i-j,i,i+j);
				a1+=j;j*=2;
			}
			let c=1;
			for(;j<l;j*=2){
				while((c*c*c/2/j|0)<2*j)c++;
				for(i=a1;i+2*j<=b;i+=2*j)
					await lazierBlockMerge(A,i,i+j,i+2*j,c);
				if(i+j<b)
					await lazierBlockMerge(A,i,i+j,b,c);
			}
			await hs.sort(A,a,a1,1);
			await inPlaceMerge(A,a,a1,b);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			if(p<i)while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		async function mergeToBW(A,a,m,b,p){
			let i=m-1,j=b-1;p--;
			while(i>=a&&j>=m){
				if(compareIndices(A,i,j)>0)
					await swap(A,p--,i--,1,true);
				else await swap(A,p--,j--,1,true);
			}
			if(p>j)while(j>=m)await swap(A,p--,j--,1,true);
			while(i>=a)await swap(A,p--,i--,1,true);
		}
		async function mergeFW(A,a,p,m,b){
			let i=a,j=m,k=p;
			while(j<b){
				while(i<p&&compareIndices(A,i,j)<1)
					await swap(A,k++,i++,1,true);
				if(i==p)return;
				let n=leftExpSearch(A,j+1,b,A[i]);
				while(j<n)await swap(A,k++,j++,1,true);
			}
			while(i<p)await swap(A,k++,i++,1,true);
		}
		async function sort(A,a,b){
			let l=b-a;
			if(l<65)return await insertion(A,a,b);
			let bL,mR;
			for(bL=1;(bL*bL*bL/l|0)<l;bL*=2);
			for(mR=1;(mR*mR*mR/l|0)<l;mR++);
			mR=(16*mR)/bL|0;
			bL=(bL*mR)/16|0;
			let k=await findKeys(A,a,b,bL);
			if(k<bL){
				if(k==1)return;
				else if(k<=cbrt(l)|0)await inPlaceMergeSort(A,a,b);
				else await lazierBlockMergeSort(A,a,b,k);
				return;
			}
			let a1=a+bL,b1=b,i,j=mR;
			for(i=a1;i+j<=b;i+=j)
				await insertion(A,i,i+j);
			await insertion(A,i,b);
			for(i=a1;i+2*j<=b;i+=2*j)
				await mergeTo(A,i,i+j,i+2*j,i-2*j);
			if(i+j<b)await mergeTo(A,i,i+j,b,i-2*j);
			else await shift(A,i-2*j,i,b);
			j*=2;a1-=j;b1-=j;
			while(a1>a){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await mergeTo(A,i,i+j,i+2*j,i-j);
				if(i+j<b1)await mergeTo(A,i,i+j,b1,i-j);
				else await shift(A,i-j,i,b1);
				a1-=j;b1-=j;j*=2;
			}
			for(i=a;i+bL<b1;i+=bL);
			await shiftBW(A,i,b1,b);
			b1=i+bL;i-=bL;
			while(i>=a){
				await mergeFW(A,i,i+bL,b1,b);
				i-=bL;b1-=bL;
			}
			a1=a+bL;
			await hs.sort(A,a,a1,1);
			await inPlaceMerge(A,a,a1,b);
		}
		await sort(arr,0,len);
	}
	async blockSelectionMergeSort(len){
		async function swapBlocks(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s,m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;am-=z;m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;d+=m;s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function lzmerge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function blockSelection(A,s,e,bZ){
			for(let i=s;i<e-bZ;i+=bZ){
				let l=i;
				for(let j=i+bZ;j<e;j+=bZ)
					if(compareIndices(A,j,l)<0)
						l=j;
				if(l>i)
					await swapBlocks(A,i,l,bZ);
			}
		}
		async function merge(A,s,e){
			let bZ=(e-s)/16|0;
			while(bZ>=4){
				await blockSelection(A,s,e,bZ);
				bZ=bZ/8|0;
			}
			await binaryInsertion(A,s,e,1/3);
		}
		async function mergeRun(A,s,m,e,z){
			if(s==m)return;
			if(e-s==z)return await binaryInsertion(A,s,e,1/3);
			await mergeRun(A,s,(m+s)/2|0,m,z);
			await mergeRun(A,m,(m+e)/2|0,e,z);
			await merge(A,s,e);
		}
		async function sort(A,l){
			let z=(log(l)/log(2)|0)/3+2|0;
			z=2**z;
			if(l<=z)return await binaryInsertion(A,0,l,1/3);
			let uL=pow(2,log(l)/log(2)|0);
			let s=l-uL;
			let e=l;
			let m=s+((e-s)/2);
			await mergeRun(A,s,m,e,z);
			if(l>uL){
				await sort(A,l-uL);
				await lzmerge(A,0,l-uL,e);
			}
		}
		await sort(arr,len);
	}
	async bufferedMergeSort(len){
		function log2(v){
			return log(v)/log(2);
		}
		function getBufferSize(l){
			return pow(2,ceil(log2(log2(l)|0)))*2;
		}
		async function swapBlocks(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function merge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function blockSelection(A,s,e,bZ){
			for(let i=s;i<e-bZ;i+=bZ){
				let l=i;
				for(let j=i+bZ;j<e;j+=bZ)
					if(compareIndices(A,j,l)<0)
						l=j;
				if(l>i)
					await swapBlocks(A,i,l,bZ);
			}
		}
		async function mergeUnderBuffer(A,bZ,s,m,e){
			let bP=0,l=s,r=m;
			while(l<m&&r<e){
				if(compareIndices(A,l,r)<1)
					await swap(A,bP,l++,.25,true);
				else
					await swap(A,bP,r++,.25,true);
				bP++;
			}
			while(l<m)
				await swap(A,bP++,l++,.25,true);
			while(r<e)
				await swap(A,bP++,r++,.25,true);
			for(let i=0;i<e-s;i++)
				await swap(A,i,s+i,.5,true);
		}
		async function mergeOverBuffer(A,bZ,s,m,e){
			let blZ=bZ/2|0;
			await blockSelection(A,s,e,blZ);
			let cS=s;
			while(cS<e-blZ){
				if(compareIndices(A,cS+blZ-1,cS+blZ)>0)
					await mergeUnderBuffer(A,bZ,cS,cS+blZ,cS+bZ);
				cS+=blZ;
			}
		}
		async function sort(A,l){
			let bZ=getBufferSize(len);
			let ln=l-(l-bZ)%(bZ/2|0);
			if(bZ*2>=ln)return await binaryInsertion(A,0,l,1/3);
			for(let i=bZ;i<ln-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,.5,true);
			for(let g=4;g<=bZ;g*=2)
				for(let i=bZ;i+g<=ln;i+=g)
					await mergeUnderBuffer(A,bZ,i,i+g/2|0,i+g);
			for(let g=bZ*2;(g/2|0)<=ln;g*=2){
				let i;
				for(i=bZ;i+g<=ln;i+=g)
					await mergeOverBuffer(A,bZ,i,i+g/2|0,i+g);
				if(i+g>ln)
					await mergeOverBuffer(A,bZ,i,i+g/2|0,ln);
			}
			await sort(A,bZ);
			await merge(A,0,bZ,ln);
			if(l-ln>0){
				await binaryInsertion(A,ln,l,1/3);
				await merge(A,0,ln,l);
			}
		}
		await sort(arr,len);
	}
	async improvedWeaveMergeSort(len){
		function getMaxBit(n){
			let i=0;
			for(;(1<<i)<=n;i++);
			return i-1;
		}
		async function weaveMerge(A,a,b){
			let n=b-a,m=(n+1)/2;
			for(let j=1<<(getMaxBit(n-1)-1);j>0;j>>=1){
				let s=m>j?1:0;
				for(let i=a+m+(1-s)*(j<<1);i+j<=b;i+=j<<2)
					for(let k=0;k<j;k++)
						await swap(A,i-j+k,i+k,1,true);
				m-=s*j;
			}
			await insertSort(A,a,b,.2);
		}
		async function weaveMergeSort(A,a,b){
			if(b-a>2){
				let m=a+(b-a+1)/2|0;
				await weaveMergeSort(A,a,m);
				if(b-a>3)
					await weaveMergeSort(A,m,b);
			}
			await weaveMerge(A,a,b);
		}
		await weaveMergeSort(arr,0,len);
	}
	async medianOfSixteenAdaptiveQuickSort(len){
		const hs=new HeapSorting(true);
		let medianOfSixteenSwaps=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
		let incs=[48,21,7,3,1];
		function log2(n){
			return log(n)/log(2)|0;
		}
		async function shellSort(A,lo,hi){
			for(let k=0;k<5;k++){
				for(let h=incs[k],i=h+lo;i<hi;i++){
					let v=A[i],j=i;
					while(j>=h+lo&&compareValues(A[j-h],v)>0)
						await write(A,j,A[j-=h],1,true);
					await write(A,j,v,0.5,true);
				}
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<b&&compareIndices(A,i,p)<0);
				do j--;while(j>=a&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function compNSwap(A,a,b,g,s){
			if(compareIndices(A,s+a*g,s+b*g)>0)
				await swap(A,s+a*g,s+b*g,1,true);
		}
		async function medianOfSixteen(A,a,b){
			let g=(b-1-a)/16|0;
			for(let i=0;i<medianOfSixteenSwaps.length;i+=2)
			await compNSwap(A,medianOfSixteenSwaps[i],medianOfSixteenSwaps[i+1],g,a);
			await swap(A,a,a+8*g,1,true);
		}
		async function getSortedRuns(A,a,b){
			let rS=true,as=true,c;
			for(let i=a;i<b-1;i++){
				c=compareIndices(A,i,i+1,.5,true);
				if(c>0)as=false;
				else rS=false;
				if(!rS&&!as)return false;
			}
			if(rS&&!as)
				await reversal(A,a,b-1,1,as=true);
			return as;
		}
		async function quickSort(A,a,b,d,u){
			while(b-a>32){
				if(await getSortedRuns(A,a,b))return;
				if(!d)return await hs.sort(A,a,b);
				let p;
				if(!u){
					await medianOfThree(A,a,b);
					p=await partition(A,a,b,a);
				}else p=a;
				let l=p-a;
				let r=b-p-1;
				if((!l||!r)||((l/r|0)>15||(r/l|0)>15)||u){
					if(b-a>80){
						await swap(A,a,p,1,true);
						if(l<r)await quickSort(A,a,a=p,d-1,true);
						else{
							await quickSort(A,p+1,b,d-1,true);
							b=p;
						}
						await medianOfSixteen(A,a,b);
						p=await partition(A,a+1,b,a);
					}else return await shellSort(A,a,b);
				}
				await swap(A,a,p,1,true);
				await quickSort(A,p+1,b,--d,false);
				b=p;
			}
			await insertSort(A,a,b);
		}
		await quickSort(arr,0,len,2*log2(len),false);
	}
	async swapMergeSort(len){
		async function moveDown(A,s,d){
			for(let i=d;i<s;i++)
				await swap(A,i,s,1,true);
		}
		async function merge(A,lS,rS,e){
			let l=lS,r=rS;
			while(l<r){
				if(l>=e||r>=e)break;
				else if(compareIndices(A,l,r)<1)l+=1;
				else await moveDown(A,r++,l++);
			}
		}
		async function mergeRun(A,s,m,e){
			if(s==m)return;
			await mergeRun(A,s,(m+s)/2|0,m);
			await mergeRun(A,m,(m+e)/2|0,e);
			if(e-s<32)return;
			else if(e-s==32)await binaryInsertion(A,s,minVal(A.length,e+1),1/3);
			else await merge(A,s,m,e);
		}
		async function sort(A,l){
			if(l<32)return await binaryInsertion(A,0,l,1/3);
			let m=l/2|0;
			await mergeRun(A,0,m,l);
		}
		await sort(arr,len);
	}
	async bubblescanQuickSort(len){
		const hs=new HeapSorting(true);
		async function partition(A,a,b,v){
			let i=a,j=b-1;
			while(i<=j){
				while(compareValues(A[i],v)<0)i++;
				while(compareValues(A[j],v)>0)j--;
				if(i<=j)await swap(A,i++,j--,1,true);
			}
			return i;
		}
		async function sort(A,a,b,d){
			let e=b,l=b-a;
			while(l>16){
				if(!d)return await hs.sort(A,a,e);
				let sum=0,sw=false;
				for(let i=a+1;i<e;i++){
					if(compareValues(A[i-1],A[i])>0)
						await swap(A,i-1,i,.5,sw=true);
					sum+=A[i-1];
				}
				if(!sw)return;
				let p=await partition(A,a,e-1,sum/(l-1)|0);
				await sort(A,p,e-1,--d);
				e=p;l=e-a;
			}
			await insertSort(A,a,e,.5);
		}
		await sort(arr,0,len,2*(log(len)/log(2)|0));
	}
	async stableQuarterMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function binarySearchMid(A,s,md,e){
			let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
			while(b>a){
				if(compareIndices(A,md-m-1,md+m)>0)a=m+1;
				else b=m;
				m=a+(b-a)/2|0;
			}
			return m;
		}
		async function multiSwapMerge(A,s,md,e){
			let m=binarySearchMid(A,s,md,e);
			while(m>0){
				await multiSwap(A,md-m,md,m);
				await multiSwapMerge(A,md,md+m,e);
				e=md;
				md-=m;
				m=binarySearchMid(A,s,md,e);
			}
		}
		async function multiSwapMergeSort(A,a,b){
			let len=b-a,i;
			for(let j=1;j<len;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await multiSwapMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await multiSwapMerge(A,i,i+j,b);
			}
		}
		async function merge(A,bL,s,m,e){
			await multiSwap(A,0,s,m-s);
			let bP=0;
			let l=s,r=m;
			while(l<r&&r<e)
				if(compareIndices(A,bP,r)<1)
					await swap(A,bP++,l++,0.5,true);
				else
					await swap(A,l++,r++,0.5,true);
			while(l<r)
				await swap(A,bP++,l++,0.5,true);
		}
		function pow2lte(n){
			let v;
			for(v=1;v<=n;v<<=1);
			return v>>1;
		}
		async function quarterMergeSort(A,l){
			if(l<33)return await binaryInsertion(A,0,l,1/3);
			let qL=l/4|0;
			let uL=qL*4;
			for(let i=qL;i<uL-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,0.5,true);
			let sS,sE=uL,sL=uL-qL,g;
			for(let pr=sL;pr>1;pr=sE-qL){
				sL=pow2lte(pr);
				sS=sE-sL;
				for(g=4;g<=sL;g*=2)
					for(let i=sS;i+g<=sE;i+=g)
						await merge(A,qL,i,i+g/2|0,i+g);
				if(pr-uL+qL)
					await merge(A,qL,sS,sE,uL);
				sE=sS;
			}
			let ex=l-uL;
			if(ex>0){
				if(ex>1&&compareIndices(A,l-2,l-1)>0)
					await swap(A,l-2,l-1,0.5,true);
				await multiSwapMerge(A,qL,uL,l);
			}
			await quarterMergeSort(A,qL);
			await multiSwapMerge(A,0,qL,l);
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		async function rotateCommon(A,s,d,z){
			if(s>d)await rotateSmart(A,s,d,z);
			else await rotateSmart(A,s+z,s,d-s-z);
		}
		async function ejectDuplicates(A,s,m,e){
			let mb=s,ci=s+1,lG=ci,bC=0,c;
			for(c=1;c<m-s;c++){
				let n=A[ci],l=mb,h=lG,lB=bC;
				while(l<h){
					let m=l+(h-l)/2|0;
					let cm=compareValues(n,A[m]);
					if(cm<0)h=m;
					else if(!cm){
						bC++;
						break;
					}else l=m+1;
				}
				if(bC>0){
					if(bC>lB){
						c--;
						if(++ci>=e)break;
						continue;
					}
					await rotateCommon(A,lG,mb,bC);
					mb+=bC;
					lG=ci;
					l+=bC;
					bC=0;
				}
				let j=ci-1;
				while(j>=l)
					await write(A,j+1,A[j--],0.1,true);
				await write(A,l,n,0.1,true);
				ci++;
				lG++;
				if(ci>=e)break;
			}
			if(mb-s)await rotateSmart(A,mb,s,c);
			return c;
		}
		let req=len/4|0;
		if(await ejectDuplicates(arr,0,req,len)<req)
			await multiSwapMergeSort(arr,0,len);
		else
			await quarterMergeSort(arr,len);
	}
	async stupidQuickSort(len){
		let t=sqrt(len)|0;
		for(let c=0;c<t;c++){
			let i=0,j=len-1;
			let pvp=random()*len|0,pv=arr[pvp];
			while(i<j){
				while(compareValues(arr[i],pv)<0)i++;
				while(compareValues(arr[j],pv)>0)j--;
				if(i<j)
					await swap(arr,i++,j--,1,true);
			}
		}
		await insertSort(arr,0,len,.4);
	}
	async shellHighSort(len){
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		let tr=1,ti=2,g=len,t=false;
		while(g-1){
			tr=g;
			while(tr-1){
				t=false;ti=2;
				while(!t){
					if((tr/ti|0)==tr/ti){
						tr=tr/ti;
						t=true;
					}else ti++;
				}
			}
			g=g/ti|0;
			await shellPass(arr,len,g);
		}
	}
	async shellLowSort(len){
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		let tr=1,ti=2,g=len,t=false;
		while(g-1){
			tr=g;
			while(tr==g){
				t=false;ti=2;
				while(!t){
					if((tr/ti|0)==tr/ti){
						tr=tr/ti;
						t=true;
					}else ti++;
				}
			}
			g=g/ti|0;
			await shellPass(arr,len,g);
		}
	}
	async cocktailShellSort(len){
		let g=len/2|0,d=true;
		while(g>0){
			if(d){
				for(let i=g;i<len;i++){
					let t=arr[i],j=i;
					while(j>=g&&compareValues(arr[j-g],t)>0)
						await write(arr,j,arr[j-=g],0.7,true);
					await write(arr,j,t,0.7,true);
				}
			}else{
				for(let i=len-g;i>=0;i--){
					let t=arr[i],j=i;
					while(j<len-g&&compareValues(arr[j+g],t)<0)
						await write(arr,j,arr[j+=g],0.7,true);
					await write(arr,j,t,0.7,true);
				}
			}
			g=g/2|0;
			d=!d;
		}
	}
	async simpleHybridQuickSort(len){
		const hs=new HeapSorting(true);
		function medianOfThree(A,a,m,b){
			if(compareIndices(A,m,a)>0){
				if(compareIndices(A,m,b)<0)return m;
				if(compareIndices(A,a,b)>0)return a;
				else return b;
			}else{
				if(compareIndices(A,m,b)>0)return m;
				if(compareIndices(A,a,b)<0)return a;
				else return b;
			}
		}
		function ninther(A,a,b){
			let s=(b-a)/9|0;
			return medianOfThree(A,medianOfThree(A,a,a+s,a+2*s),medianOfThree(A,a+3*s,a+4*s,a+5*s),medianOfThree(A,a+6*s,a+7*s,a+8*s));
		}
		function medianOfThreeNinthers(A,a,b){
			let s=(b-a+2)/3|0;
			return medianOfThree(A,ninther(A,a,a+s),ninther(A,a+s,a+2*s),ninther(A,a+2*s,b));
		}
		async function partition(A,a,b,v){
			let i=a,j=b;
			while(i<=j){
				while(compareValues(A[i],v)<0)i++;
				while(compareValues(A[j],v)>0)j--;
				if(i<=j)await swap(A,i++,j--,1,true);
			}
			return i;
		}
		async function sort(A,a,b,d){
			while(b-a>16){
				if(!d)return await hs.sort(A,a,b,1.0);
				let pv=medianOfThreeNinthers(A,a,b-1);
				let p=await partition(A,a,b-1,A[pv]);
				await sort(A,p,b,--d);
				b=p;
			}
			await insertSort(A,a,b,.5);
		}
		await sort(arr,0,len,2*(log(len)/log(2)|0));
	}
	async adaptiveLogMedianQuickSort(len){
		const hs=new HeapSorting(true);
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function logMedian(A,a,b){
			let n=b-a,c=maxVal(floorLog(n),5);
			c-=1-c%2;
			let p=a,s=n/c|0;
			let r=random()*s|0;
			for(let i=a+r;c>0;c--,p++,i+=s)
				await swap(A,i,p,0.5,true);
			await insertSort(A,a,p,.25);
			await swap(A,a,a+(p-a)/2,.5,true);
		}
		async function partition(A,a,b){
			let pv=A[a];
			let f=a,l=b;
			while(compareValues(A[++f],pv)<0);
			if(f-1==a)
				while(f<l&&compareValues(A[--l],pv)>0);
			else
				while(compareValues(A[--l],pv)>0);
			let aP=f>=l;
			while(f<l){
				await swap(A,f,l,1,true);
				while(compareValues(A[++f],pv)<0);
				while(compareValues(A[--l],pv)>0);
			}
			let pvp=f-1;
			await write(A,a,A[pvp],1,true);
			await write(A,pvp,pv,1,true);
			return[pvp,aP];
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,bA,lM){
			while(b-a>24){
				if(!lM)await medianOfThree(A,a,b);
				let lML=false,lMR=false;
				let[p,aP]=await partition(A,a,b);
				let l=p-a,r=b-p-1;
				if(l<((b-a)/16|0)||r<((b-a)/16|0)){
					if(!--bA)return await hs.sort(A,a,b);
					if(l>24){
						await logMedian(A,a,p);
						lML=true;
					}
					if(r>24){
						await logMedian(A,p+1,b);
						lMR=true;
					}
				}else if(aP&&await partialInsert(A,a,p)&&await partialInsert(A,p+1,b))return;
				if(l>r){
					await quickSort(A,p+1,b,bA,lMR);
					b=p;
					lM=lML;
				}else{
					await quickSort(A,a,p,bA,lML);
					a=p+1;
					lM=lMR;
				}
			}
			await insertSort(A,a,b,.25);
		}
		await quickSort(arr,0,len,floorLog(len));
	}
	async PDLaziestSort(len){
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let c=A[i],p=i-1;
				while(p>=a&&compareValues(A[p],c)>0)
					await write(A,p+1,A[p--],1,true);
				await write(A,p+1,c,1,true);
				i++;
			}
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,1.0,true,false);
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function laziestStableSort(A,s,e){
			let l=e-s;
			if(l<17)return await insertion(A,s,e);
			let i,bL=maxVal(16,sqrt(len)|0);
			for(i=s;i+2*bL<e;i+=bL)
				await insertion(A,i,i+bL);
			await insertion(A,i,e);
			while(i-bL>=s){
				await inPlaceMerge(A,i-bL,i,e);
				i-=bL;
			}
		}
		await laziestStableSort(arr,0,len);
	}
	async LAQuickSort(len){
		const hs=new HeapSorting(true);
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<b&&compareIndices(A,i,p)<0);
				do j--;while(j>=a&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function ghostPartition(A,a,b,v){
			let i=a,j=b-1;
			while(i<=j){
				while(compareValues(A[i],v)<0)i++;
				while(compareValues(A[j],v)>0)j--;
				if(i<=j){
					await swap(A,i++,j--,1,true);
				}
			}
			return i;
		}
		function log2(n){
			return log(n)/log(2)|0;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		function logarithmicAverage(A,l,h){
			let s=0,c=0,q=log2(h-l);
			if(2>q)q=2;
			for(let i=l;i<h;i+=(h-l)/q|0){
				s+=A[i];
				c++;
			}
			return s/c|0;
		}
		async function getSortedRuns(A,a,b){
			let rS=true,s=true,c;
			for(let i=a;i<b-1;i++){
				c=compareIndices(A,i,i+1);
				if(c>0)s=false;
				else rS=false;
				if(!rS&&!s)return false;
			}
			if(rS&&!s)await reversal(A,a,b-1,1,s=true);
			return s;
		}
		async function quickSort(A,l,h,d,bP,lA,qP){
			if(await getSortedRuns(A,l,h))return;
			if(h-l>16){
				let pi=l,pv=l;
				if(!lA){
					await medianOfThree(A,l,h);
					pi=await partition(A,l,h,l);
					let a=pi-l;
					let b=h-(pi+1);
					if((!a||!b)||((a/b|0)>15||(b/a|0)>15))lA=true;
					else{
						await swap(A,l,pi,1,true);
						pv=A[pi];
					}
				}
				if(lA){
					pv=logarithmicAverage(A,l,h);
					pi=await ghostPartition(A,l,h,pv);
				}
				if(bP==pv)qP++;
				if(d==0||qP>4){
					if(qP>4)qP=0;
					await hs.sort(A,l,h);
					return;
				}
				d--;
				await quickSort(A,l,pi,d,pv,lA,qP);
				await quickSort(A,pi+(lA?0:1),h,d,pv,lA,qP);
			}else await insertSort(A,l,h);
		}
		await quickSort(arr,0,len,2*log2(len),arr[1],false,0);
	}
	async adaptiveBinaryInsertionSort(len){
		async function abinaryinsert(A,s,e){
			let c=0,k=0;
			for(let i=s+1;i<e;i++){
				let n=A[i];
				let v=2*c/(i-s)+1|0;
				let lo=maxVal(i-v,s),hi=i;
				while(lo>=s&&compareValues(A[lo],n)>0){
					lo-=v;
					hi-=v;
				}
				if(++lo<s)lo=s;
				while(lo<hi){
					let m=lo+(hi-lo)/2|0;
					if(compareValues(n,A[m])<0)hi=m;
					else lo=m+1;
				}
				c+=i-lo;
				let j=i-1;
				if(j>=lo){
					while(j>=lo){
						write(A,j+1,A[j--],0);
						if(++k>=len){
							mark(j+2);
							await sleep(k=0);
						}
					}
					await write(A,lo,n,1,true,false);
				}
			}
		}
		await abinaryinsert(arr,0,len);
	}
	async ciuraCocktailShellSort(len){
		let gs=[1,4,10,23,57,132,301,701];
		function ciura(n){
			if(n<=gs.length)return gs[n-1];
			return pow(2.25,n)|0;
		}
		async function sort(A,l){
			let g=1,k;
			for(k=1;g<l;k++)g=ciura(k);
			let d=true;
			while(--k>0){
				g=ciura(k);
				if(d){
					for(let i=g;i<l;i++){
						let t=A[i],j=i;
						while(j>=g&&compareValues(A[j-g],t)>0)
							await write(A,j,A[j-=g],0.7,true);
						await write(A,j,t,0.7,true);
					}
				}else{
					for(let i=l-g;i>=0;i--){
						let t=A[i],j=i;
						while(j<l-g&&compareValues(A[j+g],t)<0)
							await write(A,j,A[j+=g],0.7,true);
						await write(A,j,t,0.7,true,false);
					}
				}
				d=!d;
			}
		}
		await sort(arr,len);
	}
	async PCBoysParShellSort(len){
		const base=askForBase(10);
		function threshold(x){
			return sqrt(x);
		}
		async function par(A,l){
			let x=new Array(l).fill(!1);
			let mx=A[0];
			for(let i=1;i<l;i++){
				if(A[i]>mx){
					mx=A[i];
					x[i]=true;
				}
			}
			let i=l-1,p=1,j=l-1;
			while(j>=0&&i>=p){
				while(!x[j]&&j>0)j--;
				mx=A[j];
				while(mx<=A[i]&&i>=p)i--;
				if(A[j]>A[i]&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		async function shellPass(A,l,g){
			if(g>=lg)return;
			if(g==lg-1&&g-1)return;
			lg=g;
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],0.25,w=true);
				if(w)
					await write(A,j,v,0.25,true);
			}
		}
		let td=base;
		let lp=len;
		let lg=len;
		while(1){
			let p=await par(arr,len);
			let psp=p;
			if(p>=lp)p=lp-td|0;
			if((p/td|0)<2){
				await shellPass(arr,len,1);
				break;
			}
			await shellPass(arr,len,(p/td|0)+p%td);
			if(lp-par<=threshold(lp))td*=1.5;
			lp=p;
		}
	}
	async anarchySort(len){
		function containsValue(l,v){
			for(let a=0;a<l.length;a++){
				mark(a);
				if(l[a]==v)return true;
			}
			return false;
		}
		async function swapper(A,B,a,b){
			swap(B,a,b,0,false,true);
			await swap(A,a,b,1,true);
		}
		async function convert(A,aux,l){
			let i=0,j=0;
			while(i<l){
				if(compareIndices(A,j,i)<0)
					j=i;
				i++;
			}
			await swap(A,0,j,1,true,true);
			for(let init=0;init<l;init++)
				write(aux,init,A[init],0,false,true);
			let t2=[];
			let m=0;
			while(m<l){
				i=j=0;
				while(i<l){
					if(compareIndices(A,i,j)<1&&!containsValue(t2,i))
						j=i;
					i++;
				}
				t2.push(j);
				await write(A,j,m++,1,true);
			}
		}
		async function sort(A,t,l){
			for(let i=0;i<l;i++)
				while(A[i]-i)
					await swapper(A,t,i,A[i]);
		}
		let aux=new Array(len);
		await convert(arr,aux,len);
		await sort(arr,aux,len);
		for(let i=0;i<len;i++)
			await write(arr,i,aux[i],1,true);
	}
	async adaptiveInsertionSort(len){
		async function findRun(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.5,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function moveFront(A,a,m,b){
			let mi=m,mv=A[m];
			for(let i=m+1;i<b;i++)
				if(compareIndexValue(A,i,mv)<0)
					mv=A[mi=i];
			m--;
			while(mi>m)
				await write(A,mi,A[--mi],1,true);
			--a;
			while(mi>a&&compareValues(A[mi],mv)>0)
				await write(A,mi+1,A[mi--],1,true);
			await write(A,mi+1,mv,1,true);
		}
		async function insertion(A,a,b){
			let i=await findRun(A,a,b),j=0;
			if(i<b){
				await moveFront(A,a,i++,b);
				while(i<b){
					let c=A[i],p=i-1;
					while(compareValues(A[p],c)>0){
						write(A,p+1,A[p--],0);
						if(++j>=len){
							mark(p+2);
							await sleep(j=0);
						}
					}
					await write(A,p+1,c,1,true);
					i++;
				}
			}
		}
		await insertion(arr,0,len);
	}
	async bidirectionalInsertionSort(len){
		let j=0;
		async function insertFw(A,i,c){
			let p=i-1;
			while(compareValues(A[p],c)>0){
				write(A,p+1,A[p--],0);
				if(++j>=len){
					mark(p+2);
					await sleep(j=0);
				}
			}
			await write(A,p+1,c,1,true);
		}
		async function insertBw(A,i,c){
			let p=i-1;
			while(compareValues(A[p],c)<1){
				write(A,p+1,A[p--],0);
				if(++j>=len){
					mark(p+2);
					await sleep(j=0);
				}
			}
			await write(A,p+1,c,1,true);
		}
		async function insertion(A,a,b){
			let d=true;
			for(let i=a+1;i<b;i++){
				let c=A[i];
				if(d){
					if(compareValues(c,A[a])<0){
						await reversal(A,a,i-1,1,true);
						d=!d;
					}else
						await insertFw(A,i,c);
				}else{
					if(compareValues(c,A[a])+1){
						await reversal(A,a,i-1,1,true);
						d=!d;
					}else
						await insertBw(A,i,c);
				}
			}
			if(!d)await reversal(A,a,b-1,1,true);
		}
		await insertion(arr,0,len);
	}
	async exponentialInsertionSort(len){
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			let j=0;
			if(a>b){
				let t=A[a];
				do{
					write(A,a,A[--a],1);
					if(++j>=len)await sleep(j=0);
				}while(a>b);
				await write(A,b,t,1,true);
			}
		}
		for(let i=1;i<len;i++)
			await insertTo(arr,i,rightExpSearch(arr,0,i,arr[i]));
	}
	async roomSort(len){
		async function insertTo(A,a,b){
			let v=A[a--],j=0;
			while(a>=b&&compareValues(A[a],v)>0){
				write(A,a+1,A[a--],0);
				if(++j>=len)await sleep(j=0);
			}
			await write(A,a+1,v,1,true);
		}
		let rL=sqrt(len)+1|0;
		let e,i;
		for(e=len;e>rL;e-=rL){
			await insertSort(arr,0,rL);
			for(i=rL;i<e;i++)
				await insertTo(arr,i,i-rL);
		}
		await insertSort(arr,0,len);
	}
	async rendezvousSort(len){
		async function rendezvousSort(A,l){
			let ln=l,i,j,t,f,g;
			while(ln>0){
				i=0;j=ln;
				while(l>=j){
					t=i;f=0;
					while(!(i<1||!(compareIndices(A,j,i)<0))){
						await swap(A,i,j,1,true);
						f=1;g=1+j-i;i-=g;j-=g;
					}
					i++;j++;
					if(f==1){
						ln=ln/.25|0;
						i=0;
						j=ln;
					}
				}
				ln=ln/8|0;
			}
			i=0;j=1;
			while(l>=j){
				t=i;
				while(i>=0&&compareIndices(A,j,i)<0)
					await swap(A,i--,j--,1,true);
				i=t+1;
				j=t+2;
			}
		}
		await rendezvousSort(arr,len-1);
	}
	async gambitInsertionSort(len){
		function binSearch(A,b,e,t){
			while(1){
				let d=e-b;
				if(d<1)break;
				let p=b+d/2|0;
				if(!compareIndices(A,p,t))return p;
				if(compareIndices(A,p,t)>0){
					e=p;
					continue;
				}
				b=p+1;
			}
			return e;
		}
		async function binInsert(A,l,s,e){
			let o=1,k=0;
			for(;o*o<l;o*=2);
			for(let bS=0,bE=e,i=s+o;i<e;i++){
				let t=binSearch(A,bS,bE,i);
				let m=A[i],j=i-1;
				while(j>=t&&A[j]>m){
					write(A,j+1,A[j--],0);
					if(++k>=sqrt(len)){
						mark(j+2);
						await sleep(k=0);
					}
				}
				A[j+1]=m;
			}
		}
		await binInsert(arr,len,0,len);
		await insertSort(arr,0,len,.1);
	}
	async triSearchInsertionSort(len){
		function triSearch(A,l,h,v){
			let m=l+(h-l)/2|0;
			if(compareValues(v,A[l])<0)return l;
			else{
				if(compareValues(v,A[h])<0){
					if(compareValues(v,A[m])<0)return triSearch(A,l+1,m-1,v);
					else return triSearch(A,m+1,h-1,v);
				}else return h+1;
			}
		}
		async function triInsertSort(A,s,e){
			let k=0;
			for(let i=s+1;i<e;i++){
				let n=A[i];
				let lo=s;
				lo=triSearch(A,s,i-1,n);
				let j=i-1;
				while(j>=lo){
					write(A,j+1,A[j--],0,true);
					if(++k>=len){
						mark(j+1);
						await sleep(k=0);
					}
				}
				await write(A,lo,n,1,true);
			}
		}
		await triInsertSort(arr,0,len);
	}
	async adaptiveMedianOfMediansQuickSort(len){
		const hs=new HeapSorting(true);
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,l=a,i,j,ad=true;
			while(e-l>1){
				j=l;
				for(i=l;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s,1/4);
					await swap(A,j++,i+s/2,1);
				}
				if(i<e){
					await insertSort(A,i,e,.25);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,1);
					if((e-i+1)%2)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b){
			let pv=A[a],f=a,l=b;
			while(compareValues(A[++f],pv)<0);
			if(f-1==a)while(f<l&&compareValues(A[--l],pv)>0);
			else while(compareValues(A[--l],pv)>0);
			let aP=f>=l;
			while(f<l){
				await swap(A,f,l,1,true);
				while(compareValues(A[++f],pv)<0);
				while(compareValues(A[--l],pv)>0);
			}
			let pvp=f-1;
			await write(A,a,A[pvp],1,true);
			await write(A,pvp,pv,1,true);
			return[pvp,aP];
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,bA,med){
			while(b-a>16){
				if(!med)await medianOfThree(A,a,b);
				let mL=false,mR=false;
				let[p,aP]=await partition(A,a,b);
				let l=p-a,r=b-p-1;
				if(l<((b-a)/16|0)||r<((b-a)/16|0)){
					if(!--bA)return await hs.sort(A,a,b,1);
					if(l>16){
						await medianOfMedians(A,a,p,5);
						mL=true;
					}
					if(r>16){
						await medianOfMedians(A,p+1,b,5);
						mR=true;
					}
				}else if(aP&&await partialInsert(A,a,p)&&await partialInsert(A,p+1,b))return;
				if(l>r){
					await quickSort(A,p+1,b,bA,mR);
					b=p;
					med=mL;
				}else{
					await quickSort(A,a,p,bA,mL);
					a=p+1;
					med=mR;
				}
			}
			await insertSort(A,a,b,.5);
		}
		await quickSort(arr,0,len,floorLog(len),false);
	}
	async blockInsertionSort(len){
		function grailRotate(A,p,a,b){
			return Rotations.holyGriesMills(A,p,a,b,.5,true);
		}
		function grailBinSearch(A,p,ln,kP,iL){
			let l,r;
			for(l=-1,r=ln;l<r-1;){
				let m=l+(r-l>>1);
				if(compareIndices(A,kP,p+m)<(iL?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2)while(l1){
				let o=grailBinSearch(A,p+l1,l2,p,true);
				if(o){
					await grailRotate(A,p,l1,o);
					p+=o;l2-=o;
				}
				if(!l2)break;
				do{p++;l1--;}while(l1&&compareIndices(A,p,p+l1)<1);
			}else while(l2){
				let o=grailBinSearch(A,p,l1,p+l1+l2-1,false);
				if(o-l1){
					await grailRotate(A,p+o,l1-o,l2);
					l1=o;
				}
				if(!l1)break;
				do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
			}
		}
		async function insert1(A,a,l){
			let t=A[l--];
			while(l>=a&&compareValues(A[l],t)>0)
				await write(A,l+1,A[l--],1,true);
			await write(A,l+1,t,1,true);
		}
		async function insert2(A,a,l,r){
			let tL=A[l--];
			let tR=A[r];
			while(l>=a&&compareValues(A[l],tR)>0)
				await write(A,l+2,A[l--],1,true);
			await write(A,l+2,tR,1,true);
			while(l>=a&&compareValues(A[l],tL)>0)
				await write(A,l+1,A[l--],1,true);
			await write(A,l+1,tL,1,true,false);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function insertion(A,a,b){
			let i=await findRun(A,a,b),j,l;
			while(i<b){
				j=await findRun(A,i,b);
				l=j-i;
				if(l<3){
					if(l>1)await insert2(A,a,i,i+1);
					else await insert1(A,a,i);
				}else await grailMergeWithoutBuffer(A,a,i-a,l);
				i=j;
			}
		}
		await insertion(arr,0,len);
	}
	async adaptiveMedianMergeSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j;
			let ad=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s,.25);
					await swap(A,j++,i+s/2,0);
				}
				if(i<e){
					await insertSort(A,i,e,0.25);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,0);
					if((e-i+1)%2)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(true){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		function lBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1) b=m;
				else a=m+1;
			}
			return a;
		}
		function rBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function lBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+1)i*=2;
			return rBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return lBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function mergeWithBufRest(A,a,m,b,p,pL){
			let i=0,j=m,k=a;
			while(i<pL&&j<b){
				if(compareValues(A[p+i],A[j])<1)
					await swap(A,k++,p+(i++),1,true);
				else
					await swap(A,k++,j++,1,true);
			}
			while(i<pL)await swap(A,k++,p+(i++),1,true);
		}
		async function mergeWithBuf(A,a,m,b,p){
			let l=m-a;
			await multiSwap(A,p,a,l);
			await mergeWithBufRest(A,a,m,b,p,l);
		}
		async function mergeWithBufBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareValues(A[p+i],A[j])+1)
					await swap(A,k--,p+(i--),1,true);
				else
					await swap(A,k--,j--,1,true);
			}
			while(i>=0)await swap(A,k--,p+(i--),1,true);
		}
		async function smartMerge(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=lBoundSearch(A,a,m,A[m]);
			b=rBoundSearch(A,m,b,A[m-1]);
			if(b-m<m-a)await mergeWithBufBW(A,a,m,b,p);
			else await mergeWithBuf(A,a,m,b,p);
		}
		function getMinLevel(n){
			while(n>31)n=(n+1)/2|0;
			return n;
		}
		async function insertTo(A,a,b){
			if(a>b){
				let t=A[a];
				do await write(A,a,A[--a],0.25,true);while(a>b);
				await write(A,b,t,0.25,true);
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)await insertTo(A,i,rBinSearch(A,a,i,A[i]));
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)await insertTo(A,i,rBinSearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,j=getMinLevel(l);
			await buildRuns(A,a,b,j);
			while(j<l){
				for(i=a;i+2*j<=b;i+=2*j)
					await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b)
					await smartMerge(A,i,i+j,b,p);
				j*=2;
			}
		}
		async function medianMergeSort(A,a,b){
			let s=a,e=b;
			let bP=false,m=false;
			while(e-s>16){
				if(bP){
					await medianOfMedians(A,s,e,5);
					m=true;
				}else await medianOfThree(A,s,e);
				let p=await partition(A,s+1,e,s);
				await swap(A,s,p,1,true);
				let l=p-s,r=e-p-1;
				bP=!m&&((!l||!r)||((l/r|0)>15||(r/l|0)>15));
				if(l<=r){
					await mergeSort(A,s,p,p+1);
					s=p+1;
				}else{
					await mergeSort(A,p+1,e,s);
					e=p;
				}
			}
			await insertion(A,s,e);
		}
		await medianMergeSort(arr,0,len);
	}
	async twinSort(len){
		async function twinSwap(A,l,n){
			let i=0,s,e=n-2;
			while(i<=e){
				if(compareIndices(A,i+l,i+1+l)<1){
					i+=2;
					continue;
				}
				s=i;i+=2;
				while(1){
					if(i>e){
						if(!s){
							if(!(n%2)||compareIndices(A,i-1+l,i+l)>0){
								counts.rev++;
								e=n-1;
								while(s<e)await swap(A,l+s++,l+e--,1,true);
								return 1;
							}
						}
						break;
					}
					if(compareIndices(A,i+l,i+1+l)>0){
						if(compareIndices(A,i-1+l,i+l)>0){
							i+=2;
							continue;
						}	
						await swap(A,i+l,i+1+l,1,true);
					}
					break;
				}
				e=i-1;counts.rev++;
				while(s<e)
					await swap(A,l+s++,l+e--,1,true);
				e=n-2;
				i+=2;
			}
			return 0;
		}
		async function tailMerge(A,l,tmp,n,bl){
			let o,a,s=0,c,cx,d,dx,e;
			while(bl<n){
				for(o=0;o+bl<n;o+=bl*2){
					a=o;e=a+bl-1;
					if(compareIndices(A,e+l,e+1+l)<1)continue;
					if(o+bl*2<=n){
						cx=s+bl;
						dx=a+bl*2;
					}else{
						cx=s+n-o-bl;
						dx=n;
					}
					d=dx-1;
					while(compareIndices(A,e+l,d+l)<1){
						dx--;
						d--;
						cx--;
					}
					c=s;d=a+bl;
					while(c<cx)
						write(tmp,c++,A[l+d++],0,false,true);
					c--;d=a+bl-1;e=dx-1;
					if(compareIndices(A,a+l,a+bl+l)<1){
						await write(A,l+e--,A[l+d--],1,true);
						while(c>=s){
							while(compareValues(A[d+l],tmp[c])>0)
								await write(A,l+e--,A[l+d--],1,true);
							await write(A,l+e--,tmp[c--],1,true);
						}
					}else{
						await write(A,l+e--,A[l+d--],1,true);
						while(d>=a){
							while(compareValues(A[d+l],tmp[c])<1)
								await write(A,l+e--,tmp[c--],1,true);
							await write(A,l+e--,A[l+d--],1,true);
						}
						while(c>=s)
							await write(A,l+e--,tmp[c--],1,true);
					}
				}
				bl*=2;
			}
		}
		async function sort(A,n){
			if(!await twinSwap(A,0,n)){
				let tmp=[];
				await tailMerge(A,0,tmp,n,2);
			}
		}
		await sort(arr,len);
	}
	async PDExponentialInsertionSort(len){
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			if(a>b){
				let j=0,t=A[a];
				do{
					write(A,a,A[--a],1);
					if(++j>=len/2){
						mark(a+1);
						await sleep(j=0);
					}
				}while(a>b);
				await write(A,b,t,1,true);
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b)
				await insertTo(A,i,rightExpSearch(A,a,i,A[i++]));
		}
		await insertion(arr,0,len);
	}
	async fibonacciInsertionSort(len){
		function fibonacciSearch(A,s,e,m){
			let fibM2=0,fibM1=1,fibM=1;
			while(fibM<=e-s){
				fibM2=fibM1;
				fibM1=fibM;
				fibM=fibM2+fibM1;
			}
			let o=s-1;
			while(fibM>1){
				let i=minVal(o+fibM2,e);
				if(compareValues(A[i],m)<1){
					fibM=fibM1;
					fibM1=fibM2;
					fibM2=fibM-fibM1;
					o=i;
				}else{
					fibM=fibM2;
					fibM1-=fibM2;
					fibM2=fibM-fibM1;
				}
			}
			let p=++o;
			if(compareValues(A[p],m)<1)p++;
			return p;
		}
		async function fibonacciInsertionSort(A,l){
			for(let i=1,k=0;i<l;i++){
				let t=A[i];
				let p=fibonacciSearch(A,0,i-1,t);
				let j=i-1;
				while(j>=p){
					write(A,j+1,A[j--],0);
					if(++k>=len){
						mark(j+2);
						await sleep(k=0);
					}
				}
				await write(A,j+1,t,1,true);
			}
		}
		await fibonacciInsertionSort(arr,len);
	}
	async PDBinaryInsertionSort(len){
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,1,true);
			else await reversal(A,s,e,1,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,1,true);
					else await reversal(A,l,r,1,true);
				}
				i++;
			}
		}
		async function pd(A,s,e){
			let f=s;
			let c=compareIndices(A,f,f+1);
			let u=false;
			while(c<1&&f+1<e){
				if(!c)u=true;
				if(++f+1<e)c=compareIndices(A,f,f+1);
			}
			let r=s;
			if(f==s){
				let d=false;
				c=compareIndices(A,r,r+1);
				while(c+1&&r+1<e){
					if(!c)u=true;
					else d=true;
					if(++r+1<e)c=compareIndices(A,r,r+1);
				}
				if(r>s&&d){
					if(u)await stableSegmentReversal(A,s,r);
					else if(r<s+3)await swap(A,s,r,1,true);
					else await reversal(A,s,r,1,true);
				}
			}
			return maxVal(f,r);
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function pdbinsert(A,s,e){
			let p=await pd(A,s,e),j=0;
			for(let i=p+1;i<e;i++){
				let t=A[i];
				let l=binarySearch(A,s,i,t);
				let w=false;
				for(let r=i;r>l;r--){
					write(A,r,A[r-1],0);
					w=true;
					if(++j>=len){
						mark(r);
						await sleep(j=0);
					}
				}
				if(w)await write(A,l,t,1,true);
			}
		}
		await pdbinsert(arr,0,len);
	}
	async stacklessTimSort(len){
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		function leftBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>=0)i*=2;
			return rightBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return leftBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			if(a>b){
				let t=A[a];
				do await write(A,a,A[--a],0.25,true);while(a>b);
				await write(A,b,t,0.25,true);
			}
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)
					await insertTo(A,i,rightBinSearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function mergeFW(A,tmp,a,m,b){
			let l1=m-a,t=a;
			arraycopy(A,a,tmp,0,l1,0,false,true);
			let i=0,mG=7,l=0,r=0;
			while(1){
				do{
					if(compareValues(tmp[i],A[m])<1){
						await write(A,a++,tmp[i++],1,true);
						l++;
						r=0;
						if(i==l1)return;
					}else{
						await write(A,a++,A[m++],1,true);
						r++;
						l=0;
						if(m==b){
							while(i<l1)await write(A,a++,tmp[i++],1,true);
							return;
						}
					}
				}while((l|r)<mG);
				do{
					l=leftExpSearch(A,m,b,tmp[i])-m;
					for(let j=0;j<l;j++)
						await write(A,a++,A[m++],1,true);
					await write(A,a++,tmp[i++],1,true);
					if(i==l1)return;
					else if(m==b){
						while(i<l1)await write(A,a++,tmp[i++],1,true);
						return;
					}
					r=leftBoundSearch(tmp,i,l1,A[m])-i;
					for(let j=0;j<r;j++)
						await write(A,a++,tmp[i++],1,true);
					await write(A,a++,A[m++],1,true);
					if(i==l1)return;
					else if(m==b){
						while(i<l1)await write(A,a++,tmp[i++],1,true);
						return;
					}
					mG--;
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function mergeBW(A,tmp,a,m,b){
			let l2=b-m,t=a;
			arraycopy(A,m--,tmp,0,l2,0,false,true);
			let i=l2-1,mG=7,l=0,r=0;
			while(1){
				do{
					if(compareValues(tmp[i],A[m])+1){
						await write(A,--b,tmp[i--],1,true);
						l++;
						r=0;
						if(i<0)return;
					}else{
						await write(A,--b,A[m--],1,true);
						r++;
						l=0;
						if(m<a){
							while(i>=0)await write(A,--b,tmp[i--],1,true);
							return;
						}
					}
				}while((l|r)<mG);
				do{
					l=(m+1)-rightExpSearch(A,a,m+1,tmp[i]);
					for(let j=0;j<l;j++)
						await write(A,--b,A[m--],1,true);
					await write(A,--b,tmp[i--],1,true);
					if(i<0)return;
					else if(m<a){
						while(i>=0)await write(A,--b,tmp[i--],1,true);
						return;
					}
					r=(i+1)-rightBoundSearch(tmp,0,i+1,A[m]);
					for(let j=0;j<r;j++)
						await write(A,--b,tmp[i--],1,true);
					await write(A,--b,A[m--],1,true);
					if(i<0)return;
					else if(m<a){
						while(i>=0)await write(A,--b,tmp[i--],1,true);
						return;
					}
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function smartMerge(A,tmp,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftBoundSearch(A,a,m,A[m]);
			b=rightBoundSearch(A,m,b,A[m-1]);
			if(b-m<m-a)await mergeBW(A,tmp,a,m,b);
			else await mergeFW(A,tmp,a,m,b);
		}
		let mR=len;
		let tmp=new Array(mR/2|0);
		for(;mR>31;mR=(mR+1)/2|0);
		await buildRuns(arr,0,len,mR);
		for(let i,j=mR;j<len;j*=2){
			for(i=0;i+2*j<=len;i+=2*j)
				await smartMerge(arr,tmp,i,i+j,i+2*j);
			if(i+j<len)await smartMerge(arr,tmp,i,i+j,len);
		}
	}
	async OOPBufferedMergeSort(len){
		function log2(v){
			return log(v)/log(2);
		}
		function getBufferSize(l){
			return pow(2,1+ceil(log2(log2(len)|0)));
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function merge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function mergeUnderBuffer(A,bS,s,m,e){
			let bP=0,l=s,r=m;
			while(l<m&&r<e){
				if(compareIndices(A,l,r)<1)write(B,bP,A[l++],0,false,true);
				else write(B,bP,A[r++],0,false,true);
				bP++;
			}
			while(l<m)
				write(B,bP++,A[l++],0,false,true);
			while(r<e)
				write(B,bP++,A[r++],0,false,true);
			for(let i=0;i<e-s;i++)
				await write(A,s+i,B[i],1,true);
		}
		async function blockCopy(A,s,e){
			let bZ=e-s;
			for(let i=e-1;i>=s;i--)
				await write(A,i,A[i-bZ],0.125,true);
		}
		async function blockCopyFromBuffer(A,s,e){
			for(let i=e-1;i>=s;i--)
				await write(A,i,B[i-s],0.125,true);
		}
		async function blockInsertionSort(A,s,m,e,bZ){
			for(let i=m;i<e;i+=bZ){
				let k=A[i];
				let j=i-bZ;
				if(compareValues(k,A[j])+1)continue;
				for(let k=i;k<i+bZ;k++)
					write(B,k-i,A[k],0,false,true);
				await blockCopy(A,j+bZ,j+2*bZ);
				j-=bZ;
				while(j>=s&&compareValues(k,A[j])<0){
					await blockCopy(A,j+bZ,j+2*bZ);
					j-=bZ;
				}
				await blockCopyFromBuffer(A,j+bZ,j+2*bZ);
			}
		}
		async function mergeOverBuffer(A,bS,s,m,e){
			let bZ=bS/2|0;
			await blockInsertionSort(A,s,m,e,bZ);
			let cS=s;
			while(cS<e-bZ){
				if(compareIndices(A,cS+bZ-1,cS+bZ)>0)
					await mergeUnderBuffer(A,bS,cS,cS+bZ,cS+bS);
				cS+=bZ;
			}
		}
		let B;
		async function sort(A,l){
			let bS=getBufferSize(l);
			let ln=l-(l-bS)%(bS/2|0);
			if(bS*2>=ln)return await binaryInsertion(A,0,l,.3);
			B=new Array(bS);
			for(let i=0;i<ln-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,0.5,true);
			for(let g=4;g<=bS;g*=2)
				for(let i=0;i+g<=ln;i+=g)
					await mergeUnderBuffer(A,bS,i,i+g/2|0,i+g);
			for(let g=bS*2;(g/2|0)<=ln;g*=2){
				let i;
				for(i=0;i+g<=ln;i+=g)
					await mergeOverBuffer(A,bS,i,i+g/2|0,i+g);
				if(i+g>ln)
					await mergeOverBuffer(A,bS,i,i+g/2|0,ln);
			}
			if(l-ln>0){
				await binaryInsertion(A,ln,l);
				await merge(A,0,ln,l);
			}
		}
		await sort(arr,len);
	}
	async baseNMergeSort(len){
		let base=askForBase(10);
		function copyStarts(s,b){
			let c=new Array(b);
			for(let i=0;i<b;i++)
				write(c,i,s[i],0,false,true);
			return c;
		}
		async function merge(A,ss,e,b){
			let cS=copyStarts(ss,b);
			let l=e-ss[0];
			for(let nx=0;nx<l;nx++){
				let mV=1/0,mI=0;
				for(let i=0;i<b;i++){
					let sE=i==b-1?e:ss[i+1];
					if(cS[i]>=sE)continue;
					if(compareValues(A[cS[i]],mV)<0)
						mV=A[cS[mI=i]];
				}
				write(tmp,nx,mV,0,false,true);
				write(cS,mI,cS[mI]+1,0,false,true);
			}
			for(let i=0;i<l;i++)
				await write(A,ss[0]+i,tmp[i],1,true);
		}
		async function mergeRun(A,ss,e,b){
			if(e-ss[0]<b)return insertSort(A,ss[0],e,.5);
			for(let i=0;i<b;i++){
				let su=calculateStarts(ss[i],ss[1]-ss[0],b);
				let sE=i==b-1?e:ss[i+1];
				await mergeRun(A,su,sE,b);
			}
			await merge(A,ss,e,b);
		}
		function calculateStarts(s,l,b){
			let ss=new Array(b);
			let z=l/b|0;
			let c=s;
			for(let i=0;i<b;i++){
				write(ss,i,c,0,false,true);
				c+=z;
			}
			return ss;
		}
		function logBase(v,b){
			return log(v)/log(b);
		}
		async function mergeBase2(A,s,m,e){
			let l=e-s,lo=s,hi=m;
			for(let nx=0;nx<l;nx++){
				if(lo>=m&&hi>=e)break;
				if(lo<m&&hi>=e)write(tmp,nx,A[lo++],0,false,true);
				else if(lo>=m&&hi<e)write(tmp,nx,A[hi++],0,false,true);
				else if(compareIndices(A,lo,hi)<0)write(tmp,nx,A[lo++],0,false,true);
				else write(tmp,nx,A[hi++],0,false,true);
			}
			for(let i=0;i<l;i++)
				await write(A,s+i,tmp[i],1,true);
		}
		async function baseNMerge(A,l,b){
			let lBC=logBase(b,2);
			let uB=pow(2,lBC)==pow(2,lBC|0);
			let s=0;
			let lB=uB?2:b;
			let lL=logBase(l,lB);
			if(pow(lB,lL|0)<pow(lB,lL))s=l-pow(lB,lL|0)|0;
			let ss=calculateStarts(s,l-s,b);
			await mergeRun(A,ss,l,b);
			if(s>0){
				await baseNMerge(A,s,b);
				await mergeBase2(A,0,s,l);
			}
		}
		let tmp=new Array(len);
		await baseNMerge(arr,len,base);
	}
	async shuffledTreeSort(len){
		async function stableSwap(A,k,a,b){
			await swap(A,a,b,0,true);
			swap(k,a,b,1,false,true);
		}
		function traverse(A,k,l,u,r){
			if(l[r])traverse(A,k,l,u,l[r]);
			write(k,idx++,r,1,false,true);
			if(u[r])traverse(A,k,l,u,u[r]);
		}
		let idx=0;
		async function sort(A,l){
			let k=new Array(l);
			for(let i=0;i<k;i++)
				write(keys,i,i,0,false,true);
			let R=new Random();
			for(let i=0;i<l;i++){
				let r=R.nextInt(l-i)+i;
				await stableSwap(A,k,i,r);
			}
			let lo=new Array(l);
			let hi=new Array(l);
			let nx;
			for(let i=1;i<l;i++){
				mark(i);
				let c=0;
				while(true){
					mark(c);
					let cmp=compareIndices(A,i,c);
					nx=(cmp<0||(!cmp&&compareIndices(k,i,c)<0))?lo:hi;
					if(!nx[c]){
						write(nx,c,i,0,false,true);
						break;
					}else c=nx[c];
				}
			}
			idx=0;
			traverse(A,k,lo,hi,0);
			for(let i=0;i<l-1;i++){
				if(compareValues(i,k[i])){
					let t=A[i];
					let j=i,n=k[i];
					do{
						await write(A,j,A[n],1,true);
						write(k,j,j,0,false,true);
						j=n;
						n=k[n];
					}while(compareValues(n,i));
					await write(A,j,t,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		await sort(arr,len);
	}
	async adaptiveCreaseSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,0.5,true);
				return true;
			}
			return false;
		}
		let m=2,sw;
		for(;2*m<len;m*=2);
		for(let k=m;k>0;k=k/2|0){
			for(let i=1;i<len;i+=2)
				await compSwap(arr,i-1,i);
			sw=false;
			for(let j=m;j>=k&&j>1;j=j/2|0){
				for(let i=1;i+j-1<len;i+=2)
					sw|=await compSwap(arr,i,i+j-1);
				if(!sw&&j==k)k=k/2|0;
			}
		}
	}
	async adaptiveFoldSort(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0){
				await swap(A,a,b,.5,true);
				return true;
			}
			return false;
		}
		let cL=1,e=len,sw;
		for(;(1<<cL)<len;cL++);
		len=1<<cL;
		for(let k=len/2|0;k>0;k=k/2|0){
			sw=false;
			for(let j=len;j>=k&&j>0;j=j/2|0){
				for(let i=0;i<len;i+=j)
					for(let m=0;m<(j/2|0);m++)
						sw|=await compSwap(arr,i+m,i+j-1-m);
				sw&=j<len;
				if(!sw&&j==k)k=k/2|0;
			}
		}
	}
	async burningSortRec(len){
		function comp(A,s,e){
			if(s-e&&compareIndices(A,s,e)>0)
				return swap(A,s,e,0.5,true);
		}
		let j=0;
		async function sort(A,s,e){
			if(s==e)return;
			let m=(s+e)/2|0,g0=m-s;
			if(s==m)return;
			await sort(A,s,m);
			await sort(A,m,e);
			for(let i=0;i<g0;i++){
				if(comp(A,i+s,e-i-1)&&++j>=cbrt(len)){
					mark(i+s);
					await sleep(j=0);
				}
			}
			await sort(A,s,m);
			await sort(A,m,e);
		}
		await sort(arr,0,len);
	}
	async circleHalverSort(len){
		async function compSwap(A,a,b){
			if(a<e&&b<e&&compareIndices(A,a,b)>0){
				await swap(A,a,b,.25,true);
				return true;
			}
			return false;
		}
		async function bwdComp(A,a,b){
			let d=false;
			for(let i=a,j=b-1;i<j;i++,j--)
				d=await compSwap(A,i,j)?true:d;
			return d;
		}
		async function fwdComp(A,a,m,l){
			for(let i=0;i<l;i++)
				await compSwap(A,a+i,m+i);
		}
		async function halver(A,a,b){
			let n=b-a,c=-1;
			let d=true;
			while(d){
				d=false;
				for(let j=1;j<(n/2|0);j*=2)
					for(let i=a;i<minVal(e,b);i+=2*j)
						await fwdComp(A,i,i+j,j);
				d=await bwdComp(A,a,b)?true:d;
				c++;
			}
		}
		let l=len;
		let e=l;
		l=1<<(log(l-1)/log(2)|0)+1;
		await halver(arr,0,l);
		for(let j=l/2|0;j>4;j=j/2|0)
			for(let i=0;i+(j/2|0)<e;i+=j)
				if(await bwdComp(arr,i,i+j))
					await halver(arr,i,i+j);
		for(let i=2;i<e;i+=4)
			await compSwap(arr,i-1,i);
	}
	async corruptSort(len){
		async function comp(A,s,e){
			if(compareIndices(A,s,e)>0)
				await swap(A,s,e,.5,true);
		}
		function cpotlt(l){
			let z=1;
			while(z<=l)z*=2;
			return z/2;
		}
		async function pass(A,s,e,l,g,t){
			for(let i=s;i<e;i++){
				let g2=g;
				while(g2>t){
					if(i+g2<l)
						await comp(A,i,i+g2);
					g2=g2/2|0;
				}
			}
		}
		async function merge(A,s,e,b){
			if(e<=s)return;
			let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
			if(!b)
				for(let i=s;i<m;i++){
					if(i+g0<e)
						await comp(A,i,i+g0);
				}
			if(s==m)return;
			if(e-s>4)await pass(A,s+g1,m,e,g1,1);
			await merge(A,s,m,true);
			await merge(A,m,e,true);
		}
		async function sort(A,s,e){
			if(e<=s)return;
			let m=(s+e)/2|0;
			if(s==m)return await merge(A,s,e);
			await sort(A,s,m);
			await sort(A,m,e);
			await merge(A,s,e);
		}
		await sort(arr,0,len);
		await pass(arr,0,len,len,cpotlt(len)-1,0);
	}
	async XORCircleSort(len){
		async function comp(A,s,e,d,x){
			if(e<x&&s<x&&s-e&&d==(compareIndices(A,s,e)>0))
				await swap(A,s,e,.5,true);
		}
		function xLess(l){
			let z=1;
			while(z<=l)z<<=1;
			return z>>1;
		}
		async function xorPass(A,s,e){
			let x=xLess(e-s);
			for(let i=s;i<e;i++)
				for(let j=x;j>0;j=j/2|0)
					if(!(i&j))await comp(A,i,i^j,true,e);
					else await comp(A,i,i^j,false,e);
		}
		async function circlePass(A,s,e){
			let m=s+(e-s)/2|0;
			for(let i=0;i<m-s;i++)
				await comp(A,s+i,e-i-1,true,e);
		}
		async function circleSort(A,s,e){
			let k=e-s;
			while(k>0&&!isRangeSorted(A,s,e)){
				for(let i=s;i<e;i+=k){
					await xorPass(A,i,i+k);
					await circlePass(A,i,i+k);
				}
				for(let i=s+k/2|0;i<e-(k/2|0);i+=k){
					await circlePass(A,i,i+k);
					await xorPass(A,i,i+k);
				}
				k=k/2|0;
			}
		}
		await circleSort(arr,0,len);
	}
	async matrixSortReal(len){
		async function bitonicSort(A,p,g,n,c){
			for(let k=n;k>1;k=k/2|0)
				for(let j=0;j<n;j+=k)
					for(let i=0;i<(k/2|0);i++)
						if(compareIndices(A,p+(j+i)*g,p+(j+i+k/2)*g)==c)
							await swap(A,p+(j+i)*g,p+(j+i+k/2|0)*g,1,true);
		}
		async function sort(A,p,g,n,c,l){
			if(n==2){
				if(compareIndices(A,p,p+g)==c)
					await swap(A,p,p+g,1,true);
				return;
			}
			let sqLR=(l+1)/2|0,sqLC=l/2|0;
			let it=sqLC;
			let sqR=1<<sqLR,sqC=1<<sqLC;
			while(it-->0){
				for(let i=0;i<sqC;i++)
					await sort(A,p+i*sqR*g,g,sqR,2*(i&1)*c-c,sqLR);
				for(let i=0;i<sqR;i++)
					await sort(A,p+i*g,sqR*g,sqC,c,sqLC);
			}
			for(let i=0;i<sqC;i++)
				await bitonicSort(A,p+(i*sqR)*g,g,sqR,c);
		}
		await sort(arr,0,1,len,1,31-clz32(len));
	}
	async vanVoorhisFourFourSortIterative(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function compRange(A,a,b,s){
			while(s-->0)await compSwap(A,a++,b++);
		}
		async function sort(A,l){
			for(let k=4;k<=l;k*=4){
				let f=k/4|0;
				for(let i=0;i<l;i+=k){
					await compRange(A,i,i+f,f);
					await compRange(A,i+2*f,i+3*f,f);
				}
				for(let i=0;i<l;i+=k){
					await compRange(A,i,i+2*f,f);
					await compRange(A,i+f,i+3*f,f);
				}
				for(let i=0;i<l;i+=k)
					await compRange(A,i+f,i+f+f,f);
				for(let m=16;m<=k;m*=4){
					let s=k/m|0;
					for(let i=0;i<l;i+=k){
						for(let j=2;j+7<m;j+=4){
							await compRange(A,i+j*s,i+(j+6)*s,s);
							await compRange(A,i+(j+1)*s,i+(j+7)*s,s);
						}
					}
					for(let i=0;i<l;i+=k){
						for(let j=1;j+5<m;j+=4){
							await compRange(A,i+j*s,i+(j+3)*s,s);
							await compRange(A,i+(j+2)*s,i+(j+5)*s,s);
						}
					}
					for(let i=0;i<l;i+=k){
						for(let j=2;j+3<m;j+=4){
							await compRange(A,i+j*s,i+(j+2)*s,s);
							await compRange(A,i+(j+1)*s,i+(j+3)*s,s);
						}
					}
					for(let i=0;i<l;i+=k)
						for(let j=3;j+3<m;j+=2)
							await compRange(A,i+j*s,i+(j+1)*s,s);
				}
			}
		}
		await sort(arr,len);
	}
	async pairwiseSortCursed(len){
		async function compSwap(A,a,b){
			if(b<N&&compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		async function pw(A,a,b,g){
			if(a>=b-g)return;
			for(let i=a;i<=b-2*g;i+=2*g)
				await compSwap(A,i,i+g);
			await pdw(A,a,b,2*g);
			await pdw(A,a+g,b+g,2*g);
			let p=1;
			while(p<(b-a)/g|0)p|=p<<1;
			while(p>0){
				for(let i=a+g;i+p*g<b;i+=2*g)
					await compSwap(A,i,i+p*g);
				p>>=1;
			}
		}
		async function pdw(A,a,b,g){
			if(a>=b-g)return;
			let n=(b-a)/g|0,m=n/2|0,o=m;
			m=a+m*g;
			for(let i=a;i<m;i+=g)
				await compSwap(A,i,m+i-a);
			await pw(A,a,m,g);
			await pw(A,m,b,g);
			for(let i=n>>2;i>0;i>>=1)
				for(let j=i;j<o-i<<1;j+=i<<1)
					for(let k=0;k<i;k++)
						await compSwap(A,a+(j+k)*g,a+(i+j+k)*g);
		}
		async function pairwise(A,a,b){
			let n=1;
			while(n<b-a)n*=2;
			N=b;
			await pdw(A,a,a+n,1);
		}
		let N;
		await pairwise(arr,0,len);
	}
	async XORSort(len){
		let e=len,j=0,th=len**2.2,s=0;
		for(let k=len-1;k>0;k--)
			for(let l=1;l<=k&&s<th;l++)
				for(let i=0;i<len&&s<th;i++){
					let b=i^(k%(l+1));
					if(b<e&&compareIndices(arr,i,b)<0){
						swap(arr,i,b);s++;
						if(++j>=len/2){
							mark(i);
							await sleep(j=0);
						}
					}
				}
		await insertSort(arr,0,len,.01);
	}
	async vanVoorhisFourFourSortRecursive(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function merge(A,p,n,g){
			if(n==4){
				await compSwap(A,p,p+g);
				await compSwap(A,p+2*g,p+3*g);
				await compSwap(A,p,p+2*g);
				await compSwap(A,p+g,p+3*g);
				await compSwap(A,p+g,p+2*g);
				return;
			}
			await merge(A,p,n/4|0,4*g);
			await merge(A,p+g,n/4|0,4*g);
			await merge(A,p+2*g,n/4|0,4*g);
			await merge(A,p+3*g,n/4|0,4*g);
			for(let i=2;i+7<n;i+=4){
				await compSwap(A,p+i*g,p+(i+6)*g);
				await compSwap(A,p+(i+1)*g,p+(i+7)*g);
			}
			for(let i=1;i+3<n;i+=2)
				await compSwap(A,p+i*g,p+(i+3)*g);
			for(let i=2;i+3<n;i+=4){
				await compSwap(A,p+i*g,p+(i+2)*g);
				await compSwap(A,p+(i+1)*g,p+(i+3)*g);
			}
			for(let i=3;i+3<n;i+=2)
				await compSwap(A,p+i*g,p+(i+1)*g);
		}
		async function sort(A,p,n){
			let f=n/4|0;
			if(f>1){
				await sort(A,p,f);
				await sort(A,p+f,f);
				await sort(A,p+2*f,f);
				await sort(A,p+3*f,f);
			}
			await merge(A,p,n,1);
		}
		await sort(arr,0,len);
	}
	async vanVoorhisThreeThreeSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function compRange(A,a,b,s){
			while(s-->0)await compSwap(A,a++,b++);
		}
		async function merge(A,p,n){
			let t=n/3|0;
			await compRange(A,p+t,p+t+t,t);
			await compRange(A,p,  p+t,  t);
			await compRange(A,p+t,p+t+t,t);
			for(let k=9;k<=n;k*=3){
				let s=n/k|0;
				for(let i=2;i+4<k;i+=3)
					await compRange(A,p+i*s,p+(i+4)*s,s);
				for(let i=1;i+2<k;i+=3)
					await compRange(A,p+i*s,p+(i+2)*s,s);
				for(let i=2;i+2<k;i+=3)
					await compRange(A,p+i*s,p+(i+2)*s,s);
				for(let i=2;i+1<k;i+=3)
					await compRange(A,p+i*s,p+(i+1)*s,s);
			}
		}
		for(let k=3;k<=len;k*=3)
			for(let i=0;i<len;i+=k)
				await merge(arr,i,k);
		await insertSort(arr,0,len,0);
	}
	async weavedVanVoorhisFourFourSortIterative(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function compRange(A,a,b,s){
			while(s-->0)await compSwap(A,a++,b++);
		}
		let e;
		async function sort(A,l){
			let n=1<<(2*(33-clz32(l-1))/2|0);e=l;
			for(let k=4;k<=n;k*=4){
				let g=n/k|0;
				for(let i=0;i<k;i+=2)
					await compRange(A,i*g,(i+1)*g,g);
				for(let i=0;i<k;i+=4){
					await compRange(A,i*g,(i+2)*g,g);
					await compRange(A,(i+1)*g,(i+3)*g,g);
				}
				for(let i=0;i<k;i+=4)
					await compRange(A,(i+1)*g,(i+2)*g,g);
				for(let j=16;j<=k;j*=4){
					let s=k/j|0,g1=4*(s-1);
					for(let i=2;i+7<j;i+=4){
						for(let m=0;m<s;m++){
							await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+6+((i+6)/4|0)*g1+4*m)*g,g);
							await compRange(A,(i+1+((i+1)/4|0)*g1+4*m)*g,(i+7+((i+7)/4|0)*g1+4*m)*g,g);
						}
					}
					for(let i=1;i+5<j;i+=4){
						for(let m=0;m<s;m++){
							await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+3+((i+3)/4|0)*g1+4*m)*g,g);
							await compRange(A,(i+2+((i+2)/4|0)*g1+4*m)*g,(i+5+((i+5)/4|0)*g1+4*m)*g,g);
						}
					}
					for(let i=2;i+3<j;i+=4){
						for(let m=0;m<s;m++){
							await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+2+((i+2)/4|0)*g1+4*m)*g,g);
							await compRange(A,(i+1+((i+1)/4|0)*g1+4*m)*g,(i+3+((i+3)/4|0)*g1+4*m)*g,g);
						}
					}
					if(g1>0){
						for(let i=3;i+3<j;i+=4)
							for(let m=0;m<s;m++)
								await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+1+((i+1)/4|0)*g1+4*m)*g,g);
						for(let i=5;i+3<j;i+=4)
							for(let m=0;m<s;m++)
								await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+1+((i+1)/4|0)*g1+4*m)*g,g);
					}else{
						for(let i=3;i+3<j;i+=2)
							for(let m=0;m<s;m++)
								await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+1+((i+1)/4|0)*g1+4*m)*g,g);
					}
				}
			}
		}
		await sort(arr,len);
	}
	async weavedVanVoorhisFourFourSortRecursive(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				await swap(A,a,b,0.5,true);
		}
		async function merge(A,p,n,g,g1){
			if(n<5){
				await compSwap(A,p,p+g);
				await compSwap(A,p+2*g,p+3*g);
				await compSwap(A,p,p+2*g);
				await compSwap(A,p+g,p+3*g);
				await compSwap(A,p+g,p+2*g);
				return;
			}
			await merge(A,p,n/4|0,g,4*(g1+3));
			await merge(A,p+(g1+4)*g,n/4|0,g,4*(g1+3));
			await merge(A,p+(g1+4)*g*2,n/4|0,g,4*(g1+3));
			await merge(A,p+(g1+4)*g*3,n/4|0,g,4*(g1+3));
			for(let i=2;i+7<n;i+=4){
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+6+((i+6)/4|0)*g1)*g);
				await compSwap(A,p+(i+1+((i+1)/4|0)*g1)*g,p+(i+7+((i+7)/4|0)*g1)*g);
			}
			for(let i=1;i+3<n;i+=2)
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+3+((i+3)/4|0)*g1)*g);
			for(let i=2;i+3<n;i+=4){
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+2+((i+2)/4|0)*g1)*g);
				await compSwap(A,p+(i+1+((i+1)/4|0)*g1)*g,p+(i+3+((i+3)/4|0)*g1)*g);
			}
			for(let i=3;i+3<n;i+=2)
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+1+((i+1)/4|0)*g1)*g);
		}
		async function sort(A,p,n,g){
			let f=n/4|0;
			if(f>1){
				await sort(A,p,f,g*4);
				await sort(A,p+g,f,g*4);
				await sort(A,p+2*g,f,g*4);
				await sort(A,p+3*g,f,g*4);
			}
			await merge(A,p,n,g,0);
		}
		let e=len,n=1<<(2*(33-clz32(e-1))/2|0);
		await sort(arr,0,n,1);
	}
	async safeStalinSort(len){
		function oAdd(o,x){
			o.push(x);
			counts.aux++;
		}
		function oPop(o){
			return o.pop();
			counts.aux++;
		}
		async function remove(A,i,l){
			await arraycopy(A,i+1,A,i,l-i-1,0);
			await write(A,l-1,-1,1,true);
		}
		async function add(A,x,l){
			await write(A,l,x,1,true);
		}
		async function insert(A,i,x,l){
			await arraycopy(A,i,A,i+1,l-i,0);
			await write(A,i,x,1,true);
		}
		async function sort(A,l){
			let o=[];
			let p=false;
			let gL=l,xL=0,k=0;
			while(!p){
				let i=0;
				while(i<l){
					i++;
					while(i<gL){
						let compare=compareIndices(A,i-1,i);
						if(compare>0){
							oAdd(o,A[i]);
							mark(A[i]);
							await remove(A,i,l--);
							gL--;xL++;
						}else i++;
					}
					for(let j=0;j<xL;j++){
						await add(A,oPop(o),l++);
						gL++;
					}
					gL=l;
					xL=0;
				}
				let vI=1;
				p=true;
				while(vI-l&&p){
					let compare=compareIndices(A,vI-1,vI);
					if(compare<=0)vI++;
					else p=false;
				}
				if(!p){
					i=vI;
					mark(i);
					while(!(i+1>l)){
						oAdd(o,A[i]);
						await remove(A,i,l--);
						xL++;
					}
					i=1;
					for(let j=0;j<xL;j++)
						await insert(A,++i-2,oPop(o),l++);
					xL=0;
				}
			}
		}
		await sort(arr,len);
	}
	async calcium57Sort(len){
		async function t(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function b(A,l,r,k){
			while(l<r){
				let m=(l&r)+((l^r)>>1);
				if(compareValues(A[m],k)<0)r=m;
				else l=m+1;
			}
			return l;
		}
		async function milk(A,s,m,e){
			if(s-m&&m-e&&compareIndices(A,m-1,m)<1)return;
			if((e-s<17||s==m||m==e)&&s<e)return await insertSort(A,s,e,.5);
			let rz=e-m,r=m,z=s+(m-s)-rz,l=z;
			while(rz>0){
				if(compareIndices(A,l,r)>0)await t(A,l,r,rz);
				else{
					l++;
					rz--;
				}
			}
			await sort(A,m,e);
			if(z>s){
				let c=b(A,z,e,A[z-1]);
				for(let i=z;i<c;i+=z-s)
					await milk(A,i-(z-s),i,minVal(i+z-s,c));
			}
		}
		async function sort(A,s,e){
			let m=(e-s+1)/3|0;
			if(m<1)return;
			await sort(A,s+m,e);
			await sort(A,s,e-m);
			let z=e-s-2*m;
			await milk(A,s+minVal(m,z),e-m,e);
		}
		await sort(arr,0,len);
	}
	async calcium58Sort(len){
		async function t(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function b(A,l,r,k){
			while(l<r){
				let m=(l&r)+((l^r)>>1);
				if(compareValues(A[m],k)<0)r=m;
				else l=m+1;
			}
			return l;
		}
		async function milk(A,s,m,e){
			if((e-s<17||s==m||m==e)&&s<e)return insertSort(A,s,e,0);
			let rz=e-m,r=m,z=s+(m-s)-rz,l=z;
			while(rz>0){
				if(compareIndices(A,l,r)>0)await t(A,l,r,rz);
				else{
					l++;
					rz--;
				}
			}
			await sort(A,m,e);
			if(z>s){
				let c=b(A,z,e,A[z-1]);
				for(let i=z;i<c;i+=z-s)
					await milk(A,i-(z-s),i,minVal(i+z-s,c));
			}
		}
		async function sort(A,s,e){
			let m=(e-s+1)/3|0;
			if(m<1)return;
			await sort(A,s+m,e);
			await sort(A,s,e-m);
			await milk(A,s,e-m,e);
		}
		await sort(arr,0,len);
	}
	async sunriseSort(len){
		async function insert(t,i,a,b){
			draw();
			if(a+1&&!compareValues(t[a],i)){
				let r=randInt(a,b+1);
				await write(t,b,t[r],0.5,true,true);
				await write(t,r,i,0.5,true,true);
				return a;
			}else{
				await write(t,b,i,0.5,true,true);
				return b;
			}
		}
		async function sunriseMerge(A,x,a,b,c){
			let m=b-1,t=a,l=c-a+1,t2=-1;
			while(a<=m&&b<=c){
				if(compareIndices(A,a,b)<0)
					t2=await insert(x,A[a++],t2,t++);
				else
					t2=await insert(x,A[b++],t2,t++);
			}
			while(a<=m)
				t2=await insert(x,A[a++],t2,t++);
			while(b<=c)
				t2=await insert(x,A[b++],t2,t++);
			for(let i=0;i<l;i++,c--)
				await write(A,c,x[c],1,true);
		}
		async function sunrise(A,x,a,b){
			let m=a+(b-a)/2|0;
			if(a>=b)return;
			await sunrise(A,x,a,m);
			await sunrise(A,x,m+1,b);
			await sunriseMerge(A,x,a,m+1,b);
		}
		let tmp=new Array(len);
		await sunrise(arr,tmp,0,len-1);
	}
	async ringSort(len){
		function getMinMax(A,l){
			let mn=[A[0],A[0]];
			for(let i=1;i<l;i++){
				if(mn[0]>A[i])mn[0]=A[i];
				if(mn[1]<A[i])mn[1]=A[i];
			}
			return mn;
		}
		async function sort(A,l){
			let nx=getMinMax(A,l);
			let n=nx[0],x=nx[1];
			let m=0,i=0,k=0;
			let c=new Array(x-n+1).fill(0);
			for(let i=0;i<l;i++)
				write(c,A[i]-n,c[A[i]-n]+1,0,false,true);
			while(m<l){
				while(!c[i])i++;
				let w=i+n;
				for(let j=m;j<l;j++){
					if(c[i]>0){
						c[i]--;
						m++;
					}
					write(A,j,w,0);
					if(++k>=sqrt(len)){
						mark(j);
						await sleep(k=0);
					}
				}
			}
		}
		await sort(arr,len);
	}
	async adaptiveForcedStableQuickSort(len){
		let ofs;
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,1,true);
			else await reversal(A,s,e,.5,true);
			let i=s;
			let l,r;
			while(i<e){
				l=i;
				while(i<e&&!compareIndices(A,i,i+1))i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,1,true);
					else await reversal(A,l,r,1,true);
				}
				i++;
			}
		}
		function stableComp(A,k,a,b){
			let c=compareIndices(A,ofs+a,ofs+b);
			return c>0||(!c&&compareIndices(k,a,b)>0);
		}
		async function stableSwap(A,k,a,b){
			if(a==b)return;
			await swap(A,ofs+a,ofs+b,0,true);
			swap(k,a,b,0,false,true);
		}
		async function smallSort(A,k,a,b){
			for(let i=a+1;i<b;i++){
				let j=i;
				while(j>0&&stableComp(A,k,j-1,j))
					await stableSwap(A,k,j-1,j--);
			}
		}
		function medianOfThree(A,k,i0,i1,i2){
			let t;
			if(stableComp(A,k,i0,i1)){
				t=i1;
				i1=i0;
			}else t=i0;
			if(stableComp(A,k,i1,i2)){
				if(stableComp(A,k,t,i2))return t;
				return i2;
			}
			return i1;
		}
		async function medianOfMedians(A,k,a,b){
			while(b-a>2){
				let m=a,i=a;
				for(;i+2<b;i+=3)await stableSwap(A,k,m++,medianOfThree(A,k,i,i+1,i+2));
				while(i<b)await stableSwap(A,k,m++,i++);
				b=m;
			}
		}
		async function partition(A,k,a,b){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&!stableComp(A,k,i,a));
				do j--;while(j>=i&&stableComp(A,k,j,a));
				if(i>=j){
					await stableSwap(A,k,a,j);
					return j;
				}
				await stableSwap(A,k,i,j);
			}
		}
		async function innerSort(A,k,a,b,bA){
			while(b-a>16){
				if(bA)await medianOfMedians(A,k,a,b);
				else await stableSwap(A,k,a,medianOfThree(A,k,a,a+(b-a)/2|0,b-1));
				let p=await partition(A,k,a,b);
				let lL=p-a,rL=b-p-1;
				bA=lL<((b-a)/16||0)|rL<((b-a)/16|0);
				if(lL>rL){
					await innerSort(A,k,p+1,b,bA);
					b=p;
				}else{
					await innerSort(A,k,a,p,bA);
					a=p+1;
				}
			}
			await smallSort(A,k,a,b);
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0?1:0;
				e+=c?0:1;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(e>0)await stableSegmentReversal(A,a,b-1);
				else if(b-a<4)await swap(A,a,b-1,0.75,true);
				else reversal(A,a,b-1,0.75,true,false);
				return;
			}
			let l=b-a,k=new Array(l);
			for(let i=0;i<l;i++)
				write(k,i,i,0,false,true);
			ofs=a;
			await innerSort(A,k,0,l,false);
		}
		await quickSort(arr,0,len);
	}
	async headPullQuickSort(len){
		let l=1;
		while(l-len){
			let as=false;
			for(let r=l+1;r<=len;r++)
				if(compareIndices(arr,l-1,r-1)>0)
					await multiSwap(arr,r-1,0,.1,as=true);
			if(as)l=1;
			else l++;
		}
	}
	async LDQuickSort(len){
		async function partition(A,a,b){
			let p=A[a],i=a;
			for(let j=a;j<=b;j++){
				if(compareValues(A[j],p)<0){
					await swap(A,i,j,1,true);
					await swap(A,++i,j,1,true);
				}
			}
			return i;
		}
		async function quickSort(A,a,b){
			if(a<b){
				let p=await partition(A,a,b);
				await quickSort(A,a,p-1);
				await quickSort(A,p+1,b);
			}
		}
		await quickSort(arr,0,len-1);
	}
	async orpicSort(len){
		const hs=new HeapSorting(true);
		async function sort3(A,a,b,c){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,2.5,true);
			if(compareIndices(A,b,c)>0){
				await swap(A,b,c,2.5,true);
				if(compareIndices(A,a,b)>0)
					await swap(A,a,b,2.5,true);
			}
		}
		async function partition(a,p,r,pw){
			let mG,mZ=1,po=pw,mT=sqrt(r-p+1)|0;
			while(po-->0)mZ*=3;
			mG=(r-p+1)/mZ|0;
			if(mG<1)return hs.sort(a,p,r,.25);
			if(mG>1)
				for(let i=p+mG,j=p+1;i<=r;i+=mG)
					await swap(a,i,j++,2.5,true);
			for(let j=0;j<pw;j++){
				for(let i=p,k=p;i<p+mZ-2;i+=3,k++){
					await sort3(a,i,i+1,i+2);
					await swap(a,i+1,k,2.5,true);
				}
				mZ=(mZ+2)/3|0;
			}
			let pv=a[p],i=p,j=r,it=0,itn=0;
			while(i<=j){
				while(it<=mT&&compareValues(a[i],pv)<0){
					i++;
					it++;
					itn=0;
				}
				if(it+itn>mT&&i<=j)return await partition(a,p,r,pw+1);
				else{
					it=0;
					itn++;
				}
				while(it<=mT&&compareValues(a[j],pv)>0){
					j--;
					it++;
					itn=0;
				}
				if(it+itn>mT&&i<=j)return await partition(a,p,r,pw+1);
				else{
					it=0;
					itn++;
				}
				if(i<=j)
					await swap(a,i++,j--,1,true);
			}
			let m=maxVal(pw-1,1);
			await partition(a,p,j,m);
			await partition(a,i,r,m);
		}
		await partition(arr,0,len-1,1);
		await insertSort(arr,0,len,.1);
	}
	async adjacencyPancakeSort(len){
		function dualSwap(A,K,a,b){
			swap(K,a,b,0,false,true);
			swap(A,a,b,0);
		}
		async function reverse(A,K,a,b){
			let i=0;
			while(b-a>1){
				dualSwap(A,K,a++,--b);
				if(++i>=cbrt(len)){
					mark(a-1);
					await sleep(i=0);
				}
			}
		}
		function isAdjacent(K,a,b,N){
			return(K[a]+1)%N==K[b]||(K[b]+1)%N==K[a];
		}
		function findAdjacent(K,e,a,N){
			while(!isAdjacent(K,a,e,N))a++;
			return a;
		}
		async function sort(A,N){
			let a=0,b=N;
			if(N==2){
				if(compareIndices(A,a,a+1)>0)
					await reversal(A,a,a+1,.5,true);
				return;
			}
			let K=new Array(N);
			for(let j=a;j<b;j++){
				let c=0;
				for(let i=a;i<b;i++){
					if(i==j)continue;
					let cm=compareIndices(A,i,j);
					if(cm<0||(!cm&&i<j))c++;
				}
				write(K,j-a,c,0,false);
			}
			while(1){
				let i=a;
				while(i<b-1&&isAdjacent(K,i,i+1,N))i++;
				if(i==b-1)break;
				if(i==a){
					let j=findAdjacent(K,a,a+2,N);
					if(!isAdjacent(K,j-1,j,N))
						await reverse(A,K,a,j);
					else{
						let k=findAdjacent(K,a,j+1,N);
						if(!isAdjacent(K,k-1,k,N))
							await reverse(A,K,a,k);
						else{
							await reverse(A,K,a,j+1);
							await reverse(A,K,a,j);
							await reverse(A,K,a,k+1);
							await reverse(A,K,a,a+k-j);
						}
					}
				}else{
					let j=findAdjacent(K,a,i+1,N);
					if(!isAdjacent(K,j-1,j,N))
						await reverse(A,K,a,j);
					else{
						let k=findAdjacent(K,i,i+2,N);
						if(k+1<b&&isAdjacent(K,k+1,k,N)){
							await reverse(A,K,a,i+1);
							await reverse(A,K,a,k+1);
						}else if(isAdjacent(K,k-1,k,N)){
							await reverse(A,K,a,k+1);
							await reverse(A,K,a,a+k-i);
						}else{
							await reverse(A,K,a,k+1);
							await reverse(A,K,a,a+k-i);
							if(j<k){
								await reverse(A,K,a,k+1);
								await reverse(A,K,a,i+k-j+1);
							}else{
								await reverse(A,K,a,j+1);
								await reverse(A,K,a,a+j-k);
							}
						}
					}
				}
			}
			let i=a;
			while(K[i]&&K[i]!=N-1)i++;
			if(!K[i]){
				if(i==a)return;
				await reverse(A,K,a,b);
				i=b-2-i+a;
			}else if(i==a)return await reverse(A,K,a,b);
			await reverse(A,K,a,++i);
			await reverse(A,K,a,b);
			await reverse(A,K,a,b-i);
		}
		await sort(arr,len);
	}
	async rotatePancakeInsertionSort(len){
		let o;
		function compare(A,a,b){
			return compareIndices(A,o+a,o+b);
		}
		async function flip(A,i){
			if(i<1)return;
			if(i>2)
				await reversal(A,o,o+i,.1,true);
			else
				await swap(A,o,o+i,1,true);
		}
		async function sort(A,a,b){
			let ln=b-a;o=a;
			let v=false;
			let l,r,m;
			for(let i=1;i<ln;i++){
				if(v^compare(A,i-1,i)<1)continue;
				if(v^compare(A,0,i)>0){
					await flip(A,i-1);
					v=!v;
					continue;
				}
				l=0;r=i;
				while(l<r){
					m=l+(r-l)/2|0;
					if(v^compare(A,m,i)>0)r=m;
					else l=m+1;
				}
				await flip(A,l-1);
				await flip(A,i-1);
				await flip(A,i);
				await flip(A,l);
			}
			if(v)await flip(A,len-1);
		}
		await sort(arr,0,len);
	}
	async binaryQuasiPancakeSort(len){
		function binarySearch(A,s,e,v){
			while(s<e){
				let m=s+e>>>1;
				if(compareValues(A[m],v)<1)s=m+1;
				else e=m;
			}
			return s;
		}
		for(let i=1;i<len;++i){
			let j=binarySearch(arr,0,i,arr[i]);
			if(j-i){
				await reversal(arr,j,i-1,.2,true);
				await reversal(arr,j,i,.2,true);
			}
		}
	}
	async cubicPancakeSort(len){
		async function cubicReversal(A,i,j){
			for(let x=j;x>i;x--){
				for(let y=i;y<x;y++){
					reversal(A,i,y,0,true);
					reversal(A,i+1,y+1,0,true);
					reversal(A,i,y+1,0,true);
					await reversal(A,i,y-1,.1,true);
				}
			}
		}
		function sorted(A,l){
			for(let i=0;i<l;i++)
				if(compareIndices(A,i,i+1)>0)return false;
			return true;
		}
		function findMax(A,e){
			let j=0,m=-1/0;
			for(let i=0;i<=e;i++){
				if(compareValues(A[i],m)>0){
					m=A[i];
					j=i;
				}
			}
			return j;
		}
		for(let i=len-1;i>=0;i--){
			if(!sorted(arr,i)){
				let j=findMax(arr,i);
				if(!j)
					await cubicReversal(arr,0,i);
				else if(j-i){
					await cubicReversal(arr,0,j);
					await cubicReversal(arr,0,i);
				}
			}else break;
		}
	}
	async tinyPullSort(len){
		let k=0;
		for(let j=len;j>0;j--)
			for(let i=1;i<j;i++){
				swap(arr,i-1,i,0);
				if(++k>len){
					mark(i-1);
					await sleep(k=0);
				}
				if(compareIndices(arr,i-1,i)>0)i=0;
			}
	}
	async inverseGnomeSort(len){
		for(let i=1;i<len;i++)
			for(let g=0;g<i;g++)
				if(compareIndices(arr,g,i)>0){
					multiSwap(arr,g,i,0);
					markSwap(g,i);
					await sleep();
					g=-1;
				}
	}
	async reverseClamberSort(len){
		for(let i=len-2,k=0;i>=0;i--)
			for(let j=len-1;j>i;j--)
				if(compareIndices(arr,i,j)>0){
					swap(arr,i,j,0);
					if(++k>sqrt(len)){
						markSwap(i,j);
						await sleep(k=0);
					}
				}
	}
	async bottleSort(len){
		for(let i=0;i<len-1;i++){
			reversal(arr,0,i-1,0);
			if(compareIndices(arr,i,i+1)>0){
				await swap(arr,i,i+1,1,true);
				i=-1;
			}
		}
		for(let i=len-2;i>0;i--)
			reversal(arr,0,i-1,0);
	}
	async slightlyUnoptimizedBubbleSort(len){
		for(let i=len-1,k=0;i>0;i--)
			for(let j=0;j<i;j++)
				if(compareIndices(arr,j,j+1)>0){
					swap(arr,j,j+1,0);
					if(++k>sqrt(len)){
						markSwap(j,j+1);
						await sleep(k=0);
					}
				}
	}
	async jumpDownSort(len){
		let mP=len-1;
		for(let i=mP;i>0;i--){
			for(let j=0;j<i;j++){
				if(compareIndices(arr,i,j)<0){
					await swap(arr,i,j,0.2,true);
				}
			}
		}
	}
	async inPlaceOptimizedSmartSafeStalinSortInserts(len){
		function scan(A,c,l){
			for(let i=c;i+1<l;i++)
				if(compareIndices(A,i,i+1)>0)
					return false;
			return true;
		}
		function stepDown(A,e){
			for(let i=e-1;i>0;i--)
				for(let j=i-1;j>=0;j--)
					if(compareIndices(A,j,i)>0)
						return i+1;
			return 0;
		}
		function checkSegments(A,e){
			sC=0;
			for(let i=0;i+1<e&&sC<2;i++)
				if(compareIndices(A,i,i+1)>0)sC++;
		}
		let sC;
		async function sort(A,l){
			let p=false;
			l=stepDown(A,l);
			let nC=true;
			while(!p){
				p=nC=true;
				let c=1;
				for(let i=1;i+1<l;i++){
					if(compareIndices(A,c-1,i)<1){
						if(c-i)await Wr.insert(A,i,c,0.01,true,nC=false);
						p=false;
						c++;
					}
				}
				if(nC){
					checkSegments(A,l);
					if(sC<2)break;
				}
				if(p)p=scan(A,c,l);
				if(!p)await IndexedRotations.adaptable(A,0,c,l,0.25,true);
				if(--l-1>0){
					let cmp=compareIndices(A,l-1,l);
					while(!cmp&&l>0)
						if(--l>0)cmp=compareIndices(A,l-1,l);
				}
				l=stepDown(A,l);
			}
			if(nC)
				await insertSort(A,0,l,0.1);
		}
		await sort(arr,len);
	}
	async twoOptSort(len){
		function getDist(A,l){
			let d=0;
			for(let i=0;i<l-1;i++)
				d+=abs(A[i+1]-A[i]);
			return d;
		}
		async function sort(A,l){
			let d=false;
			while(!d){
				d=true;
				let bD=getDist(A,l);
				for(let i=0;i<l-1;i++){
					for(let j=i+1;j<l;j++){
						await reversal(A,i,j,0.02,true);
						let ds=getDist(A,l);
						if(ds<bD){
							bD=ds;
							d=false;
						}else await reversal(A,i,j,0.02,true);
					}
				}
			}
		}
		await sort(arr,len);
	}
	async grossSort(len){
		async function comp(A,s,e,d){
			if(s-e&&d==(compareIndices(A,s,e)>0)){
				await swap(A,s,e,1,true);
				return true;
			}
			return false;
		}
		async function rot(A,p,lA,lB,sl,m,x){
			for(let i=0;i<lB;i++)
				await multiSwap(A,p+lA+lB-1,p,sl,m,x);
		}
		async function bitPass(A,s,e,d){
			if(s==e)return;
			let m=(e-s)/2|0;
			for(let i=0;i<m;i++)
				await comp(A,s+i,s+m+i,d);
			if(m==e-s)return;
			await bitPass(A,s,s+m,d);
			await bitPass(A,e-m,e,d);
		}
		async function circlePass(A,s,e){
			if(s==e)return 0;
			let m=(e-s)/2|0,sw=0;
			for(let i=0;i<m;i++)
				if(await comp(A,s+i,e-i-1,true))
					sw++;
			if(m==e-s)return 0;
			sw+=await circlePass(A,s,s+m);
			sw+=await circlePass(A,e-m,e);
			return sw;
		}
		async function circleSort(A,s,e){
			let a=1;
			while(a>0)
				a=await circlePass(A,s,e);
		}
		async function horrorPass(A,s,e){
			for(let i=0;i<e-s;i++){
				await bitPass(A,s,e,true);
				await bitPass(A,s+i,e);
			}
		}
		async function surpass(A,s,e){
			for(let i=s;i<e;i++)
				for(let j=s;j<e;j++)
					for(let k=0;k<e-s;k++)
						if(compareIndices(A,i,j)<0)
							await multiSwap(A,j,i,0.05,true);
		}
		async function greenHerringPass(A,s,e){
			let h=(e-s)/2|0,a=s+h/2|0,b=e-h/2|0;
			if(a==s||b==e)return;
			await horrorPass(A,s,a);
			await surpass(A,s,a);
			await greenHerringPass(A,a,e);
			await circleSort(A,s,e);
		}
		async function grossPass(A,s,e,ln,l){
			let h=(e-s)/2|0,m=s+h;
			if (m==s)return;
			if(e-s<32)return await greenHerringPass(A,s,e);
			await grossPass(A,s,m,ln,true);
			if(l)await rot(A,s,h,h,.1,true);
			await grossPass(A,s,e-(m-s),ln,false);
			await circleSort(A,s,e);
			if(!l)await rot(A,s,e-s,minVal(ln-e,e-s),.1,true);
		}
		await grossPass(arr,0,len,len,true);
	}
}
const sorts=new Sorts(),sortNames=sorts.getNames();
function filterSorts(t){
	t=t.replaceAll("Sort","");
	if(t.startsWith("@"))t=t.trim();
	else t=t.toLowerCase().trim();
	Array.from(document.querySelectorAll("div.btnholder>div")).forEach((e,i)=>{
		if(t.length<1)e.className="shown";
		else{
			let raw=e.innerText.trim().replace("Sort","");
			let txt=e.innerText.trim().replace("Sort",""),f,nt=t.slice(1);
			if(!t.startsWith("@"))txt=txt.toLowerCase();
			if(t.startsWith("#"))f=txt.startsWith(nt);
			else if(t.startsWith("!")&&nt.length)f=txt.indexOf(nt)<0;
			else if(t.startsWith("@"))f=txt.indexOf(nt)+1;
			else if(t.startsWith("{")&&t.endsWith("}")&&t.length>2){
				let n=t.substr(1,t.length-2);
				if(n.indexOf("upper")+1)f=raw[0].toUpperCase()==raw[0];
				if(n.indexOf("lower")+1)f=raw[0].toLowerCase()==raw[0];
				if(n.indexOf("num")+1)f=/\d/.test(raw);
			}else f=txt.indexOf(t)+1;
			e.className=f?"shown":"hidden";
		}
	});
}
function appendTo(p,t,c){
	function hold(e){
		["touchstart","mousedown","mouseenter","mouseover"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=.5));
		["touchend","mouseup","mouseout","mouseleave","touchcancel","contextmenu"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=1));
	}
	let a=document.createElement("div");a.className="shown";a.textContent=a.title=t;hold(a);a.onclick=c;
	p.appendChild(a);
}
sortNames.forEach((e,i)=>appendTo(sortsholder,e,()=>runSort(e)));
document.querySelectorAll("div.btnholder")[0].style.height=parseFloat(window.getComputedStyle(cont).getPropertyValue("height"))+"px";
function runSort(name){
	if(sortRunning||!sorts[name]){
		if(sortnamedisp.innerText!="Running: ...")sortQueue=name;
		return;
	}
	sortRunning=true;
	if(emergencyStop){
		emergencyStop=false;
		loopSort.checked=willLoop;
	}
	shuffle().then(()=>{
		counts.reset();
		sortnamedisp.innerText="Running: "+name;
		sorts[name](arr_size).then(async()=>{
			await sleep(50);
			let{w,h}=getPixelR();
			let t=parseFloat(displayType.value);
			let delay=sqrt(arr_size),sorted=isArraySorted(arr,arr_size);
			draw();
			fill(sorted?"#0f0":"#f00");
			if(!sorted)console.warn(name);
			let b=t>1&&t<2.1;
			for(let i=0,j=0;i<arr_size;i++){
				let v=arr[i];
				if(t-4)ctx.fillRect(i*w,b?0:cvs.height-v*h,w+.5,b?cvs.height:v*h);
				else{
					let correct=[...arr].sort((a,b)=>a-b);
					let rad=minVal(cvs.width,cvs.height)/2*.9;
					function getDist(n,i){
						return(arr_size-abs(correct.indexOf(n)-i))/(arr_size)*rad;
					}
					let rd=getDist(v,i);
					let a=2*PI/arr_size*i-.5*PI;
					ctx.beginPath();
					ctx.arc(cvs.width/2+cos(a)*rd,cvs.height/2+sin(a)*rd,w,0,2*PI);
					ctx.fill();
				}
				if(++j>=delay)await sleep(j=0);
				sound(v,.015);
			}
			await sleep(250);
			throw".";
		}).catch(async e=>{
			arr=[...new Array(arr_size)].map((e,i)=>++i);
			draw();
			sortRunning=false;
			if(e.stack){
				let line=parseInt(e.stack.split(".html")[1].split(":")[1]);
				console.log("Error at",line-9,":",e.message);
			}
			if(nextSort.checked){
				let nxt=loopSort.checked?name:sortNames[(sortNames.indexOf(name)+1)%sortNames.length];
				if(sortQueue){
					nxt=sortQueue;
					sortQueue=null;
				}
				if(loopSort.checked&&nextShuffle.checked){
					shuffleType.value=shuffleNames[(shuffleNames.indexOf(shuffleType.value)+1)%shuffleNames.length]
				}
				counts.reset();
				await sleep(250);
				runSort(nxt);
			}
		});
	}).catch(e=>{
		let line=parseInt(e.stack.split(".html")[1].split(":")[1]);
		console.log("Error at",line-9,":",e.message);
	});
}
let unfiltered=Object.getOwnPropertyNames(Sorts.prototype);
runSort(unfiltered.pop());
//@400 massive clean up and speed optimization for slower sorts
//if(++j>=len)await sleep(j=0);
		</script>
	</body>
</html>