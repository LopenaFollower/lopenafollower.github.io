<!DOCTYPE html>
<html>
	<head>
		<title>Array Sorting</title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{
				user-select:none;
				color:#fff;
				margin:0;
			}
			::-webkit-scrollbar{
				height:5px;
				width:5px;
			}
			::-webkit-scrollbar-thumb{
				border-radius:10px;
				background:#777;
			}
			@media(orientation:landscape){#cvs{width:auto}}
			@media(orientation:portrait){#cvs{width:98%}}
			#cvs{
				background:#000;
				margin:1%;
			}
			td,#sortnamedisp,#nextsortdisp,.topicname{
				font-family:monospace;
				color:#fff;
			}
			#sortnamedisp,#nextsortdisp,#statisticsholder{
				margin:5px;
			}
			#cont{
				vertical-align:top;
				height:100%;
			}
			#sortsholder{
				border:3px #000 solid;
				background:#1e252a;
				border-radius:2px;
				overflow-x:scroll;
				text-align:left;
				height:0px;
				width:100%;
				margin:0;
			}
			div.fieldset{
				border:1px white solid;
				padding:3px;
				margin:2px;
				width:100%;
			}
			#sortsholder>div.shown{
				margin-top:3px;
			}
			#sortsholder>div.hidden,#imageInput{
				display:none;
			}
			div.topicname{
				border:2px dashed grey;
				font-family:monospace;
				text-align:center;
				padding:2px;
				margin:5px;
			}
			.flex{
				display:flex;
			}
			input{
				margin:0;
			}
			#shuffleType,#displayType{
				max-width:105px;
			}
			#searchBar{
				transition-timing-function:linear;
				background-color:#0e151a;
				transition-duration:.2s;
				border:1px grey solid;
				border-radius:2px;
				margin-left:5px;
				box-shadow:none;
				outline:none;
				opacity:.5;
				color:#fff;
				width:50%;
			}
			#searchBar:focus{
				box-shadow:-.2px -.2px 4px 2px #1d2a35;
				background-color:#121c24;
				opacity:1;
			}
		</style>
	</head>
	<body bgcolor=#0e151a>
		<div id=flexbox>
			<canvas id=cvs></canvas>
			<div id=statisticsholder>
				<div>
					<span id=sortnamedisp></span><br>
					<span id=nextsortdisp></span>
				</div>
				<div class=flex style='width:100%'>
					<div class=fieldset>
						<table>
							<tr>
								<td>Display</td>
								<td>
									<select id=displayType oninput='draw();let v=+this.value;if(v==3||v==4)verifyc();else if(v==8)verify(prompt("url",""));imageInput.style.display=v==9?"block":"none";'>
										<option value=0>Bar</option>
										<option value=1>Point</option>
										<option value=2>Line</option>
										<option value=3>Gradient</option>
										<option value=4>Gradient - Bars</option>
										<option value=5>RGB</option>
										<option value=6>Circle</option>
										<option value=7>Circle RGB</option>
										<option value=8>Custom Image(URL)</option>
										<option value=9>Custom Image(Upload)</option>
									</select>
									<input id=imageInput type=file accept="image/*"/>
								</td>
							</tr>
							<tr>
								<td>Shuffle</td>
								<td>
									<select id=shuffleType>
										<option>Normal</option>
										<option>Reverse</option>
										<option>Few Uniques</option>
										<option>Slighty Shuffled</option>
										<option>Sorted</option>
										<option>Naive</option>
										<option>Shuffled Tail</option>
										<option>Shuffled Head</option>
										<option>Shifted Elements</option>
										<option>Noisy</option>
										<option>Shuffled Odds</option>
										<option>Final Merge</option>
										<option>Shuffled Final Merge</option>
										<option>Shuffled Half</option>
										<option>Partitioned</option>
										<option>Sawtooth</option>
										<option>Pipe Organ</option>
										<option>Final Bitonic Pass</option>
										<option>Interlaced</option>
										<option>Double Layered</option>
										<option>Final Radix</option>
										<option>Real Final Radix</option>
										<option>Recursive Final Radix</option>
										<option>Half Rotation</option>
										<option>Half Reversed</option>
										<option>Logarithmic Slopes</option>
										<option>Heapified</option>
										<option>Triangular Heapified</option>
										<option>First Circle Pass</option>
										<option>Final Pairwise Pass</option>
										<option>Recursive Reversal</option>
										<option>Gray Code Fractal</option>
										<option>Sierpinski Triangle</option>
										<option>Triangular</option>
										<option>Quicksort Adversary</option>
										<option>Grailsort Adversary</option>
										<option>Shuffle Merge Adversary</option>
										<option>Bit Reversal</option>
										<option>Random Blocks</option>
										<option>Block Reverse</option>
									</select>
								</td>
							</tr>
							<tr>
								<td>Prompts</td>
								<td><input type=checkbox checked id='prompts'/></td>
							</tr>
							<tr>
								<td>Mark</td>
								<td><input type=checkbox checked id='markArray'/></td>
							</tr>
							<tr id=markRequired>
								<td>Sound</td>
								<td><input type=checkbox oninput='playsound=true'id='playSound'/></td>
							</tr>
							<tr>
								<td>Next Sort</td>
								<td><input type=checkbox checked id='nextSort'/></td>
							</tr>
							<tr id=nextRequired>
								<td>Loop</td>
								<td><input type=checkbox id='loopSort'/></td>
							</tr>
							<tr id=loopRequired>
								<td>Next Shuffle</td>
								<td><input type=checkbox id='nextShuffle'/></td>
							</tr>
							<tr><td colspan=2><button onclick='stopped=true'>Skip</button></td></tr>
							<tr><td colspan=2><button onclick='setArraySize()'>Array Size</button></td></tr>
							<tr><td colspan=2><button onclick='cvs.style.backgroundColor=prompt("Color","#000")'>BG Color</button></td></tr>
							<tr><td colspan=2><button onclick='sorts.randomSort()'>Random Sort</button></td></tr>
							<tr><td colspan=2 id=fpsDisplay></td></tr>
							<tr><td colspan=2 id=comparisonsDisplay></td></tr>
							<tr><td colspan=2 id=swapsDisplay></td></tr>
							<tr><td colspan=2 id=writesDisplay></td></tr>
							<tr><td colspan=2 id=reversalDisplay></td></tr>
							<tr><td colspan=2 id=auxWritesDisplay></td></tr>
							<tr><td colspan=2 id=progressDisplay></td></tr>
							<tr><td colspan=2 id=uniquesCount></td></tr>
							<tr><td colspan=2 id=timeDisplay></td></tr>
						</table>
					</div>
					<div class=fieldset style="max-width:50%">
						<div id=cont>
							<input id=searchBar oninput='filterSorts(this.value)'placeholder='Search...'/>
							<div class=topicname>
								<span id=nameholder>Sorts</span>
								<div class=flex><div id=sortsholder></div></div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script>
/* Project Started: April 4, 2024
Last Github Sync: Oct 18, 2024
Sources:
github.com/Gaming32/ArrayV/tree/c90c065805d682b3e92a8a056f891765fe1992f0/src/main/java/io/github/arrayv/sorts
github.com/Gaming32/ArrayV-Extra-Sorts/tree/main/src/main/java/io/github/arrayv/sorts
github.com/PCBoyGames/ArrayV-v4.0/tree/PCBoy's-Personal-Build/src/sorts
github.com/smaybius/ArrayV/blob/712a17411cd47e19719f6268080c234aafdf6442/src/main/java/io/github/arrayv/sorts
github.com/w0rthy/SortingVisualizer/tree/master/SortingVisualizer/sorts
*/
function ctz(n){for(var c=0,o=n|=0;!(n&1)&&o;n>>=1,c++);return o?c:32}
const ctx=cvs.getContext("2d"),{random,ceil,floor,round,sqrt,cbrt,log,log1p,log2,log10,cos,abs,pow,clz32,PI,sin,sign,trunc,min:minVal,max:maxVal}=Math;
let winRtn="",aud;
let arr_size=256,maxValue=arr_size;
let arr=[...new Array(arr_size)].map((e,i)=>++i);
let soundPerSec=0,elapsed=0,prevTime=0,frames=0;
let sortRunning=false,playsound=false,drawCooldown=false,stopped=false,urgentStop=false,willLoop=false,restoreLen=null,shuffling=true,sortQueue=null;
let image=new Image(),startTime=Date.now(),clog=console.log,tempCvs=document.createElement("canvas");
let shuffleNames=[...shuffleType.children].map(e=>e.value);
let counts={
	swp:0,wrt:0,rev:0,aux:0,cmps:0,
	comp:function(){this.cmps++},reset:function(){this.cmps=this.swp=this.wrt=this.rev=this.aux=0}
}
function doubleToInt(n){
	return Math.max(-(2**31),Math.min(2**31-1,Math.trunc(n)));
}
function doubleToLong(n){
	n=Number(n);
	const lmx=2n**63n-1n,lmn=-(2n**63n);
	if(n>Number(lmx))return lmx;
	else if(n<Number(lmn))return lmn;
	else return BigInt(trunc(n));
}
function longToDouble(n){
	return Number(n);
}
function longToInt(n){
	return Number(n&0xFFFFFFFFn)|0;
}
function toByte(n){return(n&255)<<24>>24}
function formatTime(t){
	const pad=n=>("0"+n).slice(-2);
	let s=(t=(t-t%1e3)/1e3)%60;
	return(t-s)/60+":"+pad(s);
}
function isNumber(n){
	return(typeof n=="number"&&n-n===0)||(typeof n=="string"&&Number.isFinite(+n)&&n.trim()!=="");
}
function sleep(ms){
	return new Promise(r=>setTimeout(r,ms));
}
Array.prototype.remove=function(i){
	if(!isNumber(i))throw"";
	this.splice(i,1);
}
requestAnimationFrame(function update(time){
	requestAnimationFrame(update);
	let btns=document.querySelectorAll("#sortsholder>div");
	drawCooldown=false;soundPerSec=0;playsound=playSound.checked;
	if(time-prevTime>5e2){
		prevTime=time;fpsDisplay.innerText=frames+" FPS";
		if(sortRunning&&!shuffling)elapsed=Date.now()-startTime;
		let c=frames=0;
		for(let i=0;i<btns.length;i++)if(btns[i].className=="shown")c++;
		nameholder.innerText=`Sorts(${c})`;
	}else frames+=2;
	winRtn=window.innerWidth<window.innerHeight?"portrait":"landscape";
	timeDisplay.innerText="Elapsed: "+formatTime(elapsed);
	flexbox.style.display=winRtn=="portrait"?"inline-block":"flex";
	nextRequired.style.display=nextSort.checked?"table-row":"none";
	loopRequired.style.display=nextSort.checked&&loopSort.checked?"table-row":"none";
	markRequired.style.display=markArray.checked?"table-row":"none";
	if(sortnamedisp.innerText!="Running: ..."){
		let c=sortnamedisp.innerText.split(" ")[1];
		if(!nextSort.checked)nextsortdisp.innerText="Next: ...";
		else if(loopSort.checked)nextsortdisp.innerText="Next: "+c;
		else if(sortQueue)nextsortdisp.innerText="Next: "+sortQueue;
		else nextsortdisp.innerText="Next: "+sortNames[(1+sortNames.indexOf(c))%sortNames.length];
	}
});
window.onresize=function(){
	let dim=minVal(window.innerWidth,window.innerHeight),m=winRtn=="portrait";
	cvs.width=dim*(m?2:1);
	cvs.height=dim/(m?1:2);
	ctx.lineCap="round";
	if(image.width){
		tempCvs.width=cvs.width;tempCvs.height=cvs.height;
		let iw=image.width,ih=image.height;
		tempCvs.getContext("2d").drawImage(image,0,0,iw,ih,0,0,tempCvs.width,tempCvs.height);
	}
	draw();
}
window.onresize();
function setArraySize(){
	let pn=prompt("Array Size"),n=minVal(2048,maxVal(2,parseInt(pn)));
	if(!isNumber(n))return;
	arr=[...new Array(maxValue=arr_size=n)].map((e,i)=>++i);
	willLoop=loopSort.checked;
	urgentStop=stopped=loopSort.checked=true;
	draw();
}
function limitArraySize(n){
	let old=arr_size;
	if(old<=n)return old;
	maxValue=arr_size=minVal(old,n);
	let t=[...arr];arr=[];
	arraycopy(t,0,arr,0,n,0,false,true);
	willLoop=loopSort.checked;
	urgentStop=stopped=loopSort.checked=true;
	restoreLen=old;
}
function restoreArraySize(){
	if(restoreLen===null)return;
	arr=[...new Array(maxValue=arr_size=restoreLen)].map((e,i)=>++i);
	restoreLen=null;
	draw();
}
function sortRange(A,a,b){
	[a,b]=[maxVal(0,minVal(a,b)),minVal(A.length,maxVal(a,b))];
	if(b-a<1)return A;
	return[A.slice(0,a),A.slice(a,b).sort((x,y)=>x-y),A.slice(b,1/0)].flat();
}
class Gradient{
	hex(c){
		let s="0123456789abcdef",i=parseInt(c);
		if(!i||!isNumber(c))return"00";
		i=round(minVal(maxVal(0,i),255));
		return s.charAt((i-i%16)/16)+s.charAt(i%16);
	}
	convertToHex([r,g,b]){
		return this.hex(r)+this.hex(g)+this.hex(b);
	}
	trim(s){
		return s[0]=="#"?s.substring(1,7):s
	}
	convertToRGB(h){
		return[parseInt(this.trim(h).substring(0,2),16),parseInt(this.trim(h).substring(2,4),16),parseInt(this.trim(h).substring(4,6),16)];
	}
	verify(rh){
		let h=this.trim(rh.replaceAll(/[^\d^a-f]/g,"")),l=h.length;
		if(l==3){
			let[r,g,b]=h.split("");
			return r+r+g+g+b+b;
		}else if(l==6)return h;
		else return 0;
	}
	gen(cS,cE,cC){
		let ts=this.verify(cS),te=this.verify(cE),s=this.convertToRGB(ts?ts:"000000"),e=this.convertToRGB(te?te:"ffffff"),l=cC,a=0,r=[],i,j;
		for(i=0;i<l;i++){
			let c=[];a+=1/l;
			for(j=0;j<3;j++)c[j]=s[j]*a+(1-a)*e[j];
			r.push("#"+this.convertToHex(c));
		}
		return r;
	}
	genRGB(l){
		let r=[],s=360/l,{hex}=this;
		function hsl2rgb(h,s,l){
			let a=s*minVal(l,1-l),f=(n,k=(n+h/30)%12)=>(l-a*maxVal(minVal(k-3,9-k,1),-1))*255;
			return"#"+hex(f(0))+hex(f(8))+hex(f(4));
		}
		for(let i=0;i<=360;i+=s)r.push(hsl2rgb(i,1,.5));
		return r;
	}
}
const gradient={
	c1:"#000",c2:"#fff",g:new Gradient(),
	gen:function(){
		return this.g.gen(this.c2,this.c1,arr_size+1);
	},
	genRGB:function(){
		return this.g.genRGB(arr_size);
	}
}
function verifyc(){
	let c1=prompt("color 1",gradient.c1);
	let c2=prompt("color 2",gradient.c2);
	gradient.c1=c1.toLowerCase();
	gradient.c2=c2.toLowerCase();
}
function verify(s){
	if(image.src==s)return;
	image.setAttribute("crossorigin","anonymous");
	image.src=s;
}
imageInput.onchange=e=>{
	let t=e.target||window.event.srcElement,f=t.files;
	if(FileReader&&f&&f.length){
		let fr=new FileReader();
		fr.onload=function(){
			image.src=fr.result;
			draw();
		}
		fr.readAsDataURL(f[0]);
	}
}
image.onload=e=>{
	tempCvs.width=cvs.width;tempCvs.height=cvs.height;
	let iw=image.width,ih=image.height;
	tempCvs.getContext("2d").drawImage(image,0,0,iw,ih,0,0,tempCvs.width,tempCvs.height);
}
function fill(hex="#fff"){
	ctx.fillStyle=hex;
}
function getPixelR(){
	return{w:cvs.width/arr_size,h:cvs.height/maxValue};
}
function localeS(s){
	return s.toLocaleString();
}
function findSegments(a,l){
	let c=0;
	for(let i=0;i<l-1;i++)if(a[i]<=a[i+1])c++;
	return c/(l-1)*100;
}
function getDisparity(n,i,r){
	return(arr_size-minVal((n-1-i+arr_size)%arr_size,(i-n+1+arr_size)%arr_size)*2)/arr_size*r;
}
function draw(force){
	if(drawCooldown&&!force)return;
	const{w,h}=getPixelR();drawCooldown=true;
	ctx.clearRect(0,0,cvs.width,cvs.height);fill();
	let renMd=+displayType.value,useG,grad,cx=cvs.width/2,cy=cvs.height/2,rad=minVal(cx,cy)*.9;
	if(renMd==3||renMd==4||renMd==5||renMd==7){
		grad=renMd<4?gradient.gen():gradient.genRGB();
		useG=true;
	}
	if(2==renMd)ctx.strokeStyle="#fff";
	for(let i=0;i<arr_size;i++){
		let v=arr[i];
		if(useG)fill(grad[arr[i]]);
		if(0==renMd||4==renMd||5==renMd)ctx.fillRect(i*w,cvs.height-v*h,w*1.05,v*h);
		else if(1==renMd)ctx.fillRect(i*w,cvs.height-v*h,w*1.05,w);
		else if(3==renMd)ctx.fillRect(i*w,0,w*1.05,cvs.height);
		else if(2==renMd){
			if(i<1){
				ctx.beginPath();
				ctx.moveTo(-.1,cvs.height);
			}else if(i+1==arr_size){
				ctx.lineTo(arr_size*w+1,cvs.height-(v-1)*h);
				ctx.stroke();
			}else ctx.lineTo(i*w,cvs.height-(v-1)*h);
		}else if(6==renMd||7==renMd){
			let rd=getDisparity(v,i,rad),a=2*PI/arr_size*i-PI/2;
			ctx.beginPath();
			ctx.arc(cx+cos(a)*rd,cy+sin(a)*rd,w*1.05,0,2*PI);
			ctx.fill();
		}else if(8==renMd||9==renMd)if(image.width)ctx.drawImage(tempCvs,w*(v-1),0,w,cvs.height,w*i,0,w,cvs.height);
	}
	comparisonsDisplay.innerText=localeS(counts.cmps)+" Comparisons";
	swapsDisplay.innerText=localeS(counts.swp)+" Swaps";
	writesDisplay.innerText=localeS(counts.wrt)+" Writes";
	reversalDisplay.innerText=localeS(counts.rev)+" Reversals";
	auxWritesDisplay.innerText=localeS(counts.aux)+" Aux Writes";
	progressDisplay.innerText=findSegments(arr,arr_size).toFixed(1)+"% Sorted";
	uniquesCount.innerText=new Set(arr).size+" Uniques";
}
function mark(i){
	if(markArray.checked){
		sound(Number(arr[i])||0,.05);
		let{w,h}=getPixelR(),renMd=+displayType.value,v=arr[i],rd=getDisparity(v,i,minVal(cvs.width,cvs.height)/2*.9),a=2*PI/arr_size*i-PI/2;
		ctx.strokeStyle=renMd-7?"#f00":renMd-2?"#fff":"#f00";
		fill(renMd-5&&renMd-7?"#f00":"#fff");
		if(0==renMd||1==renMd||4==renMd||5==renMd)ctx.fillRect(i*w,cvs.height-v*h,w*1.05,v*h);
		else if(3==renMd||8==renMd||9==renMd)ctx.fillRect(i*w,0,w*1.05,cvs.height);
		else if(2==renMd){
			ctx.lineWidth=w/2;
			ctx.beginPath();
			if(i>0)ctx.moveTo((i-1)*w,cvs.height-(arr[i-1]-1)*h);
			else ctx.moveTo(i*w,cvs.height-v*h);
			ctx.lineTo(i*w,cvs.height-v*h);
			if(i<arr_size)ctx.lineTo((i+1)*w,cvs.height-(arr[i+1]-1)*h);
			ctx.stroke();
			ctx.lineWidth=1;
		}else if(6==renMd||7==renMd){
			ctx.lineWidth=w;
			ctx.beginPath();
			ctx.moveTo(cvs.width/2,cvs.height/2);
			ctx.lineTo(cvs.width/2+cos(a)*rd,cvs.height/2+sin(a)*rd);
			ctx.stroke();
		}
	}
	return sleep();
}
function sound(fr,g=.1){
	if(!playsound)return;
	if(soundPerSec++>3)playsound=0;
	if(!aud)aud=new AudioContext();
	let o=aud.createOscillator(),f=250+fr/maxValue*1e3;
	o.frequency.value=f;o.start();o.stop(aud.currentTime+.09);
	let n=aud.createGain();
	n.gain.value=g;n.gain.linearRampToValueAtTime(0,aud.currentTime+.05);o.connect(n);n.connect(aud.destination);
}
const DEL={
	set:function(d){
		d=abs(d);
		this.d=d<1?d:1/d;this.i=0;
	},
	WR:function(i,m){
		if(++this.i*this.d>=1)
			if(m)return mark(i,this.i%=this.d);
			else return sleep(this.i%=this.d);
	},
	SW:function(i,j,m){
		if(++this.i*this.d>=1)
			if(m)return markSwap(i,j,this.i%=this.d);
			else return sleep(this.i%=this.d);
	}
}
const Rotations={
	swapBlocksBackwards:async function(A,a,b,l,sl,m,x){
		DEL.set(sl);for(let i=0;i<l;i++){
			swap(A,a+l-i-1,b+l-i-1,0,false,x);
			await DEL.SW(a+l-i-1,b+l-i-1,m);
		}
	},
	blockSwap:async function(A,a,b,l,sl,m,x){
		DEL.set(sl);for(let i=0;i<l;i++){
			swap(A,a+i,b+i,0,false,x);
			await DEL.SW(a+i,b+i,m);
		}
	},
	shiftForwards:async function(A,s,l,sl,m,x){
		let t=A[s];DEL.set(sl);
		for(let i=0;i<l;i++){
			write(A,s+i,A[s+i+1],0,false,x);
			await DEL.WR(s+i,m);
		}
		write(A,s+l,t,0,false,x);
		if(!x)await mark(s+l);
	},
	shiftBackwards:async function(A,s,l,sl,m,x){
		let t=A[s+l];DEL.set(sl);
		for(let i=l,j=0;i>0;i--){
			write(A,s+i,A[s+i-1],0,false,x);
			await DEL.WR(s+i,m);
		}
		write(A,s,t,0,false,x);
		if(!x)await mark(s);
	},
	mapIndex:function(i,n,l){
		return(i-n+l)%l;
	},
	swap:function(A,a,v,m,x){
		let o=A[a];
		write(A,a,v,0,m,x);
		return o;
	},
	griesMills:async function(A,p,lA,lB,sl,m,x){
		while(lA&&lB)if(lA<=lB){
			await this.blockSwap(A,p,p+=lA,lA,sl,m,x);
			lB-=lA;
		}else{
			await this.blockSwap(A,p+lA-lB,p+lA,lB,sl,m,x);
			lA-=lB;
		}
	},
	threeReversal:async function(A,p,lA,lB,sl,m,x){
		await reversal(A,p,p+lA-1,sl,m,x);
		await reversal(A,p+lA,p+lA+lB-1,sl,m,x);
		await reversal(A,p,p+lA+lB-1,sl,m,x);
	},
	holyGriesMills:async function(A,p,lA,lB,sl,r,x){
		while(lA>1&&lB>1){
			while(lA<=lB){
				await this.blockSwap(A,p,p+=lA,lA,sl,r,x);lB-=lA;
			}
			if(lA<2||lB<2)break;
			while(lA>lB){
				await this.swapBlocksBackwards(A,p+lA-lB,p+lA,lB,sl,r,x);lA-=lB;
			}
		}
		if(lA==1)await this.shiftForwards(A,p,lB,sl,r,x);
		else if(lB==1)await this.shiftBackwards(A,p,lA,sl,r,x);
	},
	helium:async function(A,p,lA,lB,sl,m,x){
		while(lB>1&&lA>1)if(lB<lA){
			await this.blockSwap(A,p,p+=lA,lB,sl,m,x);lA-=lB;
		}else{
			await this.swapBlocksBackwards(A,p,p+lB,lA,sl,m,x);lB-=lA;
		}
		if(lB==1)await this.shiftBackwards(A,p,lA,sl,m,x);
		else if(lA==1)await this.shiftForwards(A,p,lB,sl,m,x);
	},
	cycleReverse:async function(A,p,lA,lB,sl,m,x){
		if(lA<1||lB<1)return;DEL.set(sl);
		let a=p,b=p+lA-1,c=p+lA,d=p+lA+lB-1,sw;
		while(a<b&&c<d){
			sw=A[b];
			write(A,b--,A[a],0,m,x);
			write(A,a++,A[c],0,m,x);
			write(A,c++,A[d],0,m,x);
			write(A,d--,sw,0,m,x);
			await DEL.WR(d+1);
		}
		while(a<b){
			sw=A[b];
			write(A,b--,A[a],0,m,x);
			write(A,a++,A[d],0,m,x);
			write(A,d--,sw,0,m,x);
			await DEL.WR(d+1);
		}
		while(c<d){
			sw=A[c];
			write(A,c++,A[d],0,m,x);
			write(A,d--,A[a],0,m,x);
			write(A,a++,sw,0,m,x);
			await DEL.WR(a-1);
		}
		if(a<d)
			if(d-a<3)await swap(A,a,d,sl,m,x);
			else await reversal(A,a,d,sl,m,x);
	},
	neon:async function(A,p,lA,lB,sl,r,x){
		let e=p+lA+lB;DEL.set(sl);
		while(lA>0&&lB>0)if(lA<lB){
			for(let i=0;i<lA;i++){
				let t=A[p+i],j=p+i+lA;
				for(let k=0;j<e;j+=lA){
					write(A,j-lA,A[j],0,false,x);
					await DEL.WR(j-lA,r);
				}
				await write(A,j-lA,t,sl,r,x);
			}
			p+=lB;lB%=lA;lA-=lB;
		}else{
			for(let i=0;i<lB;i++){
				let t=A[p+i+lA],j=p+i+lA-lB;
				for(let k=0;j>=p;j-=lB){
					write(A,j+lB,A[j],0,false,x);
					await DEL.WR(j+lB,r);
				}
				await write(A,j+lB,t,sl,r,x);
			}
			e=p+lB;lA%=lB;lB-=lA;
		}
	},
	juggling:async function(A,p,lA,lB,sl,r,x){
		let l=lA+lB;lA%=l;
		if(!lA)return;DEL.set(sl);
		for(let c=0,i=0,v=A[p+i],sI=i,j=0;c<l;c++){
			let nI=this.mapIndex(i,lA,l);v=this.swap(A,p+nI,v,false,x);
			await DEL.WR(p+nI,r);
			if(nI==sI){
				sI=i=this.mapIndex(i,1,l);v=A[p+i];
			}else i=nI;
		}
	},
	bridge:async function(A,p,l,r,sl,m,x){
		if(l<1||r<1)return;
		let pa=p,pb=p+l,pc=p+r,pd=pb+r;
		if(l<r){
			let b=r-l;
			if(b<l){
				let o=l,sw=new Array(b).fill(0);
				arraycopy(A,pb,sw,0,b,0,false,true);
				while(o-->0){
					await write(A,--pc,A[--pd],sl/2,m,x);
					await write(A,pd,A[--pb],sl/2,m,x);
				}
				await arraycopy(sw,0,A,pa,b,sl,m,x);
			}else{
				let sw=new Array(l).fill(0);
				arraycopy(A,pa,sw,0,l,0,false,true);
				await arraycopy(A,pb,A,pa,r,sl,m,x);
				await arraycopy(sw,0,A,pc,l,sl,m,x);
			}
		}else if(r<l){
			let b=l-r;
			if(b<r){
				let o=r,sw=new Array(b).fill(0);
				arraycopy(A,pc,sw,0,b,0,false,true);
				while(o-->0){
					await write(A,pc++,A[pa],sl/2,m,x);
					await write(A,pa++,A[pb++],sl/2,m,x);
				}
				await arraycopy(sw,0,A,pd-b,b,sl,m,x);
			}else{
				let sw=new Array(r).fill(0);
				arraycopy(A,pb,sw,0,r,0,false,true);
				while(l-->0)await write(A,--pd,A[--pb],sl,m,x);
				await arraycopy(sw,0,A,pa,r,sl,m,x);
			}
		}else while(l-->0)await swap(A,pa++,pb++,sl,m,x);
	},
	adaptable:async function(A,p,lA,lB,sl,m,x){
		if(!lA||!lB)return;
		if(lA%lB<1||lB%lA<1)await this.holyGriesMills(A,p,lA,lB,sl,m,x);
		else await this.cycleReverse(A,p,lA,lB,sl,m,x);
	}
}
const IndexedRotations={
	griesMills:async function(A,s,m,e,sl,r,x){await Rotations.griesMills(A,s,m-s,e-m,sl,r,x)},
	threeReversal:async function(A,s,m,e,sl,r,x){await Rotations.threeReversal(A,s,m-s,e-m,sl,r,x)},
	juggling:async function(A,s,m,e,sl,r,x){await Rotations.juggling(A,s,m-s,e-m,sl,r,x)},
	holyGriesMills:async function(A,s,m,e,sl,r,x){await Rotations.holyGriesMills(A,s,m-s,e-m,sl,r,x)},
	helium:async function(A,s,m,e,sl,r,x){await Rotations.helium(A,s,m-s,e-m,sl,r,x)},
	cycleReverse:async function(A,s,m,e,sl,r,x){await Rotations.cycleReverse(A,s,m-s,e-m,sl,r,x)},
	neon:async function(A,s,m,e,sl,r,x){await Rotations.neon(A,s,m-s,e-m,sl,r,x)},
	bridge:async function(A,s,m,e,sl,r,x){await Rotations.bridge(A,s,m-s,e-m,sl,r,x)},
	adaptable:async function(A,s,m,e,sl,r,x){await Rotations.adaptable(A,s,m-s,e-m,sl,r,x)}
}
const Wr={
	insert:async function(A,p,t,sl,m,x){
		let tm=A[p],j=0;DEL.set(sl);
		if(t-p>0)for(let i=p;i<t;i++){
			write(A,i,A[i+1],0,false,x);
			await DEL.SW(i,m);
		}else if(t-p<0)for(let i=p;i>t;i--){
			write(A,i,A[i-1],0,false,x);
			await DEL.WR(i,m);
		}
		if(p-t)write(A,t,tm,0,m,x);
	}
}
const MHT={
	stableSegmentReversal:async function(A,s,e,sl,m,x){
		if(e-s<1)return;
		if(e-s<3)await swap(A,s,e,sl*.3,m,x);
		else await reversal(A,s,e,sl*.3,m,x);
		for(let i=s;i<e;i++){
			let l=i;
			while(!compareIndices(A,i,i+1)&&i<e)i++;
			if(l-i)
				if(r-l<3)await swap(A,l,i,sl*3,m,x);
				else await reversal(A,l,i,sl*3,m,x);
		}
	},
	stableFindRun:async function(A,s,e,sl,m,x){
		let i=s,lu=false,d=false,c=compareIndices(A,i,i+1);
		while(!c&&i+1<e){
			lu=true;
			if(++i+1<e)c=compareIndices(A,i,i+1);
		}
		if(c>0){
			while(c+1&&i+1<e){
				if(!c)lu=true;
				else d=true;
				if(++i+1<e)c=compareIndices(A,i,i+1);
			}
			if(i>s&&d)
				if(lu)await MHT.stableSegmentReversal(A,s,i,sl/2,m,x);
				else if(i<s+3)await swap(A,s,i,sl*2,m,x);
				else await reversal(A,s,i,d*2,m,x);
		}else while(c<1&&i<e)if(++i+1<e)c=compareIndices(A,i,i+1);
		return minVal(i+1,e);
	},
	findRun:async function(A,s,e,d,m,x){
		if(s+1==e)return s+1;
		let i=s+1,c=compareIndices(A,i-1,i++);
		while(!c&&i<e)c=compareIndices(A,i-1,i++);
		if(c>0){
			while(i<e&&compareIndices(A,i-1,i)+1)i++;
			if(i-s<4)await swap(A,s,i-1,d,m,x);
			else await reversal(A,s,i-1,d,m,x);
		}else while(i<e&&compareIndices(A,i-1,i)<1)i++;
		return minVal(i,e);
	},
	parX:function(A,s,e){
		let m=new Array(e-s).fill(!1),mx=A[s],p=1;
		for(let i=1;i<e-s;i++)if(A[s+i]>mx){
			mx=A[s+i];m[i]=true;
		}
		for(let i=e-s-1,j=e-s-1;j>=0&&i>=p;j--){
			while(!m[j]&&j>0)j--;
			mx=A[s+j];
			while(mx<=A[s+i]&&i>=p)i--;
			if(A[s+j]>A[s+i]&&p<i-j)p=i-j;
		}
		return p;
	},
	binarySearch:function(A,s,e,v,l){
		while(s<e){
			let m=s+(e-s)/2|0,c=compareValues(v,A[m]);
			if(c<0||l&&!c)e=m;
			else s=m+1;
		}
		return s;
	},
	maxExponentialSearch:function(A,s,e,v,l){
		let i=1,c=compareValues(v,A[e-i]);
		while(e-i>=s&&(c<0||l&&!c))if(e-(i*=2)>=s)c=compareValues(v,A[e-i]);
		return MHT.binarySearch(A,maxVal(s,e-i+1),e-i/2|0,v,l);
	},
	minExponentialSearch:function(A,s,e,v,l){
		let i=1,c=compareValues(v,A[s-1+i]);
		while(s-1+i<e&&(c>0||!l&&!c))if(s-1+(i*=2)<e)c=compareValues(v,A[s-1+i]);
		return MHT.binarySearch(A,s+i/2|0,minVal(e,s-1+i),v,l);
	},
	getRectangleDimensions:function(x){
		let a=x;
		for(let p=ceil(sqrt(x));p<x;p++)if(x%p<1){
			a=p;
			break;
		}
		return[a,x/a|0];
	},
	rotate:function(A,p,lA,lB,s,m,x){
		return Rotations.adaptable(A,p,lA,lB,s,m,x);
	},
	grailRotate:function(A,p,lA,lB){
		return MHT.rotate(A,p,lA,lB,.5,true);
	},
	rotateIndexed:function(A,a,b,c,s,m,x){
		return MHT.rotate(A,a,b-a,c-b,s,m,x);
	}
}
const bestNS={
	best1:[[],[],[[0,1]],[[0,1],[1,2],[0,1]],[[0,3],[1,2],[0,1],[2,3],[1,2]],[[0,4],[2,3],[0,1],[3,4],[1,2],[2,3],[0,1],[3,4],[1,2]],[[0,5],[1,4],[2,3],[0,1],[4,5],[1,2],[3,4],[0,1],[2,3],[4,5],[1,2],[3,4]],[[0,6],[2,3],[4,5],[0,2],[1,4],[3,6],[0,1],[2,5],[3,4],[1,2],[4,6],[2,3],[4,5],[1,2],[3,4],[5,6]],[[0,2],[1,3],[4,6],[5,7],[0,4],[1,5],[2,6],[3,7],[0,1],[2,3],[4,5],[6,7],[2,4],[3,5],[1,4],[3,6],[1,2],[3,4],[5,6]],[[0,3],[1,7],[2,5],[4,8],[0,7],[2,4],[3,8],[5,6],[0,2],[1,3],[4,5],[7,8],[1,4],[3,6],[5,7],[0,1],[2,4],[3,5],[6,8],[2,3],[4,5],[6,7],[1,2],[3,4],[5,6]],[[0,8],[1,9],[2,7],[3,5],[4,6],[0,2],[1,4],[5,8],[7,9],[0,3],[2,4],[5,7],[6,9],[0,1],[3,6],[8,9],[1,5],[2,3],[4,8],[6,7],[1,2],[3,5],[4,6],[7,8],[2,3],[4,5],[6,7],[3,4],[5,6]],[[0,9],[1,6],[2,4],[3,7],[5,8],[0,1],[3,5],[4,10],[6,9],[7,8],[1,3],[2,5],[4,7],[8,10],[0,4],[1,2],[3,7],[5,9],[6,8],[0,1],[2,6],[4,5],[7,8],[9,10],[2,4],[3,6],[5,7],[8,9],[1,2],[3,4],[5,6],[7,8],[2,3],[4,5],[6,7]],[[0,8],[1,7],[2,6],[3,11],[4,10],[5,9],[0,1],[2,5],[3,4],[6,9],[7,8],[10,11],[0,2],[1,6],[5,10],[9,11],[0,3],[1,2],[4,6],[5,7],[8,11],[9,10],[1,4],[3,5],[6,8],[7,10],[1,3],[2,5],[6,9],[8,10],[2,3],[4,5],[6,7],[8,9],[4,6],[5,7],[3,4],[5,6],[7,8]],[[0,12],[1,10],[2,9],[3,7],[5,11],[6,8],[1,6],[2,3],[4,11],[7,9],[8,10],[0,4],[1,2],[3,6],[7,8],[9,10],[11,12],[4,6],[5,9],[8,11],[10,12],[0,5],[3,8],[4,7],[6,11],[9,10],[0,1],[2,5],[6,9],[7,8],[10,11],[1,3],[2,4],[5,6],[9,10],[1,2],[3,4],[5,7],[6,8],[2,3],[4,5],[6,7],[8,9],[3,4],[5,6]],[[0,6],[1,11],[2,12],[3,10],[4,5],[7,13],[8,9],[1,2],[3,7],[4,8],[5,9],[6,10],[11,12],[0,4],[1,3],[5,6],[7,8],[9,13],[10,12],[0,1],[2,9],[3,7],[4,11],[6,10],[12,13],[2,5],[4,7],[6,9],[8,11],[1,2],[3,4],[6,7],[9,10],[11,12],[1,3],[2,4],[5,6],[7,8],[9,11],[10,12],[2,3],[4,7],[6,9],[10,11],[4,5],[6,7],[8,9],[3,4],[5,6],[7,8],[9,10]],[[1,2],[3,10],[4,14],[5,8],[6,13],[7,12],[9,11],[0,14],[1,5],[2,8],[3,7],[6,9],[10,12],[11,13],[0,7],[1,6],[2,9],[4,10],[5,11],[8,13],[12,14],[0,6],[2,4],[3,5],[7,11],[8,10],[9,12],[13,14],[0,3],[1,2],[4,7],[5,9],[6,8],[10,11],[12,13],[0,1],[2,3],[4,6],[7,9],[10,12],[11,13],[1,2],[3,5],[8,10],[11,12],[3,4],[5,6],[7,8],[9,10],[2,3],[4,5],[6,7],[8,9],[10,11],[5,6],[7,8]],[[0,13],[1,12],[2,15],[3,14],[4,8],[5,6],[7,11],[9,10],[0,5],[1,7],[2,9],[3,4],[6,13],[8,14],[10,15],[11,12],[0,1],[2,3],[4,5],[6,8],[7,9],[10,11],[12,13],[14,15],[0,2],[1,3],[4,10],[5,11],[6,7],[8,9],[12,14],[13,15],[1,2],[3,12],[4,6],[5,7],[8,10],[9,11],[13,14],[1,4],[2,6],[5,8],[7,10],[9,13],[11,14],[2,4],[3,6],[9,12],[11,13],[3,5],[6,8],[7,9],[10,12],[3,4],[5,6],[7,8],[9,10],[11,12],[6,7],[8,9]],[[0,11],[1,15],[2,10],[3,5],[4,6],[8,12],[9,16],[13,14],[0,6],[1,13],[2,8],[4,14],[5,15],[7,11],[0,8],[3,7],[4,9],[6,16],[10,11],[12,14],[0,2],[1,4],[5,6],[7,13],[8,9],[10,12],[11,14],[15,16],[0,3],[2,5],[6,11],[7,10],[9,13],[12,15],[14,16],[0,1],[3,4],[5,10],[6,9],[7,8],[11,15],[13,14],[1,2],[3,7],[4,8],[6,12],[11,13],[14,15],[1,3],[2,7],[4,5],[9,11],[10,12],[13,14],[2,3],[4,6],[5,7],[8,10],[3,4],[6,8],[7,9],[10,12],[5,6],[7,8],[9,10],[11,12],[4,5],[6,7],[8,9],[10,11],[12,13]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[1,5],[2,6],[3,7],[4,10],[8,16],[9,17],[12,14],[13,15],[0,8],[1,10],[2,12],[3,14],[6,13],[7,15],[9,16],[11,17],[0,4],[1,9],[5,17],[8,11],[10,16],[0,2],[1,6],[4,10],[5,9],[14,16],[15,17],[1,2],[3,10],[4,12],[5,7],[6,14],[9,13],[15,16],[3,8],[5,12],[7,11],[9,10],[3,4],[6,8],[7,14],[9,12],[11,13],[1,3],[2,4],[7,9],[8,12],[11,15],[13,16],[2,3],[4,5],[6,7],[10,11],[12,14],[13,15],[4,6],[5,8],[9,10],[11,14],[3,4],[5,7],[8,9],[10,12],[13,14],[5,6],[7,8],[9,10],[11,12]],[[0,12],[1,4],[2,8],[3,5],[6,17],[7,11],[9,14],[10,13],[15,16],[0,2],[1,7],[3,6],[4,11],[5,17],[8,12],[10,15],[13,16],[14,18],[3,10],[4,14],[5,15],[6,13],[7,9],[11,17],[16,18],[0,7],[1,10],[4,6],[9,15],[11,16],[12,17],[13,14],[0,3],[2,6],[5,7],[8,11],[12,16],[1,8],[2,9],[3,4],[6,15],[7,13],[10,11],[12,18],[1,3],[2,5],[6,9],[7,12],[8,10],[11,14],[17,18],[0,1],[2,3],[4,8],[6,10],[9,12],[14,15],[16,17],[1,2],[5,8],[6,7],[9,11],[10,13],[14,16],[15,17],[3,6],[4,5],[7,9],[8,10],[11,12],[13,14],[15,16],[3,4],[5,6],[7,8],[9,10],[11,13],[12,14],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15]],[[0,3],[1,7],[2,5],[4,8],[6,9],[10,13],[11,15],[12,18],[14,17],[16,19],[0,14],[1,11],[2,16],[3,17],[4,12],[5,19],[6,10],[7,15],[8,18],[9,13],[0,4],[1,2],[3,8],[5,7],[11,16],[12,14],[15,19],[17,18],[1,6],[2,12],[3,5],[4,11],[7,17],[8,15],[13,18],[14,16],[0,1],[2,6],[7,10],[9,12],[13,17],[18,19],[1,6],[5,9],[7,11],[8,12],[10,14],[13,18],[3,5],[4,7],[8,10],[9,11],[12,15],[14,16],[1,3],[2,4],[5,7],[6,10],[9,13],[12,14],[15,17],[16,18],[1,2],[3,4],[6,7],[8,9],[10,11],[12,13],[15,16],[17,18],[2,3],[4,6],[5,8],[7,9],[10,12],[11,14],[13,15],[16,17],[4,5],[6,8],[7,10],[9,12],[11,13],[14,15],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[3,18],[7,20],[2,7],[3,6],[14,18],[19,20],[2,16],[3,8],[6,14],[7,17],[11,19],[15,20],[0,2],[7,10],[9,16],[13,17],[15,19],[1,7],[2,3],[4,9],[5,10],[11,16],[12,13],[17,18],[1,4],[5,11],[6,12],[7,8],[10,13],[14,16],[15,17],[18,19],[1,2],[3,4],[5,6],[10,14],[11,12],[13,16],[17,18],[2,3],[4,5],[6,9],[10,11],[12,13],[14,15],[16,17],[6,7],[8,9],[13,15],[4,6],[7,8],[9,12],[15,16],[3,4],[5,7],[8,10],[9,11],[12,14],[5,6],[7,8],[9,10],[11,12],[13,14]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[17,18],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[17,21],[1,8],[6,20],[7,17],[19,21],[3,19],[4,7],[6,16],[14,21],[18,20],[0,6],[1,4],[3,12],[5,18],[7,10],[9,16],[11,20],[13,19],[14,17],[15,21],[2,5],[3,7],[6,8],[10,11],[12,13],[15,20],[16,18],[17,19],[5,8],[7,9],[10,12],[14,16],[15,17],[19,20],[2,7],[3,5],[8,9],[10,14],[11,16],[12,18],[17,19],[2,6],[4,7],[5,8],[11,13],[12,14],[15,18],[1,2],[4,6],[7,10],[9,11],[13,16],[2,4],[3,6],[5,7],[8,10],[9,12],[11,14],[13,15],[16,18],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[21,22],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[17,21],[18,20],[19,22],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[1,2],[5,18],[7,19],[9,16],[10,21],[12,20],[15,22],[5,9],[6,7],[10,18],[11,21],[12,17],[13,20],[14,15],[3,17],[6,16],[7,14],[8,12],[15,19],[20,21],[3,4],[5,8],[6,10],[9,12],[13,16],[14,15],[17,18],[19,21],[0,5],[1,8],[2,12],[3,9],[4,10],[7,13],[11,17],[14,16],[18,20],[2,6],[3,5],[4,8],[7,11],[10,12],[13,18],[14,17],[15,20],[1,3],[2,5],[6,9],[7,10],[11,13],[12,14],[15,18],[16,17],[19,20],[2,3],[4,6],[8,9],[11,12],[13,14],[15,16],[17,19],[3,4],[5,6],[7,8],[9,10],[12,13],[14,15],[17,18],[4,5],[6,7],[8,9],[10,11],[16,17]],[[0,20],[1,12],[2,16],[3,23],[4,6],[5,10],[7,21],[8,14],[9,15],[11,22],[13,18],[17,19],[0,3],[1,11],[2,7],[4,17],[5,13],[6,19],[8,9],[10,18],[12,22],[14,15],[16,21],[20,23],[0,1],[2,4],[3,12],[5,8],[6,9],[7,10],[11,20],[13,16],[14,17],[15,18],[19,21],[22,23],[2,5],[4,8],[6,11],[7,14],[9,16],[12,17],[15,19],[18,21],[1,8],[3,14],[4,7],[9,20],[10,12],[11,13],[15,22],[16,19],[0,7],[1,5],[3,4],[6,11],[8,15],[9,14],[10,13],[12,17],[16,23],[18,22],[19,20],[0,2],[1,6],[4,7],[5,9],[8,10],[13,15],[14,18],[16,19],[17,22],[21,23],[2,3],[4,5],[6,8],[7,9],[10,11],[12,13],[14,16],[15,17],[18,19],[20,21],[1,2],[3,6],[4,10],[7,8],[9,11],[12,14],[13,19],[15,16],[17,20],[21,22],[2,3],[5,10],[6,7],[8,9],[13,18],[14,15],[16,17],[20,21],[3,4],[5,7],[10,12],[11,13],[16,18],[19,20],[4,6],[8,10],[9,12],[11,14],[13,15],[17,19],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[20,22],[21,23],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[16,20],[17,21],[18,22],[19,23],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[16,24],[17,18],[21,22],[0,16],[2,8],[3,12],[4,20],[5,19],[9,22],[10,24],[1,8],[6,9],[7,22],[10,18],[14,19],[21,24],[1,17],[2,10],[5,21],[11,24],[18,20],[1,4],[2,16],[3,21],[6,10],[8,18],[9,17],[11,14],[12,20],[23,24],[1,2],[3,5],[4,16],[12,18],[13,23],[14,19],[15,24],[17,21],[4,8],[7,13],[9,16],[10,12],[11,18],[14,20],[15,23],[19,22],[2,4],[3,8],[5,16],[6,9],[7,17],[13,21],[15,19],[22,23],[3,6],[5,10],[7,11],[8,9],[12,16],[13,18],[14,17],[19,22],[20,21],[3,4],[6,8],[7,9],[10,12],[11,14],[13,16],[15,17],[18,20],[19,21],[5,8],[7,10],[9,12],[11,13],[14,16],[15,18],[17,20],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]],[[0,25],[1,3],[2,9],[4,19],[5,18],[6,21],[7,20],[8,10],[11,12],[13,14],[15,17],[16,23],[22,24],[1,4],[2,16],[3,19],[5,13],[6,22],[7,11],[8,15],[9,23],[10,17],[12,20],[14,18],[21,24],[1,5],[2,8],[3,14],[4,13],[6,7],[9,15],[10,16],[11,22],[12,21],[17,23],[18,19],[20,24],[0,10],[1,6],[3,7],[4,11],[5,12],[13,20],[14,21],[15,25],[18,22],[19,24],[0,4],[8,10],[12,13],[15,17],[21,25],[0,2],[4,8],[10,12],[13,15],[17,21],[23,25],[0,1],[2,3],[4,5],[8,14],[9,13],[11,17],[12,16],[20,21],[22,23],[24,25],[1,4],[3,10],[6,9],[7,13],[8,11],[12,18],[14,17],[15,22],[16,19],[21,24],[2,6],[3,8],[5,7],[9,12],[13,16],[17,22],[18,20],[19,23],[1,2],[4,6],[5,9],[7,10],[11,12],[13,14],[15,18],[16,20],[19,21],[23,24],[2,4],[3,5],[7,13],[8,9],[10,14],[11,15],[12,18],[16,17],[20,22],[21,23],[3,4],[6,9],[7,11],[10,12],[13,15],[14,18],[16,19],[21,22],[5,7],[6,8],[9,13],[10,11],[12,16],[14,15],[17,19],[18,20],[5,6],[7,8],[9,10],[11,13],[12,14],[15,16],[17,18],[19,20],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[20,22],[21,23],[24,26],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[16,20],[17,21],[18,22],[19,23],[25,26],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[18,24],[20,26],[22,25],[2,8],[3,12],[5,10],[6,9],[7,13],[11,14],[16,18],[17,22],[19,26],[21,25],[0,16],[1,8],[5,22],[10,24],[11,25],[23,26],[1,18],[4,8],[5,19],[9,26],[10,20],[12,23],[21,24],[2,10],[3,21],[4,17],[6,20],[7,24],[8,19],[12,18],[14,23],[15,26],[2,4],[6,10],[7,11],[8,16],[9,17],[13,19],[14,22],[15,23],[20,21],[1,8],[3,10],[5,9],[12,16],[13,18],[14,17],[15,24],[19,25],[1,2],[3,12],[4,8],[7,13],[9,16],[11,18],[14,20],[17,21],[19,22],[23,25],[2,4],[3,8],[5,12],[6,9],[7,14],[10,16],[11,17],[13,20],[15,19],[18,21],[23,24],[5,6],[7,10],[9,12],[11,13],[14,16],[15,18],[17,20],[21,22],[3,5],[6,8],[7,9],[10,12],[11,14],[13,16],[15,17],[18,20],[19,21],[22,23],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22]],[[0,9],[1,20],[2,21],[3,22],[4,19],[5,24],[6,25],[7,26],[8,23],[10,15],[11,13],[12,17],[14,16],[18,27],[0,18],[1,7],[2,6],[3,5],[4,8],[9,27],[10,12],[11,14],[13,16],[15,17],[19,23],[20,26],[21,25],[22,24],[1,2],[3,4],[5,19],[6,20],[7,21],[8,22],[9,18],[10,11],[12,14],[13,15],[16,17],[23,24],[25,26],[0,3],[1,10],[5,8],[6,7],[11,13],[14,16],[17,26],[19,22],[20,21],[24,27],[0,1],[2,7],[3,10],[4,8],[12,13],[14,15],[17,24],[19,23],[20,25],[26,27],[1,3],[2,6],[4,5],[7,19],[8,20],[11,12],[13,14],[15,16],[21,25],[22,23],[24,26],[2,4],[5,12],[7,8],[9,11],[10,14],[13,17],[15,22],[16,18],[19,20],[23,25],[2,9],[4,11],[5,6],[7,13],[8,10],[14,20],[16,23],[17,19],[18,25],[21,22],[1,2],[3,16],[4,9],[6,12],[10,14],[11,24],[13,17],[15,21],[18,23],[25,26],[2,8],[3,5],[4,7],[6,16],[9,15],[11,21],[12,18],[19,25],[20,23],[22,24],[2,3],[5,8],[7,9],[11,15],[12,16],[18,20],[19,22],[24,25],[6,8],[10,12],[11,13],[14,16],[15,17],[19,21],[5,6],[8,10],[9,11],[12,13],[14,15],[16,18],[17,19],[21,22],[4,5],[6,7],[8,9],[10,11],[12,14],[13,15],[16,17],[18,19],[20,21],[22,23],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,28],[17,26],[18,25],[19,23],[21,27],[22,24],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[17,22],[18,19],[20,27],[23,25],[24,26],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[16,20],[17,18],[19,22],[23,24],[25,26],[27,28],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[20,22],[21,25],[24,27],[26,28],[3,20],[5,24],[6,21],[7,26],[10,23],[11,13],[12,19],[14,25],[15,28],[22,27],[2,5],[3,10],[6,16],[7,14],[11,22],[13,27],[15,25],[19,23],[20,24],[2,12],[6,17],[11,20],[13,24],[14,21],[15,26],[16,18],[0,6],[1,17],[5,12],[7,20],[8,16],[9,18],[13,14],[15,21],[25,26],[1,2],[6,8],[15,22],[16,17],[18,19],[26,27],[1,6],[2,8],[4,17],[9,16],[11,18],[19,23],[22,25],[3,4],[5,16],[10,17],[13,18],[14,19],[23,24],[25,26],[3,6],[4,10],[5,9],[7,13],[12,16],[14,17],[15,23],[18,20],[21,24],[2,3],[4,9],[5,6],[7,12],[10,11],[13,16],[15,18],[19,23],[20,21],[24,25],[1,2],[3,4],[7,10],[8,9],[11,13],[12,14],[16,17],[18,19],[21,23],[22,24],[3,5],[4,7],[6,8],[9,12],[10,11],[13,16],[14,15],[17,20],[22,23],[4,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21]],[[1,2],[3,10],[4,14],[5,8],[6,13],[7,12],[9,11],[16,17],[18,25],[19,29],[20,23],[21,28],[22,27],[24,26],[0,14],[1,5],[2,8],[3,7],[6,9],[10,12],[11,13],[15,29],[16,20],[17,23],[18,22],[21,24],[25,27],[26,28],[0,7],[1,6],[2,9],[4,10],[5,11],[8,13],[12,14],[15,22],[16,21],[17,24],[19,25],[20,26],[23,28],[27,29],[0,6],[2,4],[3,5],[7,11],[8,10],[9,12],[13,14],[15,21],[17,19],[18,20],[22,26],[23,25],[24,27],[28,29],[0,3],[1,2],[4,7],[5,9],[6,8],[10,11],[12,13],[14,29],[15,18],[16,17],[19,22],[20,24],[21,23],[25,26],[27,28],[0,1],[2,3],[4,6],[7,9],[10,12],[11,13],[15,16],[17,18],[19,21],[22,24],[25,27],[26,28],[0,15],[1,2],[3,5],[8,10],[11,12],[13,28],[16,17],[18,20],[23,25],[26,27],[1,16],[3,4],[5,6],[7,8],[9,10],[12,27],[18,19],[20,21],[22,23],[24,25],[2,3],[4,5],[6,7],[8,9],[10,11],[17,18],[19,20],[21,22],[23,24],[25,26],[2,17],[3,18],[4,19],[5,6],[7,8],[9,24],[10,25],[11,26],[20,21],[22,23],[5,20],[6,21],[7,22],[8,23],[9,16],[10,17],[11,18],[12,19],[5,9],[6,10],[7,11],[8,15],[13,20],[14,21],[18,22],[19,23],[3,5],[4,8],[7,9],[12,15],[13,16],[14,17],[20,24],[21,25],[2,4],[6,8],[10,12],[11,13],[14,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,30],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[16,20],[17,21],[18,22],[19,23],[24,28],[25,29],[26,30],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[16,24],[17,25],[18,26],[19,27],[20,28],[21,29],[22,30],[0,16],[1,8],[2,4],[3,12],[5,10],[6,9],[7,14],[11,13],[17,24],[18,20],[19,28],[21,26],[22,25],[23,30],[27,29],[1,2],[3,5],[4,8],[6,22],[7,11],[9,25],[10,12],[13,14],[17,18],[19,21],[20,24],[23,27],[26,28],[29,30],[1,17],[2,18],[3,19],[4,20],[5,10],[7,23],[8,24],[11,27],[12,28],[13,29],[14,30],[21,26],[3,17],[4,16],[5,21],[6,18],[7,9],[8,20],[10,26],[11,23],[13,25],[14,28],[15,27],[22,24],[1,4],[3,8],[5,16],[7,17],[9,21],[10,22],[11,19],[12,20],[14,24],[15,26],[23,28],[27,30],[2,5],[7,8],[9,18],[11,17],[12,16],[13,22],[14,20],[15,19],[23,24],[26,29],[2,4],[6,12],[9,16],[10,11],[13,17],[14,18],[15,22],[19,25],[20,21],[27,29],[5,6],[8,12],[9,10],[11,13],[14,16],[15,17],[18,20],[19,23],[21,22],[25,26],[3,5],[6,7],[8,9],[10,12],[11,14],[13,16],[15,18],[17,20],[19,21],[22,23],[24,25],[26,28],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,30],[29,31],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[16,20],[17,21],[18,22],[19,23],[24,28],[25,29],[26,30],[27,31],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[16,24],[17,25],[18,26],[19,27],[20,28],[21,29],[22,30],[23,31],[0,16],[1,8],[2,4],[3,12],[5,10],[6,9],[7,14],[11,13],[15,31],[17,24],[18,20],[19,28],[21,26],[22,25],[23,30],[27,29],[1,2],[3,5],[4,8],[6,22],[7,11],[9,25],[10,12],[13,14],[17,18],[19,21],[20,24],[23,27],[26,28],[29,30],[1,17],[2,18],[3,19],[4,20],[5,10],[7,23],[8,24],[11,27],[12,28],[13,29],[14,30],[21,26],[3,17],[4,16],[5,21],[6,18],[7,9],[8,20],[10,26],[11,23],[13,25],[14,28],[15,27],[22,24],[1,4],[3,8],[5,16],[7,17],[9,21],[10,22],[11,19],[12,20],[14,24],[15,26],[23,28],[27,30],[2,5],[7,8],[9,18],[11,17],[12,16],[13,22],[14,20],[15,19],[23,24],[26,29],[2,4],[6,12],[9,16],[10,11],[13,17],[14,18],[15,22],[19,25],[20,21],[27,29],[5,6],[8,12],[9,10],[11,13],[14,16],[15,17],[18,20],[19,23],[21,22],[25,26],[3,5],[6,7],[8,9],[10,12],[11,14],[13,16],[15,18],[17,20],[19,21],[22,23],[24,25],[26,28],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,30],[29,31],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[16,20],[17,21],[18,22],[19,23],[24,28],[25,29],[26,30],[27,31],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[16,24],[17,25],[18,26],[19,27],[20,28],[21,29],[22,30],[23,31],[0,16],[1,17],[2,18],[3,19],[4,20],[5,21],[6,22],[7,23],[8,24],[9,25],[10,26],[11,27],[12,28],[13,29],[14,30],[15,31],[1,4],[2,16],[3,20],[5,18],[6,17],[7,22],[9,24],[10,12],[11,28],[13,26],[14,25],[15,29],[19,21],[23,32],[27,30],[1,2],[3,9],[4,16],[6,10],[7,19],[11,17],[12,24],[13,23],[15,27],[22,26],[25,28],[29,30],[3,6],[7,12],[9,18],[10,20],[13,14],[15,28],[17,22],[21,25],[27,32],[5,13],[6,16],[9,10],[12,20],[14,19],[15,23],[25,26],[30,32],[5,8],[11,13],[14,18],[15,21],[19,22],[23,27],[31,32],[4,5],[7,11],[8,16],[12,14],[13,24],[15,17],[18,20],[19,21],[22,28],[23,25],[27,29],[1,4],[3,5],[6,8],[7,9],[10,11],[13,15],[17,24],[22,23],[26,27],[29,30],[0,1],[2,6],[8,9],[11,16],[12,13],[14,17],[15,18],[19,22],[20,24],[25,26],[2,4],[5,8],[6,7],[9,11],[10,12],[13,16],[14,15],[17,20],[18,19],[21,24],[23,25],[26,28],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[28,29]],[[0,33],[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[1,3],[2,4],[5,7],[6,8],[9,11],[10,12],[13,15],[14,16],[17,19],[18,20],[21,23],[22,24],[25,27],[26,28],[29,31],[30,32],[1,5],[2,6],[3,7],[4,8],[9,13],[10,14],[11,15],[12,16],[17,21],[18,22],[19,23],[20,24],[25,29],[26,30],[27,31],[28,32],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[8,16],[17,25],[18,26],[19,27],[20,28],[21,29],[22,30],[23,31],[24,32],[1,17],[2,18],[3,19],[4,20],[5,21],[6,22],[7,23],[8,24],[9,25],[10,26],[11,27],[12,28],[13,29],[14,30],[15,31],[16,32],[0,3],[2,9],[4,11],[5,17],[6,18],[7,19],[8,20],[13,25],[14,26],[15,27],[16,28],[22,29],[24,31],[30,33],[0,5],[3,21],[6,13],[8,15],[11,19],[12,30],[14,22],[18,25],[20,27],[28,33],[0,1],[3,7],[5,6],[10,12],[11,14],[19,22],[21,23],[26,30],[27,28],[32,33],[3,9],[4,10],[7,13],[8,21],[12,25],[20,26],[23,29],[24,30],[3,5],[4,17],[8,12],[10,18],[15,23],[16,29],[21,25],[28,30],[2,4],[7,10],[8,11],[9,17],[12,14],[13,15],[16,24],[18,20],[19,21],[22,25],[23,26],[29,31],[1,2],[4,5],[6,17],[8,9],[10,11],[12,19],[13,18],[14,21],[15,20],[16,27],[22,23],[24,25],[28,29],[31,32],[2,3],[5,7],[6,10],[11,17],[12,13],[14,15],[16,22],[18,19],[20,21],[23,27],[26,28],[30,31],[3,4],[6,8],[7,9],[10,11],[13,17],[14,18],[15,19],[16,20],[22,23],[24,26],[25,27],[29,30],[5,6],[7,8],[9,12],[13,14],[15,17],[16,18],[19,20],[21,24],[25,26],[27,28],[4,5],[6,7],[9,10],[11,12],[15,16],[17,18],[21,22],[23,24],[26,27],[28,29],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25]],[[0,13],[1,12],[2,15],[3,14],[4,8],[5,6],[7,11],[9,10],[16,28],[17,20],[18,24],[19,21],[22,33],[23,27],[25,30],[26,29],[31,32],[0,5],[1,7],[2,9],[3,4],[6,13],[8,14],[10,15],[11,12],[16,18],[17,23],[19,22],[20,27],[21,33],[24,28],[26,31],[29,32],[30,34],[0,1],[2,3],[4,5],[6,8],[7,9],[10,11],[12,13],[14,15],[19,26],[20,30],[21,31],[22,29],[23,25],[27,33],[32,34],[0,2],[1,3],[4,10],[5,11],[6,7],[8,9],[12,14],[13,15],[16,23],[17,26],[20,22],[25,31],[27,32],[28,33],[29,30],[1,2],[3,12],[4,6],[5,7],[8,10],[9,11],[13,14],[16,19],[18,22],[21,23],[24,27],[28,32],[1,4],[2,6],[5,8],[7,10],[9,13],[11,14],[17,24],[18,25],[19,20],[22,31],[23,29],[26,27],[28,34],[2,4],[3,6],[9,12],[11,13],[17,19],[18,21],[22,25],[23,28],[24,26],[27,30],[33,34],[3,5],[6,8],[7,9],[10,12],[16,17],[18,19],[20,24],[22,26],[25,28],[30,31],[32,33],[0,16],[3,4],[5,6],[7,8],[9,10],[11,12],[17,18],[21,24],[22,23],[25,27],[26,29],[30,32],[31,33],[1,17],[6,7],[8,9],[19,22],[20,21],[23,25],[24,26],[27,28],[29,30],[31,32],[16,32],[17,33],[19,20],[21,22],[23,24],[25,26],[27,29],[28,30],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[2,18],[3,19],[4,20],[5,21],[6,22],[7,23],[8,24],[9,25],[10,26],[11,27],[12,28],[13,29],[14,30],[15,31],[8,16],[9,17],[11,19],[12,20],[13,21],[14,22],[15,23],[18,34],[24,32],[25,33],[4,8],[5,9],[7,11],[10,18],[12,16],[13,17],[15,19],[20,24],[21,25],[23,27],[26,34],[28,32],[29,33],[2,4],[3,5],[6,10],[7,9],[11,13],[14,18],[15,17],[19,21],[22,26],[23,25],[27,29],[30,34],[31,33],[1,2],[3,4],[6,8],[10,12],[14,16],[18,20],[22,24],[26,28],[30,32],[33,34],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[1,5],[2,6],[3,7],[4,10],[8,16],[9,17],[12,14],[13,15],[19,23],[20,24],[21,25],[22,28],[26,34],[27,35],[30,32],[31,33],[0,8],[1,10],[2,12],[3,14],[6,13],[7,15],[9,16],[11,17],[18,26],[19,28],[20,30],[21,32],[24,31],[25,33],[27,34],[29,35],[0,4],[1,9],[5,17],[8,11],[10,16],[18,22],[19,27],[23,35],[26,29],[28,34],[0,2],[1,6],[4,10],[5,9],[14,16],[15,17],[18,20],[19,24],[22,28],[23,27],[32,34],[33,35],[0,18],[1,2],[3,10],[4,12],[5,7],[6,14],[9,13],[15,16],[17,35],[19,20],[21,28],[22,30],[23,25],[24,32],[27,31],[33,34],[3,8],[5,12],[7,11],[9,10],[21,26],[23,30],[25,29],[27,28],[3,4],[6,8],[7,14],[9,12],[11,13],[21,22],[24,26],[25,32],[27,30],[29,31],[1,3],[2,4],[7,9],[8,12],[11,15],[13,16],[19,21],[20,22],[25,27],[26,30],[29,33],[31,34],[1,19],[2,3],[4,5],[6,7],[10,11],[12,14],[13,15],[16,34],[20,21],[22,23],[24,25],[28,29],[30,32],[31,33],[2,20],[4,6],[5,8],[9,10],[11,14],[15,33],[16,18],[17,19],[22,24],[23,26],[27,28],[29,32],[3,4],[5,7],[8,9],[10,12],[13,14],[21,22],[23,25],[26,27],[28,30],[31,32],[3,21],[4,22],[5,6],[7,8],[9,10],[11,12],[13,31],[14,32],[23,24],[25,26],[27,28],[29,30],[5,23],[6,24],[7,25],[8,26],[9,27],[10,28],[11,29],[12,30],[8,16],[9,17],[10,20],[11,21],[12,22],[13,23],[14,24],[15,25],[18,26],[19,27],[4,8],[5,9],[6,10],[7,11],[12,16],[13,17],[14,20],[15,21],[18,22],[19,23],[24,28],[25,29],[26,30],[27,31],[2,4],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[15,17],[18,20],[19,21],[22,24],[23,25],[26,28],[27,29],[30,32],[31,33],[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,30],[19,22],[20,26],[21,23],[24,35],[25,29],[27,32],[28,31],[33,34],[1,5],[2,6],[3,7],[4,10],[8,16],[9,17],[12,14],[13,15],[18,20],[19,25],[21,24],[22,29],[23,35],[26,30],[28,33],[31,34],[32,36],[0,8],[1,10],[2,12],[3,14],[6,13],[7,15],[9,16],[11,17],[21,28],[22,32],[23,33],[24,31],[25,27],[29,35],[34,36],[0,4],[1,9],[5,17],[8,11],[10,16],[18,25],[19,28],[22,24],[27,33],[29,34],[30,35],[31,32],[0,2],[1,6],[4,10],[5,9],[14,16],[15,17],[18,21],[20,24],[23,25],[26,29],[30,34],[1,2],[3,10],[4,12],[5,7],[6,14],[9,13],[15,16],[19,26],[20,27],[21,22],[24,33],[25,31],[28,29],[30,36],[3,8],[5,12],[7,11],[9,10],[19,21],[20,23],[24,27],[25,30],[26,28],[29,32],[35,36],[3,4],[6,8],[7,14],[9,12],[11,13],[18,19],[20,21],[22,26],[24,28],[27,30],[32,33],[34,35],[0,18],[1,3],[2,4],[7,9],[8,12],[11,15],[13,16],[19,20],[23,26],[24,25],[27,29],[28,31],[32,34],[33,35],[1,19],[2,3],[4,5],[6,7],[10,11],[12,14],[13,15],[17,35],[21,24],[22,23],[25,27],[26,28],[29,30],[31,32],[33,34],[4,6],[5,8],[9,10],[11,14],[16,34],[17,19],[21,22],[23,24],[25,26],[27,28],[29,31],[30,32],[3,4],[5,7],[8,9],[10,12],[13,14],[16,18],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[2,20],[3,21],[4,22],[5,6],[7,8],[9,10],[11,12],[13,31],[14,32],[15,33],[5,23],[6,24],[7,25],[8,26],[9,27],[10,28],[11,29],[12,30],[20,36],[8,16],[9,17],[10,20],[11,21],[12,22],[13,23],[14,24],[15,25],[18,26],[19,27],[28,36],[4,8],[5,9],[6,10],[7,11],[12,16],[13,17],[14,20],[15,21],[18,22],[19,23],[24,28],[25,29],[26,30],[27,31],[32,36],[2,4],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[15,17],[18,20],[19,21],[22,24],[23,25],[26,28],[27,29],[30,32],[31,33],[34,36],[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36]],[[0,12],[1,4],[2,8],[3,5],[6,17],[7,11],[9,14],[10,13],[15,16],[19,31],[20,23],[21,27],[22,24],[25,36],[26,30],[28,33],[29,32],[34,35],[0,2],[1,7],[3,6],[4,11],[5,17],[8,12],[10,15],[13,16],[14,18],[19,21],[20,26],[22,25],[23,30],[24,36],[27,31],[29,34],[32,35],[33,37],[3,10],[4,14],[5,15],[6,13],[7,9],[11,17],[16,18],[22,29],[23,33],[24,34],[25,32],[26,28],[30,36],[35,37],[0,7],[1,10],[4,6],[9,15],[11,16],[12,17],[13,14],[19,26],[20,29],[23,25],[28,34],[30,35],[31,36],[32,33],[0,3],[2,6],[5,7],[8,11],[12,16],[19,22],[21,25],[24,26],[27,30],[31,35],[1,8],[2,9],[3,4],[6,15],[7,13],[10,11],[12,18],[20,27],[21,28],[22,23],[25,34],[26,32],[29,30],[31,37],[1,3],[2,5],[6,9],[7,12],[8,10],[11,14],[17,18],[20,22],[21,24],[25,28],[26,31],[27,29],[30,33],[36,37],[0,1],[2,3],[4,8],[6,10],[9,12],[14,15],[16,17],[18,37],[19,20],[21,22],[23,27],[25,29],[28,31],[33,34],[35,36],[0,19],[1,2],[5,8],[6,7],[9,11],[10,13],[14,16],[15,17],[20,21],[24,27],[25,26],[28,30],[29,32],[33,35],[34,36],[1,20],[3,6],[4,5],[7,9],[8,10],[11,12],[13,14],[15,16],[17,36],[22,25],[23,24],[26,28],[27,29],[30,31],[32,33],[34,35],[3,4],[5,6],[7,8],[9,10],[11,13],[12,14],[16,35],[17,20],[22,23],[24,25],[26,27],[28,29],[30,32],[31,33],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,19],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[2,21],[3,22],[4,23],[5,24],[6,25],[7,26],[8,27],[9,28],[10,29],[11,30],[12,31],[13,32],[14,33],[15,34],[8,16],[9,17],[11,22],[12,23],[13,24],[14,25],[15,26],[18,21],[19,27],[20,28],[4,8],[5,9],[7,11],[10,18],[12,16],[13,17],[15,22],[19,23],[20,24],[21,29],[26,30],[27,31],[28,32],[2,4],[3,5],[6,10],[7,9],[11,13],[14,18],[15,17],[20,22],[21,25],[24,26],[28,30],[29,33],[32,34],[1,2],[3,4],[6,8],[10,12],[14,16],[18,19],[21,23],[25,27],[29,31],[33,35],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36]]],
	best2:[[[0,3],[1,7],[2,5],[4,8],[9,17],[10,18],[11,16],[12,14],[13,15],[19,27],[20,28],[21,26],[22,24],[23,25],[29,37],[30,38],[31,36],[32,34],[33,35],[0,7],[2,4],[3,8],[5,6],[9,11],[10,13],[14,17],[16,18],[19,21],[20,23],[24,27],[26,28],[29,31],[30,33],[34,37],[36,38],[0,2],[1,3],[4,5],[7,8],[9,12],[11,13],[14,16],[15,18],[19,22],[21,23],[24,26],[25,28],[29,32],[31,33],[34,36],[35,38],[1,4],[3,6],[5,7],[9,10],[12,15],[17,18],[19,20],[22,25],[27,28],[29,30],[32,35],[37,38],[0,1],[2,4],[3,5],[6,8],[10,14],[11,12],[13,17],[15,16],[18,38],[19,29],[20,24],[21,22],[23,27],[25,26],[30,34],[31,32],[33,37],[35,36],[0,9],[2,3],[4,5],[6,7],[10,11],[12,14],[13,15],[16,17],[20,21],[22,24],[23,25],[26,27],[30,31],[32,34],[33,35],[36,37],[0,19],[1,2],[3,4],[5,6],[8,17],[9,29],[10,20],[11,12],[13,14],[15,16],[21,22],[23,24],[25,26],[27,37],[31,32],[33,34],[35,36],[2,21],[5,28],[7,26],[8,27],[9,19],[10,30],[11,31],[12,13],[14,15],[16,36],[17,37],[22,23],[24,25],[32,33],[34,35],[1,34],[2,11],[3,22],[4,23],[5,18],[6,25],[7,16],[8,29],[12,32],[13,33],[14,24],[15,35],[17,27],[20,30],[21,31],[26,36],[28,38],[1,10],[3,12],[4,13],[5,30],[6,15],[8,19],[11,21],[16,26],[17,29],[18,28],[22,32],[23,33],[24,34],[25,35],[37,38],[4,9],[5,20],[6,21],[10,14],[12,22],[13,23],[15,25],[16,32],[18,30],[27,33],[28,34],[1,4],[5,10],[6,11],[7,22],[8,9],[13,19],[14,24],[15,31],[17,23],[26,32],[27,29],[28,30],[34,36],[2,8],[3,5],[7,12],[9,13],[14,20],[15,21],[16,22],[17,19],[18,24],[23,27],[25,31],[29,35],[30,32],[33,34],[36,37],[2,4],[6,9],[10,14],[11,13],[15,17],[18,20],[19,21],[23,25],[24,28],[27,31],[29,30],[32,35],[5,10],[6,8],[7,14],[12,18],[16,20],[22,24],[26,28],[29,31],[32,33],[34,35],[3,6],[5,8],[7,9],[10,11],[12,15],[13,14],[16,17],[18,19],[20,21],[22,23],[24,27],[25,26],[28,31],[33,34],[35,36],[3,4],[5,6],[7,10],[9,11],[12,13],[14,15],[16,18],[17,19],[20,22],[21,23],[24,25],[26,27],[28,29],[30,31],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[31,32]],[[0,8],[1,9],[2,7],[3,5],[4,6],[10,18],[11,19],[12,17],[13,15],[14,16],[20,28],[21,29],[22,27],[23,25],[24,26],[30,38],[31,39],[32,37],[33,35],[34,36],[0,2],[1,4],[5,8],[7,9],[10,12],[11,14],[15,18],[17,19],[20,22],[21,24],[25,28],[27,29],[30,32],[31,34],[35,38],[37,39],[0,3],[2,4],[5,7],[6,9],[10,13],[12,14],[15,17],[16,19],[20,23],[22,24],[25,27],[26,29],[30,33],[32,34],[35,37],[36,39],[0,1],[3,6],[8,9],[10,11],[13,16],[18,19],[20,21],[23,26],[28,29],[30,31],[33,36],[38,39],[0,10],[1,5],[2,3],[4,8],[6,7],[9,19],[11,15],[12,13],[14,18],[16,17],[20,30],[21,25],[22,23],[24,28],[26,27],[29,39],[31,35],[32,33],[34,38],[36,37],[0,20],[1,2],[3,5],[4,6],[7,8],[9,29],[10,30],[11,12],[13,15],[14,16],[17,18],[19,39],[21,22],[23,25],[24,26],[27,28],[31,32],[33,35],[34,36],[37,38],[1,11],[2,3],[4,5],[6,7],[8,18],[10,20],[12,13],[14,15],[16,17],[19,29],[21,31],[22,23],[24,25],[26,27],[28,38],[32,33],[34,35],[36,37],[1,21],[2,22],[3,4],[5,6],[7,27],[8,28],[11,31],[12,32],[13,14],[15,16],[17,37],[18,38],[23,24],[25,26],[33,34],[35,36],[2,12],[3,23],[4,24],[5,25],[6,26],[7,17],[8,30],[9,31],[11,21],[13,33],[14,34],[15,35],[16,36],[18,28],[22,32],[27,37],[3,13],[4,14],[5,15],[6,16],[8,20],[9,21],[12,22],[17,27],[18,30],[19,31],[23,33],[24,34],[25,35],[26,36],[4,10],[5,11],[6,22],[13,23],[14,24],[15,25],[16,26],[17,33],[28,34],[29,35],[1,4],[6,12],[7,23],[8,10],[9,11],[14,20],[15,21],[16,32],[18,24],[19,25],[27,33],[28,30],[29,31],[35,38],[2,8],[3,9],[7,13],[10,14],[11,15],[16,22],[17,23],[18,20],[19,21],[24,28],[25,29],[26,32],[30,36],[31,37],[2,4],[3,8],[6,10],[7,11],[12,14],[13,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,32],[29,33],[31,36],[35,37],[5,6],[7,12],[9,10],[11,16],[13,14],[15,20],[17,18],[19,24],[21,22],[23,28],[25,26],[27,32],[29,30],[33,34],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[15,17],[18,20],[19,21],[22,24],[23,25],[26,28],[27,29],[30,32],[31,33],[34,36],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36]],[[0,8],[1,9],[2,7],[3,5],[4,6],[10,18],[11,19],[12,17],[13,15],[14,16],[20,28],[21,29],[22,27],[23,25],[24,26],[30,39],[31,36],[32,34],[33,37],[35,38],[0,2],[1,4],[5,8],[7,9],[10,12],[11,14],[15,18],[17,19],[20,22],[21,24],[25,28],[27,29],[30,31],[33,35],[34,40],[36,39],[37,38],[0,3],[2,4],[5,7],[6,9],[10,13],[12,14],[15,17],[16,19],[20,23],[22,24],[25,27],[26,29],[31,33],[32,35],[34,37],[38,40],[0,1],[3,6],[8,9],[10,11],[13,16],[18,19],[20,21],[23,26],[28,29],[30,34],[31,32],[33,37],[35,39],[36,38],[0,10],[1,5],[2,3],[4,8],[6,7],[9,19],[11,15],[12,13],[14,18],[16,17],[21,25],[22,23],[24,28],[26,27],[30,31],[32,36],[34,35],[37,38],[39,40],[1,2],[3,5],[4,6],[7,8],[11,12],[13,15],[14,16],[17,18],[20,30],[21,22],[23,25],[24,26],[27,28],[32,34],[33,36],[35,37],[38,39],[0,20],[1,11],[2,3],[4,5],[6,7],[8,18],[10,30],[12,13],[14,15],[16,17],[22,23],[24,25],[26,27],[29,39],[31,32],[33,34],[35,36],[37,38],[2,22],[3,4],[5,6],[7,27],[9,29],[10,20],[13,14],[15,16],[19,39],[21,31],[23,24],[25,26],[28,38],[32,33],[34,35],[36,37],[1,21],[3,23],[4,24],[5,25],[8,28],[11,31],[12,32],[13,33],[14,34],[15,35],[16,26],[17,37],[18,38],[19,29],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],[8,30],[9,31],[11,21],[18,28],[22,32],[23,33],[24,34],[25,35],[26,40],[27,37],[4,10],[5,11],[6,36],[8,20],[9,21],[12,22],[13,23],[14,24],[15,25],[17,27],[18,30],[19,31],[26,32],[28,34],[29,35],[1,4],[6,12],[7,23],[8,10],[9,11],[14,20],[15,21],[16,36],[17,33],[18,24],[19,25],[22,26],[28,30],[29,31],[2,8],[3,9],[7,13],[10,14],[11,15],[12,22],[16,26],[17,23],[18,20],[19,21],[24,28],[25,29],[27,33],[31,37],[36,40],[2,4],[5,8],[6,10],[7,11],[12,14],[13,15],[16,22],[17,19],[21,23],[25,27],[29,33],[32,36],[35,40],[3,8],[7,12],[9,10],[11,14],[16,18],[20,22],[26,32],[27,29],[30,36],[34,35],[38,40],[3,6],[7,9],[10,12],[13,16],[15,18],[17,20],[19,22],[24,26],[28,32],[31,34],[33,36],[37,38],[39,40],[3,5],[6,8],[9,10],[13,14],[15,17],[18,20],[21,24],[23,26],[25,28],[30,32],[31,36],[35,37],[3,4],[7,8],[11,13],[14,16],[17,18],[19,21],[22,24],[23,25],[26,28],[27,30],[29,32],[31,33],[34,36],[37,38],[11,12],[15,16],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[35,36]],[[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[0,2],[1,3],[4,6],[5,7],[8,10],[9,11],[12,14],[13,15],[16,18],[17,19],[21,23],[22,24],[25,27],[26,28],[29,31],[30,32],[33,35],[34,36],[37,39],[38,40],[0,4],[1,5],[2,6],[3,7],[8,12],[9,13],[10,14],[11,15],[21,25],[22,26],[23,27],[24,28],[29,33],[30,34],[31,35],[32,36],[0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15],[21,29],[22,30],[23,31],[24,32],[25,33],[26,34],[27,35],[28,36],[3,18],[7,20],[24,39],[28,41],[2,7],[3,6],[14,18],[19,20],[23,28],[24,27],[35,39],[40,41],[2,16],[3,8],[6,14],[7,17],[11,19],[15,20],[23,37],[24,29],[27,35],[28,38],[32,40],[36,41],[0,2],[7,10],[9,16],[13,17],[15,19],[20,41],[21,23],[28,31],[30,37],[34,38],[36,40],[0,21],[1,7],[2,3],[4,9],[5,10],[11,16],[12,13],[17,18],[22,28],[23,24],[25,30],[26,31],[32,37],[33,34],[38,39],[1,4],[5,11],[6,12],[7,8],[10,13],[14,16],[15,17],[18,19],[22,25],[26,32],[27,33],[28,29],[31,34],[35,37],[36,38],[39,40],[1,2],[3,4],[5,6],[10,14],[11,12],[13,16],[17,18],[19,40],[22,23],[24,25],[26,27],[31,35],[32,33],[34,37],[38,39],[1,22],[2,3],[4,5],[6,9],[10,11],[12,13],[14,15],[16,17],[18,39],[23,24],[25,26],[27,30],[31,32],[33,34],[35,36],[37,38],[2,23],[6,7],[8,9],[13,15],[17,38],[27,28],[29,30],[34,36],[4,6],[7,8],[9,12],[15,16],[17,22],[18,23],[25,27],[28,29],[30,33],[36,37],[3,4],[5,7],[8,10],[9,11],[12,14],[15,36],[16,37],[24,25],[26,28],[29,31],[30,32],[33,35],[3,24],[4,25],[5,6],[7,8],[9,10],[11,12],[13,14],[16,21],[26,27],[28,29],[30,31],[32,33],[34,35],[5,26],[6,27],[7,28],[8,29],[9,30],[10,31],[11,32],[12,33],[13,34],[14,35],[19,24],[20,25],[8,16],[9,17],[10,18],[11,19],[12,20],[13,26],[14,27],[15,28],[21,29],[22,30],[23,31],[24,32],[25,33],[4,8],[5,9],[6,10],[7,11],[12,16],[13,17],[14,18],[15,19],[20,21],[22,26],[23,27],[24,28],[25,29],[30,34],[31,35],[32,36],[33,37],[2,4],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[15,17],[18,20],[19,22],[21,23],[24,26],[25,27],[28,30],[29,31],[32,34],[33,35],[36,38],[37,39],[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40]],[[0,8],[1,9],[2,7],[3,5],[4,6],[10,19],[11,16],[12,14],[13,17],[15,18],[21,30],[22,27],[23,25],[24,28],[26,29],[32,41],[33,38],[34,36],[35,39],[37,40],[0,2],[1,4],[5,8],[7,9],[10,11],[13,15],[14,20],[16,19],[17,18],[21,22],[24,26],[25,31],[27,30],[28,29],[32,33],[35,37],[36,42],[38,41],[39,40],[0,3],[2,4],[5,7],[6,9],[11,13],[12,15],[14,17],[18,20],[22,24],[23,26],[25,28],[29,31],[33,35],[34,37],[36,39],[40,42],[0,1],[3,6],[8,9],[10,14],[11,12],[13,17],[15,19],[16,18],[21,25],[22,23],[24,28],[26,30],[27,29],[32,36],[33,34],[35,39],[37,41],[38,40],[1,5],[2,3],[4,8],[6,7],[10,11],[12,16],[14,15],[17,18],[19,20],[21,22],[23,27],[25,26],[28,29],[30,31],[32,33],[34,38],[36,37],[39,40],[41,42],[0,10],[1,2],[3,5],[4,6],[7,8],[12,14],[13,16],[15,17],[18,19],[20,42],[21,32],[23,25],[24,27],[26,28],[29,30],[34,36],[35,38],[37,39],[40,41],[0,21],[2,3],[4,5],[6,7],[9,19],[10,32],[11,12],[13,14],[15,16],[17,18],[22,23],[24,25],[26,27],[28,29],[30,41],[33,34],[35,36],[37,38],[39,40],[1,11],[3,4],[5,6],[8,18],[9,30],[10,21],[12,13],[14,15],[16,17],[19,41],[22,33],[23,24],[25,26],[27,28],[29,40],[34,35],[36,37],[38,39],[1,22],[2,38],[3,24],[4,25],[5,26],[6,31],[7,28],[8,29],[11,33],[12,23],[13,35],[14,36],[15,37],[16,27],[17,39],[18,40],[19,30],[3,13],[4,14],[5,15],[6,20],[7,17],[8,32],[9,33],[11,22],[12,34],[18,29],[24,35],[25,36],[26,37],[27,38],[28,39],[31,42],[2,12],[4,10],[5,11],[8,21],[9,22],[13,24],[14,25],[15,26],[17,28],[18,32],[19,33],[20,31],[23,34],[29,36],[30,37],[41,42],[1,4],[6,34],[7,24],[8,10],[9,11],[12,16],[14,21],[15,22],[17,35],[18,25],[19,26],[29,32],[30,33],[31,38],[2,8],[3,9],[6,23],[7,13],[10,14],[11,15],[16,27],[17,24],[18,21],[19,22],[20,34],[25,29],[26,30],[28,35],[33,39],[38,40],[2,4],[5,8],[6,12],[7,11],[13,15],[16,23],[17,19],[20,27],[22,24],[26,28],[30,35],[31,34],[38,39],[40,41],[3,8],[6,10],[7,9],[12,16],[20,23],[27,31],[33,35],[34,36],[6,8],[12,14],[16,18],[20,21],[23,25],[27,29],[31,32],[36,37],[3,6],[10,12],[11,14],[13,16],[15,20],[17,18],[19,21],[22,23],[24,27],[25,26],[28,29],[30,31],[32,34],[36,38],[37,39],[3,5],[7,10],[9,12],[11,13],[14,16],[15,17],[18,20],[19,22],[21,23],[24,25],[26,27],[28,30],[29,31],[32,33],[34,35],[37,38],[39,40],[3,4],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36]],[[0,9],[1,6],[2,4],[3,7],[5,8],[11,20],[12,17],[13,15],[14,18],[16,19],[22,31],[23,28],[24,26],[25,29],[27,30],[33,42],[34,39],[35,37],[36,40],[38,41],[0,1],[3,5],[4,10],[6,9],[7,8],[11,12],[14,16],[15,21],[17,20],[18,19],[22,23],[25,27],[26,32],[28,31],[29,30],[33,34],[36,38],[37,43],[39,42],[40,41],[1,3],[2,5],[4,7],[8,10],[12,14],[13,16],[15,18],[19,21],[23,25],[24,27],[26,29],[30,32],[34,36],[35,38],[37,40],[41,43],[0,4],[1,2],[3,7],[5,9],[6,8],[11,15],[12,13],[14,18],[16,20],[17,19],[22,26],[23,24],[25,29],[27,31],[28,30],[33,37],[34,35],[36,40],[38,42],[39,41],[0,1],[2,6],[4,5],[7,8],[9,10],[11,12],[13,17],[15,16],[18,19],[20,21],[22,23],[24,28],[26,27],[29,30],[31,32],[33,34],[35,39],[37,38],[40,41],[42,43],[0,11],[2,4],[3,6],[5,7],[8,9],[10,21],[13,15],[14,17],[16,18],[19,20],[22,33],[24,26],[25,28],[27,29],[30,31],[32,43],[35,37],[36,39],[38,40],[41,42],[0,22],[1,2],[3,4],[5,6],[7,8],[9,20],[10,32],[11,33],[12,13],[14,15],[16,17],[18,19],[21,43],[23,24],[25,26],[27,28],[29,30],[31,42],[34,35],[36,37],[38,39],[40,41],[1,12],[2,3],[4,5],[6,7],[8,19],[9,31],[11,22],[13,14],[15,16],[17,18],[20,42],[21,32],[23,34],[24,25],[26,27],[28,29],[30,41],[35,36],[37,38],[39,40],[1,23],[2,13],[3,25],[4,26],[5,27],[6,28],[7,29],[8,30],[12,34],[14,36],[15,37],[16,38],[17,39],[18,40],[19,41],[20,31],[24,35],[2,24],[3,14],[4,15],[5,16],[6,17],[7,18],[8,33],[9,34],[12,23],[13,35],[19,30],[25,36],[26,37],[27,38],[28,39],[29,40],[4,11],[5,12],[8,22],[9,23],[10,35],[13,24],[14,25],[15,26],[16,27],[17,28],[18,29],[19,33],[20,34],[30,37],[31,38],[32,39],[1,4],[6,13],[7,25],[8,11],[9,12],[10,24],[15,22],[16,23],[18,36],[19,26],[20,27],[21,35],[30,33],[31,34],[38,40],[39,42],[2,8],[3,9],[7,14],[10,13],[11,15],[12,16],[17,24],[18,25],[19,22],[20,23],[21,28],[26,30],[27,31],[29,36],[32,35],[34,38],[2,4],[5,8],[6,11],[7,12],[10,15],[13,17],[14,16],[18,20],[21,24],[23,25],[27,29],[28,32],[31,36],[35,41],[3,6],[7,10],[9,11],[12,15],[13,19],[17,22],[21,26],[24,30],[28,33],[32,37],[39,41],[3,5],[6,8],[7,11],[13,14],[16,19],[17,18],[20,22],[21,23],[24,27],[25,26],[28,31],[29,30],[32,36],[33,34],[35,37],[3,4],[5,6],[7,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,36],[35,38],[37,40],[7,8],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40]],[[0,9],[1,6],[2,4],[3,7],[5,8],[11,20],[12,17],[13,15],[14,18],[16,19],[22,31],[23,28],[24,26],[25,29],[27,30],[33,41],[34,40],[35,39],[36,44],[37,43],[38,42],[0,1],[3,5],[4,10],[6,9],[7,8],[11,12],[14,16],[15,21],[17,20],[18,19],[22,23],[25,27],[26,32],[28,31],[29,30],[33,34],[35,38],[36,37],[39,42],[40,41],[43,44],[1,3],[2,5],[4,7],[8,10],[12,14],[13,16],[15,18],[19,21],[23,25],[24,27],[26,29],[30,32],[33,35],[34,39],[38,43],[42,44],[0,4],[1,2],[3,7],[5,9],[6,8],[11,15],[12,13],[14,18],[16,20],[17,19],[22,26],[23,24],[25,29],[27,31],[28,30],[33,36],[34,35],[37,39],[38,40],[41,44],[42,43],[0,1],[2,6],[4,5],[7,8],[9,10],[11,12],[13,17],[15,16],[18,19],[20,21],[22,23],[24,28],[26,27],[29,30],[31,32],[34,37],[36,38],[39,41],[40,43],[0,11],[2,4],[3,6],[5,7],[8,9],[10,21],[13,15],[14,17],[16,18],[19,20],[22,33],[24,26],[25,28],[27,29],[30,31],[34,36],[35,38],[39,42],[41,43],[0,22],[1,2],[3,4],[5,6],[7,8],[9,20],[11,33],[12,13],[14,15],[16,17],[18,19],[23,24],[25,26],[27,28],[29,30],[32,43],[35,36],[37,38],[39,40],[41,42],[1,12],[2,3],[4,5],[6,7],[8,19],[10,32],[11,22],[13,14],[15,16],[17,18],[21,43],[23,34],[24,25],[26,27],[28,29],[31,42],[37,39],[38,40],[1,23],[2,13],[3,25],[4,26],[5,27],[6,28],[9,31],[12,34],[18,29],[20,42],[21,32],[24,35],[36,37],[38,39],[40,41],[2,24],[7,18],[9,34],[12,23],[13,35],[14,36],[15,37],[16,38],[17,39],[20,31],[29,44],[30,41],[3,14],[4,15],[5,16],[6,17],[7,40],[8,30],[9,23],[10,35],[13,24],[19,41],[20,34],[25,36],[26,37],[27,38],[28,39],[4,11],[5,12],[6,13],[8,33],[10,24],[14,25],[15,26],[16,27],[17,28],[18,40],[19,30],[21,35],[29,36],[31,38],[32,39],[1,4],[7,14],[8,22],[9,12],[10,13],[16,23],[17,24],[19,33],[20,27],[21,28],[25,29],[30,37],[31,34],[32,35],[39,42],[40,44],[3,9],[8,11],[12,16],[13,17],[14,25],[15,22],[18,29],[19,26],[20,23],[21,24],[27,31],[28,32],[30,33],[35,41],[36,40],[42,44],[2,8],[3,5],[7,12],[11,15],[14,16],[18,25],[19,22],[26,30],[28,33],[29,36],[32,37],[34,40],[38,42],[43,44],[2,4],[6,11],[10,15],[13,19],[17,22],[18,20],[21,26],[23,25],[24,30],[27,29],[31,36],[32,33],[35,38],[37,40],[39,42],[6,8],[7,10],[9,11],[12,15],[13,14],[16,19],[17,18],[20,22],[21,23],[24,27],[25,26],[28,30],[29,31],[34,36],[35,40],[39,41],[3,6],[5,8],[7,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,34],[33,36],[35,37],[38,40],[41,42],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[39,40]],[[0,9],[1,6],[2,4],[3,7],[5,8],[11,19],[12,18],[13,17],[14,22],[15,21],[16,20],[23,32],[24,29],[25,27],[26,30],[28,31],[34,42],[35,41],[36,40],[37,45],[38,44],[39,43],[0,1],[3,5],[4,10],[6,9],[7,8],[11,12],[13,16],[14,15],[17,20],[18,19],[21,22],[23,24],[26,28],[27,33],[29,32],[30,31],[34,35],[36,39],[37,38],[40,43],[41,42],[44,45],[1,3],[2,5],[4,7],[8,10],[11,13],[12,17],[16,21],[20,22],[24,26],[25,28],[27,30],[31,33],[34,36],[35,40],[39,44],[43,45],[0,4],[1,2],[3,7],[5,9],[6,8],[11,14],[12,13],[15,17],[16,18],[19,22],[20,21],[23,27],[24,25],[26,30],[28,32],[29,31],[34,37],[35,36],[38,40],[39,41],[42,45],[43,44],[0,1],[2,6],[4,5],[7,8],[9,10],[12,15],[14,16],[17,19],[18,21],[22,45],[23,24],[25,29],[27,28],[30,31],[32,33],[35,38],[37,39],[40,42],[41,44],[0,11],[2,4],[3,6],[5,7],[8,9],[12,14],[13,16],[17,20],[19,21],[23,34],[25,27],[26,29],[28,30],[31,32],[35,37],[36,39],[40,43],[42,44],[0,23],[1,2],[3,4],[5,6],[7,8],[10,21],[11,34],[13,14],[15,16],[17,18],[19,20],[24,25],[26,27],[28,29],[30,31],[33,44],[36,37],[38,39],[40,41],[42,43],[1,12],[2,3],[4,5],[6,7],[9,20],[10,33],[11,23],[15,17],[16,18],[21,44],[24,35],[25,26],[27,28],[29,30],[32,43],[38,40],[39,41],[1,24],[2,13],[3,26],[4,27],[5,28],[6,29],[7,30],[9,32],[12,35],[14,15],[16,17],[18,19],[20,43],[21,33],[25,36],[37,38],[39,40],[41,42],[2,25],[7,26],[8,19],[9,35],[12,24],[13,36],[14,37],[15,38],[16,39],[17,40],[18,41],[20,32],[30,45],[31,42],[3,18],[4,15],[5,16],[6,17],[7,37],[8,31],[9,24],[10,36],[13,25],[19,42],[20,35],[22,26],[27,38],[28,39],[29,40],[30,41],[44,45],[3,14],[4,11],[5,12],[6,13],[8,34],[10,25],[15,27],[16,28],[17,29],[18,22],[19,31],[21,36],[26,41],[30,37],[32,39],[33,40],[1,4],[7,14],[8,23],[9,12],[10,13],[16,24],[17,25],[19,34],[20,28],[21,29],[22,30],[26,37],[31,38],[32,35],[33,36],[40,44],[41,43],[3,9],[8,11],[12,16],[13,17],[14,18],[15,23],[19,27],[20,24],[21,25],[26,30],[28,32],[29,33],[31,34],[35,37],[36,42],[39,41],[43,44],[2,8],[7,12],[11,15],[14,16],[18,22],[19,23],[26,28],[27,31],[29,34],[30,32],[33,38],[36,39],[40,42],[2,4],[5,8],[6,11],[10,15],[12,14],[13,19],[17,23],[18,20],[21,27],[22,24],[25,31],[29,30],[32,35],[33,34],[37,38],[40,41],[42,43],[3,6],[7,10],[9,11],[13,15],[16,18],[17,19],[20,23],[21,22],[24,26],[25,27],[28,31],[32,33],[34,35],[36,38],[41,42],[3,5],[6,8],[7,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[33,34],[36,37],[38,39],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[35,36],[39,40]],[[0,9],[1,6],[2,4],[3,7],[5,8],[11,19],[12,18],[13,17],[14,22],[15,21],[16,20],[23,31],[24,30],[25,29],[26,34],[27,33],[28,32],[35,43],[36,42],[37,41],[38,46],[39,45],[40,44],[0,1],[3,5],[4,10],[6,9],[7,8],[11,12],[13,16],[14,15],[17,20],[18,19],[21,22],[23,24],[25,28],[26,27],[29,32],[30,31],[33,34],[35,36],[37,40],[38,39],[41,44],[42,43],[45,46],[1,3],[2,5],[4,7],[8,10],[11,13],[12,17],[16,21],[20,22],[23,25],[24,29],[28,33],[32,34],[35,37],[36,41],[40,45],[44,46],[0,4],[1,2],[3,7],[5,9],[6,8],[11,14],[12,13],[15,17],[16,18],[19,22],[20,21],[23,26],[24,25],[27,29],[28,30],[31,34],[32,33],[35,38],[36,37],[39,41],[40,42],[43,46],[44,45],[0,1],[2,6],[4,5],[7,8],[9,10],[12,15],[14,16],[17,19],[18,21],[22,46],[23,35],[24,27],[26,28],[29,31],[30,33],[36,39],[38,40],[41,43],[42,45],[0,11],[2,4],[3,6],[5,7],[8,9],[12,14],[13,16],[17,20],[19,21],[24,26],[25,28],[29,32],[31,33],[36,38],[37,40],[41,44],[43,45],[0,23],[1,2],[3,4],[5,6],[7,8],[10,21],[11,35],[13,14],[15,16],[17,18],[19,20],[24,36],[25,26],[27,28],[29,30],[31,32],[33,45],[37,38],[39,40],[41,42],[43,44],[1,12],[2,3],[4,5],[6,7],[9,20],[10,33],[11,23],[15,17],[16,18],[21,45],[25,37],[27,29],[28,30],[32,44],[39,41],[40,42],[1,24],[2,13],[7,34],[9,32],[12,36],[14,15],[16,17],[18,19],[20,44],[21,33],[26,27],[28,29],[30,31],[38,39],[40,41],[42,43],[2,25],[3,42],[4,27],[5,28],[6,29],[7,22],[8,19],[9,36],[12,24],[13,37],[14,26],[15,39],[16,40],[17,41],[18,30],[20,32],[31,43],[34,46],[4,15],[5,16],[6,17],[8,31],[9,24],[10,37],[13,25],[14,38],[19,43],[20,36],[22,34],[27,39],[28,40],[29,41],[30,42],[45,46],[3,14],[4,11],[5,12],[6,13],[8,35],[10,25],[15,27],[16,28],[17,29],[19,31],[21,37],[26,38],[32,40],[33,41],[34,42],[1,4],[7,38],[8,23],[9,12],[10,13],[14,18],[16,24],[17,25],[19,35],[20,28],[21,29],[31,39],[32,36],[33,37],[42,44],[3,9],[7,26],[8,11],[12,16],[13,17],[15,23],[18,30],[19,27],[20,24],[21,25],[22,38],[28,32],[29,33],[31,35],[37,43],[44,45],[2,8],[7,14],[11,15],[18,26],[19,23],[22,30],[27,31],[29,35],[33,39],[34,38],[41,43],[2,4],[5,8],[6,11],[7,12],[10,15],[13,19],[14,18],[17,23],[21,27],[22,26],[25,31],[30,34],[33,35],[37,39],[38,40],[3,6],[7,10],[9,11],[12,13],[14,16],[18,20],[21,23],[22,24],[25,27],[26,28],[29,31],[30,32],[34,36],[40,42],[3,8],[7,9],[10,11],[14,15],[16,19],[17,18],[20,22],[24,26],[28,30],[32,34],[36,38],[40,41],[42,43],[3,5],[6,8],[9,10],[12,14],[13,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[41,42],[43,44],[3,4],[7,8],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40]],[[0,8],[1,7],[2,6],[3,11],[4,10],[5,9],[12,20],[13,19],[14,18],[15,23],[16,22],[17,21],[24,32],[25,31],[26,30],[27,35],[28,34],[29,33],[36,44],[37,43],[38,42],[39,47],[40,46],[41,45],[0,1],[2,5],[3,4],[6,9],[7,8],[10,11],[12,13],[14,17],[15,16],[18,21],[19,20],[22,23],[24,25],[26,29],[27,28],[30,33],[31,32],[34,35],[36,37],[38,41],[39,40],[42,45],[43,44],[46,47],[0,2],[1,6],[5,10],[9,11],[12,14],[13,18],[17,22],[21,23],[24,26],[25,30],[29,34],[33,35],[36,38],[37,42],[41,46],[45,47],[0,3],[1,2],[4,6],[5,7],[8,11],[9,10],[12,15],[13,14],[16,18],[17,19],[20,23],[21,22],[24,27],[25,26],[28,30],[29,31],[32,35],[33,34],[36,39],[37,38],[40,42],[41,43],[44,47],[45,46],[0,24],[1,4],[3,5],[6,8],[7,10],[11,35],[12,36],[13,16],[15,17],[18,20],[19,22],[23,47],[25,28],[27,29],[30,32],[31,34],[37,40],[39,41],[42,44],[43,46],[0,12],[1,3],[2,5],[6,9],[8,10],[11,23],[13,15],[14,17],[18,21],[20,22],[24,36],[25,27],[26,29],[30,33],[32,34],[35,47],[37,39],[38,41],[42,45],[44,46],[1,25],[2,3],[4,5],[6,7],[8,9],[10,34],[12,24],[13,37],[14,15],[16,17],[18,19],[20,21],[22,46],[23,35],[26,27],[28,29],[30,31],[32,33],[38,39],[40,41],[42,43],[44,45],[1,13],[2,26],[4,6],[5,7],[9,33],[10,22],[14,38],[16,18],[17,19],[21,45],[25,37],[28,30],[29,31],[34,46],[40,42],[41,43],[2,14],[3,4],[5,6],[7,8],[9,21],[13,25],[15,16],[17,18],[19,20],[22,34],[26,38],[27,28],[29,30],[31,32],[33,45],[39,40],[41,42],[43,44],[3,27],[4,16],[5,17],[6,18],[7,19],[8,32],[9,37],[10,38],[14,26],[15,39],[20,44],[21,33],[28,40],[29,41],[30,42],[31,43],[3,15],[4,28],[5,29],[6,30],[7,31],[8,20],[9,25],[10,26],[16,40],[17,41],[18,42],[19,43],[21,37],[22,38],[27,39],[32,44],[4,12],[5,13],[6,14],[8,36],[11,39],[15,27],[16,28],[17,29],[18,30],[19,31],[20,32],[33,41],[34,42],[35,43],[1,4],[7,15],[8,24],[9,13],[10,14],[11,27],[17,25],[18,26],[20,36],[21,29],[22,30],[23,39],[32,40],[33,37],[34,38],[43,46],[3,9],[8,12],[11,15],[13,17],[14,18],[16,24],[19,27],[20,28],[21,25],[22,26],[23,31],[29,33],[30,34],[32,36],[35,39],[38,44],[2,8],[7,13],[11,17],[12,16],[15,19],[20,24],[23,27],[28,32],[30,36],[31,35],[34,40],[39,45],[2,4],[5,8],[6,12],[10,16],[14,20],[15,21],[18,24],[19,25],[22,28],[23,29],[26,32],[27,33],[31,37],[35,41],[39,42],[43,45],[3,8],[7,10],[9,12],[11,14],[13,16],[15,18],[17,20],[19,22],[21,24],[23,26],[25,28],[27,30],[29,32],[31,34],[33,36],[35,38],[37,40],[39,44],[3,6],[7,9],[10,12],[11,16],[15,20],[19,21],[22,24],[23,25],[26,28],[27,32],[31,36],[35,37],[38,40],[41,44],[3,5],[6,8],[9,10],[11,13],[14,16],[15,17],[18,20],[21,22],[23,24],[25,26],[27,29],[30,32],[31,33],[34,36],[37,38],[39,41],[42,44],[3,4],[7,8],[11,12],[15,16],[19,20],[27,28],[31,32],[35,36],[39,40],[43,44]],[[0,8],[1,7],[2,6],[3,11],[4,10],[5,9],[12,20],[13,19],[14,18],[15,23],[16,22],[17,21],[24,32],[25,31],[26,30],[27,35],[28,34],[29,33],[36,48],[37,46],[38,45],[39,43],[41,47],[42,44],[0,1],[2,5],[3,4],[6,9],[7,8],[10,11],[12,13],[14,17],[15,16],[18,21],[19,20],[22,23],[24,25],[26,29],[27,28],[30,33],[31,32],[34,35],[37,42],[38,39],[40,47],[43,45],[44,46],[0,2],[1,6],[5,10],[9,11],[12,14],[13,18],[17,22],[21,23],[24,26],[25,30],[29,34],[33,35],[36,40],[37,38],[39,42],[43,44],[45,46],[47,48],[0,3],[1,2],[4,6],[5,7],[8,11],[9,10],[12,15],[13,14],[16,18],[17,19],[20,23],[21,22],[24,27],[25,26],[28,30],[29,31],[32,35],[33,34],[40,42],[41,45],[44,47],[46,48],[0,24],[1,4],[3,5],[6,8],[7,10],[11,23],[13,16],[15,17],[18,20],[19,22],[25,28],[27,29],[30,32],[31,34],[36,41],[39,44],[40,43],[42,47],[45,46],[1,3],[2,5],[6,9],[8,10],[13,15],[14,17],[18,21],[20,22],[25,27],[26,29],[30,33],[32,34],[36,37],[38,41],[42,45],[43,44],[46,47],[1,13],[2,3],[4,5],[6,7],[8,9],[10,22],[12,36],[14,15],[16,17],[18,19],[20,21],[26,27],[28,29],[30,31],[32,33],[35,47],[37,39],[38,40],[41,42],[45,46],[0,12],[2,14],[4,6],[5,7],[9,21],[11,35],[16,18],[17,19],[23,47],[24,36],[28,30],[29,31],[34,46],[37,38],[39,40],[41,43],[42,44],[3,4],[5,6],[7,8],[10,34],[12,24],[15,16],[17,18],[19,20],[22,46],[23,35],[25,37],[27,28],[29,30],[31,32],[38,39],[40,41],[42,43],[44,45],[1,25],[3,15],[4,28],[5,29],[6,30],[7,31],[8,32],[13,37],[19,43],[20,48],[22,34],[26,38],[33,45],[39,40],[41,42],[2,26],[4,40],[7,19],[8,20],[9,33],[13,25],[14,38],[16,28],[17,41],[18,42],[21,45],[27,39],[31,43],[32,48],[3,27],[5,17],[6,18],[9,37],[10,38],[14,26],[15,39],[19,31],[20,32],[21,33],[28,44],[29,41],[30,42],[35,43],[36,40],[5,13],[6,14],[8,28],[9,25],[10,26],[11,39],[15,27],[16,36],[17,29],[18,30],[20,40],[21,37],[22,38],[32,44],[33,41],[34,42],[43,46],[4,16],[7,15],[8,24],[9,13],[10,14],[11,27],[17,25],[18,26],[21,29],[22,30],[23,39],[28,36],[32,40],[33,37],[34,38],[42,48],[3,9],[4,12],[11,15],[13,17],[14,18],[19,27],[21,25],[22,26],[23,31],[24,28],[29,33],[30,34],[32,36],[35,39],[38,44],[43,48],[1,4],[3,5],[7,13],[8,12],[11,17],[15,19],[16,24],[20,28],[23,27],[30,36],[31,35],[34,40],[39,45],[2,8],[7,9],[12,16],[15,21],[19,25],[20,24],[23,29],[27,33],[28,32],[31,37],[34,36],[35,41],[39,42],[45,48],[2,4],[6,12],[10,16],[14,20],[18,24],[19,21],[22,28],[23,25],[26,32],[29,30],[31,33],[35,38],[37,40],[39,44],[43,45],[46,48],[6,8],[10,12],[11,14],[13,16],[15,20],[17,18],[22,24],[26,28],[27,32],[31,34],[33,36],[35,37],[38,40],[41,44],[47,48],[3,6],[5,8],[7,10],[9,12],[11,13],[14,16],[15,17],[18,20],[19,22],[21,24],[23,26],[25,28],[27,29],[30,32],[33,34],[35,36],[37,38],[39,41],[42,44],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[39,40],[43,44]]],
	best3:[[[0,8],[1,7],[2,6],[3,11],[4,10],[5,9],[12,24],[13,22],[14,21],[15,19],[17,23],[18,20],[25,33],[26,32],[27,31],[28,36],[29,35],[30,34],[37,49],[38,47],[39,46],[40,44],[42,48],[43,45],[0,1],[2,5],[3,4],[6,9],[7,8],[10,11],[13,18],[14,15],[16,23],[19,21],[20,22],[25,26],[27,30],[28,29],[31,34],[32,33],[35,36],[38,43],[39,40],[41,48],[44,46],[45,47],[0,2],[1,6],[5,10],[9,11],[12,16],[13,14],[15,18],[19,20],[21,22],[23,24],[25,27],[26,31],[30,35],[34,36],[37,41],[38,39],[40,43],[44,45],[46,47],[48,49],[0,3],[1,2],[4,6],[5,7],[8,11],[9,10],[16,18],[17,21],[20,23],[22,24],[25,28],[26,27],[29,31],[30,32],[33,36],[34,35],[41,43],[42,46],[45,48],[47,49],[0,25],[1,4],[3,5],[6,8],[7,10],[12,17],[15,20],[16,19],[18,23],[21,22],[26,29],[28,30],[31,33],[32,35],[37,42],[40,45],[41,44],[43,48],[46,47],[1,3],[2,5],[6,9],[8,10],[12,13],[14,17],[18,21],[19,20],[22,23],[26,28],[27,30],[31,34],[33,35],[37,38],[39,42],[43,46],[44,45],[47,48],[2,3],[4,5],[6,7],[8,9],[11,23],[12,37],[13,15],[14,16],[17,18],[21,22],[27,28],[29,30],[31,32],[33,34],[36,48],[38,40],[39,41],[42,43],[46,47],[0,12],[4,6],[5,7],[10,22],[11,36],[13,14],[15,16],[17,19],[18,20],[23,48],[29,31],[30,32],[35,47],[38,39],[40,41],[42,44],[43,45],[1,13],[3,4],[5,6],[7,8],[10,35],[14,15],[16,17],[18,19],[20,21],[22,47],[23,36],[26,38],[28,29],[30,31],[32,33],[39,40],[41,42],[43,44],[45,46],[1,26],[2,14],[4,29],[5,30],[6,31],[7,32],[8,49],[9,21],[13,38],[15,16],[17,18],[19,44],[20,45],[22,35],[24,33],[27,39],[34,46],[40,41],[42,43],[2,27],[3,15],[4,37],[7,19],[8,24],[9,34],[13,26],[14,39],[16,41],[17,42],[18,43],[21,46],[28,40],[29,45],[32,44],[33,49],[3,28],[4,12],[5,17],[6,18],[9,38],[10,39],[14,27],[15,40],[16,25],[19,32],[20,29],[21,34],[24,33],[30,42],[31,43],[36,44],[48,49],[5,13],[6,14],[8,16],[9,26],[10,27],[11,40],[12,20],[15,28],[17,30],[18,31],[21,38],[22,39],[25,41],[29,37],[33,45],[34,42],[35,43],[47,48],[4,8],[7,15],[9,13],[10,14],[11,28],[16,25],[17,26],[18,27],[20,29],[21,30],[22,31],[23,40],[24,41],[34,38],[35,39],[43,45],[1,4],[3,9],[8,12],[11,15],[13,17],[14,18],[16,20],[19,28],[21,26],[22,27],[23,32],[24,25],[30,34],[31,35],[33,41],[36,40],[2,8],[7,13],[11,17],[12,16],[15,19],[23,28],[24,29],[25,37],[32,36],[39,41],[40,46],[2,4],[5,8],[6,12],[10,16],[11,13],[15,21],[19,26],[20,24],[23,30],[25,29],[28,34],[32,38],[33,37],[36,42],[40,43],[45,46],[6,8],[7,10],[9,12],[14,20],[18,24],[22,25],[27,29],[31,33],[35,37],[36,39],[41,42],[44,46],[3,6],[7,12],[14,16],[15,18],[17,20],[19,24],[21,22],[23,25],[26,27],[28,29],[30,31],[32,35],[33,34],[37,38],[40,41],[42,43],[44,47],[3,5],[6,8],[7,9],[10,12],[11,14],[13,16],[15,17],[18,20],[19,21],[22,24],[23,26],[25,27],[28,30],[29,31],[32,33],[34,35],[36,37],[38,39],[41,42],[44,45],[46,47],[3,4],[7,8],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[43,44],[47,48]],[[0,8],[1,7],[2,6],[3,11],[4,10],[5,9],[12,24],[13,22],[14,21],[15,19],[17,23],[18,20],[25,37],[26,35],[27,34],[28,32],[30,36],[31,33],[38,50],[39,48],[40,47],[41,45],[43,49],[44,46],[0,1],[2,5],[3,4],[6,9],[7,8],[10,11],[13,18],[14,15],[16,23],[19,21],[20,22],[26,31],[27,28],[29,36],[32,34],[33,35],[39,44],[40,41],[42,49],[45,47],[46,48],[0,2],[1,6],[5,10],[9,11],[12,16],[13,14],[15,18],[19,20],[21,22],[23,24],[25,29],[26,27],[28,31],[32,33],[34,35],[36,37],[38,42],[39,40],[41,44],[45,46],[47,48],[49,50],[0,3],[1,2],[4,6],[5,7],[8,11],[9,10],[16,18],[17,21],[20,23],[22,24],[29,31],[30,34],[33,36],[35,37],[42,44],[43,47],[46,49],[48,50],[1,4],[3,5],[6,8],[7,10],[12,17],[15,20],[16,19],[18,23],[21,22],[25,30],[28,33],[29,32],[31,36],[34,35],[37,50],[38,43],[41,46],[42,45],[44,49],[47,48],[1,3],[2,5],[6,9],[8,10],[12,13],[14,17],[18,21],[19,20],[22,23],[25,26],[27,30],[31,34],[32,33],[35,36],[38,39],[40,43],[44,47],[45,46],[48,49],[2,3],[4,5],[6,7],[8,9],[11,23],[12,38],[13,15],[14,16],[17,18],[21,22],[26,28],[27,29],[30,31],[34,35],[36,49],[39,41],[40,42],[43,44],[47,48],[4,6],[5,7],[10,22],[11,36],[12,25],[13,14],[15,16],[17,19],[18,20],[23,49],[26,27],[28,29],[30,32],[31,33],[35,48],[39,40],[41,42],[43,45],[44,46],[1,13],[3,4],[5,6],[7,8],[10,35],[14,15],[16,17],[18,19],[20,21],[22,48],[23,36],[26,39],[27,28],[29,30],[31,32],[33,34],[40,41],[42,43],[44,45],[46,47],[1,26],[2,14],[4,33],[7,32],[8,24],[9,21],[13,39],[15,16],[17,18],[19,45],[20,46],[22,35],[27,40],[28,29],[30,31],[34,47],[41,42],[43,44],[0,29],[2,27],[3,15],[4,38],[5,30],[6,31],[7,19],[8,37],[9,34],[13,26],[14,40],[16,42],[17,43],[18,44],[20,25],[21,47],[24,50],[28,41],[32,45],[33,46],[0,16],[3,28],[4,20],[5,17],[6,18],[9,39],[10,40],[14,27],[15,41],[19,32],[21,34],[24,37],[29,42],[30,43],[31,44],[33,38],[36,45],[49,50],[0,12],[5,13],[6,14],[8,29],[9,26],[10,27],[11,41],[15,28],[17,30],[18,31],[21,39],[22,40],[24,42],[25,33],[34,43],[35,44],[37,46],[4,12],[7,15],[9,13],[10,14],[11,28],[16,29],[17,26],[18,27],[20,25],[21,30],[22,31],[23,41],[33,38],[34,39],[35,40],[37,42],[46,48],[1,4],[3,9],[8,16],[11,15],[13,17],[14,18],[19,28],[21,26],[22,27],[23,32],[24,29],[30,34],[31,35],[36,41],[42,45],[48,49],[7,13],[8,20],[11,17],[15,19],[16,25],[23,28],[24,33],[29,38],[32,36],[41,47],[42,44],[8,12],[15,21],[16,20],[19,26],[23,30],[24,25],[28,34],[29,33],[32,39],[36,43],[37,38],[46,47],[2,8],[6,12],[10,16],[14,20],[18,24],[22,25],[27,29],[31,33],[32,34],[35,37],[38,40],[41,43],[44,46],[45,47],[2,4],[3,8],[5,6],[7,10],[9,12],[11,14],[13,16],[15,20],[17,18],[19,22],[21,24],[23,27],[25,26],[28,31],[29,30],[33,35],[36,38],[37,39],[40,42],[45,46],[47,48],[3,5],[6,8],[7,12],[11,16],[15,17],[18,20],[19,24],[23,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,39],[40,41],[42,43],[3,4],[5,6],[7,9],[10,12],[11,13],[14,16],[17,18],[19,21],[22,24],[25,26],[27,28],[29,30],[31,32],[33,34],[36,37],[38,39],[41,42],[43,44],[7,8],[11,12],[15,16],[19,20],[23,24],[35,36],[39,40]],[[0,12],[1,10],[2,9],[3,7],[5,11],[6,8],[13,25],[14,23],[15,22],[16,20],[18,24],[19,21],[26,38],[27,36],[28,35],[29,33],[31,37],[32,34],[39,51],[40,49],[41,48],[42,46],[44,50],[45,47],[1,6],[2,3],[4,11],[7,9],[8,10],[14,19],[15,16],[17,24],[20,22],[21,23],[27,32],[28,29],[30,37],[33,35],[34,36],[40,45],[41,42],[43,50],[46,48],[47,49],[0,4],[1,2],[3,6],[7,8],[9,10],[11,12],[13,17],[14,15],[16,19],[20,21],[22,23],[24,25],[26,30],[27,28],[29,32],[33,34],[35,36],[37,38],[39,43],[40,41],[42,45],[46,47],[48,49],[50,51],[4,6],[5,9],[8,11],[10,12],[17,19],[18,22],[21,24],[23,25],[30,32],[31,35],[34,37],[36,38],[43,45],[44,48],[47,50],[49,51],[0,5],[3,8],[4,7],[6,11],[9,10],[12,51],[13,18],[16,21],[17,20],[19,24],[22,23],[25,38],[26,31],[29,34],[30,33],[32,37],[35,36],[39,44],[42,47],[43,46],[45,50],[48,49],[0,1],[2,5],[6,9],[7,8],[10,11],[12,25],[13,14],[15,18],[19,22],[20,21],[23,24],[26,27],[28,31],[32,35],[33,34],[36,37],[38,51],[39,40],[41,44],[45,48],[46,47],[49,50],[0,26],[1,3],[2,4],[5,6],[9,10],[11,24],[13,39],[14,16],[15,17],[18,19],[22,23],[25,38],[27,29],[28,30],[31,32],[35,36],[37,50],[40,42],[41,43],[44,45],[48,49],[0,13],[1,2],[3,4],[5,7],[6,8],[10,23],[11,37],[14,15],[16,17],[18,20],[19,21],[24,50],[26,39],[27,28],[29,30],[31,33],[32,34],[36,49],[40,41],[42,43],[44,46],[45,47],[1,14],[2,3],[4,5],[6,7],[8,9],[10,36],[13,26],[15,16],[17,18],[19,20],[21,22],[23,49],[24,37],[27,40],[28,29],[30,31],[32,33],[34,35],[41,42],[43,44],[45,46],[47,48],[1,27],[2,15],[3,4],[5,6],[7,33],[8,34],[9,22],[14,40],[16,17],[18,19],[20,46],[21,47],[23,36],[28,41],[29,30],[31,32],[35,48],[42,43],[44,45],[2,28],[3,16],[4,43],[5,31],[6,32],[7,20],[8,21],[9,35],[14,27],[15,41],[17,30],[18,44],[19,45],[22,48],[29,42],[33,46],[34,47],[3,29],[4,17],[5,18],[6,19],[8,26],[9,40],[10,41],[15,28],[16,42],[20,33],[21,34],[22,35],[30,43],[31,44],[32,45],[37,46],[38,47],[4,13],[5,14],[6,15],[9,27],[10,28],[11,42],[12,17],[16,29],[18,31],[19,32],[21,39],[22,40],[23,41],[25,43],[35,44],[36,45],[47,50],[1,4],[7,16],[8,13],[9,14],[10,15],[11,29],[12,21],[17,30],[18,27],[19,28],[22,31],[23,32],[24,42],[25,39],[35,40],[36,41],[38,43],[2,8],[3,9],[11,16],[14,18],[15,19],[17,26],[20,29],[22,27],[23,28],[24,33],[30,34],[31,35],[32,36],[37,42],[43,49],[2,4],[5,8],[7,14],[11,18],[12,17],[16,20],[21,26],[24,29],[25,30],[33,37],[34,39],[42,48],[47,49],[3,8],[12,13],[16,22],[17,21],[20,27],[24,31],[25,26],[29,35],[30,34],[33,40],[37,44],[38,39],[43,48],[6,12],[10,13],[15,17],[19,21],[23,25],[24,27],[26,28],[30,32],[34,36],[37,40],[38,41],[39,45],[3,6],[7,12],[9,10],[11,13],[14,15],[16,19],[17,18],[20,23],[21,22],[25,26],[28,31],[29,30],[32,35],[33,34],[36,38],[39,44],[41,42],[45,46],[3,5],[6,8],[7,9],[10,12],[11,14],[13,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,40],[39,41],[42,44],[43,45],[46,48],[3,4],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[45,46],[47,48]],[[0,12],[1,10],[2,9],[3,7],[5,11],[6,8],[13,25],[14,23],[15,22],[16,20],[18,24],[19,21],[26,38],[27,36],[28,35],[29,33],[31,37],[32,34],[39,45],[40,50],[41,51],[42,49],[43,44],[46,52],[47,48],[1,6],[2,3],[4,11],[7,9],[8,10],[14,19],[15,16],[17,24],[20,22],[21,23],[27,32],[28,29],[30,37],[33,35],[34,36],[40,41],[42,46],[43,47],[44,48],[45,49],[50,51],[0,4],[1,2],[3,6],[7,8],[9,10],[11,12],[13,17],[14,15],[16,19],[20,21],[22,23],[24,25],[26,30],[27,28],[29,32],[33,34],[35,36],[37,38],[39,43],[40,42],[44,45],[46,47],[48,52],[49,51],[4,6],[5,9],[8,11],[10,12],[17,19],[18,22],[21,24],[23,25],[30,32],[31,35],[34,37],[36,38],[39,40],[41,48],[42,46],[43,50],[45,49],[51,52],[0,5],[3,8],[4,7],[6,11],[9,10],[13,18],[16,21],[17,20],[19,24],[22,23],[25,38],[26,31],[29,34],[30,33],[32,37],[35,36],[41,44],[43,46],[45,48],[47,50],[0,1],[2,5],[6,9],[7,8],[10,11],[13,14],[15,18],[19,22],[20,21],[23,24],[26,27],[28,31],[32,35],[33,34],[36,37],[40,41],[42,43],[45,46],[48,49],[50,51],[0,26],[1,3],[2,4],[5,6],[9,10],[11,24],[13,39],[14,16],[15,17],[18,19],[22,23],[27,29],[28,30],[31,32],[35,36],[40,42],[41,43],[44,45],[46,47],[48,50],[49,51],[0,13],[1,2],[3,4],[5,7],[6,8],[10,23],[12,51],[14,15],[16,17],[18,20],[19,21],[26,39],[27,28],[29,30],[31,33],[32,34],[41,42],[43,46],[45,48],[49,50],[1,27],[2,3],[4,5],[6,7],[8,9],[12,25],[13,26],[14,40],[15,16],[17,18],[19,20],[21,22],[28,29],[30,31],[32,33],[34,35],[37,50],[38,51],[43,44],[45,46],[47,48],[1,14],[2,15],[3,4],[5,6],[7,33],[8,34],[9,35],[11,37],[16,17],[18,19],[22,52],[24,50],[25,38],[27,40],[28,41],[29,30],[31,32],[42,43],[44,45],[46,47],[48,49],[2,28],[3,16],[4,43],[5,31],[6,32],[9,22],[14,27],[15,41],[17,30],[19,45],[20,46],[21,47],[24,37],[29,42],[35,52],[36,49],[3,29],[4,17],[5,44],[6,19],[7,20],[8,21],[10,36],[15,28],[16,42],[18,31],[22,35],[23,49],[30,43],[32,45],[33,46],[34,47],[4,13],[6,15],[8,26],[10,41],[11,42],[12,17],[16,29],[19,32],[20,33],[21,34],[23,36],[25,43],[31,48],[37,46],[38,47],[40,44],[1,4],[7,16],[8,13],[9,31],[10,28],[11,29],[17,30],[18,40],[21,39],[22,44],[23,41],[24,42],[35,48],[36,45],[38,43],[47,52],[2,8],[5,18],[9,27],[10,15],[11,16],[12,21],[17,26],[19,28],[20,29],[23,32],[24,33],[25,39],[30,34],[31,40],[35,44],[36,41],[37,42],[43,49],[46,47],[2,4],[5,14],[12,17],[15,19],[16,20],[21,26],[23,28],[24,29],[25,30],[27,31],[32,36],[33,37],[34,39],[35,40],[42,48],[49,50],[5,8],[9,14],[12,13],[17,21],[18,27],[22,31],[25,26],[30,34],[33,40],[37,44],[38,39],[43,48],[47,49],[50,52],[3,9],[6,12],[10,13],[14,18],[15,17],[19,21],[22,27],[23,25],[26,28],[30,32],[31,35],[34,36],[38,41],[39,45],[49,50],[51,52],[3,6],[7,14],[10,12],[11,18],[16,22],[20,27],[24,31],[25,26],[29,35],[32,33],[36,37],[38,40],[39,42],[41,44],[45,46],[3,8],[7,9],[11,15],[13,14],[16,19],[17,18],[20,23],[21,22],[24,27],[28,31],[29,30],[34,35],[36,38],[37,40],[39,44],[43,45],[46,48],[3,5],[6,8],[7,10],[9,12],[11,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,34],[33,35],[37,38],[39,41],[42,44],[45,46],[47,48],[3,4],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[39,40],[43,44]],[[0,12],[1,10],[2,9],[3,7],[5,11],[6,8],[13,19],[14,24],[15,25],[16,23],[17,18],[20,26],[21,22],[27,39],[28,37],[29,36],[30,34],[32,38],[33,35],[40,46],[41,51],[42,52],[43,50],[44,45],[47,53],[48,49],[1,6],[2,3],[4,11],[7,9],[8,10],[14,15],[16,20],[17,21],[18,22],[19,23],[24,25],[28,33],[29,30],[31,38],[34,36],[35,37],[41,42],[43,47],[44,48],[45,49],[46,50],[51,52],[0,4],[1,2],[3,6],[7,8],[9,10],[11,12],[13,17],[14,16],[18,19],[20,21],[22,26],[23,25],[27,31],[28,29],[30,33],[34,35],[36,37],[38,39],[40,44],[41,43],[45,46],[47,48],[49,53],[50,52],[4,6],[5,9],[8,11],[10,12],[13,14],[15,22],[16,20],[17,24],[19,23],[25,26],[31,33],[32,36],[35,38],[37,39],[40,41],[42,49],[43,47],[44,51],[46,50],[52,53],[0,5],[3,8],[4,7],[6,11],[9,10],[13,40],[15,18],[17,20],[19,22],[21,24],[27,32],[30,35],[31,34],[33,38],[36,37],[42,45],[44,47],[46,49],[48,51],[0,1],[2,5],[6,9],[7,8],[10,11],[14,15],[16,17],[19,20],[22,23],[24,25],[27,28],[29,32],[33,36],[34,35],[37,38],[41,42],[43,44],[46,47],[49,50],[51,52],[0,27],[1,3],[2,4],[5,6],[9,10],[14,16],[15,17],[18,19],[20,21],[22,24],[23,25],[28,30],[29,31],[32,33],[36,37],[41,43],[42,44],[45,46],[47,48],[49,51],[50,52],[0,13],[1,2],[3,4],[5,7],[6,8],[12,52],[14,41],[15,16],[17,20],[19,22],[23,24],[25,39],[27,40],[28,29],[30,31],[32,34],[33,35],[42,43],[44,47],[46,49],[50,51],[1,28],[2,3],[4,5],[6,7],[8,9],[11,24],[12,25],[13,27],[17,18],[19,20],[21,22],[29,30],[31,32],[33,34],[35,36],[38,51],[39,52],[44,45],[46,47],[48,49],[1,14],[2,15],[3,4],[5,6],[7,34],[8,35],[9,53],[11,38],[16,17],[18,19],[20,21],[22,23],[24,51],[25,39],[26,36],[29,42],[30,31],[32,33],[43,44],[45,46],[47,48],[49,50],[2,29],[3,16],[4,44],[5,32],[6,33],[9,26],[10,23],[15,42],[17,31],[18,45],[19,46],[20,47],[21,48],[22,49],[24,38],[30,43],[36,53],[37,50],[3,30],[4,17],[5,41],[6,19],[7,20],[8,21],[10,37],[15,29],[16,43],[18,28],[23,50],[26,36],[31,44],[32,49],[33,46],[34,47],[35,48],[51,53],[4,13],[5,14],[6,15],[8,27],[9,18],[10,42],[11,43],[12,17],[16,30],[19,33],[20,34],[21,35],[22,32],[23,37],[25,44],[28,45],[36,49],[38,47],[39,48],[52,53],[1,4],[5,9],[7,16],[8,13],[10,29],[11,30],[14,22],[17,31],[18,28],[21,40],[23,42],[24,43],[26,45],[32,41],[37,46],[39,44],[47,49],[2,8],[9,14],[10,15],[11,16],[12,21],[17,27],[19,29],[20,30],[22,32],[23,33],[24,34],[25,40],[26,28],[31,35],[36,45],[37,42],[38,43],[44,50],[2,4],[3,9],[12,17],[15,19],[16,20],[18,22],[21,27],[23,29],[24,30],[25,31],[26,32],[28,41],[33,37],[34,38],[35,40],[43,45],[49,50],[3,8],[12,13],[14,18],[17,21],[22,26],[25,27],[28,32],[31,35],[36,41],[39,40],[44,45],[48,50],[6,12],[7,14],[10,13],[11,18],[15,17],[16,22],[19,21],[20,26],[23,25],[24,28],[27,29],[30,32],[31,33],[34,36],[35,37],[38,41],[39,42],[40,46],[48,51],[5,6],[7,10],[9,12],[11,15],[13,14],[16,18],[17,19],[20,23],[21,22],[24,27],[25,26],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[40,42],[41,43],[46,47],[48,49],[50,51],[3,5],[6,8],[7,12],[11,14],[16,17],[18,19],[20,21],[22,23],[24,26],[29,30],[33,34],[37,38],[40,41],[42,43],[44,46],[45,47],[51,52],[3,4],[5,6],[7,9],[10,12],[11,13],[14,15],[17,18],[19,20],[21,22],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[41,42],[43,44],[45,46],[47,48],[7,8],[11,12],[15,16],[23,24],[27,28],[31,32],[35,36],[39,40]],[[0,12],[1,10],[2,9],[3,7],[5,11],[6,8],[13,19],[14,24],[15,25],[16,23],[17,18],[20,26],[21,22],[27,33],[28,38],[29,39],[30,37],[31,32],[34,40],[35,36],[41,47],[42,52],[43,53],[44,51],[45,46],[48,54],[49,50],[1,6],[2,3],[4,11],[7,9],[8,10],[14,15],[16,20],[17,21],[18,22],[19,23],[24,25],[28,29],[30,34],[31,35],[32,36],[33,37],[38,39],[42,43],[44,48],[45,49],[46,50],[47,51],[52,53],[0,4],[1,2],[3,6],[7,8],[9,10],[11,12],[13,17],[14,16],[18,19],[20,21],[22,26],[23,25],[27,31],[28,30],[32,33],[34,35],[36,40],[37,39],[41,45],[42,44],[46,47],[48,49],[50,54],[51,53],[4,6],[5,9],[8,11],[10,12],[13,14],[15,22],[16,20],[17,24],[19,23],[25,26],[27,28],[29,36],[30,34],[31,38],[33,37],[39,40],[41,42],[43,50],[44,48],[45,52],[47,51],[53,54],[0,5],[3,8],[4,7],[6,11],[9,10],[13,41],[15,18],[17,20],[19,22],[21,24],[29,32],[31,34],[33,36],[35,38],[40,54],[43,46],[45,48],[47,50],[49,52],[0,1],[2,5],[6,9],[7,8],[10,11],[14,15],[16,17],[19,20],[22,23],[24,25],[28,29],[30,31],[33,34],[36,37],[38,39],[42,43],[44,45],[47,48],[50,51],[52,53],[0,27],[1,3],[2,4],[5,6],[9,10],[14,16],[15,17],[18,19],[20,21],[22,24],[23,25],[28,30],[29,31],[32,33],[34,35],[36,38],[37,39],[42,44],[43,45],[46,47],[48,49],[50,52],[51,53],[0,13],[1,2],[3,4],[5,7],[6,8],[12,53],[14,42],[15,16],[17,20],[19,22],[23,24],[25,39],[27,41],[29,30],[31,34],[33,36],[37,38],[43,44],[45,48],[47,50],[51,52],[2,3],[4,5],[6,7],[8,9],[11,24],[12,25],[13,27],[14,28],[17,18],[19,20],[21,22],[29,43],[31,32],[33,34],[35,36],[38,52],[39,53],[45,46],[47,48],[49,50],[2,15],[3,4],[5,6],[9,26],[11,38],[16,17],[18,19],[20,21],[22,23],[24,52],[25,39],[30,31],[32,33],[34,35],[36,37],[44,45],[46,47],[48,49],[50,51],[1,32],[2,29],[3,16],[4,45],[5,36],[6,33],[7,34],[8,35],[9,40],[10,23],[15,43],[17,31],[18,46],[19,47],[20,48],[21,49],[22,50],[24,38],[26,54],[30,44],[37,51],[1,18],[3,30],[4,17],[5,42],[6,19],[7,20],[8,21],[10,37],[15,29],[16,44],[22,28],[23,51],[26,40],[31,45],[32,46],[33,47],[34,48],[35,49],[36,50],[53,54],[1,14],[4,13],[5,22],[6,15],[8,27],[9,32],[10,43],[11,44],[12,17],[16,30],[19,33],[20,34],[21,35],[23,37],[25,45],[26,46],[36,42],[38,48],[39,49],[40,50],[1,4],[5,14],[7,16],[8,13],[10,29],[11,30],[17,31],[18,32],[21,41],[23,43],[24,44],[28,36],[37,47],[39,45],[40,46],[50,52],[2,8],[9,18],[10,15],[11,16],[12,21],[17,27],[19,29],[20,30],[22,28],[23,33],[24,34],[25,41],[26,32],[31,35],[36,42],[37,43],[38,44],[45,51],[46,48],[49,50],[52,53],[2,4],[9,22],[12,17],[15,19],[16,20],[18,28],[21,27],[23,29],[24,30],[25,31],[26,36],[32,42],[33,37],[34,38],[35,41],[45,46],[48,51],[9,14],[12,13],[17,21],[18,22],[25,27],[26,28],[31,35],[32,36],[39,41],[40,42],[48,49],[3,9],[6,12],[7,14],[10,13],[11,18],[15,17],[16,22],[19,21],[20,26],[23,25],[24,28],[27,29],[30,32],[31,33],[34,36],[35,37],[38,40],[39,43],[41,47],[42,44],[49,51],[3,5],[6,8],[7,12],[9,10],[11,13],[14,15],[16,19],[17,18],[20,23],[21,22],[24,27],[25,26],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[40,41],[42,43],[44,47],[50,51],[3,6],[5,8],[7,9],[10,12],[11,14],[13,15],[16,17],[18,19],[20,22],[24,26],[29,30],[33,34],[37,38],[40,42],[41,43],[45,47],[51,52],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[41,42],[44,45],[46,47],[19,20],[23,24],[27,28],[31,32],[35,36],[39,40],[43,44],[47,48]],[[0,6],[1,11],[2,12],[3,10],[4,5],[7,13],[8,9],[14,20],[15,25],[16,26],[17,24],[18,19],[21,27],[22,23],[28,34],[29,39],[30,40],[31,38],[32,33],[35,41],[36,37],[42,48],[43,53],[44,54],[45,52],[46,47],[49,55],[50,51],[1,2],[3,7],[4,8],[5,9],[6,10],[11,12],[15,16],[17,21],[18,22],[19,23],[20,24],[25,26],[29,30],[31,35],[32,36],[33,37],[34,38],[39,40],[43,44],[45,49],[46,50],[47,51],[48,52],[53,54],[0,4],[1,3],[5,6],[7,8],[9,13],[10,12],[14,18],[15,17],[19,20],[21,22],[23,27],[24,26],[28,32],[29,31],[33,34],[35,36],[37,41],[38,40],[42,46],[43,45],[47,48],[49,50],[51,55],[52,54],[0,1],[2,9],[3,7],[4,11],[6,10],[12,13],[14,15],[16,23],[17,21],[18,25],[20,24],[26,27],[28,29],[30,37],[31,35],[32,39],[34,38],[40,41],[42,43],[44,51],[45,49],[46,53],[48,52],[54,55],[0,28],[2,5],[4,7],[6,9],[8,11],[13,55],[14,42],[16,19],[18,21],[20,23],[22,25],[27,41],[30,33],[32,35],[34,37],[36,39],[44,47],[46,49],[48,51],[50,53],[0,14],[1,2],[3,4],[6,7],[9,10],[11,12],[13,27],[15,16],[17,18],[20,21],[23,24],[25,26],[28,42],[29,30],[31,32],[34,35],[37,38],[39,40],[41,55],[43,44],[45,46],[48,49],[51,52],[53,54],[1,3],[2,4],[5,6],[7,8],[9,11],[10,12],[14,28],[15,17],[16,18],[19,20],[21,22],[23,25],[24,26],[27,41],[29,31],[30,32],[33,34],[35,36],[37,39],[38,40],[43,45],[44,46],[47,48],[49,50],[51,53],[52,54],[1,29],[2,3],[4,7],[6,9],[10,11],[12,54],[15,43],[16,17],[18,21],[20,23],[24,25],[26,40],[30,31],[32,35],[34,37],[38,39],[44,45],[46,49],[48,51],[52,53],[1,15],[2,16],[4,5],[6,7],[8,9],[11,25],[12,26],[18,19],[20,21],[22,23],[29,43],[30,44],[32,33],[34,35],[36,37],[39,53],[40,54],[46,47],[48,49],[50,51],[2,30],[3,4],[5,6],[7,8],[9,10],[11,39],[15,29],[16,44],[17,18],[19,20],[21,22],[23,24],[25,53],[26,40],[31,32],[33,34],[35,36],[37,38],[45,46],[47,48],[49,50],[51,52],[3,17],[4,46],[5,47],[6,34],[7,35],[8,36],[9,37],[10,24],[16,30],[18,32],[19,33],[20,48],[21,49],[22,50],[23,51],[25,39],[31,45],[38,52],[3,31],[4,18],[5,19],[6,20],[7,21],[8,22],[9,23],[10,38],[17,45],[24,52],[32,46],[33,47],[34,48],[35,49],[36,50],[37,51],[4,14],[5,15],[6,16],[8,28],[9,29],[10,44],[11,45],[12,18],[13,19],[17,31],[20,34],[21,35],[22,36],[23,37],[24,38],[26,46],[27,47],[39,49],[40,50],[41,51],[1,4],[7,17],[8,14],[9,15],[10,30],[11,31],[18,32],[19,33],[22,42],[23,43],[24,44],[25,45],[38,48],[40,46],[41,47],[51,54],[2,8],[3,9],[10,16],[11,17],[12,22],[13,23],[18,28],[19,29],[20,30],[21,31],[24,34],[25,35],[26,42],[27,43],[32,36],[33,37],[38,44],[39,45],[46,52],[47,53],[2,4],[5,8],[12,18],[13,19],[16,20],[17,21],[22,28],[23,29],[24,30],[25,31],[26,32],[27,33],[34,38],[35,39],[36,42],[37,43],[47,50],[51,53],[12,14],[13,15],[18,22],[19,23],[26,28],[27,29],[32,36],[33,37],[40,42],[41,43],[47,52],[6,12],[7,13],[10,14],[11,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,30],[29,31],[32,34],[33,35],[36,38],[37,39],[40,44],[41,45],[42,48],[43,49],[3,6],[7,10],[9,12],[11,16],[13,14],[15,18],[17,20],[19,22],[21,24],[23,25],[26,28],[27,32],[29,30],[31,34],[33,36],[35,38],[37,40],[39,44],[41,42],[43,45],[46,48],[49,52],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[15,17],[18,20],[19,21],[22,24],[23,26],[25,28],[27,29],[30,32],[31,33],[34,36],[35,37],[38,40],[39,41],[42,44],[43,46],[45,48],[47,49],[50,52],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[45,46],[47,48],[51,52]],[[0,6],[1,11],[2,12],[3,10],[4,5],[7,13],[8,9],[14,20],[15,25],[16,26],[17,24],[18,19],[21,27],[22,23],[28,34],[29,39],[30,40],[31,38],[32,33],[35,41],[36,37],[43,44],[45,52],[46,56],[47,50],[48,55],[49,54],[51,53],[1,2],[3,7],[4,8],[5,9],[6,10],[11,12],[15,16],[17,21],[18,22],[19,23],[20,24],[25,26],[29,30],[31,35],[32,36],[33,37],[34,38],[39,40],[42,56],[43,47],[44,50],[45,49],[48,51],[52,54],[53,55],[0,4],[1,3],[5,6],[7,8],[9,13],[10,12],[14,18],[15,17],[19,20],[21,22],[23,27],[24,26],[28,32],[29,31],[33,34],[35,36],[37,41],[38,40],[42,49],[43,48],[44,51],[46,52],[47,53],[50,55],[54,56],[0,1],[2,9],[3,7],[4,11],[6,10],[12,13],[14,15],[16,23],[17,21],[18,25],[20,24],[26,27],[28,29],[30,37],[31,35],[32,39],[34,38],[40,41],[42,48],[44,46],[45,47],[49,53],[50,52],[51,54],[55,56],[0,28],[2,5],[4,7],[6,9],[8,11],[16,19],[18,21],[20,23],[22,25],[27,41],[30,33],[32,35],[34,37],[36,39],[42,45],[43,44],[46,49],[47,51],[48,50],[52,53],[54,55],[1,2],[3,4],[6,7],[9,10],[11,12],[15,16],[17,18],[20,21],[23,24],[25,26],[29,30],[31,32],[34,35],[37,38],[39,40],[42,43],[44,45],[46,48],[49,51],[52,54],[53,55],[1,3],[2,4],[5,6],[7,8],[9,11],[10,12],[13,55],[14,42],[15,17],[16,18],[19,20],[21,22],[23,25],[24,26],[29,31],[30,32],[33,34],[35,36],[37,39],[38,40],[43,44],[45,47],[50,52],[53,54],[0,14],[1,29],[2,3],[4,7],[6,9],[10,11],[12,54],[13,27],[15,43],[16,17],[18,21],[20,23],[24,25],[26,40],[28,42],[30,31],[32,35],[34,37],[38,39],[41,55],[45,46],[47,48],[49,50],[51,52],[1,15],[2,30],[4,5],[6,7],[8,9],[11,25],[12,26],[14,28],[18,19],[20,21],[22,23],[27,41],[29,43],[32,33],[34,35],[36,37],[40,54],[44,45],[46,47],[48,49],[50,51],[52,53],[3,4],[5,6],[7,8],[9,10],[15,29],[16,44],[17,18],[19,20],[21,22],[23,24],[26,40],[31,32],[33,34],[35,36],[37,38],[39,53],[47,48],[49,50],[2,16],[3,17],[4,46],[5,47],[6,34],[7,35],[8,36],[9,37],[10,38],[11,39],[18,32],[19,33],[21,49],[22,50],[23,51],[24,56],[25,53],[30,44],[31,45],[3,31],[4,18],[5,19],[6,48],[7,21],[8,22],[9,23],[10,24],[16,30],[17,45],[20,34],[25,39],[32,46],[33,47],[35,49],[36,50],[37,51],[38,56],[4,14],[5,15],[8,28],[9,29],[11,45],[12,18],[13,19],[17,31],[21,35],[22,36],[23,37],[24,38],[26,46],[27,47],[34,52],[39,49],[40,50],[41,51],[44,48],[1,4],[7,17],[8,14],[9,15],[10,34],[11,31],[18,32],[19,33],[20,44],[22,42],[23,43],[24,48],[25,45],[38,52],[40,46],[41,47],[50,56],[2,8],[3,9],[6,20],[10,30],[11,17],[12,22],[13,23],[18,28],[19,29],[21,31],[25,35],[26,42],[27,43],[32,36],[33,37],[34,44],[38,48],[39,45],[46,52],[47,54],[51,56],[2,4],[5,8],[6,16],[12,18],[13,19],[17,21],[22,28],[23,29],[25,31],[26,32],[27,33],[30,34],[35,39],[36,42],[37,43],[38,44],[47,53],[54,56],[10,16],[12,14],[13,15],[18,22],[19,23],[20,30],[24,34],[26,28],[27,29],[32,36],[33,37],[40,42],[41,43],[47,50],[51,53],[55,56],[6,12],[7,13],[10,14],[11,15],[16,20],[17,19],[21,23],[24,30],[25,27],[29,31],[33,35],[34,38],[37,39],[40,44],[41,45],[42,48],[43,49],[53,54],[6,8],[7,12],[9,10],[11,14],[16,18],[19,21],[20,22],[24,26],[27,29],[28,30],[32,34],[36,38],[37,40],[39,44],[41,42],[43,48],[45,46],[49,52],[3,6],[7,9],[10,12],[13,16],[15,18],[17,20],[22,24],[23,28],[25,26],[30,32],[31,36],[33,34],[35,38],[41,44],[43,45],[46,48],[47,49],[50,52],[3,5],[6,8],[9,10],[11,13],[14,16],[15,17],[18,20],[19,22],[21,24],[23,25],[26,28],[27,30],[29,32],[31,33],[34,36],[35,37],[38,40],[39,41],[42,44],[45,46],[47,48],[49,50],[51,52],[3,4],[7,8],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[43,44]]],
	best4:[[[0,6],[1,11],[2,12],[3,10],[4,5],[7,13],[8,9],[15,16],[17,24],[18,28],[19,22],[20,27],[21,26],[23,25],[29,35],[30,40],[31,41],[32,39],[33,34],[36,42],[37,38],[44,45],[46,53],[47,57],[48,51],[49,56],[50,55],[52,54],[1,2],[3,7],[4,8],[5,9],[6,10],[11,12],[14,28],[15,19],[16,22],[17,21],[20,23],[24,26],[25,27],[30,31],[32,36],[33,37],[34,38],[35,39],[40,41],[43,57],[44,48],[45,51],[46,50],[49,52],[53,55],[54,56],[0,4],[1,3],[5,6],[7,8],[9,13],[10,12],[14,21],[15,20],[16,23],[18,24],[19,25],[22,27],[26,28],[29,33],[30,32],[34,35],[36,37],[38,42],[39,41],[43,50],[44,49],[45,52],[47,53],[48,54],[51,56],[55,57],[0,1],[2,9],[3,7],[4,11],[6,10],[12,13],[14,20],[16,18],[17,19],[21,25],[22,24],[23,26],[27,28],[29,30],[31,38],[32,36],[33,40],[35,39],[41,42],[43,49],[45,47],[46,48],[50,54],[51,53],[52,55],[56,57],[0,29],[2,5],[4,7],[6,9],[8,11],[14,17],[15,16],[18,21],[19,23],[20,22],[24,25],[26,27],[31,34],[33,36],[35,38],[37,40],[43,46],[44,45],[47,50],[48,52],[49,51],[53,54],[55,56],[1,2],[3,4],[6,7],[9,10],[11,12],[14,15],[16,17],[18,20],[21,23],[24,26],[25,27],[30,31],[32,33],[35,36],[38,39],[40,41],[43,44],[45,46],[47,49],[50,52],[53,55],[54,56],[1,3],[2,4],[5,6],[7,8],[9,11],[10,12],[13,56],[14,43],[15,16],[17,19],[22,24],[25,26],[27,42],[30,32],[31,33],[34,35],[36,37],[38,40],[39,41],[44,45],[46,48],[51,53],[54,55],[0,14],[1,30],[2,3],[4,7],[6,9],[10,11],[12,55],[13,27],[15,44],[17,18],[19,20],[21,22],[23,24],[26,41],[29,43],[31,32],[33,36],[35,38],[39,40],[42,56],[46,47],[48,49],[50,51],[52,53],[1,15],[2,31],[4,5],[6,7],[8,9],[12,26],[14,29],[16,17],[18,19],[20,21],[22,23],[24,25],[27,42],[30,44],[33,34],[35,36],[37,38],[41,55],[45,46],[47,48],[49,50],[51,52],[53,54],[3,4],[5,6],[7,8],[9,10],[11,25],[15,30],[16,45],[19,20],[21,22],[23,52],[24,53],[26,41],[32,33],[34,35],[36,37],[38,39],[40,54],[48,49],[50,51],[2,16],[3,17],[4,47],[5,48],[6,35],[7,36],[8,37],[9,38],[10,57],[11,40],[18,33],[19,34],[20,49],[21,50],[22,51],[25,54],[28,39],[32,46],[3,32],[4,18],[5,19],[6,45],[7,21],[8,22],[9,23],[10,28],[17,46],[20,31],[25,40],[33,47],[34,48],[35,53],[36,50],[37,51],[38,52],[39,57],[4,14],[5,15],[6,16],[8,29],[9,30],[10,20],[11,46],[12,18],[13,19],[17,32],[21,36],[22,37],[23,38],[24,35],[26,47],[27,48],[28,39],[31,49],[40,50],[41,51],[42,52],[55,57],[1,4],[6,10],[7,17],[8,14],[9,15],[11,32],[16,24],[18,33],[19,34],[20,31],[22,43],[23,44],[25,46],[28,49],[35,45],[39,53],[41,47],[42,48],[52,55],[56,57],[2,8],[3,9],[10,16],[11,17],[12,22],[13,23],[18,29],[19,30],[21,32],[24,35],[25,36],[26,43],[27,44],[28,31],[33,37],[34,38],[39,49],[40,46],[48,54],[51,53],[2,4],[5,8],[12,18],[13,19],[17,21],[20,24],[22,29],[23,30],[25,32],[26,33],[27,34],[28,35],[31,45],[36,40],[37,43],[38,44],[47,49],[52,53],[12,14],[13,15],[16,20],[18,22],[19,23],[24,28],[26,29],[27,30],[31,35],[33,37],[34,38],[39,45],[41,43],[42,44],[49,51],[52,54],[6,12],[7,13],[10,14],[11,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,29],[30,32],[31,33],[34,36],[35,37],[38,40],[39,41],[42,46],[43,45],[44,50],[53,54],[3,6],[7,10],[9,12],[11,16],[13,14],[15,20],[17,18],[19,22],[21,24],[23,26],[25,28],[27,30],[29,31],[32,33],[34,35],[36,37],[38,39],[40,43],[41,42],[44,47],[45,46],[48,50],[54,55],[3,8],[7,12],[11,14],[15,17],[18,20],[21,22],[25,26],[27,29],[30,31],[32,34],[33,35],[37,38],[40,41],[42,43],[44,46],[48,49],[50,51],[55,56],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[17,18],[19,21],[22,24],[23,25],[26,28],[29,30],[31,32],[33,34],[36,37],[38,39],[41,42],[44,45],[46,47],[49,50],[51,52],[3,4],[7,8],[11,12],[15,16],[19,20],[23,24],[27,28],[35,36],[39,40],[43,44],[47,48]],[[0,6],[1,11],[2,12],[3,10],[4,5],[7,13],[8,9],[15,16],[17,24],[18,28],[19,22],[20,27],[21,26],[23,25],[30,31],[32,39],[33,43],[34,37],[35,42],[36,41],[38,40],[45,46],[47,54],[48,58],[49,52],[50,57],[51,56],[53,55],[1,2],[3,7],[4,8],[5,9],[6,10],[11,12],[14,28],[15,19],[16,22],[17,21],[20,23],[24,26],[25,27],[29,43],[30,34],[31,37],[32,36],[35,38],[39,41],[40,42],[44,58],[45,49],[46,52],[47,51],[50,53],[54,56],[55,57],[0,4],[1,3],[5,6],[7,8],[9,13],[10,12],[14,21],[15,20],[16,23],[18,24],[19,25],[22,27],[26,28],[29,36],[30,35],[31,38],[33,39],[34,40],[37,42],[41,43],[44,51],[45,50],[46,53],[48,54],[49,55],[52,57],[56,58],[0,1],[2,9],[3,7],[4,11],[6,10],[12,13],[14,20],[16,18],[17,19],[21,25],[22,24],[23,26],[27,28],[29,35],[31,33],[32,34],[36,40],[37,39],[38,41],[42,43],[44,50],[46,48],[47,49],[51,55],[52,54],[53,56],[57,58],[2,5],[4,7],[6,9],[8,11],[14,17],[15,16],[18,21],[19,23],[20,22],[24,25],[26,27],[29,32],[30,31],[33,36],[34,38],[35,37],[39,40],[41,42],[43,58],[44,47],[45,46],[48,51],[49,53],[50,52],[54,55],[56,57],[1,2],[3,4],[6,7],[9,10],[11,12],[14,15],[16,17],[18,20],[21,23],[24,26],[25,27],[29,30],[31,32],[33,35],[36,38],[39,41],[40,42],[44,45],[46,47],[48,50],[51,53],[54,56],[55,57],[0,29],[1,3],[2,4],[5,6],[7,8],[9,11],[10,12],[13,57],[14,44],[15,16],[17,19],[22,24],[25,26],[27,42],[30,31],[32,34],[37,39],[40,41],[45,46],[47,49],[52,54],[55,56],[0,14],[1,30],[2,3],[4,7],[6,9],[10,11],[12,56],[13,27],[15,45],[17,18],[19,20],[21,22],[23,24],[26,41],[29,44],[32,33],[34,35],[36,37],[38,39],[42,57],[47,48],[49,50],[51,52],[53,54],[1,15],[4,5],[6,7],[8,9],[12,26],[14,29],[16,17],[18,19],[20,21],[22,23],[24,25],[27,42],[30,45],[31,32],[33,34],[35,36],[37,38],[39,40],[41,56],[46,47],[48,49],[50,51],[52,53],[54,55],[3,4],[5,6],[7,8],[9,10],[11,25],[15,30],[16,46],[18,33],[19,20],[21,22],[23,53],[24,54],[26,41],[32,47],[34,35],[36,37],[40,55],[49,50],[51,52],[2,35],[3,17],[4,48],[5,49],[6,39],[7,36],[8,37],[9,38],[10,28],[11,40],[16,31],[19,34],[20,50],[21,51],[22,52],[25,55],[2,20],[3,32],[4,18],[5,19],[6,46],[7,21],[8,22],[9,23],[10,43],[17,47],[24,31],[25,40],[28,58],[33,48],[34,49],[35,50],[36,51],[37,52],[38,53],[39,54],[2,16],[4,14],[5,15],[6,24],[8,29],[9,30],[10,35],[11,47],[12,18],[13,19],[17,32],[21,36],[22,37],[23,38],[26,48],[27,49],[28,43],[39,46],[40,51],[41,52],[42,53],[57,58],[1,4],[6,16],[7,17],[8,14],[9,15],[11,32],[18,33],[19,34],[20,35],[22,44],[23,45],[25,47],[28,50],[31,39],[41,48],[42,49],[43,54],[2,8],[3,9],[10,20],[11,17],[12,22],[13,23],[18,29],[19,30],[21,32],[24,31],[25,36],[26,44],[27,45],[28,35],[33,37],[34,38],[39,46],[40,47],[43,50],[49,55],[54,56],[2,4],[5,8],[10,24],[12,18],[13,19],[17,21],[20,31],[22,29],[23,30],[25,32],[26,33],[27,34],[28,39],[35,46],[36,40],[37,44],[38,45],[50,52],[53,54],[56,57],[10,16],[12,14],[13,15],[18,22],[19,23],[20,24],[26,29],[27,30],[28,31],[33,37],[34,38],[35,39],[41,44],[42,45],[43,46],[53,55],[6,12],[7,13],[10,14],[11,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,29],[30,32],[31,33],[34,36],[35,37],[38,40],[39,41],[42,47],[43,44],[45,51],[46,48],[52,53],[3,6],[7,10],[9,12],[11,13],[14,16],[15,20],[17,18],[19,22],[21,24],[23,28],[25,26],[27,29],[30,31],[32,34],[33,35],[36,37],[38,39],[40,43],[41,42],[44,45],[46,47],[48,49],[50,51],[53,55],[3,8],[7,12],[11,14],[13,16],[15,17],[18,20],[21,22],[23,25],[26,28],[29,30],[32,33],[34,35],[36,38],[37,39],[40,41],[42,43],[44,46],[45,47],[48,50],[49,51],[54,55],[3,5],[6,8],[7,9],[10,12],[13,14],[15,16],[17,18],[19,21],[22,24],[25,26],[27,29],[30,31],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[45,46],[47,48],[49,50],[51,52],[55,56],[3,4],[7,8],[11,12],[19,20],[23,24],[27,28],[31,32]],[[1,2],[3,10],[4,14],[5,8],[6,13],[7,12],[9,11],[16,17],[18,25],[19,29],[20,23],[21,28],[22,27],[24,26],[31,32],[33,40],[34,44],[35,38],[36,43],[37,42],[39,41],[46,47],[48,55],[49,59],[50,53],[51,58],[52,57],[54,56],[0,14],[1,5],[2,8],[3,7],[6,9],[10,12],[11,13],[15,29],[16,20],[17,23],[18,22],[21,24],[25,27],[26,28],[30,44],[31,35],[32,38],[33,37],[36,39],[40,42],[41,43],[45,59],[46,50],[47,53],[48,52],[51,54],[55,57],[56,58],[0,7],[1,6],[2,9],[4,10],[5,11],[8,13],[12,14],[15,22],[16,21],[17,24],[19,25],[20,26],[23,28],[27,29],[30,37],[31,36],[32,39],[34,40],[35,41],[38,43],[42,44],[45,52],[46,51],[47,54],[49,55],[50,56],[53,58],[57,59],[0,6],[2,4],[3,5],[7,11],[8,10],[9,12],[13,14],[15,21],[17,19],[18,20],[22,26],[23,25],[24,27],[28,29],[30,36],[32,34],[33,35],[37,41],[38,40],[39,42],[43,44],[45,51],[47,49],[48,50],[52,56],[53,55],[54,57],[58,59],[0,3],[1,2],[4,7],[5,9],[6,8],[10,11],[12,13],[14,59],[15,18],[16,17],[19,22],[20,24],[21,23],[25,26],[27,28],[29,44],[30,33],[31,32],[34,37],[35,39],[36,38],[40,41],[42,43],[45,48],[46,47],[49,52],[50,54],[51,53],[55,56],[57,58],[0,1],[2,3],[4,6],[7,9],[10,12],[11,13],[14,29],[15,16],[17,18],[19,21],[22,24],[25,27],[26,28],[30,31],[32,33],[34,36],[37,39],[40,42],[41,43],[44,59],[45,46],[47,48],[49,51],[52,54],[55,57],[56,58],[0,30],[1,2],[3,5],[8,10],[11,12],[13,58],[15,45],[16,17],[18,20],[23,25],[26,27],[28,43],[29,44],[31,32],[33,35],[38,40],[41,42],[46,47],[48,50],[53,55],[56,57],[0,15],[1,31],[3,4],[5,6],[7,8],[9,10],[12,57],[13,28],[16,46],[18,19],[20,21],[22,23],[24,25],[27,42],[30,45],[33,34],[35,36],[37,38],[39,40],[43,58],[48,49],[50,51],[52,53],[54,55],[1,16],[2,3],[4,5],[6,7],[8,9],[10,11],[12,27],[15,30],[17,18],[19,20],[21,22],[23,24],[25,26],[28,43],[31,46],[32,33],[34,35],[36,37],[38,39],[40,41],[42,57],[47,48],[49,50],[51,52],[53,54],[55,56],[2,32],[3,18],[4,49],[5,6],[7,8],[9,39],[10,40],[11,26],[16,31],[17,47],[19,34],[20,21],[22,23],[24,54],[25,55],[27,42],[33,48],[35,36],[37,38],[41,56],[50,51],[52,53],[2,17],[3,33],[4,19],[5,50],[6,51],[7,37],[8,38],[9,24],[10,25],[11,41],[18,48],[20,35],[21,36],[22,52],[23,53],[26,56],[32,47],[34,49],[39,54],[40,55],[4,15],[5,20],[6,21],[7,22],[8,23],[9,31],[11,48],[12,19],[17,32],[18,33],[24,39],[25,40],[26,41],[27,49],[35,50],[36,51],[37,52],[38,53],[43,54],[44,55],[1,4],[5,16],[6,17],[7,18],[8,30],[10,32],[11,33],[13,20],[14,21],[19,34],[22,37],[23,38],[24,46],[25,47],[26,48],[28,50],[29,51],[41,52],[42,53],[55,58],[8,15],[9,16],[10,17],[11,18],[13,24],[14,25],[19,30],[20,35],[21,36],[22,33],[23,45],[26,37],[28,46],[29,47],[34,38],[41,48],[42,49],[43,50],[44,51],[2,8],[3,9],[12,23],[18,22],[20,31],[21,32],[26,33],[27,45],[35,39],[36,40],[37,41],[50,56],[51,57],[2,4],[5,8],[12,19],[13,20],[14,21],[23,30],[24,31],[25,32],[27,34],[28,35],[29,36],[38,45],[39,46],[40,47],[51,54],[55,57],[12,15],[13,16],[14,17],[19,23],[20,24],[21,25],[27,30],[28,31],[29,32],[34,38],[35,39],[36,40],[42,45],[43,46],[44,47],[51,56],[6,12],[7,13],[10,15],[11,16],[14,19],[17,23],[18,20],[21,27],[22,24],[25,30],[26,28],[29,34],[31,33],[32,38],[35,37],[36,42],[39,41],[40,45],[43,48],[44,49],[46,52],[47,53],[3,6],[7,10],[9,12],[11,14],[13,15],[16,19],[17,18],[20,21],[22,23],[24,26],[25,27],[28,30],[29,31],[32,35],[33,34],[36,39],[37,38],[40,43],[41,42],[44,46],[45,48],[47,50],[49,52],[53,56],[3,8],[7,12],[11,13],[14,15],[16,17],[18,19],[20,22],[21,23],[24,25],[26,27],[28,29],[30,31],[32,34],[36,38],[40,41],[42,43],[44,48],[47,52],[51,53],[54,56],[3,5],[6,8],[7,9],[10,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[32,33],[34,35],[36,37],[38,39],[41,42],[44,45],[46,48],[47,49],[50,52],[55,56],[3,4],[7,8],[11,12],[31,32],[35,36],[39,40],[43,44],[47,48],[51,52]],[[1,2],[3,10],[4,14],[5,8],[6,13],[7,12],[9,11],[16,17],[18,25],[19,29],[20,23],[21,28],[22,27],[24,26],[31,32],[33,40],[34,44],[35,38],[36,43],[37,42],[39,41],[45,58],[46,57],[47,60],[48,59],[49,53],[50,51],[52,56],[54,55],[0,14],[1,5],[2,8],[3,7],[6,9],[10,12],[11,13],[15,29],[16,20],[17,23],[18,22],[21,24],[25,27],[26,28],[30,44],[31,35],[32,38],[33,37],[36,39],[40,42],[41,43],[45,50],[46,52],[47,54],[48,49],[51,58],[53,59],[55,60],[56,57],[0,7],[1,6],[2,9],[4,10],[5,11],[8,13],[12,14],[15,22],[16,21],[17,24],[19,25],[20,26],[23,28],[27,29],[30,37],[31,36],[32,39],[34,40],[35,41],[38,43],[42,44],[45,46],[47,48],[49,50],[51,53],[52,54],[55,56],[57,58],[59,60],[0,6],[2,4],[3,5],[7,11],[8,10],[9,12],[13,14],[15,21],[17,19],[18,20],[22,26],[23,25],[24,27],[28,29],[30,36],[32,34],[33,35],[37,41],[38,40],[39,42],[43,44],[45,47],[46,48],[49,55],[50,56],[51,52],[53,54],[57,59],[58,60],[0,3],[1,2],[4,7],[5,9],[6,8],[10,11],[12,13],[15,18],[16,17],[19,22],[20,24],[21,23],[25,26],[27,28],[29,44],[30,33],[31,32],[34,37],[35,39],[36,38],[40,41],[42,43],[46,47],[48,57],[49,51],[50,52],[53,55],[54,56],[58,59],[0,1],[2,3],[4,6],[7,9],[10,12],[11,13],[15,16],[17,18],[19,21],[22,24],[25,27],[26,28],[30,31],[32,33],[34,36],[37,39],[40,42],[41,43],[46,49],[47,51],[50,53],[52,55],[54,58],[56,59],[0,30],[1,2],[3,5],[8,10],[11,12],[14,59],[15,45],[16,17],[18,20],[23,25],[26,27],[28,43],[31,32],[33,35],[38,40],[41,42],[47,49],[48,51],[54,57],[56,58],[0,15],[1,31],[3,4],[5,6],[7,8],[9,10],[13,58],[14,29],[16,46],[18,19],[20,21],[22,23],[24,25],[27,42],[30,45],[33,34],[35,36],[37,38],[39,40],[44,59],[48,50],[51,53],[52,54],[55,57],[1,16],[2,3],[4,5],[6,7],[8,9],[10,11],[13,28],[15,30],[17,18],[19,20],[21,22],[23,24],[25,26],[29,44],[31,46],[32,33],[34,35],[36,37],[38,39],[40,41],[43,58],[48,49],[50,51],[52,53],[54,55],[56,57],[2,32],[3,33],[4,49],[5,6],[7,8],[9,39],[10,40],[11,41],[12,57],[16,31],[17,47],[18,48],[19,34],[20,21],[22,23],[25,55],[26,60],[28,43],[35,36],[37,38],[51,52],[53,54],[2,17],[3,18],[4,19],[5,50],[6,51],[7,37],[8,38],[10,25],[11,26],[12,27],[20,35],[21,36],[23,53],[24,54],[32,47],[33,48],[34,49],[40,55],[41,60],[42,57],[4,15],[5,20],[6,21],[7,52],[8,23],[9,24],[12,19],[17,32],[18,33],[22,37],[25,40],[26,41],[27,42],[35,50],[36,51],[38,53],[39,54],[44,55],[58,60],[1,4],[5,16],[6,17],[8,30],[9,31],[10,32],[13,20],[14,21],[19,34],[23,38],[24,39],[25,47],[27,49],[28,50],[29,51],[37,56],[42,53],[43,54],[48,52],[8,15],[9,16],[10,17],[11,37],[14,25],[19,30],[20,35],[21,36],[22,48],[23,45],[24,46],[26,52],[29,47],[34,38],[41,56],[42,49],[43,50],[44,51],[54,58],[2,8],[3,9],[7,22],[11,33],[12,23],[13,24],[20,31],[21,32],[27,45],[28,46],[35,39],[36,40],[37,48],[41,52],[50,56],[51,57],[2,4],[5,8],[7,18],[12,19],[13,20],[14,21],[23,30],[24,31],[25,32],[27,34],[28,35],[29,36],[33,37],[38,45],[39,46],[40,47],[41,48],[51,54],[57,58],[11,18],[12,15],[13,16],[14,17],[19,23],[20,24],[21,25],[22,33],[26,37],[27,30],[28,31],[29,32],[34,38],[35,39],[36,40],[42,45],[43,46],[44,47],[51,56],[55,57],[6,12],[7,13],[10,15],[11,16],[14,19],[17,23],[18,22],[21,27],[25,30],[26,33],[29,34],[32,38],[36,42],[37,41],[40,45],[43,48],[44,49],[46,52],[47,53],[57,60],[6,8],[7,10],[9,12],[11,13],[14,15],[16,19],[18,20],[22,24],[26,28],[29,30],[31,33],[35,37],[39,41],[42,43],[44,46],[45,48],[47,50],[49,52],[51,53],[57,58],[59,60],[3,6],[7,12],[11,14],[13,15],[17,18],[20,21],[22,23],[24,27],[25,26],[28,31],[32,35],[33,34],[36,39],[37,38],[40,41],[44,45],[46,48],[47,52],[53,56],[3,5],[6,8],[7,9],[10,12],[13,14],[16,17],[18,19],[20,22],[21,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[40,42],[41,43],[45,46],[47,49],[50,52],[54,56],[3,4],[7,8],[11,12],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[47,48],[51,52],[55,56]],[[1,2],[3,10],[4,14],[5,8],[6,13],[7,12],[9,11],[15,28],[16,27],[17,30],[18,29],[19,23],[20,21],[22,26],[24,25],[32,33],[34,41],[35,45],[36,39],[37,44],[38,43],[40,42],[46,59],[47,58],[48,61],[49,60],[50,54],[51,52],[53,57],[55,56],[0,14],[1,5],[2,8],[3,7],[6,9],[10,12],[11,13],[15,20],[16,22],[17,24],[18,19],[21,28],[23,29],[25,30],[26,27],[31,45],[32,36],[33,39],[34,38],[37,40],[41,43],[42,44],[46,51],[47,53],[48,55],[49,50],[52,59],[54,60],[56,61],[57,58],[0,7],[1,6],[2,9],[4,10],[5,11],[8,13],[12,14],[15,16],[17,18],[19,20],[21,23],[22,24],[25,26],[27,28],[29,30],[31,38],[32,37],[33,40],[35,41],[36,42],[39,44],[43,45],[46,47],[48,49],[50,51],[52,54],[53,55],[56,57],[58,59],[60,61],[0,6],[2,4],[3,5],[7,11],[8,10],[9,12],[13,14],[15,17],[16,18],[19,25],[20,26],[21,22],[23,24],[27,29],[28,30],[31,37],[33,35],[34,36],[38,42],[39,41],[40,43],[44,45],[46,48],[47,49],[50,56],[51,57],[52,53],[54,55],[58,60],[59,61],[0,3],[1,2],[4,7],[5,9],[6,8],[10,11],[12,13],[15,46],[16,17],[18,27],[19,21],[20,22],[23,25],[24,26],[28,29],[31,34],[32,33],[35,38],[36,40],[37,39],[41,42],[43,44],[47,48],[49,58],[50,52],[51,53],[54,56],[55,57],[59,60],[0,1],[2,3],[4,6],[7,9],[10,12],[11,13],[16,19],[17,21],[20,23],[22,25],[24,28],[26,29],[31,32],[33,34],[35,37],[38,40],[41,43],[42,44],[47,50],[48,52],[51,54],[53,56],[55,59],[57,60],[0,31],[1,2],[3,5],[8,10],[11,12],[14,60],[16,47],[17,19],[18,21],[24,27],[26,28],[29,45],[32,33],[34,36],[39,41],[42,43],[48,50],[49,52],[55,58],[57,59],[0,15],[1,32],[3,4],[5,6],[7,8],[9,10],[13,59],[14,29],[17,48],[18,20],[21,23],[22,24],[25,27],[28,44],[31,46],[34,35],[36,37],[38,39],[40,41],[45,60],[49,51],[52,54],[53,55],[56,58],[1,16],[2,3],[4,5],[6,7],[8,9],[10,11],[13,28],[15,31],[18,19],[20,21],[22,23],[24,25],[26,27],[29,45],[32,47],[33,34],[35,36],[37,38],[39,40],[41,42],[44,59],[49,50],[51,52],[53,54],[55,56],[57,58],[2,33],[3,34],[4,50],[5,6],[7,8],[9,40],[10,41],[11,61],[12,58],[16,32],[18,49],[19,35],[21,22],[23,24],[25,56],[26,57],[27,43],[28,44],[30,42],[36,37],[38,39],[52,53],[54,55],[2,17],[3,18],[4,19],[5,51],[6,52],[7,38],[8,39],[10,25],[11,30],[12,27],[20,36],[21,37],[22,53],[23,54],[24,55],[33,48],[35,50],[41,56],[42,61],[43,58],[4,15],[5,20],[6,21],[7,49],[8,23],[9,24],[12,19],[17,33],[22,34],[25,41],[27,43],[30,42],[36,51],[37,52],[38,57],[39,54],[40,55],[45,56],[59,61],[1,4],[5,16],[6,17],[7,18],[8,31],[9,32],[10,33],[11,22],[13,20],[14,21],[19,35],[23,39],[24,40],[25,48],[26,38],[27,50],[28,51],[29,52],[34,53],[42,57],[43,54],[44,55],[60,61],[7,11],[8,15],[9,16],[10,17],[14,25],[18,26],[19,31],[20,36],[21,37],[22,34],[23,46],[24,47],[29,48],[30,53],[35,39],[38,49],[43,50],[44,51],[45,52],[56,57],[2,8],[3,9],[11,18],[12,23],[13,24],[20,32],[21,33],[26,38],[27,46],[28,47],[30,34],[36,40],[37,41],[42,53],[52,58],[55,56],[57,60],[2,4],[5,8],[12,19],[13,20],[14,21],[22,26],[23,31],[24,32],[25,33],[27,35],[28,36],[29,37],[30,38],[34,49],[39,46],[40,47],[41,48],[51,53],[58,59],[3,8],[12,15],[13,16],[14,17],[18,22],[19,23],[20,24],[21,25],[26,30],[27,31],[28,32],[29,33],[34,38],[35,39],[36,40],[37,41],[42,49],[43,46],[44,47],[45,48],[53,55],[56,58],[57,59],[6,12],[7,13],[10,15],[11,16],[14,19],[17,23],[18,20],[21,27],[22,24],[25,31],[26,28],[29,35],[30,32],[33,39],[34,36],[37,43],[38,40],[41,46],[42,44],[45,50],[47,49],[48,54],[57,58],[3,6],[7,9],[10,12],[11,13],[14,15],[16,18],[17,19],[20,22],[21,23],[24,26],[25,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,39],[40,42],[41,43],[44,47],[45,46],[48,50],[49,51],[52,54],[3,5],[6,8],[7,10],[9,12],[11,14],[13,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,30],[29,31],[32,34],[33,35],[36,38],[37,39],[40,41],[42,43],[44,45],[46,47],[48,49],[50,51],[52,53],[54,55],[3,4],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[45,46],[47,48],[49,50],[51,52],[53,54],[55,56]],[[1,2],[3,10],[4,14],[5,8],[6,13],[7,12],[9,11],[15,28],[16,27],[17,30],[18,29],[19,23],[20,21],[22,26],[24,25],[31,44],[32,43],[33,46],[34,45],[35,39],[36,37],[38,42],[40,41],[47,60],[48,59],[49,62],[50,61],[51,55],[52,53],[54,58],[56,57],[0,14],[1,5],[2,8],[3,7],[6,9],[10,12],[11,13],[15,20],[16,22],[17,24],[18,19],[21,28],[23,29],[25,30],[26,27],[31,36],[32,38],[33,40],[34,35],[37,44],[39,45],[41,46],[42,43],[47,52],[48,54],[49,56],[50,51],[53,60],[55,61],[57,62],[58,59],[0,7],[1,6],[2,9],[4,10],[5,11],[8,13],[12,14],[15,16],[17,18],[19,20],[21,23],[22,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,39],[38,40],[41,42],[43,44],[45,46],[47,48],[49,50],[51,52],[53,55],[54,56],[57,58],[59,60],[61,62],[0,6],[2,4],[3,5],[7,11],[8,10],[9,12],[13,14],[15,17],[16,18],[19,25],[20,26],[21,22],[23,24],[27,29],[28,30],[31,33],[32,34],[35,41],[36,42],[37,38],[39,40],[43,45],[44,46],[47,49],[48,50],[51,57],[52,58],[53,54],[55,56],[59,61],[60,62],[0,3],[1,2],[4,7],[5,9],[6,8],[10,11],[12,13],[15,47],[16,17],[18,27],[19,21],[20,22],[23,25],[24,26],[28,29],[32,33],[34,43],[35,37],[36,38],[39,41],[40,42],[44,45],[46,62],[48,49],[50,59],[51,53],[52,54],[55,57],[56,58],[60,61],[0,1],[2,3],[4,6],[7,9],[10,12],[11,13],[16,19],[17,21],[20,23],[22,25],[24,28],[26,29],[32,35],[33,37],[36,39],[38,41],[40,44],[42,45],[48,51],[49,53],[52,55],[54,57],[56,60],[58,61],[0,31],[1,2],[3,5],[8,10],[11,12],[14,61],[16,48],[17,19],[18,21],[24,27],[26,28],[29,45],[33,35],[34,37],[40,43],[42,44],[49,51],[50,53],[56,59],[58,60],[0,15],[1,32],[3,4],[5,6],[7,8],[9,10],[13,60],[14,29],[17,49],[18,20],[21,23],[22,24],[25,27],[28,44],[31,47],[34,36],[37,39],[38,40],[41,43],[45,61],[50,52],[53,55],[54,56],[57,59],[1,16],[2,3],[4,5],[6,7],[8,9],[10,11],[13,28],[15,31],[18,19],[20,21],[22,23],[24,25],[26,27],[29,45],[32,48],[34,35],[36,37],[38,39],[40,41],[42,43],[44,60],[50,51],[52,53],[54,55],[56,57],[58,59],[2,33],[4,51],[5,6],[7,8],[10,41],[11,30],[12,59],[16,32],[18,50],[19,35],[20,36],[21,22],[23,24],[25,57],[26,58],[27,43],[28,44],[37,38],[39,40],[53,54],[55,56],[2,17],[3,38],[4,19],[5,52],[6,53],[7,42],[8,39],[9,40],[10,25],[11,46],[12,27],[18,34],[21,37],[22,54],[23,55],[24,56],[30,62],[33,49],[35,51],[41,57],[43,59],[3,22],[4,15],[5,20],[6,21],[7,50],[8,23],[9,24],[12,19],[17,33],[25,41],[26,34],[27,43],[30,46],[36,52],[37,53],[38,54],[39,55],[40,56],[42,58],[45,57],[61,62],[1,4],[3,18],[5,16],[6,17],[7,26],[8,31],[9,32],[10,33],[11,38],[13,20],[14,21],[19,35],[23,39],[24,40],[25,49],[27,51],[28,52],[29,53],[30,54],[42,50],[43,55],[44,56],[46,58],[7,18],[8,15],[9,16],[10,17],[14,25],[19,31],[20,36],[21,37],[22,38],[23,47],[24,48],[29,49],[34,42],[35,39],[43,51],[44,52],[45,53],[46,54],[58,60],[2,8],[3,9],[11,22],[12,23],[13,24],[20,32],[21,33],[26,34],[27,47],[28,48],[30,38],[36,40],[37,41],[42,50],[53,59],[54,56],[60,61],[2,4],[3,8],[11,26],[12,19],[13,20],[14,21],[22,34],[23,31],[24,32],[25,33],[27,35],[28,36],[29,37],[30,42],[38,50],[39,47],[40,48],[41,49],[56,57],[58,59],[11,18],[12,15],[13,16],[14,17],[19,23],[20,24],[21,25],[22,26],[27,31],[28,32],[29,33],[30,34],[35,39],[36,40],[37,41],[38,42],[43,47],[44,48],[45,49],[46,50],[56,58],[57,59],[6,12],[7,13],[10,15],[11,16],[14,19],[17,23],[18,20],[21,27],[22,24],[25,31],[26,28],[29,35],[30,32],[33,39],[34,36],[37,43],[38,40],[41,47],[42,44],[45,51],[46,48],[49,55],[50,52],[57,58],[59,60],[5,6],[7,10],[9,12],[11,15],[13,14],[16,19],[17,18],[20,23],[21,22],[24,27],[25,26],[28,31],[29,30],[32,35],[33,34],[36,37],[38,39],[40,41],[42,43],[44,47],[45,46],[48,50],[49,51],[52,53],[54,55],[3,5],[6,8],[7,9],[10,12],[11,13],[14,15],[16,17],[18,19],[20,21],[22,23],[24,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,38],[37,39],[40,42],[41,43],[44,45],[46,47],[48,49],[50,51],[52,54],[53,55],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[45,46],[47,48],[49,50],[51,52],[53,54],[55,56]],[[0,13],[1,12],[2,15],[3,14],[4,8],[5,6],[7,11],[9,10],[16,29],[17,28],[18,31],[19,30],[20,24],[21,22],[23,27],[25,26],[32,45],[33,44],[34,47],[35,46],[36,40],[37,38],[39,43],[41,42],[48,61],[49,60],[50,63],[51,62],[52,56],[53,54],[55,59],[57,58],[0,5],[1,7],[2,9],[3,4],[6,13],[8,14],[10,15],[11,12],[16,21],[17,23],[18,25],[19,20],[22,29],[24,30],[26,31],[27,28],[32,37],[33,39],[34,41],[35,36],[38,45],[40,46],[42,47],[43,44],[48,53],[49,55],[50,57],[51,52],[54,61],[56,62],[58,63],[59,60],[0,1],[2,3],[4,5],[6,8],[7,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,21],[22,24],[23,25],[26,27],[28,29],[30,31],[32,33],[34,35],[36,37],[38,40],[39,41],[42,43],[44,45],[46,47],[48,49],[50,51],[52,53],[54,56],[55,57],[58,59],[60,61],[62,63],[0,2],[1,3],[4,10],[5,11],[6,7],[8,9],[12,14],[13,15],[16,18],[17,19],[20,26],[21,27],[22,23],[24,25],[28,30],[29,31],[32,34],[33,35],[36,42],[37,43],[38,39],[40,41],[44,46],[45,47],[48,50],[49,51],[52,58],[53,59],[54,55],[56,57],[60,62],[61,63],[0,32],[1,2],[3,12],[4,6],[5,7],[8,10],[9,11],[13,14],[15,63],[16,48],[17,18],[19,28],[20,22],[21,23],[24,26],[25,27],[29,30],[31,47],[33,34],[35,44],[36,38],[37,39],[40,42],[41,43],[45,46],[49,50],[51,60],[52,54],[53,55],[56,58],[57,59],[61,62],[0,16],[1,4],[2,6],[5,8],[7,10],[9,13],[11,14],[15,31],[17,20],[18,22],[21,24],[23,26],[25,29],[27,30],[32,48],[33,36],[34,38],[37,40],[39,42],[41,45],[43,46],[47,63],[49,52],[50,54],[53,56],[55,58],[57,61],[59,62],[1,33],[2,4],[3,6],[9,12],[11,13],[14,62],[16,32],[17,49],[18,20],[19,22],[25,28],[27,29],[30,46],[31,47],[34,36],[35,38],[41,44],[43,45],[50,52],[51,54],[57,60],[59,61],[1,17],[2,34],[3,5],[6,8],[7,9],[10,12],[13,61],[14,30],[18,50],[19,21],[22,24],[23,25],[26,28],[29,45],[33,49],[35,37],[38,40],[39,41],[42,44],[46,62],[51,53],[54,56],[55,57],[58,60],[2,18],[3,4],[5,6],[7,8],[9,10],[11,12],[13,29],[17,33],[19,20],[21,22],[23,24],[25,26],[27,28],[30,46],[34,50],[35,36],[37,38],[39,40],[41,42],[43,44],[45,61],[51,52],[53,54],[55,56],[57,58],[59,60],[3,35],[4,52],[5,53],[6,7],[8,9],[10,58],[11,59],[12,60],[18,34],[19,51],[20,36],[21,37],[22,23],[24,25],[26,42],[27,43],[28,44],[29,45],[38,39],[40,41],[54,55],[56,57],[3,19],[4,20],[5,21],[6,54],[7,55],[8,56],[9,57],[10,26],[11,27],[12,28],[22,38],[23,39],[24,40],[25,41],[35,51],[36,52],[37,53],[42,58],[43,59],[44,60],[4,16],[5,17],[6,22],[7,23],[8,24],[9,25],[10,34],[19,35],[20,36],[21,37],[26,50],[27,51],[28,44],[29,53],[38,54],[39,55],[40,56],[41,57],[46,58],[47,59],[1,4],[6,18],[7,19],[8,32],[9,33],[11,35],[12,36],[13,37],[22,38],[23,39],[24,48],[25,49],[26,42],[27,43],[28,52],[30,54],[31,55],[44,56],[45,57],[59,62],[8,16],[9,17],[10,18],[11,19],[12,20],[13,21],[14,38],[15,39],[24,40],[25,41],[26,34],[27,35],[28,48],[29,49],[30,50],[31,51],[44,52],[45,53],[46,54],[47,55],[2,8],[3,9],[14,22],[15,23],[24,32],[25,33],[36,40],[37,41],[38,42],[39,43],[54,60],[55,61],[2,4],[5,8],[12,24],[13,25],[14,26],[15,27],[20,32],[21,33],[22,34],[23,35],[28,36],[29,37],[30,38],[31,39],[40,48],[41,49],[42,50],[43,51],[55,58],[59,61],[12,16],[13,17],[14,18],[15,19],[20,24],[21,25],[22,26],[23,27],[28,32],[29,33],[30,34],[31,35],[36,40],[37,41],[38,42],[39,43],[44,48],[45,49],[46,50],[47,51],[6,12],[7,13],[10,16],[11,17],[14,20],[15,21],[18,24],[19,25],[22,28],[23,29],[26,32],[27,33],[30,36],[31,37],[34,40],[35,41],[38,44],[39,45],[42,48],[43,49],[46,52],[47,53],[50,56],[51,57],[3,6],[7,10],[9,12],[11,14],[13,16],[15,18],[17,20],[19,22],[21,24],[23,26],[25,28],[27,30],[29,32],[31,34],[33,36],[35,38],[37,40],[39,42],[41,44],[43,46],[45,48],[47,50],[49,52],[51,54],[53,56],[57,60],[3,8],[7,12],[11,16],[15,20],[19,24],[23,28],[27,29],[30,32],[31,33],[34,36],[35,40],[39,44],[43,48],[47,52],[51,56],[55,60],[3,5],[6,8],[7,9],[10,12],[11,13],[14,16],[15,17],[18,20],[19,21],[22,24],[23,25],[26,28],[29,30],[31,32],[33,34],[35,37],[38,40],[39,41],[42,44],[43,45],[46,48],[47,49],[50,52],[51,53],[54,56],[55,57],[58,60],[3,4],[7,8],[11,12],[15,16],[19,20],[23,24],[27,28],[35,36],[39,40],[43,44],[47,48],[51,52],[55,56],[59,60]]],
	cs:async function(A,s,a,b){
		if(compareIndices(A,s+a,s+b)>0)await swap(A,s+a,s+b,0,true);
	},
	initNetwork:async function(A,s,l){
		if(l<65)
			if(l<39)for(let i=0;i<this.best1[l].length;i++)await this.cs(A,s,this.best1[l][i][0],this.best1[l][i][1]);
			else if(l<50)for(let i=0;i<this.best2[l-39].length;i++)await this.cs(A,s,this.best2[l-39][i][0],this.best2[l-39][i][1]);
			else if(l<58)for(let i=0;i<this.best3[l-50].length;i++)await this.cs(A,s,this.best3[l-50][i][0],this.best3[l-50][i][1]);
			else if(l<65)for(let i=0;i<this.best4[l-58].length;i++)await this.cs(A,s,this.best4[l-58][i][0],this.best4[l-58][i][1]);
	}
}
function ask(t,d){return!prompts.checked?d:prompt(t,d)}
function askForNum(d,t,n,x){
	n=isNumber(n)?n:2;x=isNumber(x)?x:arr_size;
	let r=Number(ask(t,d))|0;
	return minVal(x,maxVal(n,r));
}
function stop(reason){
	if(shuffling)return stopped=false;
	setTimeout(()=>{
		stopped=sortRunning=false;
		arr=[...new Array(maxValue=arr_size)].map((e,i)=>++i);
		draw();
	});
	throw"Stopped: "+reason;
}
function markSwap(a,b){
	mark(a);
	mark(b);
	return sleep();
}
function swap(a,i,j,s,m,x){
	if(stopped)return stop("UserInput");
	i|=0;j|=0;[a[i],a[j]]=[a[j],a[i]];
	let c=i-j;
	if(!x){
		draw();
		if(c){
			counts.swp++;counts.wrt+=2;
		}
	}else{
		if(m)draw();
		counts.aux+=c?2:0;
	}
	if(m)markSwap(i,j);
	return sleep(s);
}
function write(a,t,v,s,m,x){
	if(stopped)return stop("UserInput");
	let o=a[t|=0];a[t]=v|0;
	let c=o-a[t];
	if(!x){
		draw();
		if(c)counts.wrt++;
	}else{
		if(m)draw();
		if(c)counts.aux++;
	}
	if(m)mark(t);
	return sleep(s);
}
async function multiSwap(A,p,t,s,m,x){
	DEL.set(s);if(t-p>0)for(let i=p;i<t;i++){
		swap(A,i,i+1,0,false,x);
		await DEL.SW(i,i+1,m);
	}else for(let i=p;i>t;i--){
		swap(A,i,i-1,0,false,x);
		await DEL.SW(i,i-1,m);
	}
}
async function reversal(A,s,l,sl,m,x){
	counts.rev++;DEL.set(sl);
	for(let i=s;i<s+(l-s+1)/2|0;i++){
		swap(A,i,s+l-i,0,false,x);
		await DEL.SW(i,s+l-i,m);
	}
	if(sl&&m)await mark(s);
}
async function transcribe(A,r,s,m,x){
	let t=s;
	for(let i=0;i<r.length;i++){
		for(let j=0;j<r[i].length;j++){
			write(A,t++,r[i][j],0,false,x);
			if(m)await mark(t-1);
		}
		r[i]=[];
	}
}
async function transcribeMSD(A,r,s,n,sl,m,x){
	let t=s,tm=0;
	for(let i=0;i<r.length;i++)t+=r[i].length;
	for(let i=r.length-1;i>=0;i--)for(let j=r[i].length-1;j>=0;j--){
		write(A,t+n-tm++-1,r[i][j],0,m,x);
		if(m)await sleep(sl);
	}
}
async function fancyTranscribe(A,l,regs,s){
	let tA=new Array(l),tW=new Array(l).fill(!1),rad=regs.length;
	transcribe(tA,regs,0,false,true);
	counts.aux-=l;
	for(let i=0;i<l;i++){
		let reg=i%rad,p=(reg*(l/rad|0))+i/rad|0;
		if(!tW[p]){
			write(A,p,tA[p],0);
			tW[p]=true;
		}
		mark(p);
		if(!reg)await sleep(s);
	}
	for(let i=0;i<l;i++)if(!tW[i])write(A,i,tA[i],0);
}
async function arraycopy(s,sp,d,dp,l,sl,m,x){
	let b=JSON.stringify(s)!=JSON.stringify(d)||dp<sp,st=b?0:l-1,en=b?l:-1,dr=b?1:-1,j=0,sd;
	for(let i=st;i-en;i+=dr){
		if(++j*sl>1){
			if(m)mark(x?sp+i:dp+i);
			await sleep(j=0,sd=true);
		}
		write(d,dp+i,s[sp+i],0,false,x);
	}
	if(!sd)await sleep();
}
function compareValues(a,b){a|=0;b|=0;counts.comp();return a==b?0:a>b?1:-1}
function compareIndexValue(a,b,c){b|=0;c|=0;counts.comp();return a[b]==c?0:a[b]>c?1:-1}
function compareValueIndex(a,b,c){b|=0;c|=0;counts.comp();return b==a[c]?0:b>a[c]?1:-1}
function compareIndices(a,b,c){b|=0;c|=0;counts.comp();return a[b]==a[c]?0:a[b]>a[c]?1:-1}
async function shuffle(){
	shuffling=true;sortnamedisp.innerText="Running: ...";nextsortdisp.innerText="Next: ...";
	const L=arr_size,R=new Random();
	let delay=cbrt(L)|0,aux=new Array(L),tmp=new Array(L).fill(0),cnt,cs,a,b,c,d,e,f,g,h,i=0,j=0,k=0,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,sm,sb,d1,d2;
	async function shuf(a,s,l,sl,x){
		DEL.set(sl);for(let i=s;i<l;i++){
			swap(a,i,R.nextInt(l-i)+i,0,false,x);
			await DEL.WR(i,!x);
		}
	}
	async function sort(a,s,l,sl=1){
		let n=a[s],x=n;DEL.set(sl);
		for(let i=s+1;i<l;i++)if(a[i]<n)n=a[i];else if(a[i]>x)x=a[i];
		let z=x-n+1,h=new Array(z).fill(0);
		for(let i=s;i<l;i++)write(h,a[i]-n,h[a[i]-n]+1,0,false,true);
		for(let i=0,j=s;i<z;i++)while(h[i]>0){
			write(h,i,h[i]-1,0,false,true);
			write(a,j++,i+n,0,true);
			await DEL.WR(j);
		}
	}
	if(shuffleType.value!="Few Uniques")arr=[...new Array(L)].map((e,i)=>++i);
	switch(shuffleType.value){
		case"Normal":
			await shuf(arr,0,L,1/delay);
			break;
		case"Reverse":
			await reversal(arr,0,L-1,1/delay,true);
			break;
		case"Few Uniques":
			s=sqrt(L)|0;tmp=[...new Array(L)].map((e,i)=>++i);
			for(i=0;i<L;i++)await write(arr,i,tmp[i/s|0]*s,1,true);
			await shuf(arr,0,L,1/delay);
			break;
		case"Slighty Shuffled":
			for(;i<maxVal(L/20|0,1);i++)await swap(arr,R.nextInt(L),R.nextInt(L),0,true);
			break;
		case"Naive":
			for(;i<L;i++){
				n=R.nextInt(L);
				swap(arr,i,n,0);
				if(++j>delay)await markSwap(i,n,j=0);
			}
			break;
		case"Shuffled Tail":
			while(i<L){
				mark(i);
				if(randBool(6/7))write(aux,k++,arr[i++],0,false,true);
				else await write(arr,j++,arr[i++],1,true);
			}
			await arraycopy(aux,0,arr,j,k,1,true);
			await shuf(arr,j,L,1);
			break;
		case"Shuffled Head":
			while(i<L){
				mark(i);
				if(randBool(6/7))write(aux,k++,arr[i++],0,false,true);
				else await write(arr,j++,arr[i++],1,true);
			}
			await arraycopy(aux,0,arr,j,k,1,true);
			await shuf(arr,j,L,1);
			for(i=j-1;i>=0;i--)await swap(arr,(L-j+i)%L,i%L,1,true);
			break;
		case"Shifted Elements":
			s=R.nextInt(L);d=R.nextInt(L);
			if(d<s)await IndexedRotations.holyGriesMills(arr,d,s,s+1,1,true);
			else await IndexedRotations.holyGriesMills(arr,s,s+1,d,1,true);
			break;
		case"Noisy":
			s=maxVal(4,sqrt(L)/2|0);
			for(;i+s<=L;i+=R.nextInt(s-1)+1)await shuf(arr,i,i+s,1);
			await shuf(arr,i,L,1);
			break;
		case"Shuffled Odds":
			for(i=1;i<L;i+=2)await swap(arr,i,(R.nextInt(L-i)/2|0)*2+i,0,true);
			break;
		case"Final Merge":
			for(c=2;j<c;j++)for(i=j;i<L;i+=c)write(tmp,k++,arr[i],0,false,true);
			for(i=0;i<L;i++)await write(arr,i,tmp[i],1,true);
			break;
		case"Shuffled Final Merge":
			await shuf(arr,0,L,.1);
			await sort(arr,0,L/2|0);
			await sort(arr,L/2|0,L);
			break;
		case"Shuffled Half":
			await shuf(arr,0,L,2/3);
			await sort(arr,0,L/2|0);
			break;
		case"Partitioned":
			await shuf(arr,0,L/2|0,.5);
			await shuf(arr,L/2|0,L,.5);
			break;
		case"Sawtooth":
			for(;j<4;j++)for(i=j;i<L;i+=4)write(tmp,k++,arr[i],0,false,true);
			for(i=0;i<L;i++)await write(arr,i,tmp[i],1,true);
			break;
		case"Pipe Organ":
			for(;i<L;i+=2)tmp[j++]=arr[i];
			for(i=1,j=L;i<L;i+=2)tmp[--j]=arr[i];
			for(i=0;i<L;i++)await write(arr,i,tmp[i],1,true);
			break;
		case"Final Bitonic Pass":
			await reversal(arr,0,L-1,.1,true);
			for(;i<L;i+=2)tmp[j++]=arr[i];
			for(i=1,j=L;i<L;i+=2)tmp[--j]=arr[i];
			for(i=0;i<L;i++)await write(arr,i,tmp[i],0,true);
			break;
		case"Interlaced":
			arraycopy(arr,0,aux,0,L);
			for(j=1,k=L-1,i=1;i<L;i++)
				if(i%2)await write(arr,i,aux[k--],1,true);
				else await write(arr,i,aux[j++],1,true);
			break;
		case"Double Layered":
			for(;i<L/2|0;i+=2)await swap(arr,i,L-i-1,0,true);
			break;
		case"Final Radix":
			l=L;l-=l%2;m=l/2|0;tmp=new Array(m);
			for(;i<m;i++)write(tmp,i,arr[i],0,false,true);
			for(i=m;i<l;i++,j+=2){
				await write(arr,j,arr[i],1,true);
				await write(arr,j+1,tmp[i-m],1,true);
			}
			break;
		case"Real Final Radix":
			c=2;e=1;p=0;m=minVal(...arr);x=maxVal(...arr);
			for(;(x-m)/e>=1&&p++<2;e*=10){
				b=new Array(10).fill(0);o=new Array(L);
				for(n=0;n<L;n++)b[((arr[n]-m)/e)%10|0]++;
				for(n=1;n<10;n++)b[n]+=b[n-1];
				for(n=L-1;n>=0;n--)o[--b[((arr[n]-m)/e)%10|0]]=arr[n];
				for(n=0;n<L;n++)await write(arr,n,o[n],1,true);
			}
			break;
		case"Recursive Final Radix":
			w=async(A,p,l,g)=>{
				if(l<2)return;
				let m2=l%2,m=(l-=m2)/2|0,t=new Array(m);
				for(let i=p,j=0;i<p+g*m;i+=g,j++)write(t,j,A[i],0,false,true);
				for(let i=p+g*m,j=p,k=0;i<p+g*l;i+=g,j+=2*g,k++){
					await write(A,j,A[i],0,true);
					await write(A,j+g,t[k],0,true);
				}
				await w(A,p,m+m2,2*g);
				await w(A,p+g,m,2*g);
			}
			await w(arr,0,L,1);
			break;
		case"Half Rotation":
			m=(L+1)/2|0;
			if(L%2){
				t=arr[i];
				while(m<L){
					await write(arr,i++,arr[m],1,true);
					await write(arr,m++,arr[i],1,true);
				}
				await write(arr,i,t,1,true);
			}else while(m<L)await swap(arr,i++,m++,1,true);
			break;
		case"Half Reversed":
			await reversal(arr,0,L-1,.25,true);
			await reversal(arr,L/4|0,(3*L+3)/4-1|0,.25,true);
			break;
		case"Logarithmic Slopes":
			for(;i<L;i++)write(tmp,i,arr[i],0,false,true);
			await write(arr,0,0,1,true);
			for(i=1;i<L;i++){
				l=log(i)/log(2)|0;p=2**l;v=tmp[2*(i-p)+1];
				await write(arr,i,v,1,true);
			}
			break;
		case"Heapified":
			await new HeapSorting(true).heapify(arr,0,L,1);
			break;
		case"Triangular Heapified":
			s=async(a,e,r)=>{
				const trt=v=>sqrt((8*v+1)-1)/2|0;
				let t=a[r],ln=trt(r),l=r+ln+1,ri=l+1;
				while(l<e){
					if(ri>=e){
						if(compareValues(a[l],t)>0)await write(a,r,a[l],1,true);
						break;
					}
					let mx=compareIndices(a,ri,l)<1?l:ri;
					if(compareValues(a[mx],t)>0){
						await write(a,r,a[r=mx],1,true);
						ln=trt(r);l=r+ln+1;ri=l+1;
						continue;
					}
					break;
				}
				await write(a,r,t,1,true);
			}
			for(let i=L-1;i>=0;i--)await s(arr,L,i);
			break;
		case"First Circle Pass":
			await shuf(arr,0,L,.2);
			cs=async(A,lo,hi,e)=>{
				if(lo==hi)return;
				let h=hi,l=lo,m=(hi-lo)/2|0;
				while(lo<hi){
					if(hi<e&&compareIndices(A,lo,hi)>0)
						await swap(A,lo,hi,1,true);
					lo++;hi--;
				}
				await cs(A,l,l+m,e);
				if(l+m+1<e)await cs(A,l+m+1,h,e);
			}
			for(n=1;n<L;n*=2);await cs(arr,0,n-1,L);
			break;
		case"Final Pairwise Pass":
			await shuf(arr,0,L,1);tmp=[];aux=[];
			for(i=1;i<L;i+=2)if(compareIndices(arr,i-1,i)>0)await swap(arr,i-1,i,1,true);
			for(i=0;i<L;i++)
				if(i%2)tmp[k++]=arr[i];
				else aux[j++]=arr[i];
			aux.sort((a,b)=>a-b);tmp.sort((a,b)=>a-b);
			for(i=0,j=0,k=0;i<L;i++)
				if(i%2)await write(arr,i,tmp[k++],1,true);
				else await write(arr,i,aux[j++],1,true);
			break;
		case"Recursive Reversal":
			r=async(a,b)=>{
				if(b-a<2)return;
				await reversal(arr,a,b-1,.2,true);
				let m=(a+b)/2|0;
				await r(a,m);
				await r(m,b);
			}
			await r(0,L);
			break;
		case"Gray Code Fractal":
			r=async (a,b,d)=>{
				if(b-a<3)return;
				let m=(a+b)/2|0;
				if(d)await reversal(arr,a,m-1,.2,true);
				else await reversal(arr,m,b-1,.2,true);
				await r(a,m,false);
				await r(m,b,true);
			}
			await r(0,L,false);
			break;
		case"Sierpinski Triangle":
			t=(tm,a,b)=>{
				if(b-a<2)return;if(b-a<3)return tm[a+1]++;
				let h=(b-a)/3|0,t1=(a+a+b)/3|0,t2=(a+b+b+2)/3|0;
				for(let i=a;i<t1;i++)tm[i]+=h;
				for(let i=t1;i<t2;i++)tm[i]+=2*h;
				t(tm,a,t1);
				t(tm,t1,t2);
				t(tm,t2,b);
			}
			t(tmp,0,L);aux=[...arr];
			for(let i=0;i<L;i++)await write(arr,i,aux[tmp[i]]);
			break;
		case"Triangular":
			for(k=2,m=0,i=1;i<L;i++,j++){
				if(i==k){
					j=0;k*=2;
				}
				tmp[i]=tmp[j]+1;
				if(tmp[i]>m)m=tmp[i];
			}
			c=new Array(m+1).fill(0);
			for(i=0;i<L;i++)c[tmp[i]]++;
			for(i=1;i<c.length;i++)c[i]+=c[i-1];
			for(i=L-1;i+1;i--)tmp[i]=--c[tmp[i]];
			aux=[...arr];
			for(i=0;i<L;i++)await write(arr,i,aux[tmp[i]],1,true);
			break;
		case"Quicksort Adversary":
			for(j=L-L%2-2,i=j-1;i>=0;i-=2,j--)await swap(arr,i,j,1,true);
			break;
		case"Grailsort Adversary":
			r=async(A,a,m,b)=>{
				await reversal(A,a,m-1,.1,true);
				await reversal(A,m,b-1,.1,true);
				await reversal(A,a,b-1,.1,true);
			}
			p=async(A,a,b,bL)=>{
				let l=b-a,b1=b-l%bL,l1=b1-a,m=bL;
				if(l1<=2*bL)return;
				while(2*m<l)m*=2;m+=a;
				if(b1-m<bL)await p(A,a,m,bL);
				else{
					await r(A,(m=a+b1-m)-bL+2,b1-bL+1,b1);
					await multiSwap(A,a,m,.1,true);
					await r(A,a,m,b1);
					await p(A,a,m=a+b1-m,bL);
					await p(A,m,b,bL);
				}
			}
			if(L<17)await reversal(arr,0,L-1,.5,true);
			else{
				let bL=1;
				while(bL*bL<L)bL*=2;
				let nK=(L-1)/bL+1|0,k=bL+nK;
				await shuf(arr,0,L,.25);
				await sort(arr,0,k);
				await reversal(arr,0,k-1,.25,true);
				await sort(arr,k,L);
				await p(arr,k,L,bL);
			}
			break;
		case"Shuffle Merge Adversary":
			d=2;e=1<<(log(L-1)/log(2)+1|0);
			sm=async(A,T,a,m,b)=>{
				if((b-a)%2)
					if(m-a>b-m)a++;
					else b--;
				await sb(A,T,a,b);
			}
			sb=async(A,T,a,b)=>{
				if(b-a<2)return;
				let m=(a+b)/2|0,s=(b-a-1)/4+1|0,j=a=m-s;b=m+s;
				for(let i=a+1;i<b;i+=2)write(T,j++,A[i],0,false,true);
				for(let i=a;i<b;i+=2)write(T,j++,A[i],0,false,true);
				await arraycopy(T,a,A,a,b-a,1,true);
			}
			while(d<=e){
				i=c=0;
				while(i<L){
					j=i;c+=L;
					while(c>=d){
						c-=d;j++;
					}
					k=j;c+=L;
					while(c>=d){
						c-=d;k++;
					}
					await sm(arr,tmp,i,j,i=k);
				}
				d*=2;
			}
			break;
		case"Bit Reversal":
			e=1<<(log(L)/log(2)|0);p=e==L;tmp=[...arr];
			for(i=0;i<e;i++)arr[i]=i;
			for(m=0,d1=e>>1,d2=d1+(d1>>1),i=1;i<e-1;i++){
				for(j=d1,k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);m+=j;
				if(m>i)await swap(arr,i,m,1,true);
			}
			if(!p){
				for(i=e;i<L;i++)await write(arr,i,arr[i-e],.5,true);
				cnt=new Array(e).fill(0);
				for(i=0;i<L;i++)cnt[arr[i]]++;
				for(i=1;i<cnt.length;i++)cnt[i]+=cnt[i-1];
				for(i=L-1;i+1;i--)await write(arr,i,--cnt[arr[i]],.5,true);
			}
			aux=[...arr];
			for(i=0;i<L;i++)await write(arr,i,tmp[aux[i]],0,true);
			break;
		case"Random Blocks":
			p=v=>{
				let a;
				for(a=1;a<=v;a<<=1);
				return a>>1;
			}
			z=p(sqrt(L)|0);
			b=async(A,a,b,l)=>{
				for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			}
			for(i=0;i<L;i+=z)await b(arr,i,R.nextInt((L-i)/z|0)*z+i,z);
			break;
		case"Block Reverse":
			e=L;p=v=>{
				let a;
				for(a=1;a<=v;a<<=1);
				return a>>1;
			}
			z=p(sqrt(L)|0);
			b=async(A,a,b,l)=>{
				for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			}
			e-=e%z;i=0;j=e-z;
			while(i<j){
				await b(arr,i,j,z);
				i+=z;j-=z;
			}
			break;
	}
	await sleep(100);
	shuffling=false;
}
function randInt(s=0,e=2){
	return random()*(e-s)+s|0;
}
function randBool(n=.5){
	return random()>n;
}
async function bogoSwap(A,s,l,sl=0,x){
	DEL.set(sl);for(let i=s;i<l;++i){
		let r=randInt(i,l);
		swap(A,i,r,0,0,x);
		await DEL.SW(i,r,1);
	}
}
async function bogoCombo(A,s,l,z,x){
	for(let i=s;i<l;++i)await write(A,i,0,0,true,x);
	for(let i=l-z;i<l;++i){
		let j=randInt(s,i+1);
		await write(A,compareValues(A[j],0)?i:j,1,0,true,x);
	}
}
function isRangeSorted(A,s,e){
	for(let i=s;i<e-1;++i)if(compareIndices(A,i,i+1)>0)return false;
	return true;
}
function isArraySorted(A,l){
	return isRangeSorted(A,0,l);
}
function isRangePartitioned(A,s,p,e){
	for(let i=s;i<p;i++)if(compareIndices(A,i,p)>0)return false;
	for(let i=p+1;i<e;i++)if(compareIndices(A,p,i)>0)return false;
	return true;
}
function isMinSorted(A,s,e){
	return isRangePartitioned(A,s,s,e);
}
function isMaxSorted(A,s,e){
	return isRangePartitioned(A,s,e-1,e);
}
function isRangeSplit(A,s,m,e){
	let lM=A[s];
	if(stopped)return A.sort((a,b)=>a-b),draw();
	for(let i=s+1;i<m;++i)if(compareValues(lM,A[i])<0)lM=A[i];
	for(let i=m;i<e;++i)if(compareValues(lM,A[i])>0)return false;
	return true;
}
function analyzeMax(A,l){
	let m=0;
	for(let i=0;i<l;i++)if(A[i]>m)m=A[i];
	return m;
}
function analyzeMaxLog(a,l,b){
	let m=0,i;
	for(i=0;i<l;i++)if(a[i]>m)m=a[i];
	return log(m)/log(b)|0;
}
function analyzeBit(a,l){
	let m=0;
	for(let i=0;i<l;i++)if(a[i]>m)m=a[i];
	return 31-clz32(m);
}
function getDigit(a,p,r){
	return(a/pow(r,p)|0)%r;
}
function getBit(n,k){
	return(n>>k&1)>0;
}
async function insertSort(a,s,l,sl=1,x){
	DEL.set(sl);for(let i=s;i<l;i++){
		let p=i-1,c=a[i];
		while(p>=s&&compareValues(a[p],c)>0){
			write(a,p+1,a[p--],0,false,x);
			await DEL.WR(p+2,!x);
		}
		write(a,p+1,c,0,false,x);
	}
}
async function binaryInsertion(A,s,e,sl){
	DEL.set(sl);for(let i=s;i<e;i++){
		let n=A[i],l=s,h=i;
		while(l<h){
			let m=l+(h-l)/2|0;
			if(compareValues(n,A[m])<0)h=m;
			else l=m+1;
		}
		let j=i-1;
		while(j>=l){
			write(A,j+1,A[j--],0);
			await DEL.WR(j+2,1);
		}
		await write(A,l,n,0,true);
	}
}
async function binaryDoubleInsertion(A,a,b){
	function binarySearch(A,a,b,v,c){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<c)b=m;
			else a=m+1;
		}
		return a;
	}
	async function insertToLeft(A,a,b,t){
		DEL.set(b-a);while(a>b){
			write(A,a,A[--a],0);
			await DEL.WR(a+1,1);
		}
		await write(A,b,t,0,true);
	}
	async function insertToRight(A,a,b,t){
		DEL.set(b-a);while(a<b){
			write(A,a,A[++a],0);
			await DEL.WR(a-1,1);
		}
		await write(A,a,t,0,true);
	}
	async function doubleInsertion(A,a,b){
		if(b-a<2)return;
		let j=a+(b-a-2)/2+1|0,i=a+(b-a-1)/2|0;
		if(j>i&&compareIndices(A,i,j)>0)await swap(A,i,j,0,true);
		for(i--,j++;j<b;i--,j++)if(compareIndices(A,i,j)>0){
			let l=A[j],r=A[i],m=binarySearch(A,i+1,j,l,0);
			await insertToRight(A,i,m-1,l);
			await insertToLeft(A,j,binarySearch(A,m,j,r,1),r);
		}else{
			let l=A[i],r=A[j],m=binarySearch(A,i+1,j,l,1);
			await insertToRight(A,i,m-1,l);
			await insertToLeft(A,j,binarySearch(A,m,j,r,0),r);
		}
	}
	await doubleInsertion(A,a,b);
}
async function cocktailShaker(a,s,l,sl=1,x){//lwk
	let k=0;
	for(let i=s;i<(l/2|0)+s;){
		let sw=true;
		for(let j=i;j<l+s-i-1;j++)if(compareIndices(a,j,j+1)>0){
			swap(a,j,j+1,0,sw=false,x);
			if(++k*sl>=1)await mark(j,k=0);
		}
		for(let j=l+s-i-1;j>i;j--)if(compareIndices(a,j,j-1)<0){
			swap(a,j,j-1,0,sw=false,x);
			if(++k*sl>=1)await mark(j,k=0);
		}
		if(sw)break;else i++;
	}
}
async function iterativeCircleSortRoutine(A,l){
	let e=arr_size,sc=0;
	for(let g=l/2|0;g>0;g=g/2|0)for(let st=0;st+g<e;st+=2*g)for(let hi=st+2*g-1,lo=st;lo<hi;lo++,hi--)if(hi<e&&compareIndices(A,lo,hi)>0){
		await swap(A,lo,hi,0,true);sc++;
	}
	return sc;
}
async function recursiveCircleSortRoutine(A,lo,hi,sc){
	if(lo==hi)return sc;
	let e=arr_size,h=hi,l=lo,m=(hi-lo)/2|0;
	while(lo<hi){
		if(hi<e&&compareIndices(A,lo,hi)>0){
			await swap(A,lo,hi,0,true);
			sc++;
		}
		lo++;hi--;
	}
	sc=await recursiveCircleSortRoutine(A,l,l+m,sc);
	if(l+m+1<e)sc=await recursiveCircleSortRoutine(A,l+m+1,h,sc);
	return sc;
}
class PriorityQueue{
	constructor(comp=(a,b)=>a-b){
		this.heap=[];this.comp=comp;
	}
	size(){
		return this.heap.length;
	}
	clear(){
		this.heap=[];
	}
	add(v){
		this.heap.push(v);this.bubbleUp();
	}
	offer(v){
		if(v!==null)this.add(v);
	}
	poll(){
		if(!this.size())return null;
		if(this.size()<2)return this.heap.pop();
		const r=this.heap[0];
		this.heap[0]=this.heap.pop();this.bubbleDown();
		return r;
	}
	bubbleUp(){
		let i=this.heap.length-1,v=this.heap[i];
		while(i>0){
			let pI=(i-1)/2|0,p=this.heap[pI];
			if(this.comp(v,p)>=0)break;
			this.heap[i]=p;i=pI;
		}
		this.heap[i]=v;
	}
	bubbleDown(){
		let i=0;
		const l=this.heap.length,v=this.heap[i];
		while(1){
			let lI=2*i+1,rI=2*i+2,lC,rC,sI=null;
			if(lI<l){
				lC=this.heap[lI];
				if(this.comp(lC,v)<0)sI=lI;
			}
			if(rI<l){
				rC=this.heap[rI];
				if(sI===null&&this.comp(rC,v)<0||sI!==null&&this.comp(rC,lC)<0)sI=rI;
			}
			if(sI===null)break;
			this.heap[i]=this.heap[i=sI];
		}
		this.heap[i]=v;
	}
}
class BigInteger{
	constructor(n){
		this.v=BigInt(n||0);
	}
	setBit(bP){
		return new BigInteger(this.v|(1n<<BigInt(bP)));
	}
	testBit(bP){
		return(this.v&(1n<<BigInt(bP)))!==0n;
	}
}
class Random{
	nextInt(l,h){
		if(h===undefined)return random()*l|0;
		else{
			let n=minVal(l,h),x=maxVal(l,h);
			return random()*(x-n)+n|0;
		}
	}
	nextBoolean(){
		return!this.nextInt(2);
	}
	next(){
		return random();
	}
}
class GrailSorting{
	async grailSwap(A,a,b){
		await swap(A,a,b,.1,true);
	}
	async grailMultiSwap(A,a,b,l){
		while(l--)await this.grailSwap(A,a++,b++);
	}
	setRotation(r){
		this.rot=r;
	}
	async grailRotate(A,p,lA,lB){
		if(typeof this.rot=="function")await this.rot(A,p,lA,lB);
		else while(lA&&lB)if(lA<=lB)await this.grailMultiSwap(A,p,p+=lA,lA,lB-=lA);
		else await this.grailMultiSwap(A,p+(lA-=lB),p+lA+lB,lB);
	}
	async grailInsertSort(A,p,l){
		await binaryInsertion(A,p,p+l,.1);
	}
	grailBinSearch(A,p,n,k,d){
		let l,r;
		for(l=-1,r=n;l<r-1;){
			let m=l+(r-l>>1);
			if(compareIndices(A,k,p+m)<!!d)r=m;
			else l=m;
		}
		return r;
	}
	async grailFindKeys(A,p,l,k){
		let f=1,r=0;
		for(let d=1;d<l&&f<k;d++){
			let o=this.grailBinSearch(A,p+r,f,p+d,true);
			if(o==f||compareIndices(A,p+d,p+r+o)){
				await this.grailRotate(A,p+r,f,d-r-f);
				await this.grailRotate(A,p+(r=d-f)+o,f++-o,1);
			}
		}
		await this.grailRotate(A,p,r,f);
		return f;
	}
	async grailMergeWithoutBuffer(A,p,l1,l2){
		if(l1<l2)while(l1){
			let o=this.grailBinSearch(A,p+l1,l2,p,true);
			if(o){
				await this.grailRotate(A,p,l1,o);p+=o;l2-=o;
			}
			if(!l2)break;
			do{p++;l1--;}while(l1&&compareIndices(A,p,p+l1)<1);
		}else while(l2){
			let o=this.grailBinSearch(A,p,l1,p+l1+l2-1,false);
			if(o-l1){
				await this.grailRotate(A,p+o,l1-o,l2);l1=o;
			}
			if(!l1)break;
			do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
		}
	}
	async grailMergeBuffersLeft(A,kP,mk,p,bC,bL,hb,aC,lL){
		if(!bC)return await this.grailMergeLeft(A,p,aC*bL,lL,-bL);
		let lOL=bL,lOF=compareIndices(A,kP,mk)<0?0:1,pI=bL,rT;
		for(let kI=1;kI<bC;kI++,pI+=bL){
			let nF=compareIndices(A,kP+kI,mk)<0?0:1;rT=pI-lOL;
			if(nF==lOF){
				if(hb)await this.grailMultiSwap(A,p+rT-bL,p+rT,lOL);rT=pI;lOL=bL;
			}else if(hb)[lOL,lOF]=await this.grailSmartMergeWithBuffer(A,p+rT,lOL,lOF,bL);
			else[lOL,lOF]=await this.grailSmartMergeWithoutBuffer(A,p+rT,lOL,lOF,bL);
		}
		rT=pI-lOL;
		if(lL){
			if(lOF){
				if(hb)await this.grailMultiSwap(A,p+rT-bL,p+rT,lOL);rT=pI;lOL=bL*aC;lOF=0;
			}else lOL+=bL*aC;
			if(hb)await this.grailMergeLeft(A,p+rT,lOL,lL,-bL);
			else this.grailMergeWithoutBuffer(A,p+rT,lOL,lL);
		}else if(hb)await this.grailMultiSwap(A,p+rT,p+rT-bL,lOL);
	}
	async grailMergeLeft(A,p,lL,rL,d){
		let l=0,r=lL;rL+=lL;
		while(r<rL)
			if(l==lL||compareIndices(A,p+l,p+r)>0)await this.grailSwap(A,p+d++,p+r++);
			else await this.grailSwap(A,p+d++,p+l++);
		if(d-l)await this.grailMultiSwap(A,p+d,p+l,lL-l);
	}
	async grailMergeRight(A,p,lL,rL,d){
		let m=lL+rL+d-1,r=lL+rL-1,l=lL-1;
		while(l>=0)
			if(r<lL||compareIndices(A,p+l,p+r)>0)await this.grailSwap(A,p+m--,p+l--);
			else await this.grailSwap(A,p+m--,p+r--);
		if(r-m)while(r>=lL)await this.grailSwap(A,p+m--,p+r--);
	}
	async grailSmartMergeWithoutBuffer(A,p,lL,lF,rL){
		if(!rL)return[lL,lF];
		let l1=lL,l2=rL,tF=1-lF;
		if(l1&&compareIndices(A,p+l1-1,p+l1)-tF+1)
			while(l1){
				let f=this.grailBinSearch(A,p+l1,l2,p,!!tF);
				if(f){
					await this.grailRotate(A,p,l1,f);p+=f;l2-=f;
				}
				if(!l2)return[l1,lF];
				do{p++;l1--;}while(l1&&compareIndices(A,p,p+l1)-tF<0);
			}
		return[l2,tF];
	}
	async grailSmartMergeWithBuffer(A,p,lL,lF,bL){
		let d=-bL,l=0,r=lL,lE=r,rE=r+bL,tF=1-lF,n,f=lF;
		while(l<lE&&r<rE)
			if(compareIndices(A,p+l,p+r)-tF<0)await this.grailSwap(A,p+d++,p+l++);
			else await this.grailSwap(A,p+d++,p+r++);
		if(l<lE){
			n=lE-l;
			while(l<lE)await this.grailSwap(A,p+--lE,p+--rE);
		}else{
			n=rE-r;f=tF;
		}
		return[n,f];
	}
	async grailSmartMergeWithXBuf(A,p,lL,lF,bL){
		let d=-bL,l=0,r=lL,lE=r,rE=r+bL,tF=1-lF,n,f=lF;
		while(l<lE&&r<rE)
			if(compareIndices(A,p+l,p+r)-tF<0)await write(A,p+d++,A[p+l++],1,true);
			else await write(A,p+d++,A[p+r++],1,true);
		if(l<lE){
			n=lE-l;
			while(l<lE)await write(A,p+--rE,A[p+--lE],1,true);
		}else{
			n=rE-r;f=tF;
		}
		return[n,f];
	}
	async grailMergeLeftWithXBuf(A,p,lE,rE,d){
		let l=0,r=lE;rE+=lE;
		while(r<rE)
			if(l==lE||compareIndices(A,p+l,p+r)>0)await write(A,p+d++,A[p+r++],1,true);
			else await write(A,p+d++,A[p+l++],1,true);
		if(d-l)while(l<lE)await write(A,p+d++,A[p+l++],1,true);
	}
	async grailMergeBuffersLeftWithXBuf(A,kP,mk,p,bC,gL,aB,lL){
		if(!bC)return await this.grailMergeLeftWithXBuf(A,p,aB*gL,lL,-gL);
		let lOL=gL,lOF=compareIndices(A,kP,mk)<0?0:1,pI=gL,rT;
		for(let kI=1;kI<bC;kI++,pI+=gL){
			let nF=compareIndices(A,kP+kI,mk)<0?0:1;rT=pI-lOL;
			if(nF==lOF){
				await arraycopy(A,p+rT,A,p+rT-gL,lOL,1,true);rT=pI;lOL=gL;
			}else[lOL,lOF]=await this.grailSmartMergeWithXBuf(A,p+rT,lOL,lOF,gL);
		}
		rT=pI-lOL;
		if(lL){
			if(lOF){
				await arraycopy(A,p+rT,A,p+rT-gL,lOL,1,true);rT=pI;lOL=gL*aB;lOF=0;
			}else lOL+=gL*aB;
			await this.grailMergeLeftWithXBuf(A,p+rT,lOL,lL,-gL);
		}else await arraycopy(A,p+rT,A,p+rT-gL,lOL,1,true);
	}
	async grailBuildBlocks(A,p,ln,bL,eB,bP,eL){
		let eD,pt,bB=bL<eL?bL:eL;
		while(bB&bB-1)bB&=bB-1;
		if(bB){
			arraycopy(A,p-bB,eB,bP,bB,0,false,true);
			for(let d=1;d<ln;d+=2){
				eD=0;
				if(compareIndices(A,p+d-1,p+d)>0)eD=1;
				await write(A,p+d-3,A[p+d-1+eD],1,true);
				await write(A,p+d-2,A[p+d-eD],1,true);
			}
			if(ln%2)await write(A,p+ln-3,A[p+ln-1],1,true);
			for(p-=2,pt=2;pt<bB;pt*=2){
				let l=0,r=ln-2*pt;
				while(l<=r){
					await this.grailMergeLeftWithXBuf(A,p+l,pt,pt,-pt);l+=2*pt;
				}
				let rs=ln-l;
				if(rs>pt)await this.grailMergeLeftWithXBuf(A,p+l,pt,rs-pt,-pt);
				else for(;l<ln;l++)await write(A,p+l-pt,A[p+l],1,true);p-=pt;
			}
			await arraycopy(eB,bP,A,p+ln,bB,1,true);
		}else{
			for(let d=1;d<ln;d+=2){
				eD=0;
				if(compareIndices(A,p+d-1,p+d)>0)eD=1;
				await this.grailSwap(A,p+d-3,p+d-1+eD);
				await this.grailSwap(A,p+d-2,p+d-eD);
			}
			if(ln%2)await this.grailSwap(A,p+ln-1,p+ln-3);
			p-=2;pt=2
		}
		for(;pt<bL;pt*=2){
			let l=0,r=ln-2*pt;
			while(l<=r){
				await this.grailMergeLeft(A,p+l,pt,pt,-pt);l+=2*pt;
			}
			let rs=ln-l;
			if(rs>pt)await this.grailMergeLeft(A,p+l,pt,rs-pt,-pt);
			else await this.grailRotate(A,p+l-pt,pt,rs);p-=pt;
		}
		let rT=ln%(2*bL),lP=ln-rT;
		if(rT<=bL)await this.grailRotate(A,p+lP,rT,bL);
		else await this.grailMergeRight(A,p+lP,bL,rT-bL,bL);
		while(lP>0)await this.grailMergeRight(A,p+(lP-=2*bL),bL,bL,bL);
	}
	async grailCombineBlocks(A,kP,p,ln,bL,rB,hb,br,bP){
		let cL=ln/(2*bL)|0,lO=ln%(2*bL);
		if(lO<=bL){
			ln-=lO;lO=0;
		}
		if(br!=null)arraycopy(A,p-rB,br,bP,rB,0,false,true);
		for(let i=0;i<=cL;i++){
			if(i==cL&&!lO)break;
			let blP=p+i*2*bL,blC=(i==cL?lO:2*bL)/rB|0,mk=bL/rB|0;
			await this.grailInsertSort(A,kP,blC+(i==cL?1:0));
			for(let i=1;i<blC;i++){
				let lI=i-1;
				for(let rI=i;rI<blC;rI++){
					let rC=compareIndices(A,blP+lI*rB,blP+rI*rB);
					if(rC>0||(!rC&&compareIndices(A,kP+lI,kP+rI)>0))lI=rI;
				}
				if(lI-i+1){
					await this.grailMultiSwap(A,blP+(i-1)*rB,blP+lI*rB,rB);
					await this.grailSwap(A,kP+i-1,kP+lI);
					if(mk==i-1||mk==lI)mk^=(i-1)^lI;
				}
			}
			let alC=0,lL=0;
			if(i==cL)lL=lO%rB;
			if(lL)while(alC<blC&&compareIndices(A,blP+blC*rB,blP+(blC-alC-1)*rB)<0)alC++;
			if(br!=null)await this.grailMergeBuffersLeftWithXBuf(A,kP,kP+mk,blP,blC-alC,rB,alC,lL);
			else await this.grailMergeBuffersLeft(A,kP,kP+mk,blP,blC-alC,rB,hb,alC,lL);
		}
		if(br!=null){
			for(let i=ln;--i>=0;)await write(A,p+i,A[p+i-rB],1,true);
			await arraycopy(br,bP,A,p-rB,rB,1,true);
		}else if(hb)while(--ln>=0)await this.grailSwap(A,p+ln,p+ln-rB);
	}
	async grailLazyStableSort(A,p,l){
		for(let d=1;d<l;d+=2)if(compareIndices(A,p+d-1,p+d)>0)await this.grailSwap(A,p+d-1,p+d);
		for(let pt=2;pt<l;pt*=2){
			let lf=0,ri=l-2*pt;
			for(;lf<=ri;lf+=2*pt)await this.grailMergeWithoutBuffer(A,p+lf,pt,pt);
			if(l-lf>pt)await this.grailMergeWithoutBuffer(A,p+lf,pt,l-lf-pt);
		}
	}
	async grailCommonSort(A,p,ln,br,bfP,bL){
		if(ln<17)return await this.grailInsertSort(A,p,ln);
		let blL=1;
		while(blL*blL<ln)blL*=2;
		let nK=(ln-1)/blL+1|0,kF=await this.grailFindKeys(A,p,ln,nK+blL),bE=true;
		if(kF<nK+blL){
			if(kF<4)return await this.grailLazyStableSort(A,p,ln);nK=blL;
			while(nK>kF)nK=nK/2|0;bE=false;blL=0;
		}
		let d=blL+nK,buL=bE?blL:nK;
		await this.grailBuildBlocks(A,p+d,ln-d,buL,bE?br:null,bfP,bE?bL:0);
		while(ln-d>(buL*=2)){
			let rBL=blL,bBE=bE;
			if(!bE)if(nK>4&&(nK/8|0)*nK>=buL){
				rBL=nK/2|0;bBE=true;
			}else{
				let cK=1,i=buL*kF/2|0;
				while(cK<nK&&i){
					cK*=2;i=i/8|0;
				}
				rBL=2*buL/cK|0;
			}
			await this.grailCombineBlocks(A,p,p+d,ln-d,buL,rBL,bBE,bBE&&rBL<=bL?br:null,bfP);
		}
		await this.grailInsertSort(A,p,d);
		await this.grailMergeWithoutBuffer(A,p,d,ln-d);
	}
	async grailInPlaceMerge(A,p,l1,l2){
		if(l1<3||l2<3)return await this.grailMergeWithoutBuffer(A,p,l1,l2);
		let mp=l1<l2?l1+l2/2|0:l1/2|0,l1L,l1R;l1L=l1R=this.grailBinSearch(A,p,l1,p+mp,true);
		if(l1R<l1&&!compareIndices(A,p+l1R,p+mp))l1R=this.grailBinSearch(A,p+l1L,l1-l1L,p+mp,false)+l1L;
		let l2L,l2R;l2L=l2R=this.grailBinSearch(A,p+l1,l2,p+mp,true);
		if(l2R<l2&&!compareIndices(A,p+l1+l2R,p+mp))l2R=this.grailBinSearch(A,p+l1+l2L,l2-l2L,p+mp,false)+l2L;
		if(l1L==l1R)await this.grailRotate(A,p+l1R,l1-l1R,l2R);
		else{
			await this.grailRotate(A,p+l1L,l1-l1L,l2L);
			if(l2R-l2L)await this.grailRotate(A,p+l1R+l2L,l1-l1R,l2R-l2L);
		}
		await this.grailInPlaceMerge(A,p+l1R+l2R,l1-l1R,l2-l2R);
		await this.grailInPlaceMerge(A,p,l1L,l2L);
	}
	async grailInPlaceMergeSort(A,s,e){
		for(let d=s+1;d<e;d+=2)if(compareIndices(A,d-1,d)>0)await this.grailSwap(A,d-1,d);
		for(let p=2;p<e;p*=2){
			let l=s,r=e-2*p;
			for(;l<=r;l+=2*p)await this.grailInPlaceMerge(A,l,p,p);
			if(e-l>p)await this.grailInPlaceMerge(A,l,p,e-l-p);
		}
	}
}
class TimSorting{
	G=7;sS=0;
	constructor(a,l){
		this.a=a;this.l=l;
		this.T=new Array(l<512?l>>>1:256);
		let sL=l<120?5:l<1542?10:l<119151?19:40;
		this.rB=new Array(sL);this.rL=new Array(sL);
	}
	async customSort(a,s,l){
		await TimSorting.sort(this,a,s,l);
	}
	static async sort(ts,a,lo,hi){
		let nR=hi-lo,mR=ts.minRunLength(nR);
		if(nR<32)return await ts.binarySort(a,lo,hi,lo+await ts.countRunAndMakeAscending(a,lo,hi));
		do{
			let rL=await ts.countRunAndMakeAscending(a,lo,hi);
			if(rL<mR){
				let f=nR<=mR?nR:mR;
				await ts.binarySort(a,lo,lo+f,lo+rL);rL=f;
			}
			ts.pushRun(lo,rL);
			await ts.mergeCollapse();lo+=rL;nR-=rL;
		}while(nR);
		await ts.mergeForceCollapse();
	}
	async binarySort(a,lo,hi,s){
		if(s==lo)s++;
		for(;s<hi;s++){
			let p=a[s],l=lo,r=s;
			while(l<r){
				let m=l+r>>>1;
				if(compareValues(p,a[m])<0)r=m;
				else l=m+1;
			}
			let n=s-l;
			if(n&&n<3){
				if(n>1)await write(a,l+2,a[l+1],1,true);
				await write(a,l+1,a[l],1,true);
			}else await arraycopy(a,l,a,l+1,n,1,true);
			await write(a,l,p,1,true);
		}
	}
	async countRunAndMakeAscending(a,lo,hi){
		let rH=lo+1;
		if(rH==hi)return 1;
		if(compareIndices(a,rH++,lo)<0){
			while(rH<hi&&compareIndices(a,rH,rH-1)<0)rH++;
			await reversal(a,lo,rH-1,1,true);
		}else while(rH<hi&&compareIndices(a,rH-1,rH)<1)rH++;
		return rH-lo;
	}
	minRunLength(n){
		let r=0;
		while(n>31){
			r|=n&1;n>>=1;
		}
		return n+r;
	}
	pushRun(rB,rL){
		this.rB[this.sS]=rB;this.rL[this.sS++]=rL;
	}
	async mergeCollapse(){
		while(this.sS>1){
			let n=this.sS-2;
			if((n>0&&this.rL[n-1]<=this.rL[n]+this.rL[n+1])||(n>1&&this.rL[n-2]<=this.rL[n]+this.rL[n-1])){
				if(this.rL[n-1]<this.rL[n+1])n--;
			}else if(this.rL[n]>this.rL[n+1])break;
			await this.mergeAt(n);
		}
	}
	async mergeForceCollapse(){
		while(this.sS>1){
			let n=this.sS-2;
			if(n>0&&this.rL[n-1]<this.rL[n+1])n--;
			await this.mergeAt(n);
		}
	}
	async mergeAt(i){
		let b1=this.rB[i],b2=this.rB[i+1],l1=this.rL[i],l2=this.rL[i+1];
		this.rL[i]=l1+l2;
		if(i==this.sS-3){
			this.rB[i+1]=this.rB[i+2];
			this.rL[i+1]=this.rL[i+2];
		}
		let k=this.gallopRight(this.a[b2],this.a,b1,l1,0);this.sS--;b1+=k;l1-=k;
		if(!l1)return;l2=this.gallopLeft(this.a[b1+l1-1],this.a,b2,l2,l2-1);
		if(!l2)return;
		if(l1<=l2)await this.mergeLo(this,b1,l1,b2,l2);
		else await this.mergeHi(this,b1,l1,b2,l2);
	}
	gallopLeft(k,a,b,l,h){
		let lO=0,of=1;
		if(compareValues(k,a[b+h])>0){
			let mO=l-h;
			while(of<mO&&compareValues(k,a[b+h+of])>0){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;lO+=h;of+=h;
		}else{
			let mO=h+1;
			while(of<mO&&compareValues(k,a[b+h-of])<1){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;
			let t=lO;lO=h-of;of=h-t;
		}
		lO++;
		while(lO<of){
			let m=lO+(of-lO>>>1);
			if(compareValues(k,a[b+m])>0)lO=m+1;
			else of=m;
		}
		return of;
	}
	gallopRight(k,a,b,l,h){
		let of=1,lO=0;
		if(compareValues(k,a[b+h])<0){
			let mO=h+1;
			while(of<mO&&compareValues(k,a[b+h-of])<0){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;
			let t=lO;lO=h-of;of=h-t;
		}else{
			let mO=l-h;
			while(of<mO&&compareValues(k,a[b+h+of])+1){
				lO=of;of=of*2+1;
				if(of<1)of=mO;
			}
			if(of>mO)of=mO;lO+=h;of+=h;
		}
		lO++;
		while(lO<of){
			let m=lO+(of-lO>>>1);
			if(compareValues(k,a[b+m])<0)of=m;
			else lO=m+1;
		}
		return of;
	}
	async mergeLo(ts,b1,l1,b2,l2){
		let a=ts.a,T=ts.ensureCapacity(l1);
		arraycopy(a,b1,T,0,l1,0,false,true);
		let c1=0,c2=b2,ds=b1;
		await write(a,ds++,a[c2++],1);
		if(!--l2)return await arraycopy(T,c1,a,ds,l1,1,true);
		if(l1==1){
			await arraycopy(a,c2,a,ds,l2,1,true);
			await write(a,ds+l2,T[c1],1);
			return;
		}
		let mG=ts.G;
		outer:while(1){
			let cn1=0,cn2=0;
			do if(compareValues(a[c2],T[c1])<0){
				await write(a,ds++,a[c2++],1,true);cn2++;cn1=0;
				if(!--l2)break outer;
			}else{
				await write(a,ds++,T[c1++],1,true);cn1++;cn2=0;
				if(--l1==1)break outer;
			}while((cn1|cn2)<mG);
			do{
				cn1=ts.gallopRight(a[c2],T,c1,l1,0);
				if(cn1){
					await arraycopy(T,c1,a,ds,cn1,1,true);ds+=cn1;c1+=cn1;l1-=cn1;
					if(l1<2)break outer;
				}
				await write(a,ds++,a[c2++],1,true);
				if(!--l2)break outer;cn2=ts.gallopLeft(T[c1],a,c2,l2,0);
				if(cn2){
					await arraycopy(a,c2,a,ds,cn2,1,true);ds+=cn2;c2+=cn2;l2-=cn2;
					if(!l2)break outer;
				}
				await write(a,ds++,T[c1++],1,true);
				if(--l1==1)break outer;mG--;
			}while(cn1>6|cn2>6);
			if(mG<0)mG=0;mG+=2;
		}
		ts.G=mG<1?1:mG;
		if(l1==1){
			await arraycopy(a,c2,a,ds,l2,1,true);
			await write(a,ds+l2,T[c1],1,true);
		}else if(!l1)throw"violates contract!";
		else await arraycopy(T,c1,a,ds,l1,1,true);
	}
	async mergeHi(ts,b1,l1,b2,l2){
		let a=ts.a,T=ts.ensureCapacity(l2);
		arraycopy(a,b2,T,0,l2,0,false,true);
		let c1=b1+l1-1,c2=l2-1,ds=b2+l2-1;
		await write(a,ds--,a[c1--],1);
		if(!--l1)return await arraycopy(T,0,a,ds-l2+1,l2,1,true);
		if(l2==1){
			ds-=l1;c1-=l1;
			await arraycopy(a,c1+1,a,ds+1,l1,1,true);
			await write(a,ds,T[c2],1);
			return;
		}
		let mG=ts.G;
		outer:while(1){
			let cn1=0,cn2=0;
			do if(compareValues(T[c2],a[c1])<0){
				await write(a,ds--,a[c1--],1,true);cn1++;cn2=0;
				if(!--l1)break outer;
			}else{
				await write(a,ds--,T[c2--],1,true);cn2++;cn1=0;
				if(--l2==1)break outer;
			}while((cn1|cn2)<mG);
			do{
				cn1=l1-this.gallopRight(T[c2],a,b1,l1,l1-1);
				if(cn1){
					ds-=cn1;c1-=cn1;l1-=cn1;
					await arraycopy(a,c1+1,a,ds+1,cn1,1,true);
					if(!l1)break outer;
				}
				await write(a,ds--,T[c2--],1);
				if(--l2==1)break outer;cn2=l2-this.gallopLeft(a[c1],T,0,l2,l2-1);
				if(cn2){
					ds-=cn2;c2-=cn2;l2-=cn2;
					await arraycopy(T,c2+1,a,ds+1,cn2,1,true);
					if(l2<2)break outer;
				}
				await write(a,ds--,a[c1--],1,true);
				if(!--l1)break outer;mG--;
			}while(cn1>6|cn2>6);
			if(mG<0)mG=0;mG+=2;
		}
		ts.G=mG<1?1:mG;
		if(l2==1){
			ds-=l1;c1-=l1;
			await arraycopy(a,c1+1,a,ds+1,l1,1,true);
			await write(a,ds,T[c2],1,true);
		}else if(!l2)throw"violates contract!";
		else await arraycopy(T,0,a,ds-l2+1,l2,1,true);
	}
	ensureCapacity(m){
		if(this.T.length<m){
			let n=m;
			for(let i=0;i<5;i++)n|=n>>(2**i)
			if(++n<0)n=m;
			else n=minVal(n,this.l>>>1);
			this.T=new Array(n);
		}
		return this.T;
	}
}
class PDQSorting{
	hs=new HeapSorting(true);lO=new Array(128);rO=new Array(128);
	pdqLog(n){
		let l=0;
		while(n>>=1)++l;
		return l;
	}
	pdqLessThan(a,b){
		counts.comp();
		return 1&((a<b?1231:1237)>>1);
	}
	async pdqInsertSort(A,b,e){
		if(b==e)return;
		for(let c=b+1;c-e;++c){
			let s=c,s1=c-1;
			if(compareIndices(A,s,s1)<0){
				let t=A[s];
				do await write(A,s--,A[s1],1,true);while(s-b&&compareValues(t,A[--s1])<0);
				await write(A,s,t,1,true);
			}
		}
	}
	async pdqUnguardInsertSort(A,b,e){
		if(b==e)return;
		for(let c=b+1;c-e;++c){
			let s=c,s1=c-1;
			if(compareIndices(A,s,s1)<0){
				let t=A[s];
				do await write(A,s--,A[s1],1,true);while(compareValues(t,A[--s1])<0);
				await write(A,s,t,1,true);
			}
		}
	}
	async pdqPartialInsertSort(A,b,e){
		if(b==e)return true;
		let l=0;
		for(let c=b+1;c-e;++c){
			if(l>8)return false;
			let s=c,s1=c-1;
			if(compareIndices(A,s,s1)<0){
				let t=A[s];
				do await write(A,s--,A[s1],1,true);while(s-b&&compareValues(t,A[--s1])<0);
				await write(A,s,t,1,true);
				l+=c-s;
			}
		}
		return true;
	}
	async pdqSortTwo(A,a,b){
		if(compareIndices(A,b,a)<0)await swap(A,a,b,1,true);
	}
	async pdqSortThree(A,a,b,c){
		await this.pdqSortTwo(A,a,b);
		await this.pdqSortTwo(A,b,c);
		await this.pdqSortTwo(A,a,b);
	}
	async pdqSwapOffsets(A,s,e,lOs,lOP,rOs,rOP,n,u){
		if(u)for(let i=0;i<n;++i)await swap(A,s+lOs[lOP+i],e-rOs[rOP+i],1,true);
		else if(n>0){
			let l=s+lOs[lOP],r=e-rOs[rOP],t=A[l];
			await write(A,l,A[r],1,true);
			for(let i=1;i<n;++i){
				await write(A,r,A[l=s+lOs[lOP+i]],1,true);
				await write(A,l,A[r=e-rOs[rOP+i]],1,true);
			}
			await write(A,r,t,1,true);
		}
	}
	async pdqPartRightBranchless(A,b,e){
		let pv=A[b],f=b,l=e;
		while(this.pdqLessThan(A[++f],pv)==1);
		if(f-1==b)while(f<l&&!this.pdqLessThan(A[--l],pv));
		else while(!this.pdqLessThan(A[--l],pv));
		let aP=f>=l,lN,rN,lS,rS;lN=rN=lS=rS=0;
		if(!aP)await swap(A,f++,l,1,true);
		while(l-f>128){
			if(!lN){
				let it=f;lS=0;
				for(let i=0;i<64;)for(let j=0;j<8;j++){
					this.lO[lN]=i++;lN+=abs(this.pdqLessThan(A[it++],pv)-1);counts.aux++;
				}
			}
			if(!rN){
				let it=l;rS=0;
				for(let i=0;i<64;)for(let j=0;j<8;j++){
					this.rO[rN]=++i;rN+=this.pdqLessThan(A[--it],pv);counts.aux++;
				}
			}
			let n=minVal(lN,rN);
			await this.pdqSwapOffsets(A,f,l,this.lO,lS,this.rO,rS,n,lN==rN);lN-=n;rN-=n;lS+=n;rS+=n;
			if(!lN)f+=64;
			if(!rN)l-=64;
		}
		let lZ=0,rZ=0,uL=l-f-(rN||lN?64:0);
		if(rN){
			lZ=uL;rZ=64;
		}else if(lN){
			lZ=64;rZ=uL;
		}else{
			lZ=uL/2|0;rZ=uL-lZ;
		}
		if(uL&&!lN){
			let it=f;lS=0;
			for(let i=0;i<lZ;){
				this.lO[lN]=i++;lN+=abs(this.pdqLessThan(A[it++],pv)-1);counts.aux++;
			}
		}
		if(uL&&!rN){
			let it=l;rS=0;
			for(let i=0;i<rZ;){
				this.rO[rN]=++i;rN+=this.pdqLessThan(A[--it],pv);counts.aux++;
			}
		}
		let n=minVal(lN,rN);
		await this.pdqSwapOffsets(A,f,l,this.lO,lS,this.rO,rS,n,lN==rN);lN-=n;rN-=n;lS+=n;rS+=n;
		if(!lN)f+=lZ;
		if(!rN)l-=rZ;
		let lP=0,rP=0;
		if(lN){
			lP+=lS;
			while(lN--)await swap(A,f+this.lO[lP+lN],--l,1,true);f=l;
		}
		if(rN){
			rP+=rS;
			while(rN--)await swap(A,l-this.rO[rP+rN],f++,1,true);l=f;
		}
		let pvP=f-1;
		await write(A,b,A[pvP],1,true);
		await write(A,pvP,pv,1,true);
		return[pvP,aP];
	}
	async pdqPartRight(A,b,e){
		let pv=A[b],f=b,l=e;
		while(compareValues(A[++f],pv)<0);
		if(f-1==b)while(f<l&&compareValues(pv,A[--l])<1);
		else while(compareValues(pv,A[--l])<1);
		let aP=f>=l;
		while(f<l){
			await swap(A,f,l,1,true);
			while(compareValues(A[++f],pv)<0);
			while(compareValues(pv,A[--l])<1);
		}
		let pvP=f-1;
		await write(A,b,A[pvP],1,true);
		await write(A,pvP,pv,1,true);
		return[pvP,aP];
	}
	async pdqPartLeft(A,b,e){
		let pv=A[b],f=b,l=e;
		while(compareValues(pv,A[--l])<0);
		if(l+1==e)while(f<l&&compareValues(A[++f],pv)<1);
		else while(compareValues(A[++f],pv)<1);
		while(f<l){
			await swap(A,f,l,1,true);
			while(compareValues(pv,A[--l])<0);
			while(compareValues(A[++f],pv)<1);
		}
		let pvP=l;
		await write(A,b,A[pvP],1,true);
		await write(A,pvP,pv,1,true);
		return pvP;
	}
	async pdqLoop(A,b,e,br,bA){
		let lm=true;
		while(1){
			let z=e-b;
			if(z<24){
				if(lm)await this.pdqInsertSort(A,b,e);
				else await this.pdqUnguardInsertSort(A,b,e);
				return;
			}
			let hf=z/2|0;
			if(z>128){
				await this.pdqSortThree(A,b,b+hf,e-1);
				await this.pdqSortThree(A,b+1,b+hf-1,e-2);
				await this.pdqSortThree(A,b+2,b+hf+1,e-3);
				await this.pdqSortThree(A,b+hf-1,b+hf,b+hf+1);
				await swap(A,b,b+hf,1,true);
			}else await this.pdqSortThree(A,b+hf,b,e-1);
			if(!lm&&compareIndices(A,b,b-1)<1){
				b=await this.pdqPartLeft(A,b,e)+1;
				continue;
			}
			let[pvP,aP]=br?await this.pdqPartRightBranchless(A,b,e):await this.pdqPartRight(A,b,e);
			let lZ=pvP-b,rZ=e-pvP-1;
			if(lZ<(z/8|0)||rZ<(z/8|0)){
				if(!--bA)return await this.hs.sort(A,b,e);
				if(lZ>23){
					await swap(A,b,b+lZ/4,65,true);
					await swap(A,pvP-1,pvP-lZ/4,65,true);
					if(lZ>128){
						await swap(A,b+1,b+lZ/4+1,65,true);
						await swap(A,b+2,b+lZ/4+2,65,true);
						await swap(A,pvP-2,pvP-lZ/4-1,65,true);
						await swap(A,pvP-3,pvP-lZ/4-2,65,true);
					}
				}
				if(rZ>23){
					await swap(A,pvP+1,pvP+1+rZ/4,65,true);
					await swap(A,e-1,e-rZ/4,65,true);
					if(rZ>128){
						await swap(A,pvP+2,pvP+2+rZ/4,65,true);
						await swap(A,pvP+3,pvP+3+rZ/4,65,true);
						await swap(A,e-2,e-1-rZ/4,65,true);
						await swap(A,e-3,e-2-rZ/4,65,true);
					}
				}
			}else if(aP&&await this.pdqPartialInsertSort(A,b,pvP)&&await this.pdqPartialInsertSort(A,pvP+1,e))return;
			await this.pdqLoop(A,b,pvP,br,bA);b=pvP+1;lm=false;
		}
	}
}
class MultiWayMergeSorting{
	keyLessThan(s,p,a,b){
		let c=compareIndices(s,p[a],p[b]);
		return c<0||!c&&compareValues(a,b)<0;
	}
	siftDown(s,h,p,t,r,z){
		while(2*r+2<z){
			let n=2*r+1,m=n+(this.keyLessThan(s,p,h[n],h[n+1])?0:1);
			if(this.keyLessThan(s,p,h[m],t))write(h,r,h[r=m],0,false,true);
			else break;
		}
		let m=2*r+1;
		if(m<z&&this.keyLessThan(s,p,h[m],t))write(h,r,h[r=m],0,false,true);
		write(h,r,t,0,false,true);
	}
	async kWayMerge(s,d,h,a,b,z,x){
		for(let i=0;i<z;i++)write(h,i,i,0,false,true);
		for(let i=(z-1)/2|0;i>=0;i--)this.siftDown(s,h,p,h[i],i,z);
		for(let i=0;z>0;i++){
			let m=h[0];
			write(d,i,s[a[m]],0,!x,x);
			if(!x)await sleep();
			write(a,m,a[m]+1,0,false,true);
			if(a[m]==b[m])this.siftDown(s,h,a,h[--z],0,z);
			else this.siftDown(s,h,a,h[0],0,z);
		}
	}
}
class HeapSorting{
	constructor(isMax){
		this.m=isMax;this.j=0;
	}
	async siftDown(A,r,d,s,sl){
		let v=this.m?-1:1;
		while(r<=(d/2|0)){
			let l=2*r;
			if(l<d&&compareIndices(A,s+l-1,s+l)==v)l++;
			if(compareIndices(A,s+r-1,s+l-1)==v){
				swap(A,s+r-1,s+l-1,0);
				if(++this.j*sl>=1)await mark(s+r-1,this.j=0);
				r=l;
			}else break;
		}
	}
	async heapify(A,l,h,sl){
		let n=h-l;
		for(let i=n/2|0;i>=1;i--)await this.siftDown(A,i,n,l,sl);
	}
	async sort(A,s,l,sl=1){
		await this.heapify(A,s,l,sl);
		for(let i=l-s;i>1;i--){
			await swap(A,s,s+i-1,0,true);
			await this.siftDown(A,1,i-1,s,sl);
		}
		if(!this.m)await reversal(A,s,s+l-1,1,true);
	}
}
class BlockMergeSorting{
	async shiftFW(A,a,m,b){
		while(m<b)await swap(A,a++,m++,1,true);
	}
	async shiftBW(A,a,m,b){
		while(m>a)await swap(A,--b,--m,1,true);
	}
	async shiftFWExt(A,a,m,b){
		while(m<b)await write(A,a++,A[m++],1,true);
	}
	async shiftBWExt(A,a,m,b){
		while(m>a)await write(A,--b,A[--m],1,true);
	}
	async insertTo(A,a,b){
		let t=A[a];
		while(a>b)await write(A,a,A[--a],.5,true);
		await write(A,b,t,.5,true);
	}
	async insertToBW(A,a,b){
		let t=A[a];
		while(a<b)await write(A,a,A[++a],.5,true);
		await write(A,a,t,.5,true);
	}
	async multiSwap(A,a,b,l){
		for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
	}
	async rotate(A,a,m,b){
		await IndexedRotations.cycleReverse(A,a,m,b,1,true);
	}
	leftBinSearch(A,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<1)b=m;
			else a=m+1;
		}
		return a;
	}
	rightBinSearch(A,a,b,v){
		while(a<b){
			let m=a+(b-a)/2|0;
			if(compareValues(v,A[m])<0)b=m;
			else a=m+1;
		}
		return a;
	}
	async buildRuns(A,a,b){
		let S=true,i=a+1,j=a;
		while(i<b){
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,j,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			if(i<b){
				S=false;j=i-(i-j-1)%16-1;
			}
			while(i-j<16&&i<b)await this.insertTo(A,i,this.rightBinSearch(A,j,i,A[i++]));j=i++;
		}
		return S;
	}
	async findKeys(A,a,b,nK,n){
		let p=a,pE=a+nK;
		for(let i=pE;i<b&&nK<n;i++){
			let o=this.leftBinSearch(A,p,pE,A[i]);
			if(pE==o||compareIndices(A,i,loc)){
				await this.rotate(A,p,pE,i);
				let n=i-pE;p+=n;pE+=n;nK++;
				await this.insertTo(A,pE++,o+=n);
			}
		}
		await this.rotate(A,a,p,pE);
		return nK;
	}
	async findKeysBW(A,a,b,nK,n){
		let p=b-nK,pE=b;
		for(let i=p-1;i>=a&&nK<n;i--){
			let o=this.leftBinSearch(A,p,pE,A[i]);
			if(pE==o||compareIndices(A,i,o)){
				await this.rotate(A,i+1,p,pE);
				let n=p-i-1;o-=n;pE-=n;p-=n+1;nK++;
				await this.insertToBW(A,i,o-1);
			}
		}
		await this.rotate(A,p,pE,b);
		return nK;
	}
	async binaryInsertion(A,a,b){
		for(let i=a+1;i<b;i++)await this.insertTo(A,i,this.rightBinSearch(A,a,i,A[i]));
	}
	boundCheck(A,a,m,b){
		return m>=b||compareIndices(A,m-1,m)<1;
	}
	async mergeBW(A,a,m,b,p){
		if(this.boundCheck(A,a,m,b))return;
		let pL=b-m,i=pL-1,j=m-1,k=b-1;
		await this.multiSwap(A,m,p,pL);
		while(i>=0&&j>=a)
			if(compareIndices(A,j,p+i)<1)await swap(A,k--,p+i--,1,true);
			else await swap(A,k--,j--,1,true);
		while(i>=0)await swap(A,k--,p+i--,1,true);
	}
	async mergeTo(A,a,m,b,p){
		let i=a,j=m;
		while(i<m&&j<b)
			if(compareIndices(A,i,j)<1)await swap(A,p++,i++,1,true);
			else await swap(A,p++,j++,1,true);
		while(i<m)await swap(A,p++,i++,1,true);
		while(j<b)await swap(A,p++,j++,1,true);
	}
	async pingPongMerge(A,a,m1,m2,m3,b,p){
		if(compareIndices(A,m1-1,m1)>0||(m3<b&&compareIndices(A,m3-1,m3)>0)){
			let p1=p+m2-a,pE=p+b-a;
			await this.mergeTo(A,a,m1,m2,p);
			await this.mergeTo(A,m2,m3,b,p1);
			await this.mergeTo(A,p,p1,pE,a);
		}else await this.mergeBW(A,a,m2,b,p);
	}
	async mergeFWExt(A,T,a,m,b){
		let s=m-a,i=0,j=m;
		arraycopy(A,a,T,0,s,0,false,true);
		while(i<s&&j<b)
			if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
			else await write(A,a++,A[j++],1,true);
		while(i<s)await write(A,a++,T[i++],1,true);
	}
	async mergeBWExt(A,T,a,m,b){
		let s=b-m,i=s-1,j=m-1;
		arraycopy(A,m,T,0,s,0,false,true);
		while(i>=0&&j>=a)
			if(compareValues(A[j],T[i])<1)await write(A,--b,T[i--],1,true);
			else await write(A,--b,A[j--],1,true);
		while(i>=0)await write(A,--b,T[i--],1,true);
	}
	async mergeWithBufFW(A,a,m,b,p){
		let i=m;
		while(a<m&&i<b)
			if(compareIndices(A,a,i)<1)await swap(A,p++,a++,1,true);
			else await swap(A,p++,i++,1,true);
		if(a>p)await this.shiftFW(A,p,a,m);
		await this.shiftFW(A,p,i,b);
	}
	async mergeWithBufBW(A,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a)
			if(compareIndices(A,i,b)<1)await swap(A,--p,b--,1,true);
			else await swap(A,--p,i--,1,true);
		if(p>b)await this.shiftBW(A,m,b+1,p);
		await this.shiftBW(A,a,i+1,p);
	}
	async mergeWithBufFWExt(A,a,m,b,p){
		let i=m;
		while(a<m&&i<b)
			if(compareIndices(A,a,i)<1)await write(A,p++,A[a++],1,true);
			else await write(A,p++,A[i++],1,true);
		if(a>p)await this.shiftFWExt(A,p,a,m);
		await this.shiftFWExt(A,p,i,b);
	}
	async mergeWithBufBWExt(A,a,m,b,p){
		let i=m-1;b--;
		while(b>=m&&i>=a)
			if(compareIndices(A,i,b)<1)await write(A,--p,A[b--],1,true);
			else await write(A,--p,A[i--],1,true);
		if(p>b)await this.shiftBWExt(A,m,b+1,p);
		await this.shiftBWExt(A,a,i+1,p);
	}
	async inPlaceMerge(A,a,m,b){
		while(a<m&&m<b){
			if((a=this.rightBinSearch(A,a,m,A[m]))==m)return;
			let i=this.leftBinSearch(A,m,b,A[a]);
			await this.rotate(A,a,m,i);
			let t=i-m;m=i;a+=t+1;
		}
	}
	async inPlaceMergeBW(A,a,m,b){
		while(b>m&&m>a){
			let i=this.rightBinSearch(A,a,m,A[b-1]);
			await this.rotate(A,i,m,b);
			let t=m-i;m=i;b-=t+1;
			if(m==a)break;
			b=this.leftBinSearch(A,m,b,A[m-1]);
		}
	}
}
class QuadSortBase{
	async swapTwo(A,s){
		if(compareIndices(A,s,s+1)>0)await swap(A,s,s+1,1,true);
	}
	async swapThree(A,s){
		if(compareIndices(A,s,s+1)>0){
			if(compareIndices(A,s,s+2)<1)await swap(A,s,s+1,1,true);
			else if(compareIndices(A,s+1,s+2)>0)await swap(A,s,s+2,1,true);
			else{
				let t=A[s];
				await write(A,s,A[s+1],1,true);
				await write(A,s+1,A[s+2],1,true);
				await write(A,s+2,t,1,true);
			}
		}else if(compareIndices(A,s+1,s+2)>0)
			if(compareIndices(A,s,s+2)>0){
				let t=A[s+2];
				await write(A,s+2,A[s+1],1,true);
				await write(A,s+1,A[s],1,true);
				await write(A,s,t,1,true);
			}else await swap(A,s+2,s+1,1,true);
	}
	async swapFour(A,s){
		if(compareIndices(A,s,s+1)>0)await swap(A,s,s+1,1,true);
		if(compareIndices(A,s+2,s+3)>0)await swap(A,s+2,s+3,1,true);
		if(compareIndices(A,s+1,s+2)>0)if(compareIndices(A,s,s+2)<1)
			if(compareIndices(A,s+1,s+3)<1)await swap(A,s+1,s+2,1,true);
			else{
				let t=A[s+1];
				await write(A,s+1,A[s+2],1,true);
				await write(A,s+2,A[s+3],1,true);
				await write(A,s+3,t,1,true);
			}
		else if(compareIndices(A,s,s+3)>0){
			await swap(A,s+1,s+3,1,true);
			await swap(A,s,s+2,1,true);
		}else if(compareIndices(A,s+1,s+3)<1){
			let t=A[s+1];
			await write(A,s+1,A[s],1,true);
			await write(A,s,A[s+2],1,true);
			await write(A,s+2,t,1,true);
		}else{
			let t=A[s+1];
			await write(A,s+1,A[s],1,true);
			await write(A,s,A[s+2],1,true);
			await write(A,s+2,A[s+3],1,true);
			await write(A,s+3,t,1,true);
		}
	}
	async swapFive(A,s){
		this.e=s+4;this.pa=this.e++;this.pt=this.pa--;
		if(compareIndices(A,this.pa,this.pt)>0){
			this.k=A[this.pt];
			await write(A,this.pt--,A[this.pa--],1,true);
			if(this.pa>s&&compareValues(A[this.pa-1],this.k)>0){
				await write(A,this.pt--,A[this.pa--],1,true);
				await write(A,this.pt--,A[this.pa--],1,true);
			}
			if(this.pa>=s&&compareValues(A[this.pa],this.k)>0)await write(A,this.pt--,A[this.pa--],1,true);
			A[this.pt]=this.k;
		}
	}
	async tailSwapEight(A,s){
		this.pa=this.e++;this.pt=this.pa--;
		if(compareIndices(A,this.pa,this.pt)>0){
			this.k=A[this.pt];
			await write(A,this.pt--,A[this.pa--],1,true);
			if(compareValues(A[this.pa-2],this.k)>0)for(let i=0;i<3;i++)await write(A,this.pt--,A[this.pa--],1,true);
			if(this.pa>s&&compareValues(A[this.pa-1],this.k)>0){
				await write(A,this.pt--,A[this.pa--],1,true);
				await write(A,this.pt--,A[this.pa--],1,true);
			}
			if(this.pa>=s&&compareValues(A[this.pa],this.k)>0)await write(A,this.pt--,A[this.pa--],1,true);
			A[this.pt]=this.k;
		}
	}
	async swapSix(A,s){
		await this.swapFive(A,s);
		await this.tailSwapEight(A,s);
	}
	async swapSeven(A,s){
		await this.swapSix(A,s);
		await this.tailSwapEight(A,s);
	}
	async swapEight(A,s){
		await this.swapSeven(A,s);
		await this.tailSwapEight(A,s);
	}
}
class QuadSorting{
	qs=new QuadSortBase();
	async tailSwap(A,s,n){
		let m,t,o;
		switch(n){
			case 0:
			case 1:return;
			case 2:await this.qs.swapTwo(A,s);return;
			case 3:await this.qs.swapThree(A,s);return;
			case 4:await this.qs.swapFour(A,s);return;
			case 5:await this.qs.swapFour(A,s);await this.qs.swapFive(A,s);return;
			case 6:await this.qs.swapFour(A,s);await this.qs.swapSix(A,s);return;
			case 7:await this.qs.swapFour(A,s);await this.qs.swapSeven(A,s);return;
			case 8:await this.qs.swapFour(A,s);await this.qs.swapEight(A,s);return;
		}
		await this.qs.swapFour(A,s);
		await this.qs.swapEight(A,s);this.qs.e=s+8;o=8;
		while(o<n){
			t=o++;this.qs.pa=this.qs.e++;this.qs.pt=this.qs.pa--;
			if(compareIndices(A,this.qs.pa,this.qs.pt)<1)continue;
			let tm=A[this.qs.pt];
			while(t>1){
				m=t/2|0;
				if(compareValues(A[this.qs.pa-m],tm)>0)this.qs.pa-=m;t-=m;
			}
			for(let i=this.qs.pt;i>this.qs.pa;i--)await write(A,i,A[i-1],1,true);
			await write(A,this.qs.pa,tm,1,true);
		}
	}
	async parityMerge4(f,s,d,xO){
		let pl=s,pr=s+4,xP=xO;
		for(let i=0;i<3;i++)
			if(compareIndices(f,pl,pr)<1)write(d,xP++,f[pl++],0,false,true);
			else write(d,xP++,f[pr++],0,false,true);
		if(compareIndices(f,pl,pr)<1)write(d,xP,f[pl],1,false,true);
		else write(d,xP,f[pr],1,false,true);pl=s+3;pr=s+7;xP+=4;
		for(let i=0;i<3;i++)
			if(compareIndices(f,pl,pr)>0)write(d,xP--,f[pl--],1,false,true);
			else write(d,xP--,f[pr--],1,false,true);
		if(compareIndices(f,pl,pr)>0)write(d,xP,f[pl],1,false,true);
		else write(d,xP,f[pr],1,false,true);
	}
	async parityMerge8(f,s,d){
		let pl=0,pr=8,mP=s;
		for(let i=0;i<7;i++)
			if(compareIndices(f,pl,pr)<1)await write(d,mP++,f[pl++],1,true);
			else await write(d,mP++,f[pr++],1,true);
		if(compareIndices(f,pl,pr)<1)await write(d,mP,f[pl],1,true);
		else await write(d,mP,f[pr],1,true);pl=7;pr=15;mP+=8;
		for(let i=0;i<7;i++)
			if(compareIndices(f,pl,pr)>0)await write(d,mP--,f[pl--],1,true);
			else await write(d,mP--,f[pr--],1,true);
		if(compareIndices(f,pl,pr)>0)await write(d,mP,f[pl],1,true);
		else await write(d,mP,f[pr],1,true);
	}
	async parityMerge16(A,s,x){
		if(compareIndices(A,s+3,s+4)<1&&compareIndices(A,s+7,s+8)<1&&compareIndices(A,s+11,s+12)<1)return;
		await this.parityMerge4(A,s,x,0);
		await this.parityMerge4(A,s+8,x,8);
		await this.parityMerge8(x,s,A);
	}
	async partialBackwardMerge(A,X,st,n,bl){
		let m=st+bl,e=st+n-1,s,r=m--;
		if(compareIndices(A,m,r)<1)return;
		while(compareIndices(A,m,e)<1)e--;
		for(let i=r;i<r+e-m;i++)write(X,i-r,A[i],1,false,true);s=e-r;
		await write(A,e--,A[m--],1,true);
		if(compareValues(A[st],X[0])<1)do{
			while(compareValues(A[m],X[s])>0)await write(A,e--,A[m--],1,true);
			await write(A,e--,X[s--],1,true);
		}while(s>=0);else{
			do{
				while(compareValues(A[m],X[s])<1)await write(A,e--,X[s--],1,true);
				await write(A,e--,A[m--],1,true);
			}while(m>=st);
			do await write(A,e--,X[s--],1,true);while(s>=0);
		}
	}
	async tailMerge(A,X,s,n,bl){
		let pa,pe=s+n;
		while(bl<n){
			for(pa=s;pa+bl<pe;pa+=bl*2){
				if(pa+bl*2<pe){
					await this.partialBackwardMerge(A,X,pa,bl*2,bl);
					continue;
				}
				await this.partialBackwardMerge(A,X,pa,pe-pa,bl);
				break;
			}
			bl*=2;
		}
	}
	async forwardMerge(d,f,s,xS,bl,tX){
		let l=tX?s:xS,r=tX?s+bl:xS+bl,m=r,e=r+bl,mP=tX?xS:s;
		if(compareIndices(f,r-1,e-1)<1){
			L:do for(let i=0;i<3;i++){
				if(compareIndices(f,l,r)<1){
					write(d,mP++,f[l++],tX?0:1,!tX,tX);
					if(!tX)await sleep();
					continue L;
				}
				write(d,mP++,f[r++],tX?0:1,!tX,tX);
				if(!tX)await sleep();
			}while(l<m);
			do{
				write(d,mP++,f[r++],tX?0:1,!tX,tX);
				if(!tX)await sleep();
			}while(r<e);
		}else{
			R:do for(let i=0;i<3;i++){
				if(compareIndices(f,l,r)>0){
					write(d,mP++,f[r++],tX?0:1,!tX,tX);
					if(!tX)await sleep();
					continue R;
				}
				write(d,mP++,f[l++],tX?0:1,!tX,tX);
				if(!tX)await sleep();
			}while(r<e);
			do{
				write(d,mP++,f[l++],tX?0:1,!tX,tX);
				if(!tX)await sleep();
			}while(l<m);
		}
	}
	async quadMergeBlock(A,s,X,b){
		let ps,c,cM=s+b,b2=b*2;
		if(compareIndices(A,cM-1,cM)<1){
			cM+=b2;
			if(compareIndices(A,cM-1,cM)<1){
				cM-=b;
				if(compareIndices(A,cM-1,cM)<1)return;ps=0;c=s;
				do write(X,ps++,A[c++],0,false,true);while(c<cM);cM=c+b2;
				do write(X,ps++,A[c++],0,false,true);while(c<cM);
				await this.forwardMerge(A,X,s,0,b2,false);
				return;
			}
			ps=0;c=s;cM=s+b2;
			do write(X,pts++,A[c++],0,false,true);while(c<cM);
		}else await this.forwardMerge(X,A,s,0,b,true);
		await this.forwardMerge(X,A,s+b2,b2,b,true);
		await this.forwardMerge(A,X,s,0,b2,false);
	}
	async quadMerge(A,X,s,n,b){
		let pa,pe=s+n;b*=4;
		while(b*2<=n){
			pa=s;
			do{
				await this.quadMergeBlock(A,pa,X,b/4|0);pa+=b;
			}while(pa+b<=pe);
			await this.tailMerge(A,X,pa,pe-pa,b/4|0);b*=4;
		}
		await this.tailMerge(A,X,s,n,b/4|0);
	}
	async quadSwap(A,s,n){
		let sw=new Array(16),c=n/4|0,r,pa=s,ps=0,pt=0,t=0;
		swr:while(c-->0){
			while(1){
				if(compareIndices(A,pa,pa+1)>0){
					if(compareIndices(A,pa+2,pa+3)>0){
						if(compareIndices(A,pa+1,pa+2)>0){
							ps=pa;pa+=4;
							break;
						}
						await swap(A,pa+2,pa+3,1,true);
					}
					await swap(A,pa,pa+1,1,true);
				}else if(compareIndices(A,pa+2,pa+3)>0)await swap(A,pa+2,pa+3,1,true);
				if(compareIndices(A,pa+1,pa+2)>0)if(compareIndices(A,pa,pa+2)<1)if(compareIndices(A,pa+1,pa+3)<1)await swap(A,pa+1,pa+2,1,true);
				else{
					t=A[pa+1];
					await write(A,pa+1,A[pa+2],1,true);
					await write(A,pa+2,A[pa+3],1,true);
					await write(A,pa+3,t,1,true);
				}else if(compareIndices(A,pa,pa+3)>0){
					await swap(A,pa+1,pa+3,1,true);
					await swap(A,pa,pa+2,1,true);
				}else if(compareIndices(A,pa+1,pa+3)<1){
					t=A[pa+1];
					await write(A,pa+1,A[pa],1,true);
					await write(A,pa,A[pa+2],1,true);
					await write(A,pa+2,t,1,true);
				}else{
					t=A[pa+1];
					await write(A,pa+1,A[pa],1,true);
					await write(A,pa,A[pa+2],1,true);
					await write(A,pa+2,A[pa+3],1,true);
					await write(A,pa+3,t,1,true);
				}
				pa+=4;
				continue swr;
			}
			while(1){
				if(c-->0){
					if(compareIndices(A,pa,pa+1)> 0){
						if(compareIndices(A,pa+2,pa+3)>0){
							if(compareIndices(A,pa+1,pa+2)>0){
								if(compareIndices(A,pa-1,pa)>0){
									pa+=4;
									continue;
								}
							}
							await swap(A,pa+2,pa+3,1,true);
						}
						await swap(A,pa,pa+1,1,true);
					}else if(compareIndices(A,pa+2,pa+3)>0)await swap(A,pa+2,pa+3,1,true);
					if(compareIndices(A,pa+1,pa+2)>0)if(compareIndices(A,pa,pa+2)<1)if(compareIndices(A,pa+1,pa+3)<1)await swap(A,pa+1,pa+2,1,true);
					else{
						t=A[pa+1];
						await write(A,pa+1,A[pa+2],1,true);
						await write(A,pa+2,A[pa+3],1,true);
						await write(A,pa+3,t,1,true);
					}else if(compareIndices(A,pa,pa+3)>0){
						await swap(A,pa,pa+2,1,true);
						await swap(A,pa+1,pa+3,1,true);
					}else if(compareIndices(A,pa+1,pa+3)<1){
						t=A[pa];
						await write(A,pa,A[pa+2],1,true);
						await write(A,pa+2,A[pa+1],1,true);
						await write(A,pa+1,t,1,true);
					}else{
						t=A[pa];
						await write(A,pa,A[pa+2],1,true);
						await write(A,pa+2,A[pa+3],1,true);
						await write(A,pa+3,A[pa+1],1,true);
						await write(A,pa+1,t,1,true);
					}
					pt=pa-1;r=(pt-ps)/2|0;
					do await swap(A,ps++,pt--,1,true);while(r-->0);pa+=4;
					continue swr;
				}
				if(ps==s)switch(n%4){
					case 3:if(compareIndices(A,pa+1,pa+2)<1)break;
					case 2:if(compareIndices(A,pa,pa+1)<1)break;
					case 1:if(compareIndices(A,pa-1,pa)<1)break;
					case 0:
						pt=ps+n-1;r=(pt-ps)/2|0;
						do await swap(A,ps++,pt--,1,true);while(r-->0);
						return 1;
				}
				pt=pa-1;r=(pt-ps)/2|0;
				do await swap(A,ps++,pt--,1,true);while(r-->0);
				break swr;
			}
		}
		await this.tailSwap(A,pa,n%4);pa=s;c=n/16|0;
		for(;c-->0;pa+=16)await this.parityMerge16(A,pa,sw);
		if(n%16>4)await this.tailMerge(A,sw,pa,n%16,4);
		return 0;
	}
	async quadSort(A,s,l){
		if(l<16)await this.tailSwap(A,s,l);
		else if(l<256){
			if(!await this.quadSwap(A,s,l))await this.tailMerge(A,new Array(128),s,l,16);
		}else if(!await this.quadSwap(A,s,l))await this.quadMerge(A,new Array(l/2|0),s,l,16);
	}
	async quadSortSwap(A,sw,s,l){
		if(l<16)await this.tailSwap(A,s,l);
		else if(l<256){
			if(!await this.quadSwap(A,s,l))await this.tailMerge(A,sw,s,l,16);
		}else if(!await this.quadSwap(A,s,l))await this.quadMerge(A,sw,s,l,16);
	}
}
class Sorts{
	getNames(){
		return Object.getOwnPropertyNames(Sorts.prototype).filter(e=>new Sorts()[e]instanceof(async()=>{}).constructor).sort((a,b)=>a.localeCompare(b));
	}
	randomSort(){
		let names=this.getNames();
		runSort(names[randInt(names.length)]);
	}
	async bitonicSortIterative(len){
		for(let i,j,k=2;k<len*2;k=2*k){
			let m=((len+k-1)/k|0)%2;
			for(j=k>>1;j>0;j=j>>1)for(i=0;i<len;i++){
				let n=i^j;
				if(n>i&&n<len)if(!(i&k)==m&&compareIndices(arr,i,n)>0||!!(i&k)==m&&compareIndices(arr,i,n)<0)await swap(arr,i,n,0,true);
			}
		}
	}
	async bitonicSortRecursive(len){
		function gpot(n){
			let k=1;
			while(k<n)k<<=1;
			return k>>1;
		}
		async function c(A,i,j,d){
			if(compareIndices(A,i,j)>0==d)await swap(A,i,j,0,true);
		}
		async function bitonicMerge(A,lo,n,d){
			if(n>1){
				let m=gpot(n);
				for(let i=lo;i<lo+n-m;i++)await c(A,i,i+m,d);
				await bitonicMerge(A,lo,m,d);
				await bitonicMerge(A,lo+m,n-m,d);
			}
		}
		async function bitonicSort(A,lo,n,d){
			if(n>1){
				let m=n/2|0;
				await bitonicSort(A,lo,m,!d);
				await bitonicSort(A,lo+m,n-m,d);
				await bitonicMerge(A,lo,n,d);
			}
		}
		await bitonicSort(arr,0,len,true);
	}
	async boseNelsonSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		async function rc(A,a,b,o){
			let h=(b-a)/2|0,m=a+h;a+=o;
			for(let i=0;i<h-o;i++)if((i&~o)==i)await cs(A,a+i,m+i);
		}
		let e=len;
		len=1<<ceil(log(len)/log(2));
		for(let k=2;k<=len;k*=2)for(let j=0;j<k/2|0;j++)for(let i=0;i+j<e;i+=k)await rc(arr,i,i+k,j);
	}
	async boseNelsonSortRecursive(len){
		function cs(A,a,b){
			if(compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		async function boseNelsonMerge(A,s1,l1,s2,l2){
			if(l1==1&&l2==1){await cs(A,s1,s2);
			}else if(l1==1&&l2==2){
				await cs(A,s1,s2+1);
				await cs(A,s1,s2);
			}else if(l1==2&&l2==1){
				await cs(A,s1,s2);
				await cs(A,s1+1,s2);
			}else{
				let m1=l1/2|0,m2=l1%2?l2/2|0:(l2+1)/2|0;
				await boseNelsonMerge(A,s1,m1,s2,m2);
				await boseNelsonMerge(A,s1+m1,l1-m1,s2+m2,l2-m2);
				await boseNelsonMerge(A,s1+m1,l1-m1,s2,m2);
			}
		}
		async function boseNelson(A,s,l){
			if(l>1){
				let m=l/2|0;
				await boseNelson(A,s,m);
				await boseNelson(A,s+m,l-m);
				await boseNelsonMerge(A,s,m,s+m,l-m);
			}
		}
		await boseNelson(arr,0,len);
	}
	async creaseSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0)await swap(A,a,b,.5,true);
		}
		let m=1;
		for(;m*2<len;m*=2);
		for(let n=m;n>0;n=n/2|0){
			for(let i=0;i+1<len;i+=2)await cs(arr,i,i+1);
			for(let j=m;j>=n&&j>1;j=j/2|0)for(let i=1;i+j-1<len;i+=2)await cs(arr,i,i+j-1);
		}
	}
	async diamondSortIterative(len){
		function cs(A,a,b){
			if(compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		let n=1,m=4;
		for(;n<len;n*=2);
		for(;m<=n;m*=2)for(let k=0;k<(m/2|0);k++){
			let c=k<=(m/4|0)?k:m/2-k|0;
			for(let j=0;j<len;j+=m)if(j+c+1<len)for(let i=j+c;i+1<minVal(len,j+m-c);i+=2)await cs(arr,i,i+1);
		}
		m=m/2|0;
		for(let k=0;k<=(m/2|0);k++)for(let i=k;i+1<minVal(len,m-k);i+=2)await cs(arr,i,i+1);
	}
	async diamondSortRecursive(len){
		async function sort(A,s,e,m){
			if(e-s==2){
				if(compareIndices(A,s,e-1)>0)await swap(A,s,e-1,0,true);
			}else if(e-s>2){
				let d=(e-s)/4|0,md=(e-s)/2+s|0;
				if(m){
					await sort(A,s,md,true);
					await sort(A,md,e,true);
				}
				await sort(A,d+s,d*3+s);
				await sort(A,s,md);
				await sort(A,md,e);
				await sort(A,d+s,d*3+s);
			}
		}
		await sort(arr,0,len,true);
	}
	async foldSort(len){
		let cL=1;
		for(;1<<cL<len;cL++);
		let e=len;len=1<<cL;
		for(let k=len>>1;k>0;k>>=1)for(let i=len;i>=k;i>>=1)for(let j=0;j<e;j+=i)for(let l=j,h=j+i-1;l<h;l++,h--)if(h<e&&compareIndices(arr,l,h)>0)await swap(arr,l,h,.5,true);
	}
	async matrixSort(len){
		class MtSp{
			constructor(w,h,l){
				this.w=w;
				this.iL=(w==1)^(h==1)||l;
			}
		}
		async function gR(A,s,e,g){
			for(let i=s,j=e;i<j;i+=g,j-=g)await swap(A,i,j-g,0,true);
		}
		const dCV=(l,r,d)=>d?compareValues(l,r):-compareValues(l,r);
		async function inL(ar,a,b,g,dr){
			let d=0,k=ar[b],j=b-g;
			while(j>=a&&dCV(k,ar[j],dr)<0){
				await write(ar,j+g,ar[j],0,true);d=1;j-=g;
			}
			await write(ar,j+g,k);
			return d;
		}
		function gMD(l){
			let d=sqrt(l)|0,iL=d*d==l-1;
			for(;l%d;d--);
			return new MtSp(d,l/d|0,iL);
		}
		async function mS(a,s,e,g,dr){
			let d=0,l=(e-s)/g|0;
			if(l<2)return 0;
			else if(l<17){
				d=0;
				for(let i=s;i<e;i+=g)d=await inL(a,s,i,g,dr)|d;
			}else{
				let nd,mSh=gMD(l);
				if(mSh.iL)return await mS(a,s,e-g,g,dr)||await inL(a,s,e-g,g,dr);
				for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)await gR(a,i,i+mSh.w*g,g);d=0;
				do{
					nd=0;
					for(let i=s,cd=dr;i<e;i+=mSh.w*g){
						nd=await mS(a,i,i+mSh.w*g,g,cd)||nd;d=d||nd;cd=!cd;
					}
					nd=0;
					for(let i=0;i<mSh.w;d=d||nd,i++)nd=await mS(a,s+i*g,e+i*g,g*mSh.w,dr)||nd;
				}while(nd);
				for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)await gR(a,i,i+mSh.w*g,g);
			}
			return d;
		}
		await mS(arr,0,len,1,true);
	}
	async mergeExchangeSortIterative(len){
		let t=log(len-1)/log(2)+1|0,p0=1<<t-1;
		for(let p=p0;p>0;p>>=1){
			let q=p0,r=0,d=p;
			while(1){
				for(let i=0;i<len-d;i++)if((i&p)==r&&compareIndices(arr,i,i+d)>0)await swap(arr,i,i+d,.5,true);
				if(q==p)break;d=q-p;q>>=1;r=p;
			}
		}
	}
	async oddEvenMergeSortIterative(len){
		for(let p=1;p<len;p*=2)for(let k=p;k>0;k=k/2|0)for(let j=k%p;j+k<len;j+=2*k)for(let i=0;i<k;i++)if(((i+j)/2/p|0)==((i+j+k)/2/p|0))if(i+j+k<len)if(compareIndices(arr,i+j,i+j+k)>0)await swap(arr,i+j,i+j+k,.5,true);
	}
	async oddEvenMergeSortRecursive(len){
		function c(A,a,b){
			if(compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		async function oddEvenMerge(A,l,m2,n,r){
			let m=r*2;
			if(m<n){
				let s=(n/r|0)%2;
				await oddEvenMerge(A,l,(m2+1)/2|0,n+(s?r:0),m);
				await oddEvenMerge(A,l+r,m2/2|0,n-(s?r:0),m);
				if(m2%2)for(let i=l;i+r<l+n;i+=m)await c(A,i,i+r);
				else for(let i=l+r;i+r<l+n;i+=m)await c(A,i,i+r);
			}else if(n>r)await c(A,l,l+r);
		}
		async function oddEvenMergeSort(A,l,n){
			if(n>1){
				let m=n/2|0;
				await oddEvenMergeSort(A,l,m);
				await oddEvenMergeSort(A,l+m,n-m);
				await oddEvenMerge(A,l,m,n,1);
			}
		}
		await oddEvenMergeSort(arr,0,len);
	}
	async pairwiseMergeSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		let e=len,n=1;
		for(;n<len;n<<=1);
		for(let k=n>>1;k>0;k>>=1)for(let j=0;j<len;j+=k<<1)for(let i=0;i<k;i++)await cs(arr,j+i,j+k+i);
		for(let k=2;k<n;k<<=1)for(let m=k>>1;m>0;m>>=1)for(let j=0;j<len;j+=k<<1)for(let p=m;p<k-m<<1;p+=m<<1)for(let i=0;i<m;i++)await cs(arr,j+p+i,j+p+m+i);
	}
	async pairwiseMergeSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		async function pairwiseMerge(A,a,b){
			let m=(a+b)/2|0,m1=(a+m)/2|0,g=m-m1;
			for(let i=0;m1+i<m;i++)for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))await cs(A,j+i,j+i+k);
			if(b-a>4)await pairwiseMerge(A,m,b);
		}
		async function pairwiseMergeSort(A,a,b){
			let m=(a+b)/2|0;
			for(let i=a,j=m;i<m;i++,j++)await cs(A,i,j);
			if(b-a>2){
				await pairwiseMergeSort(A,a,m);
				await pairwiseMergeSort(A,m,b);
				await pairwiseMerge(A,a,b);
			}
		}
		let e=len,n=1;
		for(;n<e;n<<=1);
		await pairwiseMergeSort(arr,0, n);
	}
	async pairwiseSortIterative(len){
		async function iterativepairwise(A,l){
			let a=1,b,c,d,e;
			while(a<l){
				b=a;c=0;
				while(b<l){
					if(compareIndices(A,b-a,b)>0)await swap(A,b-a,b,.5,true);c=++c%a;b+=c?1:a+1;
				}
				a*=2;
			}
			for(a=a/4|0,e=d=1;a>0;a=a/2|0,e=e*2+1,d=e)for(;d>0;d=d/2|0)for(b=d*a+a,c=0;b<l;c=++c%a,b+=c?1:a+1)if(compareIndices(A,b-d*a,b)>0)await swap(A,b-d*a,b,.5,true);
		}
		await iterativepairwise(arr,len);
	}
	async pairwiseSortRecursive(len){
		async function pairwiserecursive(A,s,e,g){
			if(s==e-g)return;
			let b=s+g;
			while(b<e){
				if(compareIndices(A,b-g,b)>0)await swap(A,b-g,b,.5,true);b+=2*g;
			}
			if(((e-s)/g+1|0)%2){
				await pairwiserecursive(A,s,e,g*2);
				await pairwiserecursive(A,s+g,e+g,g*2);
			}else{
				await pairwiserecursive(A,s,e+g,g*2);
				await pairwiserecursive(A,s+g,e,g*2);
			}
			let a=1;
			while(a<(e-s)/g|0)a=a*2+1;b=s+g;
			while(b+g<e){
				let c=a;
				while(c>1){
					c=c/2|0;
					if(b+c*g<e)if(compareIndices(A,b,b+c*g)>0)await swap(A,b,b+c*g,.5,true);
				}
				b+=2*g;
			}
		}
		await pairwiserecursive(arr,0,len,1);
	}
	async weaveSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		let e=len,n=1;
		for(;n<len;n*=2);
		for(let i=1;i<n;i*=2)for(let j=1;j<=i;j*=2)for(let k=0;k<n;k+=n/j|0)for(let d=n/i/2|0,m=0,l=n/j-d|0;l>=n/j/2|0;l-=d)for(let p=0;p<d;p++,m++)await cs(arr,k+m,k+l+p);
	}
	async weaveSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)return swap(A,a,b,.5,true);
		}
		async function circle(A,p,l,g){
			if(l<2)return;
			for(let i=0;2*i<(l-1)*g;i+=g)await cs(A,p+i,p+l*g-g-i);
			await circle(A,p,l/2|0,g);
			if(p+l*g/2|0<e)await circle(A,p+l*g/2|0,l/2|0,g);
		}
		async function weaveCircle(A,p,l,g){
			if(l<2)return;
			await weaveCircle(A,p,l/2|0,2*g);
			await weaveCircle(A,p+g,l/2|0,2*g);
			await circle(A,p,l,g);
		}
		let e=len,n=1;
		for(;n<e;n*=2);
		await weaveCircle(arr,0,n,1);
	}
	async americanFlagSort(len){
		let base=askForNum(64,"Bucket count",1);
		function gMND(A,l){
			let m=-1/0,t=0;
			for(let i=0;i<l;i++){
				t=log(A[i])/log(base)+1|0;
				if(t>m)m=t;
			}
			return m;
		}
		function getDigit(i,d){
			return(i/d|0)%base;
		}
		async function sort(A,s,l,d){
			let cn=new Array(base).fill(0),os=new Array(base).fill(0),dg=0;
			for(let i=s;i<l;i++){
				let d2=A[i];dg=getDigit(d2,d);
				write(cn,dg,cn[dg]+1,0,false,true);
			}
			write(os,0,s,0,false,true);
			for(let i=1;i<base;i++)write(os,i,cn[i-1]+os[i-1],0,false,true);
			for(let b=0;b<base;b++){
				while(cn[b]>0){
					let or=os[b],fr=or,n=A[fr];
					do{
						let to=os[dg=getDigit(n,d)];
						write(os,dg,os[dg]+1,0,false,true);
						write(cn,dg,cn[dg]-1,0,false,true);
						let t=A[to];
						await write(A,to,n,.75,true);n=t;fr=to;
					}while(fr-or);
				}
			}
			if(d>1)for(let i=0;i<base;i++){
				let bg=i>0?os[i-1]:s,e=os[i];
				if(e-bg>1)await sort(A,bg,e,d/base|0);
			}
		}
		let nOD=gMND(arr,len),max=1;
		for(let i=0;i<nOD-1;i++)max*=base;
		await sort(arr,0,len,max);
	}
	async binaryQuickSortRecursive(len){
		async function partition(A,p,r,b){
			let i=p-1,j=r+1;
			while(1){
				do i++;while(i<=r&&!getBit(arr[i],b));
				do j--;while(j>=p&&getBit(arr[j],b));
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function binaryQuickSortRecursive(A,p,r,b){
			if(p<r&&b>=0){
				let q=await partition(A,p,r,b);
				await binaryQuickSortRecursive(A,p,q,b-1);
				await binaryQuickSortRecursive(A,q+1,r,b-1);
			}
		}
		await binaryQuickSortRecursive(arr,0,len-1,analyzeBit(arr,len));
	}
	async binaryQuickSortIterative(len){
		async function partition(A,p,r,b){
			let i=p-1,j=r+1;
			while(1){
				do i++;while(i<=r&&!getBit(arr[i],b));
				do j--;while(j>=p&&getBit(arr[j],b));
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function quickSort(A,p,r,b){
			let ts=[{p,r,b}];
			while(ts.length){
				let t=ts.shift();
				if(t.p<t.r&&t.b>=0){
					let q=await partition(A,t.p,t.r,t.b);
					ts.push({p:t.p,r:q,b:t.b-1},{p:q+1,r:t.r,b:t.b-1});
				}
			}
		}
		await quickSort(arr,0,len-1,analyzeBit(arr,len));
	}
	async bogoSort(len){
		for(let i=0;!isArraySorted(arr,len);){
			bogoSwap(arr,0,len);
			if(++i>cbrt(len))await mark(randInt(0,len),i=0);
		}
	}
	async bozoSort(len){
		while(!isArraySorted(arr,len))await swap(arr,randInt(0,len),randInt(0,len),0,true);
	}
	async cocktailBogoSort(len){
		let n=0,x=len,j=0;
		while(n<x-1){
			if(isMinSorted(arr,n,x)){
				mark(n++);
				continue;
			}
			if(isMaxSorted(arr,n,x)){
				mark(--x);
				continue;
			}
			for(let i=n;i<x;++i){
				swap(arr,i,randInt(i,x));
				if(++j>sqrt(len))await mark(i,j=0);
			}
		}
	}
	async deterministicBogoSort(len){
		async function permutationSort(A,d,l){
			if(d>l-2)return isArraySorted(A,l);
			for(let i=len-1;i>d;--i){
				if(await permutationSort(A,d+1,l))return true;
				if((l-d)%2<1)await swap(A,d,i,0,true);
				else await swap(A,d,l-1,0,true);
			}
			return await permutationSort(A,d+1,l);
		}
		await permutationSort(arr,0,len);
	}
	async flashSort(len){
		async function sort(A,l){
			if(l<1)return;
			let m=l/5+2|0,n,x,mI;n=x=A[mI=0];
			for(let i=1;i<l-1;i+=2){
				let s,b,bI;
				if(compareIndices(A,i,i+1)<0){
					s=A[i];b=A[bI=i+1];
				}else{
					b=A[bI=i];s=A[i+1];
				}
				if(b>x){
					x=b;mI=bI;
				}
				if(s<n)n=s;
			}
			if(compareValues(A[l-1],n)<0)n=A[l-1];
			else if(compareValues(A[l-1],x)>0)x=A[mI=l-1];
			if(x==n)return;
			let L=new Array(m+1).fill(0),c=(m-1)/(x-n),K;
			for(let h=0;h<l;h++)write(L,K=(A[h]-n)*c+1|0,L[K]+1,0,false,true);
			for(K=2;K<=m;K++)write(L,K,L[K]+L[K-1],0,false,true);
			await swap(A,mI,0,1,true);
			let j=0,nM=0;K=m;
			while(nM<l){
				while(j>=L[K])K=(A[++j]-n)*c+1|0;
				let e=A[j];
				while(j<L[K]){
					let o=L[K=(e-n)*c+1|0]-1,t=A[o];
					await write(A,o,e,0,true);e=t;
					write(L,K,L[K]-1,0,false,true);nM++;
				}
			}
			await insertSort(A,0,l,.1);
		}
		await sort(arr,len);
	}
	async classicGravitySort(len){
		let m=analyzeMax(arr,len),t=new Array(m).fill(0);
		for(let i=0;i<len;i++)for(let n=arr[i],j=0;j<n;j++)write(t,j,t[j]+1,0,false,true);
		for(let i=0;i<len;i++){
			let s=0;
			for(let j=0;j<m;j++)if(t[j]>0)s++;
			await write(arr,len-i-1,s,.01,true);
			for(let j=0;j<m;j++)write(t,j,t[j]-1,0,false,true);
		}
	}
	async gravitySort(len){
		let n=arr[0],x=arr[0];
		for(let i=1;i<len;i++)if(arr[i]<n)n=arr[i];else if(arr[i]>x)x=arr[i];
		let X=new Array(len),T=new Array(x-n+1).fill(0);DEL.set(maxVal(2/len,.001));
		for(let i=0;i<len;i++){
			write(X,i,arr[i]-n,0,false,true);
			write(T,arr[i]-n,T[arr[i]-n]+1,0,false,true);
		}
		for(let i=T.length-1;i>0;i--)write(T,i-1,T[i-1]+=T[i],0,false,true);
		for(let j=T.length-1;j>=0;j--){
			for(let i=0,k=0;i<len;i++){
				write(arr,i,arr[i]+(i>=len-T[j])-(X[i]>=j));
				await DEL.WR(i,1);
			}
		}
	}
	async indexSort(len){
		let m=minVal(...arr);
		for(let i=0;i<len;i++){
			let c=0;
			while(compareValues(i,arr[i]-m)&&c<len){
				await swap(arr,i,arr[i]-m,.5,true);c++;
			}
			if(c>=len-1)break;
		}
	}
	async inPlaceLSDRadixSort(len){
		let base=askForNum(10,"Base");
		let ps=0,r=new Array(base-1),hp=analyzeMaxLog(arr,len,base);
		for(let p=0;p<=hp;p++){
			for(let i=0;i<r.length;i++)write(r,i,len-1,true);
			for(let i=ps=0;i<len;i++){
				let dg=getDigit(arr[ps],p,base);
				if(!dg)ps++;
				else{
					multiSwap(arr,ps,r[dg-1],0);
					for(let j=0;j<r.length;j++)mark(r[j]);
					await sleep();
					for(let j=dg-1;j>0;j--)write(r,j-1,r[j-1]-1,true);
				}
			}
		}
	}
	async lessBogoSort(len){
		for(let i=0;i<len;++i)while(!isMinSorted(arr,i,len)){
			bogoSwap(arr,i,len);
			await sleep();
		}
	}
	async LSDRadixSort(len){
		let base=askForNum(4,"Base");
		let hp=analyzeMaxLog(arr,len,base),r=new Array(base);
		for(let i=0;i<base;i++)r[i]=[];
		for(let p=0;p<=hp;p++){
			for(let i=0;i<len;i++)r[getDigit(arr[i],p,base)].push(arr[i]);
			await fancyTranscribe(arr,len,r,0);
		}
	}
	async medianQuickBogoSort(len){
		async function mQB(A,s,e){
			if(s>e-2)return;
			let m=(s+e)/2|0;
			while(!isRangeSplit(A,s,m,e)){
				bogoSwap(A,s,e);
				await sleep();
			}
			await mQB(A,s,m);
			await mQB(A,m,e);
		}
		await mQB(arr,0,len);
	}
	async mergeBogoSort(len){
		async function bogoWeave(A,t,s,m,e){
			await bogoCombo(A,s,e,e-m);
			let l=s,h=m;
			for(let i=s;i<e;++i)
				if(!compareValues(A[i],0))await write(A,i,t[l++],0,true);
				else await write(A,i,t[h++],0,true);
		}
		async function merge(A,t,s,e){
			if(s>e-2)return;
			let m=(s+e)/2|0;
			await merge(A,t,s,m);
			await merge(A,t,m,e);
			arraycopy(A,s,t,s,e-s,0,true,true);
			while(!isRangeSorted(A,s,e))await bogoWeave(A,t,s,m,e);
		}
		await merge(arr,new Array(len),0,len);
	}
	async MSDRadixSort(len){
		let base=askForNum(2,"Base");
		async function radixMSD(A,l,n,x,r,p){
			if(n>=x||p<0)return;
			let regs=new Array(r);
			for(let i=0;i<r;i++)regs[i]=[];
			for(let i=n;i<x;i++)regs[getDigit(A[i],p,r)].push(A[i]);
			await transcribeMSD(A,regs,0,n,.8,true);
			let s=0;
			for(let i=0;i<regs.length;i++){
				await radixMSD(A,l,s+n,s+n+regs[i].length,r,p-1);
				s+=regs[i].length;
				regs[i]=[];
			}
		}
		let hp=analyzeMaxLog(arr,len,base);
		await radixMSD(arr,len,0,len,base,hp);
	}
	async guessSort(len){
		let o=new Array(len);
		while(1){
			let s=true;
			for(let i=0;i<len-1;++i){
				let c=compareIndices(arr,o[i],o[i+1]);
				if(c<0||!c&&o[i]<o[i+1])continue;s=false;
				break;
			}
			draw();
			if(s)break;
			for(let p=0;p<len;++p)if(o[p]<len-1){
				write(o,p,o[p]+1,0,false,true);
				break;
			}else await write(o,p,0,0,true,true);
		}
		for(let i=0;i<len;i++)write(o,i,arr[o[i]],1,true,true);
		for(let i=0;i<len;i++)await write(arr,i,o[i],1,true);
	}
	async quickBogoSort(len){
		async function quickBogoSwap(A,s,p,e){
			for(let i=s;i<e;i++){
				let j=randInt(i,e);p=p==i?j:p==j?i:p;
				swap(A,i,j,0);
			}
			await sleep();
			return p;
		}
		async function quickBogo(A,s,e){
			if(s>e-2)return;
			let p=s;
			while(!isRangePartitioned(A,s,p,e))p=await quickBogoSwap(A,s,p,e);
			await quickBogo(A,s,p);
			await quickBogo(A,p+1,e);
		}
		await quickBogo(arr,0,len);
	}
	async rotateLSDRadixSort(len){
		let base=askForNum(10,"Base");
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,.5,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0)if(r<l){
				await multiSwap(A,m-r,m,r);b-=r;m-=r;l-=r;
			}else{
				await multiSwap(A,a,m,l);a+=l;m+=l;r-=l;
			}
		}
		function binSearch(A,a,b,d,p){
			while(a<b){
				let m=(a+b)/2|0;
				if(getDigit(A[m],p,base)>=d)b=m;
				else a=m+1;
			}
			return a;
		}
		async function merge(A,a,m,b,da,db,p){
			if(b-a<2||db-da<2)return;
			let dm=(da+db)/2|0,m1=binSearch(A,a,m,dm,p),m2=binSearch(A,m,b,dm,p);
			await rotate(A,m1,m,m2);m=m1+m2-m;
			await merge(A,m,m2,b,dm,db,p);
			await merge(A,a,m1,m,da,dm,p);
		}
		async function mergeSort(A,a,b,p){
			if(b-a<2)return;
			let m=(a+b)/2|0;
			await mergeSort(A,a,m,p);
			await mergeSort(A,m,b,p);
			await merge(A,a,m,b,0,base,p);
		}
		let m=analyzeMaxLog(arr,len,base);
		for(let i=0;i<=m;i++)await mergeSort(arr,0,len,i);
	}
	async rotateMSDRadixSort(len){
		let base=askForNum(10,"Base");
		function shift(n,q){
			while(q-->0)n=n/base|0;
			return n;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,.5,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0)if(r<l){
				await multiSwap(A,m-r,m,r);
				b-=r;m-=r;l-=r;
			}else{
				await multiSwap(A,a,m,l);
				a+=l;m+=l;r-=l;
			}
		}
		function binSearch(A,a,b,d,p){
			while(a<b){
				let m=(a+b)/2|0;
				if(getDigit(A[m],p,base)>=d)b=m;
				else a=m+1;
			}
			return a;
		}
		async function merge(A,a,m,b,da,db,p){
			if(b-a<2||db-da<2)return;
			let dm=(da+db)/2|0,m1=binSearch(A,a,m,dm,p),m2=binSearch(A,m,b,dm,p);
			await rotate(A,m1,m,m2);m=m1+m2-m;
			await merge(A,m,m2,b,dm,db,p);
			await merge(A,a,m1,m,da,dm,p);
		}
		async function mergeSort(A,a,b,p){
			if(b-a<2)return;
			let m=(a+b)/2|0;
			await mergeSort(A,a,m,p);
			await mergeSort(A,m,b,p);
			await merge(A,a,m,b,0,base,p);
		}
		async function dist(A,a,b,p){
			await mergeSort(A,a,b,p);
			return binSearch(A,a,b,1,p);
		}
		let q=analyzeMaxLog(arr,len,base),m=0,i=0,b=len;
		while(i<len){
			let p=b-i<1?i:await dist(arr,i,b,q);
			if(!q){
				m+=base;
				let t=m/base|0;
				while(t%base<1){
					t=t/base|0;q++;
				}
				i=b;
				while(b<len&&shift(arr[b],q+1)==shift(m,q+1))b++;
			}else{
				b=p;q--;
			}
		}
	}
	async selectionBogoSort(len){
		for(let i=0;i<len;++i)while(!isMinSorted(arr,i,len))await swap(arr,i,randInt(i,len),0,true);
	}
	async smartBogoBogoSort(len){
		async function smartBogoBogo(A,l){
			if(l<2)return;
			await smartBogoBogo(A,l-1);
			while(compareIndices(A,l-2,l-1)>0){
				await bogoSwap(A,0,l);
				await smartBogoBogo(A,l-1);
			}
		}
		await smartBogoBogo(arr,len);
	}
	async smartGuessSort(len){//lwk
		let o=new Array(len).fill(0);
		while(1){
			let s=true,i=len-2;
			for(;i>=0;--i){
				let c=compareIndices(arr,o[i],o[i+1]);
				if(c<0||!c&&o[i]<o[i+1])continue;
				s=false;
				break;
			}
			if(s)break;
			for(let p=0;p<len;++p)if(p>=i&&o[p]<len-1){
				write(o,p,o[p]+1,0,false,true);
				break;
			}else await write(o,p,0,0,true,true);
		}
		for(let i=0;i<len;i++)write(o,i,arr[o[i]],0,false,true);
		for(let i=0;i<len;i++)await write(arr,i,o[i],0,true);
	}
	async stacklessAmericanFlagSort(len){
		let base=askForNum(10,"Base");
		function shift(n,q,r){
			for(;q>0;q--)n=n/r|0;
			return n;
		}
		async function dist(A,C,O,a,b,q,r){
			for(let i=1;i<r;i++){
				write(C,i,C[i]+C[i-1],0,false,true);
				write(O,i,C[i-1],0,false,true);
			}
			for(let i=0;i<r-1;i++){
				let p=a+O[i];
				if(C[i]>O[i]){
					let t=A[p];
					do{
						let d=getDigit(t,q,r);
						write(C,d,C[d]-1,0,false,true);
						let t1=A[a+C[d]];
						await write(A,a+C[d],t,.5,true,false);
						t=t1;
					}while(C[i]>O[i]);
				}
			}
			let p=a+O[1];
			for(let i=0;i<r;i++){
				write(C,i,0,0,false,true);
				write(O,i,0,0,false,true);
			}
			return p;
		}
		let r=base,q=analyzeMaxLog(arr,len,r),m=0,i=0,b=len;
		let C=new Array(r).fill(0),O=new Array(r).fill(0);
		for(let j=i;j<b;j++){
			let d=getDigit(arr[j],q,r);
			write(C,d,C[d]+1,0,false,true);
		}
		while(i<len){
			let p=b-i<1?i:await dist(arr,C,O,i,b,q,r);
			if(!q){
				m+=r;
				let t=m/r|0;
				while(t%r<1){
					t=t/r|0;q++;
				}
				i=b;
				while(b<len&&shift(arr[b],q+1,r)==shift(m,q+1,r)){
					let d=getDigit(arr[b++],q,r);
					write(C,d,C[d]+1,0,false,true);
				}
			}else{
				b=p;q--;
				for(let j=i;j<b;j++){
					let d=getDigit(arr[j],q,r);
					write(C,d,C[d]+1,0,false,true);
				}
			}
		}
	}
	async stacklessBinaryQuickSort(len){
		async function partition(A,a,b,t){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&!getBit(A[i],t));
				do j--;while(j>i&&getBit(A[j],t));
				if(i<j)await swap(A,i,j,1,true,false);
				else return i;
			}
		}
		let q=analyzeBit(arr,len),m=0,i=0,b=len;
		while(i<len){
			let p=b-i<1?i:await partition(arr,i,b,q);
			if(q==0){
				m+=2;
				while(!getBit(m,q+1))q++;
				i=b;
				while(b<len&&(arr[b]>>(q+1))==(m>>(q+1)))b++;
			}else{
				b=p;
				q--;
			}
		}
	}
	async staticSort(len){
		function findMinMax(A,a,b){
			let n=A[a],x=n;
			for(let i=a+1;i<b;i++){
				if(compareIndexValue(A,i,n)<0)n=A[i];
				else if(compareIndexValue(A,i,x)>0)x=A[i];
			}
			return[n,x];
		}
		async function sort(A,a,b){
			let nx=findMinMax(A,a,b);
			let auxLen=b-a;
			let cnts=new Array(auxLen+1).fill(0),offs=new Array(auxLen+1).fill(0);
			let CONST=auxLen/(nx[1]-nx[0]+1);
			let idx;
			for(let i=a;i<b;i++){
				idx=(A[i]-nx[0])*CONST|0;
				write(cnts,idx,cnts[idx]+1,0,false,true);
			}
			write(offs,0,a,0,false,true);
			for(let i=1;i<auxLen;i++)write(offs,i,cnts[i-1]+offs[i-1],0,false,true);
			for(let v=0;v<auxLen;v++){
				while(cnts[v]>0){
					let origin=offs[v];
					let from=origin;
					let num=A[from];
					await write(A,from,-1,.5,true);
					do{
						idx=(num-nx[0])*CONST|0;
						let to=offs[idx];
						write(offs,idx,offs[idx]+1,0,false,true);
						write(cnts,idx,cnts[idx]-1,0,false,true);
						let temp=A[to];
						await write(A,to,num,1,true);
						num=temp;
						from=to;
					}while(from-origin);
				}
			}
			for(let i=0;i<auxLen;i++){
				let s=i>1?offs[i-1]:a,e=offs[i];
				if(e-s<=1)continue;
				await insertSort(A,s,e);
			}
		}
		await sort(arr,0,len);
	}
	async binaryGnomeSort(len){
		for(let i=1,k=0;i<len;i++){
			let n=arr[i];
			let l=0,h=i;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(compareValues(n,arr[m])<0)h=m
				else l=m+1;
			}
			let j=i;
			while(j>l){
				swap(arr,j,--j,1);
				if(++k>=len)await mark(j+1,k=0);
			}
		}
	}
	async bubbleBogoSort(len){
		let j=0;
		while(!isArraySorted(arr,len)){
			let i=randInt(0,len-1);
			if(compareIndices(arr,i,i+1)>0){
				swap(arr,i,i+1,0,true);
				if(1/16*++j>=1)await sleep(j=0);
			}
		}
	}
	async bubbleSort(len){
		let k=0;
		for(let i=len-1;i>0;i--){
			let s=true;
			for(let j=0;j<i;j++){
				if(compareIndices(arr,j,j+1)>0){
					swap(arr,j,j+1,0);
					if(++k>=16)await markSwap(j,j+1,k=0);
					s=false;
				}
			}
			if(s)break;
		}
	}
	async circleSortIterative(len){
		let n=1;
		for(;n<len;n*=2);
		while(await iterativeCircleSortRoutine(arr,n));
	}
	async circleSortRecursive(len){
		let n=1;
		for(;n<len;n*=2);
		while(await recursiveCircleSortRoutine(arr,0,n-1,0));
	}
	async circloidSort(len){
		async function circle(A,a,b){
			let s=false;
			while(a<b){
				if(compareIndices(A,a,b)>0){
					await swap(A,a,b,1,true);
					s=true;
				}
				a++;b--;
				if(a==b)b++;
			}
			return s;
		}
		async function circlePass(A,L,R){
			if(L>=R)return;
			let m=(L+R)/2|0;
			let l=await circlePass(A,L,m);
			let r=await circlePass(A,m+1,R);
			return await circle(A,L,R)||l||r;
		}
		while(await circlePass(arr,0,len-1));
	}
	async classicThreeSmoothCombSort(len){
		function is3Smooth(n){
			while(n%6<1)n/=6;
			while(n%3<1)n/=3;
			while(n%2<1)n/=2;
			return n==1;
		}
		for(let g=len-1;g>0;g--)
			if(is3Smooth(g))
				for(let i=g;i<len;i++)
					if(compareIndices(arr,i-g,i)>0)
						await swap(arr,i-g,i,0,true);
	}
	async cocktailShakerSort(len){
		await cocktailShaker(arr,0,len,1/sqrt(len));
	}
	async combSort(len){
		let sw=false,g=len,k=0;
		while(g>1||sw){
			if(g>1)g=g/1.3|0;
			sw=false;
			for(let i=0;g+i<len;++i){
				if(compareIndices(arr,i,i+g)>0){
					swap(arr,i,i+g,0,true);
					sw=true;
					if(++k>=4)await sleep(k=0);
				}
			}
		}
	}
	async hybridCombSort(len){
		let sw=false,g=len;
		while(g>1||sw){
			if(g>1)g=g/1.3|0;
			sw=false;
			for(let i=0;g+i<len;++i){
				if(g<=minVal(8,len*(1/32))){
					g=0;
					await insertSort(arr,0,len);
					break;
				}
				if(compareIndices(arr,i,i+g)>0){
					await swap(arr,i,i+g,.75,true);
					sw=true;
				}
			}
		}
	}
	async completeGraphSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		async function split(A,a,m,b){
			if(b-a<2)return;
			let c=0,l1=(b-a)/2|0,odd=(b-a)%2;
			if(odd){
				if(m-a>b-m)c=a++;
				else c=--b;
			}
			for(let s=0;s<l1;s++){
				let i=a;
				for(let j=s;j<l1;j++)
					await cs(A,i++,m+j);
				for(let j=0;j<s;j++)
					await cs(A,i++,m+j);
			}
			if(odd){
				if(c<m)for(let j=0;j<l1;j++)await cs(A,c,m+j);
				else for(let j=0;j<l1;j++)await cs(A,a+j,c);
			}
		}
		let n=len,d=2,e=1<<(log(n-1)/log(2)+1|0);
		while(d<=e){
			let i=0,dec=0;
			while(i<n){
				let j=i;
				dec+=n;
				while(dec>=d){
					dec-=d;
					j++;
				}
				let k=j;
				dec+=n;
				while(dec>=d){
					dec-=d;
					k++;
				}
				await split(arr,i,j,k);
				i=k;
			}
			d*=2;
		}
	}
	async dualPivotQuickSort(len){
		async function dualPivot(A,l,r,d){
			let ln=r-l;
			if(ln<4)return await insertSort(arr,l,r+1);
			let th=ln/d|0,m1=l+th,m2=r-th;
			if(m1<=l)m1=l+1;
			if(m2>=r)m2=r-1;
			if(compareIndices(A,m1,m2)<0){
				await swap(A,m1,l,0,true);
				await swap(A,m2,r,0,true);
			}else{
				await swap(A,m1,r,0,true);
				await swap(A,m2,l,0,true);
			}
			let p1=A[l],p2=A[r],ls=l+1,gr=r-1;
			for(let k=ls;k<=gr;k++){
				if(compareValues(A[k],p1)<0)await swap(A,k,ls++,0,true);
				else if(compareValues(A[k],p2)>0){
					while(k<gr&&compareValues(A[gr],p2)>0)gr--;
					await swap(A,k,gr--,0,true);
					if(compareValues(A[k],p1)<0)await swap(A,k,ls++,0,true);
				}
			}
			let ds=gr-ls;
			if(ds<13)d++;
			await swap(A,ls-1,l,0,true);
			await swap(A,gr+1,r,0,true);
			await dualPivot(A,l,ls-2,d);
			if(p1<p2)await dualPivot(A,ls,gr,d);
			await dualPivot(A,gr+2,r,d);
		}
		await dualPivot(arr,0,len-1,3);
	}
	async exchangeBogoSort(len){
		while(!isArraySorted(arr,len)){
			let i=randInt(0,len),j=randInt(0,len),c=compareIndices(arr,i,j);
			if(i<j?c>0:c<0)await swap(arr,i,j,0,true);
		}
	}
	async forcedStableQuickSort(len){
		function stableComp(A,K,a,b){
			let c=compareIndices(A,a,b);
			return c>0||(!c&&compareIndices(K,a,b)>0);
		}
		async function stableSwap(A,K,a,b){
			await swap(A,a,b,0,true);
			swap(K,a,b,0,false,true);
		}
		async function medianOfThree(A,K,a,b){
			let m=a+(b-1-a)/2|0;
			if(stableComp(A,K,a,m))await stableSwap(A,K,a,m);
			if(stableComp(A,K,m,b-1)){
				await stableSwap(A,K,m,b-1);
				if(stableComp(A,K,a,m))return;
			}
			await stableSwap(A,K,a,m);
		}
		async function partition(A,K,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&!stableComp(A,K,i,p));
				do j--;while(j>=i&&stableComp(A,K,j,p));
				if(i<j)await stableSwap(A,K,i,j);
				else return j;
			}
		}
		async function quickSort(A,K,a,b){
			if(b-a<3){
				if(b-a==2&&stableComp(A,K,a,a+1))await stableSwap(A,K,a,a+1);
				return;
			}
			await medianOfThree(A,K,a,b);
			let p=await partition(A,K,a+1,b,a);
			await stableSwap(A,K,a,p);
			await quickSort(A,K,a,p);
			await quickSort(A,K,p+1,b);
		}
		let K=new Array(len);
		for(let i=0;i<len;i++)write(K,i,i,0,false,true);
		await quickSort(arr,K,0,len);
	}
	async funSort(len){
		function binarySearch(A,s,e,v){
			while(s<e){
				let m=(s+e)>>>1;
				if(compareValues(A[m],v)<0)s=m+1;
				else e=m;
			}
			return s;
		}
		for(let i=1;i<len;i++){
			let d=false;
			do{
				d=true;
				let p=binarySearch(arr,0,len-1,arr[i]);
				if(compareIndices(arr,p,i,0,false)){
					if(i<p-1)await swap(arr,i,p-1,2,true);
					else if(i>p)await swap(arr,i,p,2,true);
					d=false;
				}
			}while(!d);
		}
	}
	async gnomeSort(len){
		for(let i=1;i<len;){
			if(compareIndices(arr,i,i-1)>=0)i++;
			else{
				await swap(arr,i,i-1,.02,true);
				if(i>1)i--;
			}
		}
	}
	async LLQuickSort(len){
		async function partition(A,l,h){
			let p=A[h],i=l;
			for(let j=l;j<h;j++)
				if(compareValues(A[j],p)<0)
					await swap(A,i++,j,1,true);
			await swap(A,i,h,1,true);
			return i;
		}
		async function quickSort(A,l,h){
			if(l<h){
				let p=await partition(A,l,h);
				await quickSort(A,l,p-1);
				await quickSort(A,p+1,h);
			}
		}
		await quickSort(arr,0,len-1);
	}
	async LRQuickSort(len){
		async function quickSort(a,p,r){
			let pv=p+(r-p+1)/2|0,x=a[pv],i=p,j=r;
			while(i<=j){
				while(compareValues(a[i],x)<0)i++;
				while(compareValues(a[j],x)>0)j--;
				if(i<=j)await swap(a,i++,j--,1,true);
			}
			if(p<j)await quickSort(a,p,j);
			if(i<r)await quickSort(a,i,r);
		}
		await quickSort(arr,0,len-1);
	}
	async oddEvenSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let i=1;i<len-1;i+=2){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,.075,true);
					s=false;
				}
			}
			for(let i=0;i<len-1;i+=2){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,.075,true);
					s=false;
				}
			}
		}
	}
	async optimizedBubbleSort(len){
		let s;
		for(let i=len-1;i>0;i-=s){
			s=1;
			for(let j=0;j<i;j++){
				if(compareIndices(arr,j,j+1)>0){
					await swap(arr,j,j+1,.075,true);
					s=1;
				}else s++;
			}
		}
	}
	async optimizedCocktailShakerSort(len){
		for(let st=0,e=len-1;st<e;){
			let s=1;
			for(let i=st;i<e;i++){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,.075,true);
					s=1;
				}else s++;
			}
			e-=s;s=1;
			for(let i=e;i>st;i--){
				if(compareIndices(arr,i-1,i)>0){
					await swap(arr,i-1,i,.075,true);
					s=1;
				}else s++;
			}
			st+=s;
		}
	}
	async optimizedGnomeSort(len){
		async function smartGnomeSort(A,l,h){
			let p=h;
			while(p>l&&compareValues(A[p-1],A[p])>0)await swap(A,p--,p,0,true);
		}
		for(let i=1;i<len;i++)await smartGnomeSort(arr,0,i);
	}
	async optimizedStoogeSort(len){
		async function forward(A,l,r){
			while(l<r){
				let i=r;
				while(l<i){
					if(compareIndices(A,l,i)>0)await swap(A,l,i,.075,true);
					l++;i--;
				}
				l=0;r--;
			}
		}
		async function backward(A,l,r){
			let ln=r;
			while(l<r){
				let i=l;
				while(i<r){
					if(compareIndices(A,i,r)>0)await swap(A,i,r,.075,true);
					i++;r--;
				}
				l++;r=ln;
			}
		}
		async function exchange(A,ln){
			let l=0,r=ln-1;
			while(l<r){
				if(compareIndices(A,l,r)>0)await swap(A,l,r,.075,true);
				l++;r--;
			}
			await forward(A,0,ln-2);
			await backward(A,1,ln-1);
		}
		await exchange(arr,len);
	}
	async optimizedStoogeSortStudio(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,0,true);
				return true;
			}
			return false;
		}
		async function stoogeSort(A,a,m,b,mr){
			if(a>=m)return false;
			if(b-a==2)return await compSwap(A,a,m);
			let lC=false,rC=false,a2=(a+a+b)/3|0,b2=(a+b+b+2)/3|0;
			if(m<b2){
				lC=await stoogeSort(A,a,m,b2,mr);
				if(mr){
					rC=await stoogeSort(A,maxVal(a+b2-m,a2),b2,b,true);
					if(rC)await stoogeSort(A,a+b2-m,a2,2*a2-a,true);
				}else{
					rC=await stoogeSort(A,a2,b2,b,false);
					if(rC)await stoogeSort(A,a,a2,2*a2-a,true);
				}
			}else{
				rC=await stoogeSort(A,a2,m,b,mr);
				if(rC)await stoogeSort(A,a,a2,a2+b-m,true);
			}
			return lC||rC;
		}
		await stoogeSort(arr,0,1,len,false);
	}
	async quadStoogeSort(len){
		async function quadStooge(A,p,ln){
			if(ln>=2&&compareIndices(A,p,p+ln-1)>0)await swap(A,p,p+ln-1,0,true);
			if(ln<=2)return;
			let ln1=ln/2|0,ln2=(ln+1)/2|0,ln3=(ln1+1)/2+(ln2+1)/2|0;
			await quadStooge(A,p,ln1);
			await quadStooge(A,p+ln1,ln2);
			await quadStooge(A,p+ln1/2|0,ln3);
			await quadStooge(A,p+ln1,ln2);
			await quadStooge(A,p,ln1);
			if(ln>3)await quadStooge(A,p+ln1/2|0,ln3);
		}
		await quadStooge(arr,0,len);
	}
	async shoveSort(len){
		for(let i=0,k=0;i<len-1;){
			if(compareIndices(arr,i,i+1)>0){
				for(let f=i;f<len-1;f++){
					swap(arr,f,f+1,0,false);
					if(++k>=sqrt(len)*8)await markSwap(f,f+1,k=0);
				}
				if(i>0)i--;
				continue;
			}
			i++;
		}
	}
	async sillySort(len){
		async function sillySort(A,i,j){
			let m;
			if(i<j){
				m=i+(j-i)/2|0;
				await sillySort(A,i,m);
				await sillySort(A,m+1,j);
				if(compareIndices(A,m+1,i)<1)await swap(A,i,m+1,1,true);
				await sillySort(A,i+1,j);
			}
		}
		await sillySort(arr,0,len-1);
	}
	async slopeSort(len){
		for(let i=1,j=1;i<len;i++,j++){
			for(let k=i-1;k>=0;k--,i--)
				if(compareIndices(arr,i,k)<0)
					await swap(arr,i,k,0,true);
			i=j;
		}
	}
	async slowSort(len){
		async function sort(A,i,j){
			if(i>=j)return;
			let m=i+(j-i)/2|0;
			await sort(A,i,m);
			await sort(A,m+1,j);
			if(compareIndices(A,m,j)>0)await swap(A,m,j,1,true);
			await sort(A,i,j-1);
		}
		await sort(arr,0,len-1);
	}
	async stablePermutationSort(len){
		async function permute(A,X,l){
			if(l<2)return isArraySorted(A,len);
			for(let i=l-2;i>=0;i--){
				if(await permute(A,X,l-1))return true;
				await swap(A,X[i],X[l-1],0,true);
				swap(X,i,l-1,0,false,true);
			}
			if(await permute(A,X,l-1))return true;
			let t=X[l-1];
			for(let i=l-1;i>0;i--)
				write(X,i,X[i-1],0,false,true);
			write(X,0,t,0,false,true);
			t=A[X[0]];
			for(let i=1;i<l;i++)
				await write(A,X[i-1],A[X[i]],0,true);
			await write(A,X[l-1],t,0,true);
			return false;
		}
		let X=new Array(len);
		for(let i=0;i<len;i++)
			write(X,i,i,0,false,true);
		await permute(arr,X,len);
	}
	async stableQuickSort(len){
		async function copy(list,A,i){
			for(let j of list)
				await write(A,i++,j,0,true);
		}
		async function stablePartition(A,s,e){
			let pV=A[s];
			let leftList=[];
			let rightList=[];
			for(let i=s+1;i<=e;i++){
				if(compareValues(A[i],pV)<0){
					leftList.push(A[i]);
				}else{
					rightList.push(A[i]);
				}
			}
			await copy(leftList,A,s)
			let nPI=s+leftList.length;
			await write(A,nPI,pV,.25,true);
			await copy(rightList,A,nPI+1);
			return nPI;
		}
		async function stableQuickSort(A,s,e){
			if(s<e){
				let pI=await stablePartition(A,s,e);
				await stableQuickSort(A,s,pI-1);
				await stableQuickSort(A,pI+1,e);
			}
		}
		await stableQuickSort(arr,0,len-1);
	}
	async stoogeSort(len){
		async function sort(A,i,j){
			if(compareIndices(A,i,j)>0)
				await swap(A,i,j,.005,true,false);
			if(j-i+1>=3){
				let t=(j-i+1)/3|0;
				await sort(A,i,j-t);
				await sort(A,i+t,j);
				await sort(A,i,j-t);
			}
		}
		await sort(arr,0,len-1);
	}
	async swaplessBubbleSort(len){
		let l;
		for(let i=len;i>0;i=l){
			l=0;
			let p=0,c=arr[0];
			for(let j=1;j<i;j++){
				if(compareValues(c,arr[j])>0){
					await write(arr,j-1,arr[j],0,true);
					l=j;
				}else{
					if(p+1<j)
						await write(arr,j-1,c,0,true);
					p=j;
					c=arr[j];
				}
			}
			await write(arr,i-1,c,.075,true);
		}
	}
	async tableSort(len){
		function sC(A,T,a,b){
			let c=compareIndices(A,T[a],T[b]);
			return c>0||(!c&&compareIndices(T,a,b)>0);
		}
		async function medianOfThree(A,T,a,b){
			let m=a+(b-1-a)/2;
			if(sC(A,T,a,m))
				await swap(T,a,m,1,true,true);
			if(sC(A,T,m,b-1)){
				await swap(T,m,b-1,1,true,true);
				if(sC(A,T,a,m))return;
			}
			await swap(T,a,m,1,true,true);
		}
		async function partition(A,T,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&!sC(A,T,i,p));
				do j--;while(j>=i&&sC(A,T,j,p));
				if(i<j)await swap(T,i,j,1,true,true);
				else return j;
			}
		}
		async function quickSort(A,T,a,b){
			if(b-a<3){
				if(b-a==2&&sC(A,T,a,a+1))
					await swap(T,a,a+1,1,true,true);
				return;
			}
			await medianOfThree(A,T,a,b)
			let p=await partition(A,T,a+1,b,a);
			await swap(T,a,p,1,true,true);
			await quickSort(A,T,a,p);
			await quickSort(A,T,p+1,b);
		}
		let T=new Array(len);
		for(let i=0;i<len;i++)write(T,i,i,0,false,true);
		await quickSort(arr,T,0,len);
		for(let i=0;i<T.length;i++){
			if(compareValues(i,T[i])){
				let t=arr[i],j=i,n=T[i];
				do{
					await write(arr,j,arr[n],1,true);
					write(T,j,j,0,true,true);
					j=n;
					n=T[n];
				}while(compareValues(n,i));
				await write(arr,j,t,1,true);
				write(T,j,j,0,true,true);
			}
		}
	}
	async threeSmoothCombSortIterative(len){
		async function cS(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		let p2=log(len-1)/log(2)|0;
		for(let k=p2;k>=0;k--){
			let p3=(log(len)-k*log(2))/log(3)|0;
			for(let j=p3;j>=0;j--){
				let g=pow(2,k)*pow(3,j)|0;
				for(let i=0;i+g<len;i++)
					await cS(arr,i,i+g);
			}
		}
	}
	async threeSmoothCombSortRecursive(len){
		async function recursiveComb(A,p,g,e){
			if(p+g>e)return;
			await recursiveComb(A,p,g*2,e);
			await recursiveComb(A,p+g,g*2,e);
			await powerOfThree(A,p,g,e);
		}
		async function powerOfThree(A,p,g,e){
			if(p+g>e)return;
			await powerOfThree(A,p,g*3,e);
			await powerOfThree(A,p+g,g*3,e);
			await powerOfThree(A,p+2*g,g*3,e);
			for(let i=p;i+g<e;i+=g)
				if(compareIndices(A,i,i+g)>0)
					await swap(A,i,i+g,0,true,false);
		}
		await recursiveComb(arr,0,1,len);
	}
	async unoptimizedBubbleSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let i=0;i<len-1;i++){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,0,true);
					s=false;
				}
			}
		}
	}
	async unoptimizedCocktailShakerSort(len){
		async function cocktailShaker(A,s,e){
			let i=s;
			while(i<e/2+s|0){
				for(let j=i;j<e+s-i-1;j++)
					if(compareIndices(A,j,j+1)>0)
						await swap(A,j,j+1,0,true);
				for(let j=e+s-i-1;j>i;j--)
					if(compareIndices(A,j,j-1)<0)
						await swap(A,j,j-1,0,true);
				i++
			}
		}
		await cocktailShaker(arr,0,len);
	}
	async binaryDoubleInsertionSort(len){
		await binaryDoubleInsertion(arr,0,len);
	}
	async binaryInsertionSort(len){
		for(let i=0,k=0;i<len;i++){
			let n=arr[i],lo=0,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,arr[m])<0)hi=m;
				else lo=m+1;
			}
			let j=i-1;
			while(j>=lo){
				write(arr,j+1,arr[j--],0);
				if(++k>=len)await mark(j+2,k=0);
			}
			await write(arr,lo,n,0,true);
		}
	}
	async doubleInsertionSort(len){
		async function insertionSort(A,s,e){
			let l=s+(e-s)/2-1|0,r=l+1;
			if(compareIndices(A,l,r)>0)
				await swap(A,l,r,0,true);
			l--;r++;
			let lI,rI;
			while(l>=s&&r<e){
				if(compareIndices(A,l,r)>0){
					lI=A[r];
					rI=A[l];
					let p=l+1;
					while(p<=r&&compareValues(A[p],lI)<1)
						await write(A,p-1,A[p++],0,true);
					await write(A,p-1,lI,0,true);
					p=r-1;
					while(p>=l&&compareValues(rI,A[p])<1)
						await write(A,p+1,A[p--],0,true);
					await write(A,p+1,rI,0,true);
				}else{
					lI=A[l];
					rI=A[r];
					let p=l+1;
					while(compareValues(A[p],lI)<0)
						await write(A,p-1,A[p++],0,true);
					await write(A,p-1,lI,0,true);
					p=r-1;
					while(compareValues(A[p],rI)>0)
						await write(A,p+1,A[p--],0,true);
					await write(A,p+1,rI,0,true);
				}
				l--;r++;
			}
			if(r<e){
				let p=r-1,c=A[r];
				while(compareValues(A[p],c)>0)
					await write(A,p+1,A[p--],0,true);
				await write(A,p+1,c,0,true);
			}
		}
		await insertionSort(arr,0,len);
	}
	async insertionSort(len){
		await insertSort(arr,0,len,1/sqrt(len));
	}
	async librarySort(len){
		let G=15;
		let R=4;
		let max;
		function shiftExt(A,a,m,b){
			let m1=a+minVal(m-a,b-m);
			while(m>a)write(A,--b,A[--m]);
			while(a<m1)write(A,a++,max);
		}
		function leftBlockSearch(A,a,b,v){
			let s=G+1;
			while(a<b){
				let m=a+(b-a)/s/2*s|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+s;
			}
			return a;
		}
		function rightBlockSearch(A,a,b,v){
			let s=G+1;
			while(a<b){
				let m=a+(b-a)/s/2*s|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+s;
			}
			return a;
		}
		function locSearch(A,a,b){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(max,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0) b=m;
				else a=m+1;
			}
			return a;
		}
		async function insertTo(A,a,b,aux){
			let t=A[a];
			while(a>b){
				if(!aux)await sleep();
				write(A,a,A[--a],0,!aux,aux);
			}
			if(!aux)await sleep();
			write(A,b,t,0,!aux,aux);
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]),false);
		}
		async function retrieve(A,T,i,p){
			let loc=i-1;
			for(let k=p-(G+1);k>G;){
				let m=locSearch(T,k-G,k)-1;k-=G+1;
				while(m>=k){
					await write(A,loc--,T[m],0,true);
					write(T,m--,max,0,false,true);
				}
			}
			let m=locSearch(T,0,G)-1;
			while(m>=0){
				await write(A,loc--,T[m],0,true);
				write(T,m--,max,0,false,true);
			}
		}
		async function sort(A,ln){
			max=ln;
			let T=new Array(ln*(G+1)-1|0).fill(max);
			let rng=new Random(),s=ln;
			while(s>=32)s=(s-1)/R+1|0;
			let i=s,j=R*i,p=(s+1)*(G+1)+G;
			await bininsert(A,0,s);
			for(let k=0;k<s;k++)write(T,k*(G+1)+G,A[k],0,false,true);
			for(;i<ln;i++){
				if(i==j){
					retrieve(A,T,s=i,p);
					p=(s+1)*(G+1)+G;
					j*=R;
					for(let k=0;k<s;k++)write(T,k*(G+1)+G,A[k],0,false,true);
				}
				let bLoc=leftBlockSearch(T,G,p-(G+1),A[i]);
				if(compareValues(A[i],T[bLoc])){
					let eqEnd=rightBlockSearch(T,bLoc+(G+1),p-(G+1),A[i]);
					bLoc+=rng.nextInt((eqEnd-bLoc)/(G+1)|0)*(G+1);
				}
				let loc=locSearch(T,bLoc-G,bLoc);
				if(loc==bLoc){
					do bLoc+=G+1;while(bLoc<p&&locSearch(T,bLoc-G,bLoc)==bLoc);
					if(bLoc==p){
						retrieve(A,T,s=i,p);
						p=(s+1)*(G+1)+G;
						j=R*i;
						for(let k=0;k<s;k++)write(T,k*(G+1)+G,A[k],1,false,true);
					}else{
						let rotP=locSearch(T,bLoc-G,bLoc),rotS=bLoc-maxVal(rotP,bLoc-G/2|0);
						shiftExt(T,loc-rotS,bLoc-rotS,bLoc);
					}
					i--;
				}else{
					write(T,loc,A[i],0,false,true);
					await insertTo(T,loc,rightBinSearch(T,bLoc-G,loc,T[loc]),true);
				}
			}
			await retrieve(A,T,ln,p);
		}
		await sort(arr,len);
	}
	async librarySort(len){
		let R=4;
		function gML(n){
			while(n>=32)n=(n-1)/R+1|0;
			return n;
		}
		function bins(ar,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,ar[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function reb(ar,t,c,l,m,b){
			for(let i=0;i<m;i++)write(c,i+1,c[i+1]+c[i]+1,0,true);
			for(let i=m,j=0;i<b;i++,j++){
				write(t,c[l[j]],ar[i],0,true);
				write(c,l[j],c[l[j]]+1,0,true);
			}
			for(let i=0;i<m;i++){
				write(t,c[i],ar[i],0,true);
				write(c,i,c[i]+1,0,true);
			}
			await arraycopy(t,0,ar,0,b,1);
			await insertSort(ar,0,c[0]-1);
			for(let i=0;i<m-1;i++)await insertSort(ar,c[i],c[i+1]-1);
			await insertSort(ar,c[m-1],c[m]);
			for(let i=0;i<m+2;i++)write(c,i,0,0,true);
		}
		if(len<32)await insertSort(arr,0,len);
		else{
			let j=gML(len),mx=j;
			await insertSort(arr,0,j);
			for(;mx*R<len;mx*=R);
			let t=new Array(len).fill(0),c=new Array(mx+2).fill(0),l=new Array(len-mx).fill(0);
			for(let i=j,k=0;i<len;i++){
				if(R*j==i){
					await reb(arr,t,c,l,j,i);
					j=i;k=0;
				}
				let o=bins(arr,0,j,arr[i]);
				write(c,o+1,c[o+1]+1,true);
				write(l,k++,o,true);
			}
			await reb(arr,t,c,l,j,len);
		}
	}
	async recursiveShellSort(len){
		async function gIns(A,a,b,g){
			for(let i=a+g;i<b;i+=g){
				let k=A[i],j=i-g;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],.5,true);
					j-=g;
				}
				await write(A,j+g,k,.5,true);
			}
		}
		async function recursiveShellSort(A,s,e,g){
			if(s+g<=e){
				await recursiveShellSort(A,s,e,3*g);
				await recursiveShellSort(A,s+g,e,3*g);
				await recursiveShellSort(A,s+(2*g),e,3*g);
				await gIns(A,s,e,g);
			}
		}
		await recursiveShellSort(arr,0,len,1);
	}
	async shellSort(len){
		async function sort(A,l){
			let incs=[8861,3938,1750,701,301,132,57,23,10,4,1];
			for(let k=0;k<incs.length;k++){
				if(incs[k]<l){
					for(let h=incs[k],i=h;i<l;i++){
						let v=A[i],j=i;
						while(j>=h&&compareValues(A[j-h],v)>0){
							await write(A,j,A[j-=h],1);
						}
						await write(A,j,v,1,true,0);
					}
				}
			}
		}
		await sort(arr,len);
	}
	async andreySort(len){
		async function sort(A,a,b){
			while(b>1){
				let k=0;
				for(let i=1;i<b;i++)
					if(compareIndices(A,a+k,a+i)>0)k=i;
				await swap(A,a,a+k,1,true);
				a++;b--;
			}
		}
		async function aswap(A,a,b,l){
			while(l-->0)
				await swap(A,a++,b++,1,true);
		}
		async function backmerge(A,a1,l1,a2,l2){
			let a0=a2+l1;
			while(1){
				if(compareIndices(A,a1,a2)>0){
					await swap(A,a1--,a0--,1,true);
					if(--l1==0)return 0;
				}else{
					await swap(A,a2--,a0--,1,true);
					if(--l2==0)break;
				}
			}
			let r=l1;
			do await swap(A,a1--,a0--,1,true);while(--l1);
			return r;
		}
		async function rmerge(A,a,l,r){
			for(let i=0;i<l;i+=r){
				let q=i;
				for(let j=i+r;j<l;j+=r)
					if(compareIndices(A,a+q,a+j)>0)
						q=j;
				if(q-i)
					await aswap(A,a+i,a+q,r)
				if(i){
					await aswap(A,a+l,a+i,r)
					await backmerge(A,a+l+r-1,r,a+i-1,r)
				}
			}
		}
		function rbnd(l){
			l=l/2|0;
			let k=0;
			for(let i=1;i<l;i*=2)k++;
			l=l/k|0;
			for(k=1;k<=l;k*=2);
			return k;
		}
		async function msort(A,a,l){
			if(l<12)return await sort(A,a,l);
			let r=rbnd(l),lr=(l/r-1|0)*r;
			for(let p=2;p<=lr;p+=2){
				if(compareIndices(A,a+p-2,a+p-1)>0)
					await swap(A,a+p-2,a+p-1,1,true);
				if(p&2)continue;
				await aswap(A,a+p-2,a+p,2);
				let m=l-p,q=2;
				while(1){
					let q0=2*q;
					if(q0>m||(p&q0))break;
					await backmerge(A,a+p-q-1,q,a+p+q-1,q);
					q=q0;
				}
				await backmerge(A,a+p+q-1,q,a+p-q-1,q);
				let q1=q;
				q*=2;
				while(!(q&p)){
					q*=2;
					await rmerge(A,a+p-q,q,q1);
				}
			}
			let q1=0;
			for(let q=r;q<lr;q*=2){
				if((lr&q)){
					q1+=q;
					if(q1-q)await rmerge(A,a+lr-q1,q1,r);
				}
			}
			let s=l-lr;
			await msort(A,a+lr,s);
			await aswap(A,a,a+lr,s);
			s+=await backmerge(A,a+s-1,s,a+lr-1,lr-s);
			await msort(A,a,s);
		}
		await msort(arr,0,len);
	}
	async blockSwapMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function binarySearchMid(A,s,md,e){
			let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
			while(b>a){
				if(compareIndices(A,md-m-1,md+m)>0)a=m+1;
				else b=m;
				m=a+(b-a)/2|0;
			}
			return m;
		}
		async function multiSwapMerge(A,s,md,e){
			let m=binarySearchMid(A,s,md,e);
			while(m>0){
				await multiSwap(A,md-m,md,m);
				await multiSwapMerge(A,md,md+m,e);
				e=md;
				md-=m;
				m=binarySearchMid(A,s,md,e);
			}
		}
		async function multiSwapMergeSort(A,a,b){
			let len=b-a,i;
			for(let j=1;j<len;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await multiSwapMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await multiSwapMerge(A,i,i+j,b);
			}
		}
		await multiSwapMergeSort(arr,0,len);
	}
	async bottomUpMergeSort(len){
		async function merge(A,ln,i,mS){
			let l=i;
			let m=l+mS/2|0;
			let r=m;
			let e=minVal(ln,i+mS);
			let sI=l;
			if(r<e){
				while(l<m&&r<e)
					if(compareValues(A[l],A[r])<1)write(X,sI++,A[l++],0,false,true);
					else write(X,sI++,A[r++],0,false,true);
				if(l<m)
					while(l<m)
						write(X,sI++,A[l++],0,false,true);
				if(r<e)
					while(r<e)
						write(X,sI++,A[r++],0,false,true);
			}else cL=l;
		}
		let X=new Array(len);
		let cL;
		let mS=2;
		while(mS<=len){
			cL=len;
			for(let i=0;i<len;i+=mS)
				await merge(arr,len,i,mS);
			for(let i=0;i<cL;i++)await write(arr,i,X[i],1,true);
			mS*=2;
		}
		if((mS/2|0)-len){
			await merge(arr,len,0,mS);
			for(let i=0;i<len;i++)await write(arr,i,X[i],1,true);
		}
	}
	async bufferedStoogeSort(len){
		function compare(A,x,y){
			return compareIndices(A,x,y)
		}
		async function wrapper(A,s,e){
			if(e-s>1){
				if(e-s==2&&compare(A,s,e-1)>0)
					await swap(A,s,e-1,1,true);
				if(e-s>2){
					let th=ceil((e-s)/3)+s;
					let tth=ceil((e-s)/3*2)+s;
					if(tth-th<th)tth--;
					if((e-s-2)%3==0)tth--;
					await wrapper(A,th,tth);
					await wrapper(A,tth,e);
					let l=th;
					let r=tth;
					let bS=s;
					while(l<tth&&r<e){
						if(compare(A,l,r)>0)await swap(A,bS,r++,1,true);
						else await swap(A,bS,l++,1,true);
						bS++;
					}
					while(r<e)await swap(A,bS++,r++,1,true);
					await wrapper(A,tth,e);
					l=tth-1;
					r=e-1;
					while(r>l&&l>=s){
						if(compare(A,l,r)>0){
							for(let i=l;i<r;i++)
								await swap(A,i,i+1,0,true);
							l--;
						}
						r--;
					}
				}
			}
		}
		await wrapper(arr,0,len);
	}
	async improvedInPlaceMergeSort(len){
		async function push(A,p,a,b){
			if(a==b)return;
			let t=A[p];
			await write(A,p,A[a],0,true);
			for(let i=a+1;i<b;i++)
				await write(A,i-1,A[i],0,true);
			await write(A,b-1,t,0,true);
		}
		async function merge(A,a,m,b){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)>0)j++;
				else await push(A,i++,m,j);
			}
			while(i<m)await push(A,i++,m,b);
		}
		async function mergeSort(A,a,b){
			let m=a+(b-a)/2|0;
			if(b-a>2){
				if(b-a>3)
					await mergeSort(A,a,m);
				await mergeSort(A,m,b);
			}
			await merge(A,a,m,b);
		}
		await mergeSort(arr,0,len);
	}
	async inPlaceMergeSort(len){
		async function push(A,low,high){
			for(let i=low;i<high;i++)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,.035,true);
		}
		async function merge(A,n,x,m){
			let i=n;
			while(i<=m){
				if(compareIndices(A,i,m+1)>0){
					await swap(A,i,m+1,.035,true);
					await push(A,m+1,x);
				}
				i++;
			}
		}
		async function mergeSort(A,n,x){
			if(x-n==0){
			}else if(x-n==1){
				if(compareIndices(A,n,x)>0)
					await swap(A,n,x,0,true);
			}else{
				let m=(n+x)/2|0;
				await mergeSort(A,n,m);
				await mergeSort(A,m+1,x)
				await merge(A,n,x,m);
			}
		}
		await mergeSort(arr,0,len-1);
	}
	async iterativeTopDownMergeSort(len){
		function cPOT(x){
			--x;
			for(let i=16;i>0;i>>=1)x|=x>>i;
			return++x;
		}
		async function merge(A,T,s,m,e){
			let lo=s;
			let hi=m;
			let n=s;
			for(;lo<m&&hi<e;++n){
				if(compareIndices(A,lo,hi)>0)write(T,n,A[hi++],0,false,true);
				else write(T,n,A[lo++],0,false,true);
			}
			if(lo>=m)
				while(hi<e)
					write(T,n++,A[hi++],0,false,true);
			else
				while(lo<m)
					write(T,n++,A[lo++],0,false,true);
			for(let i=s;i<e;i++)
				await write(A,i,T[i],1,true,false);
		}
		async function mergeSort(A,T,l){
			if(l<1<<15)
				for(let j=cPOT(l);j>1;j>>=1)
					for(let i=0;i<j;i+=2)
						await merge(A,T,l*i/j|0,l*(i+1)/j|0,l*(i+2)/j|0);
		}
		let T=new Array(len);
		await mergeSort(arr,T,len);
	}
	async newShuffleMergeSort(len){
		function cPOT(x){
			--x;
			for(let i=16;i>0;i>>=1)x|=x>>i;
			return++x;
		}
		async function rotateEqual(A,a,b,z){
			for(let i=0;i<z;++i)
				await swap(A,a+i,b+i,0,true);
		}
		async function rotate(A,m,a,b){
			while(a>0&&b>0){
				if(a>b){
					await rotateEqual(A,m-b,m,b);
					m-=b;
					a-=b;
				}else{
					await rotateEqual(A,m-a,m,a);
					m+=a;
					b-=a;
				}
			}
		}
		async function shuffleEasy(A,s,z){
			for(let i=1;i<z;i*=3){
				let v=A[s+i-1];
				for(let j=i*2%z;j-i;j=j*2%z){
					let nv=A[s+j-1];
					await write(A,s+j-1,v,1,true);
					v=nv;
				}
				await write(A,s+i-1,v,1,true);
			}
		}
		async function shuffle(A,s,e){
			while(e-s>1){
				let n=(e-s)/2|0;
				let l=1;
				while(l*3-1<=2*n)l*=3;
				let m=(l-1)/2|0;
				await rotate(A,s+n,n-m,m,1);
				await shuffleEasy(A,s,l);
				s+=l-1;
			}
		}
		async function rotateShuffledEqual(A,a,b,z){
			for(let i=0;i<z;i+=2)
				await swap(A,a+i,b+i,.25,true);
		}
		async function rotateShuffled(A,m,a,b){
			while(a>0&&b>0){
				if(a>b){
					await rotateShuffledEqual(A,m-b,m,b);
					m-=b;
					a-=b;
				}else{
					await rotateShuffledEqual(A,m-a,m,a);
					m+=a;
					b-=a;
				}
			}
		}
		async function rotateShuffledOuter(A,m,a,b){
			if(a>b){
				await rotateShuffledEqual(A,m-b,m+1,b);
				m-=b;
				a-=b;
				await rotateShuffled(A,m,a,b);
			}else{
				await rotateShuffledEqual(A,m-a,m+1,a);
				m+=a+1;
				b-=a;
				await rotateShuffled(A,m,a,b);
			}
		}
		async function unshuffleEasy(A,s,z){
			for(let i=1;i<z;i*=3){
				let pr=i;
				let v=A[s+i-1];
				for(let j=i*2%z;j-i;j=j*2%z){
					await write(A,s+pr-1,A[s+j-1],.25,true);
					pr=j;
				}
				await write(A,s+pr-1,v,.25,true);
			}
		}
		async function unshuffle(A,s,e){
			while(e-s>1){
				let n=(e-s)/2|0;
				let l=1;
				while(l*3-1<=2*n)l*=3;
				let m=(l-1)/2|0;
				await rotateShuffledOuter(A,s+2*m,2*m,2*n-2*m);
				await unshuffleEasy(A,s,l);
				s+=l-1;
			}
		}
		async function mergeUp(A,s,e,tp){
			let i=s;
			let j=i+1;
			while(j<e){
				let c=compareIndices(A,i,j,0,true);
				if(c<0||!tp&&!c){
					if(++i==j){
						++j;
						tp=!tp;
					}
				}else if(e-j==1){
					await rotate(A,j,j-i,1,.25);
					break;
				}else{
					let r=0;
					if(tp)while(j+2*r<e&&compareIndices(A,j+2*r,i)<1)++r;
					else while(j+2*r<e&&compareIndices(A,j+2*r,i)<0)++r;
					await unshuffle(A,--j,j+2*r);
					await rotate(A,j,j-i,r,.25);
					i+=r+1;
					j+=2*r+1;
				}
			}
		}
		async function merge(A,tmp,s,m,e){
			if(m-s<=e-m){
				await shuffle(A,s,e);
				await mergeUp(A,s,e,true);
			}else{
				await shuffle(A,s+1,e);
				await mergeUp(A,s,e,false);
			}
		}
		async function mergeSort(A,T,l){
			if(l<1<<15)
				for(let j=cPOT(l);j>1;j>>=1)
					for(let i=0;i<j;i+=2)
						await merge(A,T,l*i/j|0,l*(i+1)/j|0,l*(i+2)/j|0);
		}
		await mergeSort(arr,null,len);
	}
	async PDMergeSort(len){
		async function mU(A,s,m,e){
			for(let i=0;i<m-s;i++)write(c,i,A[i+s],true);
			let P=0,l=s,r=m;
			while(l<r&&r<e)
				if(compareValues(c[P],A[r])<1)await write(A,l++,c[P++],0,true);
				else await write(A,l++,A[r++],0,true);
			while(l<r)await write(A,l++,c[P++],0,true);
		}
		async function mD(A,s,m,e){
			for(let i=0;i<e-m;i++)write(c,i,A[i+m],true);
			let P=e-m-1,l=m-1,r=e-1;
			while(r>l&&l>=s)
				if(compareValues(A[l],c[P])<1)await write(A,r--,c[P--],0,true);
				else await write(A,r--,A[l--],0,true);
			while(r>l)await write(A,r--,c[P--],0,true);
		}
		async function mr(A,l,r,e){
			if(e-r<r-l)await mD(A,l,r,e);
			else await mU(A,l,r,e);
		}
		function compare(a,b){return compareValues(a,b)<1}
		async function iR(A,i,m){
			let s=i;
			if(i>=m)return-1;
			let p=compare(A[i],A[++i]);
			while(i<m&&compare(A[i],A[i+1])==p)i++;
			if(!p)await reversal(A,s,i,0,false,true);
			if(i>=m)return-1;
			return i+1;
		}
		async function fR(A,m){
			let r=new Array(2+m/2|0);C=0;
			for(let lR=0;lR+1;lR=await iR(A,lR,m))write(r,C++,lR,0,false,true);
			return r;
		}
		let C,c=new Array(len/2|0),r=await fR(arr,len-1);
		while(C>1){
			for(let i=0;i<C-1;i+=2)await mr(arr,r[i],r[i+1],i+2>=C?len:r[i+2]);
			for(let i=1,j=2;i<C;i++,j+=2,C--)write(r,i,r[j],0,false,true);
		}
	}
	async rotateMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true,false);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=l?compareValues(v,A[m])<1:compareValues(v,A[m])<0;
				if(c)b=m;
				else a=m+1;
			}
			return a;
		}
		async function rotateMerge(A,a,m,b){
			let m1,m2,m3;
			if(m-a>=b-m){
				m1=a+(m-a)/2|0;
				m2=binarySearch(A,m,b,A[m1],true);
				m3=m1+(m2-m);
			}else{
				m2=m+(b-m)/2|0;
				m1=binarySearch(A,a,m,A[m2],false);
				m3=(m2++)-(m-m1);
			}
			await rotate(A,m1,m,m2);
			if(m2-m3+1>0&&b-m2>0)await rotateMerge(A,m3+1,m2,b);
			if(m1-a>0&&m3-m1>0)await rotateMerge(A,a,m1,m3);
		}
		async function rotateMergeSort(A,a,b){
			let l=b-a,i;
			for(let j=1;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await rotateMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await rotateMerge(A,i,i+j,b);
			}
		}
		await rotateMergeSort(arr,0,len);
	}
	async weavedMergeSort(len){
		async function merge(A,T,l,r,md){
			if(r+md>=l)return;
			let lo=r,hi=r+md,d=md<<1;
			await merge(A,T,l,lo,d);
			await merge(A,T,l,hi,d);
			let n=r;
			for(;lo<l&&hi<l;n+=md){
				let c=compareIndices(A,lo,hi);
				if(c>0||!c&&lo>hi){
					write(T,n,A[hi],1,false,true);
					hi+=d;
				}else{
					write(T,n,A[lo],1,false,true);
					lo+=d;
				}
			}
			if(lo>=l)while(hi<l){
				write(T,n,A[hi],1,false,true);
				n+=md;hi+=d;
			}else while(lo<l){
				write(T,n,A[lo],1,false,true);
				n+=md;lo+=d;
			}
			for(let i=r;i<l;i+=md)await write(A,i,T[i],1,true,false);
		}
		let T=new Array(len).fill(0);
		await merge(arr,T,len,0,1);
	}
	async lazyStableSort(len){
		const GS=new GrailSorting();
		async function grailLazyStableSort(A,p,l){
			for(let d=1;d<l;d+=2)if(compareIndices(A,p+d-1,p+d)>0)await swap(A,p+d-1,p+d,1,true);
			for(let pt=2;pt<l;pt*=2){
				let lf=0;
				let ri=l-2*pt;
				while(lf<=ri){
					await GS.grailMergeWithoutBuffer(A,p+lf,pt,pt);
					lf+=2*pt;
				}
				let r=l-lf;
				if(r>pt)await GS.grailMergeWithoutBuffer(A,p+lf,pt,r-pt);
			}
		}
		await grailLazyStableSort(arr,0,len);
	}
	async mergeSort(len){
		async function merge(A,T,s,m,e){
			if(s==m)return;
			await merge(A,T,s,(m+s)/2|0,m);
			await merge(A,T,m,(m+e)/2|0,e);
			let l=s;
			let h=m;
			for(let n=0;n<e-s;n++){
				if(l>=m&&h>=e)break;
				if(l<m&&h>=e)write(T,n,A[l++],1,false,true);
				else if(l>=m&&h<e)write(T,n,A[h++],1,false,true);
				else if(compareIndices(A,l,h)<1)write(T,n,A[l++],1,false,true);
				else write(T,n,A[h++],1,false,true);
			}
			for(let i=0;i<e-s;i++)
				await write(A,s+i,T[i],1,true);
		}
		let tmp=new Array(len).fill(0);
		await merge(arr,tmp,0,len/2|0,len);
	}
	async quadSort(len){
		let qSort=new QuadSorting();
		await qSort.quadSort(arr,0,len);
	}
	async fluxSort(len){
		const qds=new QuadSorting();
		async function fluxAnalyze(A,n){
			let c=n,b=0,p=0;
			while(--c>0)
				if(compareIndices(A,p,++p)>0)b++;
			if(!b)return false;
			if(b==n-1){
				await reversal(A,0,n-1,1,true);
				return false;
			}
			if(b<=(n/6|0)||b>=(n/6*5|0)){
				await qds.quadSort(A,0,n);
				return false;
			}
			return true;
		}
		function medianOfFive(A,v0,v1,v2,v3,v4){
			let t=[0,0,0,0];
			let val;
			val=(compareIndices(A,v0,v1)+1)/2|0;t[0]=val;t[1]=val^1;
			val=(compareIndices(A,v0,v2)+1)/2|0;t[0]+=val;t[2]=val^1;
			val=(compareIndices(A,v0,v3)+1)/2|0;t[0]+=val;t[3]=val^1;
			val=(compareIndices(A,v0,v4)+1)/2|0;t[0]+=val;
			if(t[0]==2)return v0;
			val=(compareIndices(A,v1,v2)+1)/2|0;t[1]+=val;t[2]+=val^1;
			val=(compareIndices(A,v1,v3)+1)/2|0;t[1]+=val;t[3]+=val^1;
			val=(compareIndices(A,v1,v4)+1)/2|0;t[1]+=val;
			if(t[1]==2)return v1;
			val=(compareIndices(A,v2,v3)+1)/2|0;t[2]+=val;t[3]+=val^1;
			val=(compareIndices(A,v2,v4)+1)/2|0;t[2]+=val;
			if(t[2]==2)return v2;
			val=(compareIndices(A,v3,v4)+1)/2|0;t[3]+=val;
			return t[3]==2?v3:v4;
		}
		function medianOfThree(A,v0,v1,v2){
			let t=[0,0];
			let val;
			val=(compareIndices(A,v0,v1)+1)/2|0;t[0]=val;t[1]=val^1;
			val=(compareIndices(A,v0,v2)+1)/2|0;t[0]+=val;
			if(t[0]==1)return v0;
			val=(compareIndices(A,v1,v2)+1)/2|0;t[1]+=val;
			return t[1]==1?v1:v2;
		}
		function medianOfFifteen(A,p,n){
			let v0,v1,v2,v3,v4,d=n/16|0;
			v0=medianOfThree(A,p+d*2,p+d*1,p+d*3);
			v1=medianOfThree(A,p+d*5,p+d*4,p+d*6);
			v2=medianOfThree(A,p+d*8,p+d*7,p+d*9);
			v3=medianOfThree(A,p+d*11,p+d*10,p+d*12);
			v4=medianOfThree(A,p+d*14,p+d*13,p+d*15);
			return medianOfFive(A,v2,v0,v1,v3,v4);
		}
		function medianOfNine(A,p,n){
			let v0,v1,v2,div=n/16|0;
			v0=medianOfThree(A,p+div*2,p+div*1,p+div*4);
			v1=medianOfThree(A,p+div*8,p+div*6,p+div*10);
			v2=medianOfThree(A,p+div*14,p+div*12,p+div*15);
			return medianOfThree(A,v0,v1,v2);
		}
		async function fluxPartition(A,swp,m,s,n){
			let val;
			let aS,sS;
			let pta,pts,ptx,pte,piv;
			ptx=m==A?s:0;
			piv=m[n>1024?medianOfFifteen(m,ptx,n):medianOfNine(m,ptx,n)];
			pte=ptx+n;
			pta=s;
			pts=0;
			while(ptx<pte){
				val=(compareValues(m[ptx],piv)+1)/2|0;
				await write(A,pta,m[ptx],.25,true);pta+=val^1;
				write(swp,pts,m[ptx],.25,false,true);pts+=val;
				ptx++;
			}
			sS=pts;
			aS=n-sS;
			if(aS<=(sS/16|0)||sS<=24){
				await arraycopy(swp,0,A,pta,sS,.5,true);
				await qds.quadSortSwap(A,swp,pta,sS);
			}else
				await fluxPartition(A,swp,swp,pta,sS);
			if(sS<=(aS/16|0)||aS<=24)
				await qds.quadSortSwap(A,swp,s,aS);
			else
				await fluxPartition(A,swp,A,s,aS);
		}
		if(len<32)await qds.quadSort(arr,0,len);
		else if(await fluxAnalyze(arr,len)){
			let swp=new Array(len);
			await fluxPartition(arr,swp,arr,0,len);
		}
	}
	async stacklessRotateMergeSort(len){
		async function rotate(A,a,m,b){
			await IndexedRotations.griesMills(A,a,m,b,.5,true,false);
		}
		async function partitionMerge(A,a,m,b,c){
			let lenA=m-a,lenB=b-m;
			if(lenA<1||lenB<1)return;
			if(lenB<lenA){
				c=(lenA+lenB)-c;
				let r1=0,r2=minVal(c,lenB);
				while(r1<r2){
					let ml=(r1+r2)/2|0;
					if(compareIndices(A,m-c+ml,b-ml-1)>0)
						r2=ml;
					else
						r1=ml+1;
				}
				await rotate(A,m-c+r1,m,b-r1);
			}else{
				let r1=0,r2=minVal(c,lenA);
				while(r1<r2){
					let ml=(r1+r2)/2|0;
					if(compareIndices(A,a+ml,m+c-ml-1)>0)
						r2=ml;
					else
						r1=ml+1;
				}
				await rotate(A,a+r1,m,m+c-r1);
			}
		}
		async function rotateMerge(A,a,b,c){
			let i;
			for(i=a+1;i<b&&compareIndices(A,i-1,i)<1;i++);
			if(i<b)await partitionMerge(A,a,i,b,c);
		}
		async function rotatePartitionMergeSort(A,a,b){
			let l=b-a;
			for(let i=a+1;i<b;i+=2)
				if(compareIndices(A,i-1,i)>0)
					await swap(A,i-1,i,.5,true);
			for(let j=2;j<l;j*=2){
				let b1=0;
				for(let i=a;i+j<b;i+=2*j){
					b1=minVal(i+2*j,b);
					await partitionMerge(A,i,i+j,b1,j);
				}
				for(let k=j/2|0;k>1;k=k/2|0)
					for(let i=a;i+k<b1;i+=2*k)
						await rotateMerge(A,i,minVal(i+2*k,b),k);
				for(let i=a+1;i<b1;i+=2)
					if(compareIndices(A,i-1,i)>0)
						await swap(A,i-1,i,.5,true);
			}
		}
		await rotatePartitionMergeSort(arr,0,len);
	}
	async strandSort(len){
		async function mergeTo(A,T,a,m,b){
			let i=0,s=m-a;
			while(i<s&&m<b){
				if(compareValues(T[i],A[m])<0)
					await write(A,a++,T[i++],.5,true);
				else await write(A,a++,A[m++],.5,true);
			}
			while(i<s)
				await write(A,a++,T[i++],.5,true);
		}
		async function sort(A,l){
			let T=new Array(l);
			let j=l,k=j;
			while(j>0){
				write(T,0,A[0],1,true,true);
				k--;
				for(let i=0,p=0,m=1;m<j;m++){
					if(compareValues(A[m],T[i])>=0){
						await write(T,++i,A[m],1,true,true);
						k--;
					}else await write(A,p++,A[m],.1,true);
				}
				await mergeTo(A,T,k,j,l);
				j=k;
			}
		}
		await sort(arr,len);
	}
	async burntPancakeSort(len){
		for(let i=len-1;i>0;i--){
			let m=0;
			for(let j=m+1;j<=i;j++)
				if(compareIndices(arr,m,j)<1)m=j;
			if(m-i){
				await reversal(arr,0,m,.025,true);
				await reversal(arr,0,i,.025,true);
				await reversal(arr,0,i-1,.025,true);
				await reversal(arr,0,m-1,.025,true);
			}
		}
	}
	async stalinSort(len){
		for(let i=1;i<len;i++)
			if(compareIndices(arr,i-1,i)>0)
				await write(arr,i,arr[i-1],.5,true);
	}
	async pancakeInsertionSort(len){
		function monoFw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		function monoBw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)>0)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)>0)return s+1;
			return s;
		}
		function compare(A,a,b){
			return compareIndices(A,a,b,1,true);
		}
		async function flip(A,i){
			await reversal(A,0,i,.01,true,false);
		}
		async function front(A,l){
			if(l<2)return false;
			let d=true;
			if(compare(A,0,1)>0)await flip(A,1);
			if(l>2){
				if(compare(A,1,2)>0){
					if(compare(A,0,2)>0){
						await flip(A,1);
						return false;
					}else{
						await flip(A,2);
						await flip(A,1);
					}
					return false;
				}else return true;
			}
			return d;
		}
		async function sort(A,l){
			let d=await front(A,l)
			for(let i=3;i<l;i++){
				if(d){
					if(compare(A,i-1,i)<1){continue;
					}else if(compare(A,0,i)>0){
						await flip(A,i-1);
						d=!d;
					}else{
						let x=monoFw(A,0,i,A[i]);
						await flip(A,i);
						let e=i-x;
						await flip(A,e);
						await flip(A,e-1);
						d=!d;
					}
				}else{
					if(compare(A,i-1,i)>0){continue;
					}else if(compare(A,0,i)<1){
						await flip(A,i-1);
						d=!d;
					}else{
						let x=monoBw(A,0,i,A[i]);
						await flip(A,i);
						let e=i-x;
						await flip(A,e);
						await flip(A,e-1);
						d=!d;
					}
				}
			}
			if(!d)await flip(A,l-1);
		}
		await sort(arr,len);
	}
	async pancakeSort(len){
		function fM(A,e){
			let i=0,m=-1/0;
			for(let j=0;j<=e;j++)
				if(compareValues(A[j],m)>0){
					m=A[j];
					i=j;
				}
			return i;
		}
		for(let i=len-1;i>=0;i--){
			if(!isRangeSorted(arr,0,i)){
				let j=fM(arr,i);
				if(!j)
					await reversal(arr,0,i,.05,true);
				else if(j-i){
					await reversal(arr,0,j,.05,true);
					await reversal(arr,0,i,.05,true);
				}
			}else break;
		}
	}
	async ternaryLLQuickSort(len){
		function compare(A,a,b){
			return compareIndices(A,a,b);
		}
		function selectPivot(A,l,h){
			let m=(l+h)/2|0;
			if(!compare(A,l,m))return l;
			if(!compare(A,l,h-1)||!compare(A,m,h-1))return h-1;
			return compare(A,l,m)<0?compare(A,m,h-1)<0?m:compare(A,l,h-1)<0?h-1:l:compare(A,m,h-1)>0?m:compare(A,l,h-1)<0?l:h-1;
		}
		async function partitionTernaryLL(A,l,h){
			let p=selectPivot(A,l,h);
			let pv=A[p];
			await swap(A,p,h-1,1,true);
			let i=l,k=h-1;
			for(let j=l;j<k;++j){
				let cmp=compareIndexValue(A,j,pv,.5,true);
				if(!cmp)await swap(A,--k,j--,1,true);
				else if(cmp<0)await swap(A,i++,j,1,true);
			}
			let j=i+(h-k);
			for(let s=0;s<h-k;++s)
				await swap(A,i+s,h-1-s,1,true);
			return[i,j];
		}
		async function quickSortTernaryLL(A,l,h){
			if(l+1<h){
				let m=await partitionTernaryLL(A,l,h);
				await quickSortTernaryLL(A,l,m[0]);
				await quickSortTernaryLL(A,m[1],h);
			}
		}
		await quickSortTernaryLL(arr,0,len);
	}
	async ternaryLRQuickSort(len){
		function compare(A,a,b){
			return compareIndices(A,a,b);
		}
		function selectPivot(A,l,h){
			let m=(l+h)/2|0;
			if(!compare(A,l,m))return l;
			if(!compare(A,l,h-1)||!compare(A,m,h-1))return h-1;
			return compare(A,l,m)<0?compare(A,m,h-1)<0?m:compare(A,l,h-1)<0?h-1:l:compare(A,m,h-1)>0?m:compare(A,l,h-1)<0?l:h-1;
		}
		async function quickSortTernaryLR(A,l,h){
			if(h<=l)return;
			let c,piv=selectPivot(A,l,h+1);
			await swap(A,piv,h,1,true);
			let pv=A[h],i=l,j=h-1,p=l,q=h-1;
			while(1){
				while(i<=j&&(c=compareIndexValue(A,i,pv))<1){
					if(!c)await swap(A,i,p++,1,true);
					i++;
				}
				while(i<=j&&(c=compareValueIndex(A,pv,j))<1){
					if(!c)await swap(A,j,q--,1,true);
					j--;
				}
				if(i>j)break;
				await swap(A,i++,j--,1,true);
			}
			await swap(A,i,h,1,true);
			let ls=i-p;
			let gr=q-j;
			j=i-1;i=i+1;
			let pe=l+minVal(p-l,ls);
			for(let k=l;k<pe;k++,j--)
				await swap(A,k,j,1,true,false);
			let qe=h-1-minVal(h-1-q,gr-1);
			for(let k=h-1;k>qe;k--,i++)
				await swap(A,i,k,1,true,false);
			await quickSortTernaryLR(A,l,l+ls-1);
			await quickSortTernaryLR(A,h-gr+1,h);
		}
		await quickSortTernaryLR(arr,0,len-1);
	}
	async asynchronousSort(len){
		let ext=new Array(len);
		let n=1/0,x=-n;
		for(let i=0;i<len;i++){
			write(ext,i,arr[i],.5,false,true);
			if(arr[i]<n)n=arr[i];
			if(arr[i]>x)x=arr[i];
		}
		n++;
		let c=n,i=0;
		while(i<len){
			for(let j=0;j<len;j++){
				if(compareValues(ext[j],c)<1){
					await write(arr,i++,ext[j],.01,true);
					write(ext,j,x,0,false,true);
				}
			}
			c++;
		}
		await insertSort(arr,0,c);
	}
	async adaptiveGrailSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,0,true);
		}
		async function multiTriSwap(A,a,b,c,l){
			for(let i=0;i<l;i++){
				let t=A[a+i];
				write(A,a+i,A[b+i],0,true);
				write(A,b+i,A[c+i],0,true);
				await write(A,c+i,t,0,true);
			}
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		async function insertToBW(A,a,b){
			let t=A[a];
			while(a<b)await write(A,a,A[++a],.5,true);
			await write(A,a,t,.5,true);
		}
		async function shift(A,a,m,b){
			while(m<b)await swap(A,a++,m++,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>1&&r>1){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
			if(r==1)await insertTo(A,m,a);
			else if(l==1)await insertToBW(A,a,b-1);
		}
		function leftBinarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function buildUniqueRun(A,a,n){
			let nKeys=1,i=a+1;
			if(compareIndices(A,i-1,i)<0){
				do{i++;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)<0);
			}else if(compareIndices(A,i-1,i)>0){
				do{i++;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)>0);
				await reversal(A,a,i-1,1,true);
			}
			return nKeys;
		}
		async function buildUniqueRunBW(A,b,n){
			let nKeys=1,i=b-1;
			if(compareIndices(A,i-1,i)<0){
				do{i--;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)<0);
			}else if(compareIndices(A,i-1,i)>0){
				do{i--;nKeys++}while(nKeys<n&&compareIndices(A,i-1,i)>0);
				await reversal(A,i,b-1,1,true);
			}
			return nKeys;
		}
		async function findKeys(A,a,b,nKeys,n){
			let p=a,pEnd=a+nKeys;
			for(let i=pEnd;i<b&&nKeys<n;i++){
				let loc=leftBinarySearch(A,p,pEnd,A[i]);
				if(pEnd==loc||compareIndices(A,i,loc)){
					await rotate(A,p,pEnd,i);
					let inc=i-pEnd;
					loc+=inc;
					p+=inc;
					pEnd+=inc;
					await insertTo(A,pEnd++,loc);
					nKeys++;
				}
			}
			await rotate(A,a,p,pEnd);
			return nKeys;
		}
		async function findKeysBW(A,a,b,nKeys,n){
			let p=b-nKeys,pEnd=b;
			for(let i=p-1;i>=a&&nKeys<n;i--){
				let loc=leftBinarySearch(A,p,pEnd,A[i]);
				if(pEnd==loc||compareIndices(A,i,loc)){
					await rotate(A,i+1,p,pEnd);
					let inc=p-(i+1);
					loc-=inc;
					pEnd-=inc;
					p-=inc+1;
					nKeys++;
					await insertToBW(A,i,loc-1);
				}
			}
			await rotate(A,p,pEnd,b);
			return nKeys;
		}
		async function buildRuns(A,a,b){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)
					await insertTo(A,i,rightBinarySearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinarySearch(A,a,i,A[i]));
		}
		async function mergeWithBufRest(A,a,m,b,p,pL){
			let i=0,j=m,k=a;
			while(i<pL&&j<b){
				if(compareIndices(A,p+i,j)<1)
					await swap(A,k++,p+(i++),1,true);
				else
					await swap(A,k++,j++,1,true);
			}
			while(i<pL)await swap(A,k++,p+(i++),1,true);
		}
		async function mergeWithBuf(A,a,m,b,p){
			let l=m-a;
			await multiSwap(A,p,a,l);
			await mergeWithBufRest(A,a,m,b,p,l);
		}
		async function mergeWithBufBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareIndices(A,j,p+i)<1)
					await swap(A,k--,p+(i--),1,true);
				else
					await swap(A,k--,j--,1,true);
			}
			while(i>=0)await swap(A,k--,p+(i--),1,true);
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftBinarySearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=rightBinarySearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=(i+1)-k;
					i=k-1;
				}else j--;
			}
		}
		async function mergeWithoutBuf(A,a,m,b){
			if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMerge(A,a,m,b);
		}
		function checkSorted(A,a,m,b){
			return compareIndices(A,m-1,m)>0;
		}
		async function checkReverseBounds(A,a,m,b){
			if(compareIndices(A,a,b-1)>0){
				await rotate(A,a,m,b);
				return false;
			}
			return true;
		}
		async function checkBounds(A,a,m,b){
			return checkSorted(A,a,m,b)&&await checkReverseBounds(A,a,m,b);
		}
		function grailGetSubA(A,t,mK){
			return compareIndices(A,t,mK)<0?"L":"R";
		}
		async function blockSelectSort(A,p,t,r,d,lC,bC,bLen){
			let mKey=lC;
			for(let j=0,k=lC+1;j<k-1;j++){
				let min=j;
				for(let i=maxVal(lC-r,j+1);i<k;i++){
					let c=compareIndices(A,p+d+i*bLen,p+d+min*bLen);
					if(c<0||(!c&&compareIndices(A,t+i,t+min)<0))min=i;
				}
				if(min-j){
					await multiSwap(A,p+j*bLen,p+min*bLen,bLen);
					await swap(A,t+j,t+min,1,true);
					if(k<bC&&min==k-1)k++;
				}
				if(min==mKey)mKey=j;
			}
			return t+mKey;
		}
		async function grailSortKeys(A,b,p,mKey){
			await swap(A,p,mKey,1,true);
			let i=mKey,j=i+1,k=p+1;
			while(j<b){
				if(compareIndices(A,j,p)<0)
					await swap(A,i++,j,1,true);
				else await swap(A,k++,j,1,true);
				j++;
			}
			await multiSwap(A,i,p,b-i);
		}
		async function grailSortKeysWithoutBuf(A,b,mKey){
			let i=mKey,j=i+1;
			while(j<b){
				if(compareIndices(A,j,i)<0)
					await insertTo(A,j,i++);
				j++;
			}
		}
		async function grailMergeBlocks(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			if(i>p)while(i<m)await swap(A,p++,i++,1,true);
			return j;
		}
		async function grailMergeBlocksRev(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<0)
					await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			if(i>p)while(i<m)await swap(A,p++,i++,1,true);
			return j;
		}
		async function grailBlockMerge(A,a,m,b,t,p,bLen){
			let b1=b-(b-m-1)%bLen-1,
				i=a+bLen,j=a,key=t-1,
				lC=(m-i)/bLen|0,bC=(b1-i)/bLen|0,l=-1,r=lC-1;
			await multiTriSwap(A,p,m-bLen,a,bLen);
			await insertToBW(A,t,t+lC-1);
			let mKey=await blockSelectSort(A,i,t,1,bLen-1,lC,bC,bLen);
			let frag="L";
			while(l<lC&&r<bC){
				if(frag=="L"){
					do{
						j+=bLen;
						l++;
						key++;
					}while(l<lC&&grailGetSubA(A,key,mKey)=="L");
					if(l==lC){
						i=await grailMergeBlocks(A,i,j,b,i-bLen);
						await mergeWithBufRest(A,i-bLen,i,b,p,bLen);
					}else i=await grailMergeBlocks(A,i,j,j+bLen-1,i-bLen);
					frag="R";
				}else{
					do{
						j+=bLen;
						r++;
						key++;
					}while(r<bC&&grailGetSubA(A,key,mKey)=="R");
					if(r==bC){
						await shift(A,i-bLen,i,b);
						await multiSwap(A,p,b-bLen,bLen);
					}else i=await grailMergeBlocksRev(A,i,j,j+bLen-1,i-bLen);
					frag="L";
				}
			}
			await grailSortKeys(A,t+bC,p,mKey);
		}
		async function grailBlockMergeWithoutBuf(A,a,m,b,t,bLen){
			let a1=a+(m-a)%bLen,b1=b-(b-m)%bLen,
				i=a,j=a1,key=t,
				lC=(m-j)/bLen+1|0,bC=(b1-j)/bLen+1|0,l=0,r=lC;
			let mKey=await blockSelectSort(A,j,t,0,0,lC-1,bC-1,bLen);
			let frag="L";
			while(l<lC&&r<bC){
				let next=grailGetSubA(A,key++,mKey);
				if(next==frag){
					if(frag=="L")l++;
					else r++;
					i=j;
				}else{
					let m2=j,b2=j+bLen,k;
					if(frag=="L"){
						while(i<m2&&m2<b2){
							if(compareIndices(A,i,m2)>0){
								k=leftBinarySearch(A,m2+1,b2,A[i]);
								await rotate(A,i,m2,k);
								i+=k-m2;
								m2=k;
							}else i++;
						}
					}else{
						while(i<m2&&m2<b2){
							if(compareIndices(A,m2,i)<1){
								k=rightBinarySearch(A,m2+1,b2,A[i]);
								await rotate(A,i,m2,k);
								i+=k-m2;
								m2=k;
							}else i++;
						}
					}
					if(i<m2){
						if(next=="L")l++;
						else r++;
					}else{
						if(frag=="L")l++;
						else r++;
						frag=next;
					}
				}
				j+=bLen;
			}
			if(l<lC)await inPlaceMergeBW(A,a,b1,b);
			await grailSortKeysWithoutBuf(A,t+bC-1,mKey);
		}
		async function smartMerge(A,a,m,b,p){
			if(await checkBounds(A,a,m,b)){
				a=rightBinarySearch(A,a,m-1,A[m]);
				await mergeWithBuf(A,a,m,b,p);
			}
		}
		async function smartMergeBW(A,a,m,b,p){
			if(await checkBounds(A,a,m,b)){
				b=leftBinarySearch(A,m+1,b,A[m-1]);
				await mergeWithBufBW(A,a,m,b,p);
			}
		}
		async function smartBlockMerge(A,a,m,b,t,p,bLen){
			if(checkBounds(A,a,m,b)){
				let n=rightBinarySearch(A,a,m-1,A[m]);
				b=leftBinarySearch(A,m+1,b,A[m-1]);
				if(await checkReverseBounds(A,n,m,b)){
					if(m-n<=bLen||b-m<=bLen){
						if(b-m<m-n)await mergeWithBufBW(A,n,m,b,p);
						else await mergeWithBuf(A,n,m,b,p);
					}else{
						n-=(n-a)%bLen;
						await grailBlockMerge(A,n,m,b,t,p,bLen);
					}
				}
			}
		}
		async function smartBlockMergeWithoutBuf(A,a,m,b,t,bLen){
			if(await checkBounds(A,a,m,b)){
				a=rightBinarySearch(A,a,m-1,A[m]);
				if(m-a<=bLen)await inPlaceMerge(A,a,m,b);
				else await grailBlockMergeWithoutBuf(A,a,m,b,t,bLen);
			}
		}
		async function smartInPlaceMerge(A,a,m,b){
			if(await checkSorted(A,a,m,b))
				await inPlaceMergeBW(A,a,m,b);
		}
		async function redistBuffer(A,a,m,b){
			let rPos=leftBinarySearch(A,m,b,A[a]);
			await rotate(A,a,m,rPos);
			let dist=rPos-m;
			a+=dist;
			m+=dist;
			let a1=a+(m-a)/2|0;
			rPos=leftBinarySearch(A,m,b,A[a1]);
			await rotate(A,a1,m,rPos);
			dist=rPos-m;
			a1+=dist;
			m+=dist;
			await mergeWithoutBuf(A,a,a1-dist,a1);
			await mergeWithoutBuf(A,a1,m,b);
		}
		async function redistBufferBW(A,a,m,b){
			let rPos=rightBinarySearch(A,a,m,A[b-1]);
			await rotate(A,rPos,m,b);
			let dist=m-rPos;
			b-=dist;
			m-=dist;
			let b1=m+(b-m)/2|0;
			rPos=rightBinarySearch(A,a,m,A[b1-1]);
			await rotate(A,rPos,m,b1);
			dist=m-rPos;
			b1-=dist;
			m-=dist;
			await mergeWithoutBuf(A,b1,b1+dist,b);
			await mergeWithoutBuf(A,a,m,b1);
		}
		async function inPlaceMergeSort(A,a,b){
			await buildRuns(A,a,b);
			let len=b-a;
			for(let i,j=mR;j<len;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await smartInPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await smartInPlaceMerge(A,i,i+j,b);
			}
		}
		async function grailAdaptiveSortWithoutBuf(A,a,b,keys,ideal,bwBuf){
			let len=b-a,bLen;
			for(bLen=minVal(keys,mR);2*bLen<=keys;bLen*=2);
			let tLen=keys-bLen;
			let i,j=mR,
				t,p,a1,b1;
			if(bwBuf){
				p=b-bLen;a1=a;b1=p-tLen;t=b1;
			}else{
				p=a+tLen;a1=p+bLen;b1=b;t=a;
			}
			await buildRuns(A,a1,b1);
			while(j<=bLen&&j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b1)
					await smartMergeBW(A,i,i+j,b1,p);
				j*=2;
			}
			if((bLen/2|0)>=mR&&(bLen/2|0)>=((keys+1)/2|0)){
				await bininsert(A,p,p+bLen);
				bLen=bLen/2|0;
				tLen=keys-bLen;
				p+=bLen;
			}
			while(tLen>=(2*j/bLen|0)-1&&j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartBlockMerge(A,i,i+j,i+2*j,t,p,bLen);
				if(i+j<b1){
					if(b1-(i+j)>bLen)
						await smartBlockMerge(A,i,i+j,b1,t,p,bLen);
					else await smartMergeBW(A,i,i+j,b1,p);
				}
				j*=2;
			}
			await bininsert(A,p,p+bLen);
			tLen=keys-keys%2;
			while(j<len){
				bLen=2*j/tLen|0;
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartBlockMergeWithoutBuf(A,i,i+j,i+2*j,t,bLen);
				if(i+j<b1){
					if(b1-(i+j)>bLen)
						await smartBlockMergeWithoutBuf(A,i,i+j,b1,t,bLen);
					else await smartInPlaceMerge(A,i,i+j,b1);
				}
				j*=2;
			}
			if(bwBuf){
				a=rightBinarySearch(A,a,b1,A[b1]);
				if(keys>=(ideal/2|0))await redistBufferBW(A,a,b1,b);
				else await mergeWithoutBuf(A,a,b1,b);
			}else{
				b=leftBinarySearch(A,a1,b,A[a1-1]);
				if(keys>=(ideal/2|0))await redistBuffer(A,a,a1,b);
				else await mergeWithoutBuf(A,a,a1,b);
			}
		}
		async function grailAdaptiveSort(A,a,b){
			let len=b-a;
			if(len<31){
				await bininsert(A,a,b);
				return;
			}
			if(len<63){
				mR=(len+1)/2|0;
				await buildRuns(A,a,b);
				let m=a+mR;
				if(await checkBounds(A,a,m,b))
					await redistBufferBW(A,a,m,b);
				return;
			}
			for(mR=len;mR>=32;mR=(mR+1)/2|0);
			let bLen;
			for(bLen=mR;bLen*bLen<len;bLen*=2);
			let tLen=len/bLen-2|0,
				ideal=tLen+bLen;
			let bwBuf;
			let rRun=await buildUniqueRunBW(A,b,ideal),lRun=0;
			if(rRun==ideal)bwBuf=true;
			else{
				lRun=await buildUniqueRun(A,a,ideal);
				if(lRun==ideal)bwBuf=false;
				else bwBuf=(rRun<16&&lRun<16)||rRun>=lRun;
			}
			let keys=bwBuf?await findKeysBW(A,a,b,rRun,ideal):await findKeys(A,a,b,lRun,ideal);
			if(keys<ideal){
				if(keys==1)return;
				else if(keys<5)await inPlaceMergeSort(A,a,b);
				else await grailAdaptiveSortWithoutBuf(A,a,b,keys,ideal,bwBuf);
				return;
			}
			let i,j=mR,
				t,p,a1,b1;
			if(bwBuf){
				p=b-bLen;a1=a;b1=p-tLen;t=b1;
			}else{
				p=a+tLen;a1=p+bLen;b1=b;t=a;
			}
			await buildRuns(A,a1,b1);
			while(j<=bLen&&j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b1)
					await smartMergeBW(A,i,i+j,b1,p);
				j*=2;
			}
			while(j<len){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await smartBlockMerge(A,i,i+j,i+2*j,t,p,bLen);
				if(i+j<b1){
					if(b1-(i+j)>bLen)
						await smartBlockMerge(A,i,i+j,b1,t,p,bLen);
					else await smartMergeBW(A,i,i+j,b1,p);
				}
				j*=2;
			}
			await bininsert(A,p,p+bLen);
			if(bwBuf){
				a=rightBinarySearch(A,a,b1,A[b1]);
				await redistBufferBW(A,a,b1,b);
			}else{
				b=leftBinarySearch(A,a1,b,A[a1-1]);
				await redistBuffer(A,a,a1,b);
			}
		}
		let mR;
		await grailAdaptiveSort(arr,0,len);
	}
	async binaryMergeSort(len){
		async function merge(A,T,s,m,e){
			if(s==m)return;
			if(e-s<32)return;
			else if(e-s<64)await binaryInsertion(A,s,e);
			else{
				await merge(A,T,s,(m+s)/2|0,m);
				await merge(A,T,m,(m+e)/2|0,e);
				let lo=s;
				let hi=m;
				for(let n=0;n<e-s;n++){
					if(lo>=m&&hi>=e)break;
					if(lo<m&&hi>=e)write(T,n,A[lo++],0,false,true);
					else if(lo>=m&&hi<e)write(T,n,A[hi++],0,false,true);
					else if(compareIndices(A,lo,hi)<1)write(T,n,A[lo++],0,false,true);
					else write(T,n,A[hi++],0,false,true);
				}
				for(let i=0;i<e-s;i++)
					await write(A,s+i,T[i],1,true);
			}
		}
		async function mergeSort(A,l){
			if(l<32)return await binaryInsertion(A,0,l);
			let T=new Array(l).fill(0);
			await merge(A,T,0,l/2|0,len);
		}
		await mergeSort(arr,len);
	}
	async bufferPartitionMergeSort(len){
		async function shiftBW(A,a,m,b){
			while(m>a)await swap(A,--b,--m,1,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=j;
					while(++k<b&&compareIndices(A,i,k)>0);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j;
			let ad=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s);
					await swap(A,j++,i+s/2,1,false);
				}
				if(i<e){
					await insertSort(A,i,e);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,1);
					if((e-i)%2==0)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)>0);
				do j--;while(j>=i&&compareIndices(A,j,a)<0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function quickSelect(A,a,b,m){
			let bp=false,med=false;
			let m1=(m+b+1)/2|0;
			while(1){
				if(bp){
					await medianOfMedians(A,a,b,5);
					med=true;
				}else await medianOfThree(A,a,b);
				let p=await partition(A,a,b);
				await swap(A,a,p,1,true);
				let l=maxVal(1,p-a);
				let r=maxVal(1,b-p-1);
				bp=!med&&((l/r|0)>=16||(r/l|0)>=16);
				if(p>=m&&p<m1)return p;
				else if(p<m)a=p+1;
				else b=p;
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			}
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		async function mergeFW(A,p,a,m,b){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			}
			if(i<m)return i;
			else return j;
		}
		function getMinLevel(n){
			while(n>31)n=(n+3)/4|0;
			return n;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,ps,j=getMinLevel(l);
			for(i=a;i+j<=b;i+=j)
				await binaryInsertion(A,i,i+j);
			await binaryInsertion(A,i,b);
			while(j<l){
				ps=p;
				for(i=a;i+2*j<=b;i+=2*j,ps+=2*j)
					await merge(A,i,i+j,i+2*j,ps);
				if(i+j<b)
					await merge(A,i,i+j,b,ps);
				else
					while(i<b)await swap(A,i++,ps++,1,true);
				j*=2;
				ps=a;
				for(i=p;i+2*j<=p+l;i+=2*j,ps+=2*j)
					await merge(A,i,i+j,i+2*j,ps);
				if(i+j<p+l)
					await merge(A,i,i+j,p+l,ps);
				else
					while(i<p+l)await swap(A,i++,ps++,1,true);
				j*=2;
			}
		}
		async function sort(A,a,b){
			let mn=sqrt(b-a)|0;
			let m=(a+b+1)/2|0;
			await mergeSort(A,m,b,a);
			while(m-a>mn){
				let m1=(a+m+1)/2|0;
				m1=await quickSelect(A,a,m,m1);
				await mergeSort(A,m1,m,a);
				let bS=m1-a;
				let m2=minVal(m1+bS,b);
				m1=await mergeFW(A,a,m1,m,m2);
				while(m1<m){
					await shiftBW(A,m1,m,m2);
					m1=m2-m+m1;
					a=m1-bS;
					m=m2;
					if(m==b)break;
					m2=minVal(m2+bS,b);
					m1=await mergeFW(A,a,m1,m,m2);
				}
				m=m1;
				a=m1-bS;
			}
			await binaryInsertion(A,a,m);
			await inPlaceMerge(A,a,m,b);
		}
		await sort(arr,0,len);
	}
	async circularGrailSort(len){
		async function circSwap(A,a,b){
			await swap(A,a%n,b%n,1,true);
		}
		function circCompareIndices(A,a,b){
			return compareIndices(A,a%n,b%n);
		}
		async function shiftFW(A,a,m,b){
			while(m<b)await circSwap(A,a++,m++);
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await circSwap(A,--b,--m);
		}
		async function insert(A,a,b){
			for(let i=a+1;i<b;i++)
				while(i>a&&circCompareIndices(A,i-1,i)>0)
					await circSwap(A,i,--i);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await circSwap(A,a+i,b+i);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(circCompareIndices(A,i,j)>0){
					k=j;
					while(++k<b&&circCompareIndices(A,i,k)>0);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function merge(A,p,a,m,b,f){
			let i=a,j=m;
			while(i<m&&j<b){
				if(circCompareIndices(A,i,j)<1)
					await circSwap(A,p++,i++);
				else
					await circSwap(A,p++,j++);
			}
			if(i<m){
				if(i>p) await shiftFW(A,p,i,m);
			}else if(f)
				await shiftFW(A,p,j,b);
			return i<m?i:j;
		}
		function blockLessThan(A,a,b,bL){
			let c=circCompareIndices(A,a,b);
			return c<0||(!c&&circCompareIndices(A,a+bL-1,b+bL-1)<0);
		}
		async function blockMerge(A,a,m,b,bL){
			let b1=b-(b-m-1)%bL-1;
			if(b1>m){
				let b2=b1;
				for(let i=m-bL;i>a&&blockLessThan(A,b1,i,bL);i-=bL,b2-=bL);
				for(let j=a;j<b1-bL;j+=bL){
					let mn=j;
					for(let i=mn+bL;i<b1;i+=bL)
						if(blockLessThan(A,i,mn,bL))mn=i;
					if(mn-j)await multiSwap(A,j,mn,bL);
				}
				let f=a;
				for(let i=a+bL;i<b2;i+=bL){
					f=await merge(A,f-bL,f,i,i+bL,false);
					if(f<i){
						await shiftBW(A,f,i,i+bL);
						f+=bL;
					}
				}
				await merge(A,f-bL,f,b1,b,true);
			}else await merge(A,a-bL,a,m,b,true);
		}
		let n=len;
		async function sort(A,l){
			if(l<17)return await insert(A,0,l);
			let bL=1;
			for(;bL*bL<l;bL*=2);
			let i=bL,j=1,ln=l-i,b=l;
			while(j<=bL){
				for(;i+2*j<b;i+=2*j)
					await merge(A,i-j,i,i+j,i+2*j,true);
				if(i+j<b)
					await merge(A,i-j,i,i+j,b,true);
				else
					await shiftFW(A,i-j,i,b);
				i=b+bL-j;
				b=i+ln;
				j*=2;
			}
			while(j<ln){
				for(;i+2*j<b;i+=2*j)
					await blockMerge(A,i,i+j,i+2*j,bL);
				if(i+j<b)
					await blockMerge(A,i,i+j,b,bL);
				else
					await shiftFW(A,i-bL,i,b);
				i=b;
				b+=ln;
				j*=2;
			}
			await insert(A,i-bL,i);
			await inPlaceMerge(A,i-bL,i,b);
			await rotate(A,0,(i-bL)%n,l);
		}
		await sort(arr,len);
	}
	async badSort(len){
		for(let i=0;i<len;i++){
			let s=i;
			for(let j=i;j<len;j++){
				let S=true;
				for(let k=j+1;k<len;k++){
					if(compareIndices(arr,j,k)>0){
						S=false;
						break;
					}
				}
				if(S){
					s=j;
					break;
				}
			}
			await swap(arr,i,s,0,true);
		}
	}
	async ectaSort(len){
		function getMinRun(n){
			let m=n;
			for(;m>=32;m=(m+1)/2|0);
			return m;
		}
		async function shift(A,a,m,b){
			while(m<b)await write(A,a++,A[m++],1,true);
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await write(A,--b,A[--m],1,true);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await write(A,p++,A[i++],1,true);
				else
					await write(A,p++,A[j++],1,true);
			}
			while(i<m)await write(A,p++,A[i++],1,true);
			while(j<b)await write(A,p++,A[j++],1,true);
		}
		async function pingPongMerge(A,a,m1,m2,m3,b,p){
			let p1=p+m2-a,pE=p+b-a;
			await mergeTo(A,a,m1,m2,p);
			await mergeTo(A,m2,m3,b,p1);
			await mergeTo(A,p,p1,pE,a);
		}
		async function merge(A,a,m,b,p){
			let ln=b-m,pE=p+ln-1;
			await arraycopy(A,m--,A,p,ln,1,true);
			while(m>=a&&pE>=p){
				if(compareIndices(A,m,pE)>0)
					await write(A,--b,A[m--],1,true);
				else await write(A,--b,A[pE--],1,true);
			}
			while(pE>=p)
				await write(A,--b,A[pE--],1,true);
		}
		async function mergeFromBuf(A,bf,a,m,b,bL){
			let i=0;
			while(i<bL&&m<b){
				if(compareValues(bf[i],A[m])<1)
					await write(A,a++,bf[i++],1,true);
				else
					await write(A,a++,A[m++],1,true);
			}
			while(i<bL)
				await write(A,a++,bf[i++],1,true);
		}
		async function dualMergeFromBufBW(A,buf,a,a1,m,b,bfL){
			let i=bfL-1;
			bfL-=b-(m--);
			while(i>=bfL&&m>=a1){
				if(compareValues(buf[i],A[m])>0)
					await write(A,--b,buf[i--],1,true);
				else
					await write(A,--b,A[m--],1,true);
			}
			if(m<a1)
				while(i>=0)await write(A,--b,buf[i--],1,true);
			else
				await mergeFromBuf(A,buf,a,a1,b,bfL);
		}
		async function mergeSort(A,a,b,p,mRun,bfL){
			let smallSort=binaryDoubleInsertion;
			let i=a,j=mRun;
			for(;i+j<=b;i+=j)
				await smallSort(A,i,i+j);
			await smallSort(A,i,b);
			while(4*j<=bfL){
				for(i=a;i+4*j<=b;i+=4*j)
					await pingPongMerge(A,i,i+j,i+2*j,i+3*j,i+4*j,p);
				if(i+3*j<b)
					await pingPongMerge(A,i,i+j,i+2*j,i+3*j,b,p);
				else if(i+2*j<b)
					await pingPongMerge(A,i,i+j,i+2*j,b,b,p);
				else if(i+j<b)
					await merge(A,i,i+j,b,p);
				j*=4;
			}
			while(j<=bfL){
				for(i=a;i+2*j<=b;i+=2*j)
					await merge(A,i,i+j,i+2*j,p);
				if(i+j<b)
					await merge(A,i,i+j,b,p);
				j*=2;
			}
			return j;
		}
		async function blockCycle(A,keys,a,bLen,t,p,excl,fw){
			let s=fw?bLen:-bLen;
			for(let i=0;i<t;i++){
				if(compareValues(i,keys[i])){
					await arraycopy(A,a+i*s,A,p,bLen,1,true);
					let j=i,next=keys[i];
					do{
						if(!(excl&&j==t-1))
							await arraycopy(A,a+next*s,A,a+j*s,bLen,1,true);
						write(keys,j,j,1,false,true);
						j=next;
						next=keys[next];
					}while(compareValues(next,i));
					await arraycopy(A,p,A,a+j*s,bLen,1,true);
					write(keys,j,j,1,false,true);
				}
			}
		}
		async function ectaMergeFW(A,tags,a,m,b,bLen){
			let i=a,j=m,t=0,tc=0;
			let s=[2*bLen,0];
			let p=[a-2*bLen,m];
			do{
				let c=s[0]<bLen?1:0;
				for(let k=0;k<bLen;k++){
					if(i<m&&j<b){
						if(compareIndices(A,i,j)<1){
							await write(A,p[c]+k,A[i++],1,true);
							s[0]++;
						}else{
							await write(A,p[c]+k,A[j++],1,true);
							s[1]++;
						}
					}else if(i<m){
						await write(A,p[c]+k,A[i++],1,true);
						s[0]++;
					}else{
						await write(A,p[c]+k,A[j++],1,true);
						s[1]++;
					}
				}
				p[c]+=bLen;
				s[c]-=bLen;
				write(tags,tc++,!c?t++:-1,1,false,true);
			}while(i<m||j<b);
			if(s[0]>0)write(tags,tc,t++,1,false,true);
			for(let k=2;k<tc;k++)
				if(tags[k]==-1)
					write(tags,k,t++,1,false,true);
			await blockCycle(A,tags,a-2*bLen,bLen,t,b-bLen,s[0]>0,true);
		}
		async function ectaMergeBW(A,tags,a,m,b,bLen){
			let i=b-1,j=m-1,t=0,tc=0;
			let s=[2*bLen,0];
			let p=[b+2*bLen,m];
			do{
				let c=s[0]<bLen?1:0;
				for(let k=1;k<=bLen;k++){
					if(i>=m&&j>=a){
						if(compareIndices(A,j,i)<1){
							await write(A,p[c]-k,A[i--],1,true);
							s[0]++;
						}else{
							await write(A,p[c]-k,A[j--],1,true);
							s[1]++;
						}
					}else if(i>=m){
						await write(A,p[c]-k,A[i--],1,true);
						s[0]++;
					}else{
						await write(A,p[c]-k,A[j--],1,true);
						s[1]++;
					}
				}
				p[c]-=bLen;
				s[c]-=bLen;
				write(tags,tc++,!c?t++:-1,1,false,true);
			}while(i>=m||j>=a);
			if(s[0]>0)write(tags,tc,t++,1,false,true);
			for(let k=2;k<tc;k++)
				if(tags[k]==-1)
					write(tags,k,t++,1,false,true);
			await blockCycle(A,tags,b+bLen,bLen,t,a,s[0]>0,false);
		}
		async function main(A,l){
			if(l<256){
				if(l<=32){
					let smallSort=binaryDoubleInsertion;
					smallSort(A,0,l);
				}else{
					let mRun=getMinRun(l),bfL=l/2|0;
					let buf=new Array(bfL);
					arraycopy(A,bfL,buf,0,bfL,0,true,true);
					await mergeSort(A,0,bfL,bfL,mRun,bfL);
					await arraycopy(buf,0,A,bfL,bfL,1,true,false);
					arraycopy(A,0,buf,0,bfL,0,true,true);
					await mergeSort(A,bfL,l,0,mRun,bfL);
					await mergeFromBuf(A,buf,0,bfL,l,bfL);
				}
				return;
			}
			let mRun=getMinRun(l),bLen=mRun;
			for(;bLen*bLen<l/2|0;bLen*=2);
			let bfL=2*bLen+l%bLen;
			let a=bfL,b=l,ln=b-a;
			let buf=new Array(bfL);
			let tags=new Array(ln/bLen+1|0);
			arraycopy(A,a,buf,0,bfL,0,true,true);
			await mergeSort(A,0,a,a,getMinRun(bfL),bfL);
			await arraycopy(buf,0,A,a,bfL,1,true,false);
			arraycopy(A,0,buf,0,bfL,0,true,true);
			let i=a,j=await mergeSort(A,a,b,0,mRun,bfL);
			let bw=false;
			while(j<ln){
				for(i=a;i+2*j<=b;i+=2*j)
					await ectaMergeFW(A,tags,i,i+j,i+2*j,bLen);
				if(i+j<b)await ectaMergeFW(A,tags,i,i+j,b,bLen);
				else await shift(A,i-2*bLen,i,b);
				j*=2;
				a-=2*bLen;
				b-=2*bLen;
				if(j>=ln){
					bw=true;
					break;
				}
				for(i=a;i+2*j<=b;i+=2*j);
				if(i+j<b)await ectaMergeBW(A,tags,i,i+j,b,bLen);
				else await shiftBW(A,i,b,b+2*bLen);
				for(i-=2*j;i>=a;i-=2*j)
					await ectaMergeBW(A,tags,i,i+j,i+2*j,bLen);
				j*=2;
				a+=2*bLen;
				b+=2*bLen;
			}
			if(bw)await dualMergeFromBufBW(A,buf,0,a,b,l,bfL);
			else await mergeFromBuf(A,buf,0,a,b,bfL);
		}
		await main(arr,len);
	}
	async improvedBlockSelectionSort(len){
		function sqr(n){
			let i=1;
			for(;i*i<n;i*=2);
			return i;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=j;
					do k++;while(k<b&&compareIndices(A,i,k)>0);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
			return i;
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=i;
					do k--;while(k>=a&&compareIndices(A,k,j)>0);
					await rotate(A,k+1,i+1,j+1);
					j-=i-k;
					i=k;
				}else j--;
			}
		}
		function selectRange(A,a,b,bL){
			let n=a;a+=bL;
			while(a<b){
				let c=compareIndices(A,a,n);
				if(c<0||(!c&&compareIndices(A,a+bL-1,n+bL-1)<0))n=a;
				a+=bL;
			}
			return n;
		}
		async function blockSelect(A,a,m,b,bL){
			let k=a,j=m;
			while(k<m&&compareIndices(A,k,m)<1)k+=bL;
			if(k==m)return;
			let i=m;
			await multiSwap(A,k,j,bL);
			k+=bL;
			j+=bL;
			while(k<j&&j<b){
				if(compareIndices(A,i,j)<1){
					if(k!=i)await multiSwap(A,k,i,bL);
					k+=bL;
					i=selectRange(A,maxVal(m,k),j,bL);
				}else{
					if(i==k)i=j;
					if(k!=j)await multiSwap(A,k,j,bL);
					k+=bL;j+=bL;
				}
			}
			while(k<j){
				i=selectRange(A,k,b,bL);
				if(k!=i)await multiSwap(A,k,i,bL);
				k+=bL;
			}
		}
		for(let i,j=1;j<len;j*=2){
			let bL=sqr(j),n=j,b=len-len%bL;
			while(n>16){
				for(i=0;i+j<b;i+=2*j)
					for(let k=i;k+n<minVal(i+2*j,b);k+=n)
						await blockSelect(arr,k,k+n,minVal(k+2*n,b),bL);
				n=bL;
				bL=sqr(bL);
			}
			for(i=0;i+j<b;i+=2*j)
				for(let k=i,f=i;k+n<minVal(i+2*j,b);k+=n)
					f=await inPlaceMerge(arr,f,k+n,minVal(k+2*n,b));
			await inPlaceMergeBW(arr,len-len%(2*j),b,len);
		}
	}
	async kotaSort(len){
		let T,C,bfP,blL,tL,bfL,eM,ext;
		async function rotate(A,st,sp,e){
			let t;
			while(sp<e&&sp>st){
				if(e-sp<sp-st){
					if(e-sp==1){
						t=A[sp];
						await shift(A,st,sp,e,true,true);
						await write(A,st,t,1,true);
						return;
					}else{
						await shift(A,2*sp-e,sp,e,true,false);
						t=e;
						e=sp;
						sp-=t-sp;
					}
				}else{
					if(sp-st==1){
						t=A[st];
						await shift(A,st,sp,e,false,true);
						await write(A,e-1,t,1,true);
						return;
					}else{
						await shift(A,st,sp,2*sp-st,false,false);
						t=st;
						st=sp;
						sp+=sp-t;
					}
				}
			}
		}
		async function kotaSwap(A,a,b,x){
			if(x)await write(A,a,A[b],1,true);
			else await swap(A,a,b,1,true);
		}
		function binarySearch(A,st,e,v,l){
			let a=st,b=e;
			while(a<b){
				let m=(a+b)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function findKeys(A,st,e,n){
			let nK=1,p=st,pE=st+1;
			for(let i=st+1;i<e&&nK<n;i++){
				let l=binarySearch(A,p,pE,A[i],true);
				if(i==l||compareIndices(A,i,l)){
					await rotate(A,p,pE,i);
					let c=i-pE;
					l+=c;p+=c;pE+=c;nK++;
					await rotate(A,l,pE++,pE);
				}
			}
			await rotate(A,st,p,pE);
			return nK;
		}
		async function swapToTags(A,a,i,x){
			if(x){
				let t=T[i];
				write(T,i,A[a],0,false,true);
				await write(A,a,t,1,false);
			}else await kotaSwap(A,bfP+i,a,false);
		}
		async function shift(A,a,m,b,l,x){
			if(l){
				if(m==b)return;
				while(m>a)
					await kotaSwap(A,--b,--m,x);
			}else{
				if(m==a)return;
				while(m<b)
					await kotaSwap(A,a++,m++,x);
			}
		}
		async function multiSwap(A,a,b,l,x){
			for(let i=0;i<l;i++)
				await kotaSwap(A,a+i,b+i,x);
		}
		async function multiSwapBW(A,a,b,l,x){
			for(let i=0;i<l;i++)
				await kotaSwap(A,a-i,b-i,x);
		}
		async function blockSelect(A,p,c){
			for(let j=0;j<c;j++){
				let st=p+j*blL,n=st;
				for(let i=j+1;i<c;i++){
					let s=p+i*blL;
					if(compareIndices(A,s,n)<0)n=s;
				}
				if(st!=n)await multiSwap(A,st,n,blL,false);
				await swapToTags(A,st,j,false);
			}
		}
		async function blockSelectBW(A,p,c){
			for(let j=0;j<c;j++){
				let st=p-j*blL,n=st;
				for(let i=j+1;i<c;i++){
					let s=p-i*blL;
					if(compareIndices(A,s,n)<0)n=s;
				}
				if(st!=n)await multiSwapBW(A,st,n,blL,false);
				await swapToTags(A,st,j,false);
			}
		}
		async function blockCycle(A,ps,c,p){
			for(let j=0;j<c;j++){
				let st=ps+j*blL;
				if(j!=A[st]){
					let f=A[st];
					let v=j;
					await multiSwap(A,p,st,blL,true);
					while(v!=f){
						let vst=ps+v*blL;
						let k=j+1,nx=ps+k*blL;
						while(compareValues(A[nx],v))
							nx=ps+(++k)*blL;
						v=k;
						await multiSwap(A,vst,nx,blL,true);
					}
					f=ps+f*blL;
					await multiSwap(A,f,p,blL,true);
				}
				await swapToTags(A,st,j,true);
			}
		}
		async function blockCycleBW(A,ps,c,p){
			for(let j=0;j<c;j++){
				let st=ps-j*blL;
				if(j!=A[st]){
					let f=A[st];
					let v=j;
					await multiSwapBW(A,p,st,blL,true);
					while(v!=f){
						let vst=ps-v*blL;
						let k=j+1,nx=ps-k*blL;
						while(compareValues(A[nx],v))
							nx=ps-(++k)*blL;
						v=k;
						await multiSwapBW(A,vst,nx,blL,true);
					}
					f=ps-f*blL;
					await multiSwapBW(A,f,p,blL,true);
				}
				await swapToTags(A,st,j,true);
			}
		}
		async function blockMerge(A,a,m,b,auxTag){
			if(b-m<=2*bfL){
				await dualMerge(A,a,m,b,bfL);
				return;
			}
			let i=a,j=m,k,f;
			let leftAD=bfL,rightAD=0;
			let left=i-bfL,right=j;
			let tC=0;
			while(i<m&&leftAD>=rightAD){
				k=0;
				while(i<m&&k<blL){
					if(compareIndices(A,i,j)<1){
						await kotaSwap(A,left++,i++,ext);
					}else{
						await kotaSwap(A,left++,j++,ext);
						rightAD++;
						leftAD--;
					}
					k++;
				}
			}
			let selst=left
			while(i<m&&j<b){
				while(i<m&&j<b&&rightAD>leftAD){
					f=right;
					k=0;
					while(i<m&&j<b&&k<blL){
						if(compareIndices(A,i,j)<1){
							await kotaSwap(A,right++,i++,ext);
							rightAD--;
							leftAD++;
						}else{
							await kotaSwap(A,right++,j++,ext);
						}
						k++;
					}
					while(i<m&&k<blL){
						await kotaSwap(A,right++,i++,ext);
						rightAD--;
						leftAD++;
						k++;
					}
					while(j<b&&k<blL){
						await kotaSwap(A,right++,j++,ext);
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await shift(A,f,f+k,b,true,ext);
						j=b-k;
						right=f;
					}
				}
				while(i<m&&j<b&&leftAD>=rightAD){
					f=left;
					k=0;
					while(i<m&&j<b&&k<blL){
						if(compareIndices(A,i,j)<1){
							await kotaSwap(A,left++,i++,ext);
						}else{
							await kotaSwap(A,left++,j++,ext);
							rightAD++;
							leftAD--;
						}
						k++;
					}
					while(i<m&&k<blL){
						await kotaSwap(A,left++,i++,ext);
						k++;
					}
					while(j<b&&k<blL){
						await kotaSwap(A,left++,j++,ext);
						rightAD++;
						leftAD--;
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await rotate(A,f,m,right);
						left+=right-m;
						leftAD=0;
					}
				}
			}
			if(i>=m&&leftAD==blL&&tC>0){
				await multiSwap(A,left,right-blL,blL,ext)
			}else{
				if(i<m){
					await rotate(A,left,m,right)
					left+=right-m;
				}
				await shift(A,left,left+leftAD,right,false,ext)
			}
			if(j<b)await shift(A,j-bfL,j,b,false,ext);
			if(auxTag)await blockCycle(A,selst,tC,b-bfL);
			else await blockSelect(A,selst,tC);
		}
		async function blockMergeBW(A,a,m,b,auxTag){
			let i=m-1,j=b-1,k,f;
			let leftAD=0,rightAD=bfL;
			let left=i,right=j+bfL;
			let tC=0;
			while(j>=m&&rightAD>=leftAD){
				k=0;
				while(j>=m&&k<blL){
					if(compareIndices(A,i,j)>0){
						await kotaSwap(A,right--,i--,ext);
						leftAD++;
						rightAD--;
					}else{
						await kotaSwap(A,right--,j--,ext);
					}
					k++;
				}
			}
			let selst=right;
			while(j>=m&&i>=a){
				while(j>=m&&i>=a&&leftAD>rightAD){
					f=left;
					k=0;
					while(j>=m&&i>=a&&k<blL){
						if(compareIndices(A,i,j)>0){
							await kotaSwap(A,left--,i--,ext);
						}else{
							await kotaSwap(A,left--,j--,ext);
							rightAD++;
							leftAD--;
						}
						k++;
					}
					while(j>=m&&k<blL){
						await kotaSwap(A,left--,j--,ext);
						rightAD++;
						leftAD--;
						k++;
					}
					while(i>=a&&k<blL){
						await kotaSwap(A,left--,i--,ext);
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await shift(A,a,f+1-k,f+1,false,ext);
						i=a-1+k;
						left=f;
					}
				}
				while(j>=m&&i>=a&&rightAD>=leftAD){
					f=right;
					k=0;
					while(j>=m&&i>=a&&k<blL){
						if(compareIndices(A,i,j)>0){
							await kotaSwap(A,right--,i--,ext);
							leftAD++;
							rightAD--;
						}else{
							await kotaSwap(A,right--,j--,ext);
						}
						k++;
					}
					while(j>=m&&k<blL){
						await kotaSwap(A,right--,j--,ext);
						k++;
					}
					while(i>=a&&k<blL){
						await kotaSwap(A,right--,i--,ext);
						leftAD++;
						rightAD--;
						k++;
					}
					if(k==blL)
						await swapToTags(A,f,tC++,auxTag);
					else{
						await rotate(A,left+1,m,f+1);
						right-=m-(left+1);
						rightAD=0;
					}
				}
			}
			if(j<m&&rightAD==blL&&tC>0){
				await multiSwapBW(A,right,left+blL,blL,ext);
			}else{
				if(j>=m){
					await rotate(A,left+1,m,right+1);
					right-=m-(left+1);
				}
				await shift(A,left+1,right+1-rightAD,right+1,true,ext);
			}
			if(i>=a)await shift(A,a,i+1,i+1+bfL,true,ext);
			if(auxTag)await blockCycleBW(A,selst,tC,a-1+bfL);
			else await blockSelectBW(A,selst,tC);
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=binarySearch(A,j,b,A[i],true);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,j,i)<1){
					k=binarySearch(A,a,i+1,A[j],true);
					await rotate(A,k,i+1,j+1);
					j-=(i+1)-k;
					i=k-1;
				}else j--;
			}
		}
		async function inPlaceMerge2(A,st,mid,end){
			let i=st,m=mid,k=mid,q;
			while(m<end){
				if(compareIndices(A,m-1,m)<1)
					return;
				while(i<m-1&&compareIndices(A,i,m)<1)i++;
				await swap(A,i++,k++,1,true);
				while(i<m){
					while(i<m&&k<end&&compareIndices(A,m,k)>0)
						await swap(A,i++,k++,1,true,false);
					if(i>=m)break;
					else if(k>=end){
						await rotate(A,i,m,end);
						return;
					}else if(k-m>=m-i){
						await rotate(A,i,m,k);
						break;
					}
					q=m;
					while(i<m&&q<k&&compareIndices(A,q,k)<1)
						await swap(A,i++,q++,1,true,false);
					await rotate(A,m,q,k);
				}
				m=k;
			}
		}
		async function inPlaceMergeSort2(A,st,end){
			let ln=end-st,j;
			for(let i=1;i<ln;i*=2){
				for(j=st;j+2*i<end;j+=2*i)
					await inPlaceMerge2(A,j,j+i,j+2*i);
				if(j+i<end)
					await inPlaceMerge2(A,j,j+i,end);
			}
		}
		async function mergeWithBuf(A,a,m,b,l){
			let i=a,j=m,k=a-l;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await kotaSwap(A,k++,i++,ext);
				else
					await kotaSwap(A,k++,j++,ext);
			}
			while(j<b)
				await kotaSwap(A,k++,j++,ext);
			await shift(A,k,i,m,false,ext);
		}
		async function dualMerge(A,a,m,b,l){
			if(b-m<=l){
				await mergeWithBuf(A,a,m,b,l);
			}else{
				let i=a,j=m,k=a-l;
				while(k<i&&i<m){
					if(compareIndices(A,i,j)<1)
						await kotaSwap(A,k++,i++,ext);
					else
						await kotaSwap(A,k++,j++,ext);
				}
				if(k<i)
					await shift(A,j-l,j,b,false,ext);
				else{
					let i2=m-1,j2=b-1;k=(m-1)+(b-j);
					while(i2>=i&&j2>=j){
						if(compareIndices(A,i2,j2)>0)
							await kotaSwap(A,k--,i2--,ext);
						else
							await kotaSwap(A,k--,j2--,ext);
					}
					while(j2>=j)
						await kotaSwap(A,k--,j2--,ext);
				}
			}
		}
		async function dualMergeBW(A,a,m,b,l){
			let i=m-1,j=b-1,k=b-1+l;
			while(k>j&&j>=m){
				if(compareIndices(A,i,j)>0)
					await kotaSwap(A,k--,i--,ext);
				else
					await kotaSwap(A,k--,j--,ext);
			}
			if(j<m)
				await shift(A,a,i+1,i+1+l,true,ext);
			else{
				let i2=a,j2=m;
				i++;j++;k=m-(i-a);
				while(i2<i&&j2<j){
					if(compareIndices(A,i2,j2)<1)
						await kotaSwap(A,k++,i2++,ext);
					else
						await kotaSwap(A,k++,j2++,ext);
				}
				while(i2<i)
					await kotaSwap(A,k++,i2++,ext);
			}
		}
		async function mergeWithBufStatic(A,a,m,b,p,bw){
			if(m-a<1||b-m<1)
				return;
			let i,j,k,q;
			if(bw){
				i=(b-m)-1;j=m-1;k=b-1;
				while(i>=0&&j>=a){
					if(compareIndices(A,p+i,j)<1){
						q=binarySearch(A,a,j+1,A[p+i],true);
						while(j>=q)await swap(A,k--,j--,1,true);
					}
					await swap(A,k--,p+i--,1,true);
				}
				while(i>=0)await swap(A,k--,p+i--,1,true);
			}else{
				i=0;j=m;k=a;
				while(i<m-a&&j<b){
					if(compareIndices(A,j,p+i)<0){
						q=binarySearch(A,j,b,A[p+i],true);
						while(j<q)await swap(A,k++,j++,1,true,false);
					}
					await swap(A,k++,p+(i++),1,true,false);
				}
				while(i<m-a){
					await swap(A,k++,p+(i++),1,true,false);
				}
			}
		}
		async function mergeExtBuf(A,a,b,bw){
			let i,j,k,m;
			if(bw){
				i=bfL-1;j=(b-1)-bfL;k=b-1;
				while(i>=0&&j>=a){
					if(compareValues(C[i],A[j])<1){
						m=binarySearch(A,a,j+1,C[i],true);
						while(j>=m)await write(A,k--,A[j--],1,true,false);
					}
					await write(A,k--,C[i--],1,true,false);
				}
				while(i>=0){
					await write(A,k--,C[i--],1,true,false);
				}
			}else{
				i=0;j=a+bfL;k=a;
				while(i<bfL&&j<b){
					if(compareValues(A[j],C[i])<0){
						m=binarySearch(A,j,b,C[i],true);
						while(j<m)await write(A,k++,A[j++],1,true,false);
					}
					await write(A,k++,C[i++],1,true,false);
				}
				while(i<bfL){
					await write(A,k++,C[i++],1,true,false);
				}
			}
		}
		async function kotaIterator(A,st,end,auxTag){
			let i=1,j,effst=st+bfL,ln=end-effst;
			if(!ext){
				while(i<16){
					for(j=effst;j+2*i<end;j+=2*i)
						await inPlaceMerge2(A,j,j+i,j+2*i);
					if(j+i<end)
						await inPlaceMerge2(A,j,j+i,end);
					i*=2;
				}
			}
			while(i<=bfL){
				let l=i;
				for(j=effst;j+2*i<end;j+=2*i)
					await mergeWithBuf(A,j,j+i,j+2*i,l);
				if(j+i<end)
					await mergeWithBuf(A,j,j+i,end,l);
				else
					await shift(A,j-l,j,end,false,ext);
				i*=2;
				for(j=effst-l;j+2*i<end-l;j+=2*i);
				if(j+i<end-l)
					await dualMergeBW(A,j,j+i,end-l,l);
				else
					await shift(A,j,end-l,end,true,ext);
				for(j-=2*i;j>=effst-l;j-=2*i)
					await dualMergeBW(A,j,j+i,j+2*i,l);
				i*=2;
				if(ext&&eM<minVal(i,bfL)){
					await arraycopy(C,0,A,effst-eM,eM,1,true);
					ext=false;
				}
			}
			while(i<ln){
				for(j=effst;j+2*i<end;j+=2*i)
					await blockMerge(A,j,j+i,j+2*i,auxTag);
				if(j+i<end)
					await blockMerge(A,j,j+i,end,auxTag);
				else
					await shift(A,j-bfL,j,end,false,ext);
				i*=2;
				if(i>=ln)return true;
				for(j=st;j+2*i<end-bfL;j+=2*i);
				if(j+i<end-bfL)
					await blockMergeBW(A,j,j+i,end-bfL,auxTag);
				else
					await shift(A,j,end-bfL,end,true,ext);
				for(j-=2*i;j>=st;j-=2*i)
					await blockMergeBW(A,j,j+i,j+2*i,auxTag);
				i*=2;
			}
			return false;
		}
		async function kotaSort(A,st,end){
			let ln=end-st;
			if(ln<129)return await inPlaceMergeSort2(A,st,end);
			ext=false;
			bfP=st;
			for(blL=1;blL*blL<ln;blL*=2);
			let ideal=blL*2;
			bfL=await findKeys(A,st,end,ideal);
			if(bfL<ideal)
				if(bfL==1)return;
				else if(bfL<17)return await inPlaceMergeSort2(A,st,end);
				else return await inPlaceMergeSort2(A,st,end);
			ideal=ln/blL|0;
			tL=await findKeys(A,st+bfL,end,ideal);
			if(tL<ideal)
				if(tL<17)return await inPlaceMergeSort2(A,st,end);
				else return await inPlaceMergeSort2(A,st,end);
			let bufst=st+tL;
			let effst=bufst+bfL;
			let bufEnd=st+bfL;
			await shift(A,st,bufEnd,effst,false,false);
			let bw=await kotaIterator(A,bufst,end,false);
			if(bw){
				let endst=end-bfL;
				await multiSwap(A,st,endst,tL,false);
				await mergeWithBufStatic(A,st,bufst,endst,endst,false);
				await inPlaceMergeSort2(A,endst,end);
				let mid=endst+blL;
				let pos=binarySearch(A,st,endst,A[mid-1],true);
				await rotate(A,pos,endst,mid);
				pos+=blL;
				await multiSwapBW(A,end-1,pos-1,blL,false);
				await mergeWithBufStatic(A,st,pos-blL,pos,mid,true);
				await inPlaceMergeSort2(A,mid,end);
				await inPlaceMergeBW(A,pos,mid,end);
			}else{
				await mergeWithBufStatic(A,bufEnd,effst,end,st,false);
				await inPlaceMergeSort2(A,st,bufEnd);
				let mid=st+blL;
				let pos=binarySearch(A,bufEnd,end,A[mid],true);
				await rotate(A,mid,bufEnd,pos);
				pos-=blL;
				await multiSwap(A,st,pos,blL,false);
				await mergeWithBufStatic(A,pos,pos+blL,end,st,false);
				await inPlaceMergeSort2(A,st,mid);
				await inPlaceMerge(A,st,mid,pos);
			}
		}
		await kotaSort(arr,0,len);
	}
	async baseNMaxHeapSort(len){
		let base=askForNum(4,"Base");
		async function siftDown(A,b,n,s){
			let l=n*b+1;
			if(l<s){
				let mx=l;
				for(let i=l+1;i<l+b;i++){
					if(i>=s)
						break;
					if(compareIndices(A,mx,i)<0)
						mx=i;
				}
				if(compareIndices(A,n,mx)<0){
					await swap(A,n,mx,0,true);
					await siftDown(A,b,mx,s);
				}
			}
		}
		for(let i=len-1;i>-1;i--)
			await siftDown(arr,base,i,len);
		for(let i=len-1;i>0;i--){
			await swap(arr,0,i,1,true);
			await siftDown(arr,base,0,i);
		}
	}
	async bingoSort(len){
		let mx=len-1;
		let nx=arr[mx];
		for(let i=mx-1;i>=0;i--)
			if(arr[i]>nx)
				nx=arr[i];
		while(mx>0&&arr[mx]==nx)mx--;
		while(mx>0){
			let v=nx;
			nx=arr[mx];
			for(let j=mx-1;j>=0;j--){
				if(!compareValues(arr[j],v))
					await swap(arr,j,mx--,2,true);
				else
					if(arr[j]>nx)
						nx=arr[j];
			}
			while(mx>0&&arr[mx]==nx)mx--;
		}
	}
	async cycleSort(len){
		function countLesser(A,a,b,t){
			let r=a;
			for(let i=a+1;i<b;i++)r+=compareValues(A[i],t)<0?1:0;
			return r;
		}
		for(let i=0;i<len-1;i++){
			let t=arr[i];
			let r=countLesser(arr,i,len,t);
			if(r-i){
				do{
					while(!compareIndexValue(arr,r,t))r++;
					let t1=arr[r];
					await write(arr,r,t,.02,true);
					t=t1;
					r=countLesser(arr,i,len,t);
				}while(r-i);
				await write(arr,i,t,.02,true);
			}
		}
	}
	async unstableGrailSort(len){
		async function grailSwap(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)
				await grailSwap(A,a++,b++);
		}
		async function grailRotate(A,p,lA,lB){
			while(lA&&lB){
				if(lA<=lB){
					await grailMultiSwap(A,p,p+lA,lA);
					p+=lA;
					lB-=lA;
				}else{
					await grailMultiSwap(A,p+lA-lB,p+lA,lB);
					lA-=lB;
				}
			}
		}
		function grailBinSearch(A,p,ln,kP,iL){
			let l=-1,r=ln;
			while(l<r-1){
				let m=l+((r-l)>>1);
				if(compareIndices(A,kP,p+m)<(iL?1:0))r=m;
				else l=m;
			}
			return r;
		}
		async function grailMergeWithoutBuffer(A,p,l1,l2){
			if(l1<l2){
				while(l1){
					let o=grailBinSearch(A,p+l1,l2,p,true);
					if(o){
						await grailRotate(A,p,l1,o);
						p+=o;
						l2-=o;
					}
					if(!l2)break;
					do{
						p++;l1--;
					}while(l1&&compareIndices(A,p,p+l1)<1);
				}
			}else{
				while(l2){
					let o=grailBinSearch(A,p,l1,p+l1+l2-1,false);
					if(o-l1){
						await grailRotate(A,p+o,l1-o,l2);
						l1=o;
					}
					if(!l1)break;
					do l2--;while(l2&&compareIndices(A,p+l1-1,p+l1+l2-1)<1);
				}
			}
		}
		async function grailMergeBuffersLeft(A,p,blC,bL,aBC,lL){
			if(!blC)return await grailMergeLeft(A,p,aBC*bL,lL,0-bL);
			let lOL=bL;
			let pI=bL;
			let rTP;
			for(let kI=1;kI<blC;kI++,pI+=bL){
				rTP=pI-lOL;
				lOL=await grailSmartMergeWithBuffer(A,p+rTP,lOL,bL);
			}
			rTP=pI-lOL;
			if(lL){
				lOL+=bL*aBC;
				await grailMergeLeft(A,p+rTP,lOL,lL,-bL);
			}else
				await grailMultiSwap(A,p+rTP,p+(rTP-bL),lOL);
		}
		async function grailMergeLeft(A,p,lL,rL,ds){
			let l=0;
			let r=lL;
			rL+=lL;
			while(r<rL){
				if(l==lL||compareIndices(A,p+l,p+r)>0)
					await grailSwap(A,p+(ds++),p+(r++));
				else await grailSwap(A,p+(ds++),p+(l++));
			}
			if(ds-l)await grailMultiSwap(A,p+ds,p+l,lL-l);
		}
		async function grailMergeRight(A,p,lL,rL,ds){
			let mP=lL+rL+ds-1;
			let r=lL+rL-1;
			let l=lL-1;
			while(l>=0){
				if(r<lL||compareIndices(A,p+l,p+r)>0)
					await grailSwap(A,p+(mP--),p+(l--));
				else await grailSwap(A,p+(mP--),p+(r--));
			}
			if(r-mP)
				while(r>=lL)await grailSwap(A,p+(mP--),p+(r--));
		}
		async function grailSmartMergeWithBuffer(A,p,lOL,bL){
			let ds=0-bL,l=0,r=lOL,lE=r,rE=r+bL;
			while(l<lE&&r<rE){
				if(compareIndices(A,p+l,p+r)<1)
					await grailSwap(A,p+(ds++),p+(l++));
				else await grailSwap(A,p+(ds++),p+(r++));
			}
			let ln;
			if(l<lE){
				ln=lE-l;
				while(l<lE)await grailSwap(A,p+(--lE),p+(--rE));
			}else
				ln=rE-r;
			return ln;
		}
		async function grailBuildBlocks(A,p,ln,uL){
			let eD,pt;
			for(let ds=1;ds<ln;ds+=2){
				eD=0;
				if(compareIndices(A,p+ds-1,p+ds)>0)eD=1;
				await grailSwap(A,p+ds-3,p+ds-1+eD);
				await grailSwap(A,p+ds-2,p+ds-eD);
			}
			if(ln%2!=0)await grailSwap(A,p+ln-1,p+ln-3);
			p-=2;pt=2;
			for(;pt<uL;pt*=2){
				let l=0;
				let r=ln-2*pt;
				while(l<=r){
					await grailMergeLeft(A,p+l,pt,pt,0-pt);
					l+=2*pt;
				}
				let rs=ln-l;
				if(rs>pt)
					await grailMergeLeft(A,p+l,pt,rs-pt,0-pt);
				else
					await grailRotate(A,p+l-pt,pt,rs);
				p-=pt;
			}
			let rTB=ln%(2*uL);
			let lOP=ln-rTB;
			if(rTB<=uL)await grailRotate(A,p+lOP,rTB,uL);
			else await grailMergeRight(A,p+lOP,uL,rTB-uL,uL);
			while(lOP>0){
				lOP-=2*uL;
				await grailMergeRight(A,p+lOP,uL,uL,uL);
			}
		}
		async function grailCombineBlocks(A,p,l,uL,rBL){
			let cL=l/(2*uL)|0;
			let lO=l%(2*uL);
			if(lO<=uL){
				l-=lO;
				lO=0;
			}
			for(let i=0;i<=cL;i++){
				if(i==cL&&!lO)break;
				let blP=p+i*2*uL;
				let blC=(i==cL?lO:2*uL)/rBL;
				for(let j=1;j<blC;j++){
					let lI=j-1;
					for(let rI=j;rI<blC;rI++){
						let rC=compareIndices(A,blP+lI*rBL,blP+rI*rBL);
						if(rC>0||(!rC&&compareIndices(A,blP+(lI+1)*rBL-1,blP+(rI+1)*rBL-1)>0))
							lI=rI;
					}
					if(lI!=j-1)
						await grailMultiSwap(A,blP+(j-1)*rBL,blP+lI*rBL,rBL);
				}
				let aBC=0;
				let lL=0;
				if(i==cL)lL=lO%rBL;
				if(lL)
					while(aBC<blC&&compareIndices(A,blP+blC*rBL,blP+(blC-aBC-1)*rBL)<0)
						await aBC++;
				await grailMergeBuffersLeft(A,blP,blC-aBC,rBL,aBC,lL);
			}
			while(--l>=0)
				await grailSwap(A,p+l,p+l-rBL);
		}
		async function grailCommonSort(A,p,l){
			if(l<=16)return await insertSort(A,p,l);
			let bL=1;
			while(bL*bL<l)bL*=2;
			let uL=bL;
			await grailBuildBlocks(A,p+bL,l-bL,uL);
			while(l-bL>(uL*=2))
				await grailCombineBlocks(A,p+bL,l-bL,uL,bL);
			await insertSort(A,p,bL);
			await grailMergeWithoutBuffer(A,p,bL,l-bL);
		}
		await grailCommonSort(arr,0,len);
	}
	async binomialHeapSort(len){
		let mN,f,i,d;
		for(i=2;i<=len;i+=2){
			mN=i;
			do{
				f=mN;
				for(d=1;(f&d)==0;d*=2)
					if(compareIndices(arr,f-d-1,mN-1)>0)
						mN=(f-d);
				if(f-mN)
					await swap(arr,f-1,mN-1,1,true);
			}while(f-mN);
		}
		for(i=len;i>2;i--){
			mN=f=i;
			for(d=1;f;d*=2){
				if(f&d){
					if(compareIndices(arr,f-1,mN-1)>0)
						mN=f;
					f-=d;
				}
			}
			if(mN-i){
				f=i;
				do{
					await swap(arr,f-1,mN-1,1,true);
					f=mN;
					for(d=1;(f&d)==0;d*=2)
						if(compareIndices(arr,f-d-1,mN-1)>0)
							mN=(f-d);
				}while(f-mN);
			}
		}
	}
	async binomialSmoothSort(len){
		function h(n){
			let c=0;
			while((n>>c)%2)c++;
			return c;
		}
		async function thrift(A,n,p,r){
			r=r&&(n>=(1<<h(n)));
			if(!r&&!p)return;
			let c=h(n)-(r?0:1);
			if(p)
				for(let j=c-1;j>=0;j--)
					if(compareIndices(A,n-(1<<c),n-(1<<j))<1)
						c=j;
			if(compareIndices(A,n-(1<<c),n)<1)return;
			await swap(A,n,n-(1<<c),.65,true);
			await thrift(A,n-(1<<c),(n-(1<<c))%2,c==h(n));
		}
		let n;
		for(n=1;n<len;n++)
			await thrift(arr,n,n%2,(n+(1<<h(n))>=len));
		for(n-=(n-1)%2;n>2;n-=2)
			for(let j=h(n)-1;j>=0;j--)
				await thrift(arr,n-(1<<j),false,true);
	}
	async bottomUpHeapSort(len){
		async function siftDown(A,i,b){
			let j=i;
			for(;2*j+1<b;j=2*j+2<b?(compareIndices(A,2*j+2,2*j+1)>0?2*j+2:2*j+1):2*j+1);
			for(;compareIndices(A,i,j)>0;j=(j-1)/2|0);
			for(;j>i;j=(j-1)/2|0)await swap(A,i,j,1,true);
		}
		for(let i=(len-1)/2|0;i>=0;i--)
			await siftDown(arr,i,len);
		for(let i=len-1;i>0;i--){
			await swap(arr,0,i,1,true);
			await siftDown(arr,0,i);
		}
	}
	async doubleSelectionSort(len){
		let l=0,r=len-1,s=0,b=0;
		while(l<=r){
			for(let i=l;i<=r;i++){
				if(compareIndices(arr,i,b)>0)
					b=i;
				if(compareIndices(arr,i,s)<0)
					s=i;
			}
			if(b==l)b=s;
			await swap(arr,l++,s,.02,true);
			await swap(arr,r--,b,.02,true);
			s=l;b=r;
		}
	}
	async flippedMinHeapSort(len){
		async function siftDown(A,l,r,d){
			while(r<=(d/2|0)){
				let f=2*r;
				if(f<d&&compareIndices(A,l-f,l-f-1)>0)
					f++;
				if(compareIndices(A,l-r,l-f)>0){
					await swap(A,l-r,l-f,0,true);
					r=f;
				}else break;
			}
		}
		for(let i=len/2|0;i>=1;i--)
			await siftDown(arr,len,i,len);
		for(let i=len;i>1;i--){
			await swap(arr,len-1,len-i,1,true);
			await siftDown(arr,len,1,i-1);
		}
	}
	async lazyHeapSort(len){
		async function maxToFront(A,a,b){
			let m=a;
			for(let i=a+1;i<b;i++)if(compareIndices(A,i,m)>0)m=i;
			await swap(A,m,a,1,true);
		}
		async function sort(A,l){
			let s=sqrt(l-1)+1|0;
			for(let i=0;i<l;i+=s)await maxToFront(A,i,minVal(i+s,l));
			for(let j=l;j>0;){
				let m=0;
				for(let i=m+s;i<j;i+=s)if(compareIndices(A,m,i)<1)m=i;
				await swap(A,m,--j,1,true);
				await maxToFront(A,m,minVal(m+s,j));
			}
		}
		await sort(arr,len);
	}
	async maxHeapSort(len){
		const hs=new HeapSorting(true);
		await hs.sort(arr,0,len);
	}
	async minHeapSort(len){
		const hs=new HeapSorting();
		await hs.sort(arr,0,len);
	}
	async minMaxHeapSort(len){
		function compare(x,y,g){
			if(g)[x,y]=[y,x];
			return compareValues(x,y)<0;
		}
		async function sw(i,j){
			await swap(a,i,j,1,true);
		}
		function isMin(i){
			i=i-s+1;
			return(32-clz32(i))&1;
		}
		async function downheap(i){
			let cf=!isMin(i);
			let lf=2*i+1;
			while(lf<e){
				let ri=lf+1;
				let nx=lf;
				for(let c of[ri,2*lf+1,2*lf+2,2*ri+1,2*ri+2]){
					if(c>=e)break;
					if(compare(a[c],a[nx],cf))
						nx=c;
				}
				if(nx<=ri){
					if(compare(a[nx],a[i],cf))
						await sw(nx,i);
					return;
				}else{
					if(compare(a[nx],a[i],cf)){
						await sw(nx,i);
						let p=(nx-1)/2|0;
						if(compare(a[p],a[nx],cf))
							await sw(nx,p);
					}else return;
				}
				i=nx;
				lf=2*i+1;
			}
		}
		async function heapify(){
			for(let i=(e-1)/2|0;i>=s;i--)
				await downheap(i);
		}
		async function store(){
			if(e<=s+1)return;
			let im=s+1;
			if(e>im+1&&compare(a[im],a[im+1],false))
				im++;
			await sw(im,--e);
			if(im<e)
				await downheap(im);
		}
		let a=arr;
		let s=0,e=len;
		await heapify();
		for(let i=e-1;i>s;i--)
			await store();
	}
	async outOfPlaceHeapSort(len){
		async function siftDown(A,i,b){
			let j=i;
			for(;2*j+1<b;j=2*j+2<b?(compareIndices(A,2*j+2,2*j+1)>0?2*j+2:2*j+1):2*j+1);
			for(;compareIndices(A,i,j)>0;j=(j-1)/2|0);
			for(;j>i;j=(j-1)/2|0)await swap(A,i,j,1,true);
		}
		async function findNext(A,b){
			let i=0,l=1,r=2;
			while(r<b&&!(A[l]==-1&&A[r]==-1)){
				if(A[l]==-1){
					await swap(A,i,r,1,true);
					i=r;
				}else if(A[r]==-1){
					await swap(A,i,l,1,true);
					i=l;
				}else if(compareValues(A[r],A[l])>0){
					await swap(A,i,r,1,true);
					i=r;
				}else{
					await swap(A,i,l,1,true);
					i=l;
				}
				l=2*i+1;
				r=l+1;
			}
			if(l<b&&A[l]+1)
				await swap(A,i,l,1,true);
		}
		for(let i=(len-1)/2|0;i>=0;i--)
			await siftDown(arr,i,len);
		let tmp=new Array(len);
		for(let i=len-1;i>=0;i--){
			write(tmp,i,arr[0],0,false,true);
			await write(arr,0,-1,1,true);
			await findNext(arr,len);
		}
		await arraycopy(tmp,0,arr,0,len,1,true);
	}
	async poplarHeapSort(len){
		function hyperfloor(n){
			return pow(2,log(n)/log(2)|0);
		}
		async function insertion(A,f,l){
			for(let c=f+1;c-l;++c){
				let s0=c,s1=c-1;
				if(compareIndices(A,s0,s1)<0){
					let t=A[s0];
					do await write(A,s0,A[s1],.25,true);while(--s0-f&&compareValues(t,A[--s1])<0);
					await write(A,s0,t,.1,true);
				}
			}
		}
		async function insSort(A,f,l){
			if(f-l)await insertion(A,f,l);
		}
		async function sift(A,f,z){
			if(z<2)return;
			let r=f+z-1,c1=r-1,c2=f+z/2-1|0;
			while(1){
				let mr=r;
				if(compareIndices(A,mr,c1)<0)mr=c1;
				if(compareIndices(A,mr,c2)<0)mr=c2;
				if(mr==r)return;
				await swap(A,r,mr,.1,true);
				z=z/2|0;
				if(z<2)return;
				r=mr;c1=r-1;c2=mr-z+z/2|0;
			}
		}
		async function popHeap(A,f,l,z){
			let pz=hyperfloor(z+1)-1,l_r=l-1,bg=l_r,bgz=pz,it=f;
			while(1){
				let r=it+pz-1;
				if(r==l_r)break;
				if(compareIndices(A,bg,r)<0){
					bg=r;bgz=pz;
				}
				it=r+1;
				z-=pz;
				pz=hyperfloor(z+1)-1;
			}
			if(bg-l_r){
				await swap(A,bg,l_r,.1,true);
				await sift(A,bg-bgz+1,bgz);
			}
		}
		async function heapify(A,f,l){
			let z=l-f;
			if(z<2)return;
			let smP=15;
			if(z<16)return await insertion(A,f,l);
			let pl=1,it=f,nx=it+smP;
			while(1){
				await insertion(A,it,nx);
				let pz=smP;
				for(let i=(pl&(-pl))>>1;i;i>>=1){
					it-=pz;
					pz=2*pz+1;
					await sift(A,it,pz);
					++nx;
				}
				if(l-nx<=smP)return await insSort(A,nx,l);
				it=nx;
				nx+=smP;
				++pl;
			}
		}
		async function sort(A,f,l){
			let z=l-f;
			if(z<2)return;
			do await popHeap(A,f,l--,z--);while(z>1);
		}
		await heapify(arr,0,len);
		await sort(arr,0,len);
	}
	async selectionSort(len){
		for(let i=0;i<len-1;i++){
			let li=i;
			for(let j=i+1;j<len;j++)
				if(compareIndices(arr,j,li)<0)
					li=j;
			await swap(arr,i,li,.02,true);
		}
	}
	async smoothSort(len){
		let LP=[1,1,3,5,9,15,25,41,67,109,177,287,465,753,1219,1973,3193,5167,8361,13529,21891];
		async function sift(A,ps,h){
			let v=A[h];
			while(ps>1){
				let rt=h-1,lf=h-1-LP[ps-2];
				if(compareValues(A[lf],v)<1&&compareValues(A[rt],v)<1)break;
				if(compareIndices(A,rt,lf)<1){
					await write(A,h,A[h=lf],.1,true);
					ps--;
				}else{
					await write(A,h,A[h=rt],.1,true);
					ps-=2;
				}
			}
			await write(A,h,v,.1,true);
		}
		async function trinkle(A,p,ps,h,T){
			let v=A[h];
			while(p-1){
				let ss=h-LP[ps];
				if(compareValues(A[ss],v)<1)break;
				if(!T&&ps>1){
					let rt=h-1,lf=h-1-LP[ps-2];
					if(compareIndices(A,ss,rt)<1||compareIndices(A,ss,lf)<1)break;
				}
				await write(A,h,A[h=ss],.65,true);
				let tr=ctz(p&~1);
				p>>=tr;ps+=tr;T=false;
			}
			if(T)return;
			await write(A,h,v,.1,true);
			await sift(A,ps,h);
		}
		async function smoothSort(A,lo,hi,F){
			let h=lo,p=1,ps=1;
			while(h<hi){
				if((p&3)==3){
					await sift(A,ps,h);
					p>>=2;ps+=2;
				}else{
					if(LP[ps-1]>=hi-h)await trinkle(A,p,ps,h,false);
					else await sift(A,ps,h);
					if(ps==1){
						p<<=1;ps--;
					}else{
						p<<=ps-1;ps=1;
					}
				}
				p|=1;h++;
			}
			if(F){
				await trinkle(A,p,ps,h,false);
				while(ps-1||p-1){
					if(ps<2){
						let t=ctz(p&~1);
						p>>=t;ps+=t;
					}else{
						p<<=2;p^=7;ps-=2;
						await trinkle(A,p>>1,ps+1,h-LP[ps]-1,true);
						await trinkle(A,p,ps,h-1,true);
					}
					h--;
				}
			}
		}
		await smoothSort(arr,0,len-1,true);
	}
	async stableCycleSort(len){
		function getBit(t,i){
			let b=(t[i>>3])>>(i&((1<<3)-1))&1;
			return b>0;
		}
		function flag(t,i){
			write(t,i>>3,t[i>>3]|(1<<(i&((1<<3)-1))),0,false,true);
		}
		function dest(A,T,a,b1,b){
			let d=a,e=0;
			for(let i=a+1;i<b;i++){
				let c=compareIndices(A,i,a);
				if(c<0)d++;
				else if(i<b1&&!getBit(T,i)&&!c)e++;
			}
			while(getBit(T,d)||e-->0)d++;
			return d;
		}
		let bits=new Array(((len-1)>>3)+1);
		for(let i=0;i<len-1;i++)
			if(!getBit(bits,i)){
				let j=i;
				do{
					let k=dest(arr,bits,i,j,len);
					await swap(arr,i,k,.02,true);
					flag(bits,k);
					j=k;
				}while(j-i);
			}
	}
	async stableSelectionSort(len){
		for(let i=0;i<len-1;i++){
			let n=i;
			for(let j=i+1;j<len;j++)
				if(compareIndices(arr,j,n)<0)
					n=j;
			let t=arr[n];
			let p=n;
			while(p>i)
				await write(arr,p,arr[--p],0,true);
			await write(arr,p,t,0,true);
		}
	}
	async ternaryHeapSort(len){
		let hS;
		async function heapify(A,i){
			let lC=3*i+1;
			let rC=3*i+3;
			let mC=3*i+2;
			let lr;
			lr=lC<=hS&&compareIndices(A,lC,i)>0?lC:i;
			if(rC<=hS&&compareIndices(A,rC,lr)>0)
				lr=rC;
			if(mC<=hS&&compareIndices(A,mC,lr)>0)
				lr=mC;
			if(lr-i){
				await swap(A,i,lr,1,true);
				await heapify(A,lr);
			}
		}
		async function buildHeap(A,l){
			hS=l-1;
			for(let i=l-1;i>=0;i--)
				await heapify(A,i);
		}
		await buildHeap(arr,len);
		for(let i=len-1;i>=0;i--){
			await swap(arr,0,i,1,true);
			hS--;
			await heapify(arr,0);
		}
	}
	async tournamentSort(len){
		async function tC(a,b){
			draw();
			await markSwap(a,b);
			return compareValues(a,b);
		}
		function isPlayer(i){
			return i<=0;
		}
		function setWinner(r,w){
			write(aux,r,w,0,false,true);
		}
		function setWinners(r,w){
			write(aux,r+1,w,0,false,true);
		}
		function setLosers(r,l){
			write(aux,r+2,l,0,false,true);
		}
		function getWinner(r){
			return aux[r];
		}
		function getWinners(r){
			return aux[r+1];
		}
		function getLosers(r){
			return aux[r+2];
		}
		function setMatch(r,w,s,l){
			setWinner(r,w);
			setWinners(r,s);
			setLosers(r,l);
		}
		function getPlayer(i){
			return i<=0?abs(i):getWinner(i);
		}
		async function pop(A){
			let r=A[getPlayer(t)];
			t=isPlayer(t)?0:await rebuild(arr,t);
			return r;
		}
		function makePlayer(i){
			return-i;
		}
		async function makeMatch(A,t,b,r){
			let tw=getPlayer(t);
			let bw=getPlayer(b);
			if(await tC(A[tw],A[bw])<1)
				setMatch(r,tw,t,b);
			else
				setMatch(r,bw,b,t);
			return r;
		}
		async function knockout(A,i,k,r){
			if(i==k)return makePlayer(i);
			let j=(i+k)/2|0;
			return await makeMatch(A,await knockout(A,i,j,2*r),await knockout(A,j+1,k,(2*r)+3),r);
		}
		async function rebuild(A,r){
			if(isPlayer(getWinners(r)))
				return getLosers(r);
			setWinners(r,await rebuild(A,getWinners(r)));
			if(await tC(A[getPlayer(getLosers(r))],A[getPlayer(getWinners(r))])<0){
				setWinner(r,getPlayer(getLosers(r)));
				let tm=getLosers(r);
				setLosers(r,getWinners(r));
				setWinners(r,tm);
			}else{
				setWinner(r,getPlayer(getWinners(r)));
			}
			return r;
		}
		async function sort(A,l){
			let c=new Array(l);
			for(let i=0;i<l;i++){
				let r=await pop(A);
				draw();
				write(c,i,r,1,false,true);
			}
			await arraycopy(c,0,A,0,l,1,true);
		}
		let aux=new Array(6*len);
		let t=await knockout(arr,0,len-1,3);
		await sort(arr,len);
	}
	async triangularHeapSort(len){
		function triangularRoot(v){
			return(sqrt(8*v+1)-1|0)/2|0;
		}
		async function sift(A,e,r){
			let tm=A[r];
			let ln=triangularRoot(r);
			let lo=r+ln+1;
			let hi=lo+1;
			while(lo<e){
				if(hi>=e){
					if(compareValues(A[lo],tm)>0)
						await write(A,r,A[lo],0,true);
					break;
				}
				let x=compareIndices(A,hi,lo)<1?lo:hi;
				if(compareValues(A[x],tm)>0){
					await write(A,r,A[x],0,true);
					r=x;
					ln=triangularRoot(r);
					lo=r+ln+1;
					hi=lo+1;
					continue;
				}
				break;
			}
			await write(A,r,tm,0,true);
		}
		async function heapify(A,l){
			for(let i=l-1;i>=0;i--)
				await sift(A,l,i);
		}
		await heapify(arr,len);
		for(let i=1;i<len-1;i++){
			await swap(arr,0,len-i,.5,true);
			await sift(arr,len-i,0);
		}
		if(compareIndices(arr,0,1)>0)swap(arr,0,1,.5,true);
	}
	async weakHeapSort(len){
		function flag(T,x){
			return(T[x>>3]>>(x&7))&1;
		}
		function toggle(T,x){
			let flag=T[x>>3];
			flag^=1<<(x&7);
			write(T,(x)>>3,flag,0,true,true);
		}
		async function heapMerge(A,T,i,j){
			if(compareIndices(A,i,j)<0){
				toggle(T,j);
				await swap(A,i,j,1,true);
			}
		}
		let n=len;
		let i,j,x,y,gp;
		let T=new Array((n+7)/8|0);
		for(i=0;i<n/8|0;++i)
			await write(T,i,0,0,false,true);
		for(i=n-1;i>0;--i){
			j=i;
			while((j&1)==flag(T,j>>1))j>>=1;
			gp=j>>1;
			await heapMerge(arr,T,gp,i);
		}
		for(i=n-1;i>=2;--i){
			await swap(arr,0,i,1,true,false);
			x=1;
			while((y=2*x+flag(T,x))<i)x=y;
			while(x>0){
				await heapMerge(arr,T,0,x);
				x>>=1;
			}
		}
		await swap(arr,0,1,1,true);
	}
	async chaliceSort(len){
		const bms=new BlockMergeSorting();
		const hs=new HeapSorting(true);
		function ceilCbrt(n){
			let a=0,b=11;
			while(a<b){
				let m=(a+b)/2|0;
				if((1<<3*m)>=n)b=m;
				else a=m+1;
			}
			return 1<<a;
		}
		function calcKeys(bL,n){
			let a=1,b=n/4|0;
			while(a<b){
				let m=(a+b)/2|0;
				if(((n-4*m-1)/bL|0)-2<m)b=m;
				else a=m+1;
			}
			return a;
		}
		async function laziestSortExt(A,T,a,b){
			for(let i=a,s=T.length;i<b;i+=s){
				let j=minVal(b,i+s);
				await bms.binaryInsertion(A,i,j);
				if(i>a)await bms.mergeBWExt(A,T,a,i,j);
			}
		}
		async function findKeysSm(A,a,b,a1,b1,f,n){
			let p=a,pE=0;
			if(f){
				for(;p<b;p++){
					let o=bms.leftBinSearch(A,a1,b1,A[p]);
					if(o==b1||compareIndices(A,p,o)){
						pE=p+1;
						break;
					}
				}
				if(pE){
					for(let i=pE;i<b&&pE-p<n;i++){
						let o=bms.leftBinSearch(A,a1,b1,A[i]);
						if(o==b1||compareIndices(A,i,o)){
							o=bms.leftBinSearch(A,p,pE,A[i]);
							if(o==pE||compareIndices(A,i,o)){
								await bms.rotate(A,p,pE,i);
								let l1=i-pE;
								p+=l1;o+=l1;pE=i+1;
								await bms.insertTo(A,i,o);
							}
						}
					}
				}else pE=p;
			}else{
				pE=p+1;
				for(let i=pE;i<b&&pE-p<n;i++){
					let o=bms.leftBinSearch(A,p,pE,A[i]);
					if(o==pE||compareIndices(A,i,o)){
						await bms.rotate(A,p,pE,i);
						let l1=i-pE;
						p+=l1;o+=l1;pE=i+1;
						await bms.insertTo(A,i,o);
					}
				}
			}
			return[p,pE];
		}
		async function findKeys(A,T,a,b,n,s){
			let t=await findKeysSm(A,a,b,0,0,false,minVal(n,s));
			let p=t[0],pE=t[1];
			if(s<n&&pE-p==s){
				for(n-=s;;n-=s){
					t=await findKeysSm(A,pE,b,p,pE,true,minVal(s,n));
					let ks=t[1]-t[0];
					if(ks==0)break;
					if(ks<s||n==s){
						await bms.rotate(A,pE,t[0],t[1]);
						t[0]=pE;
						pE+=ks;
						await bms.mergeBWExt(A,T,p,t[0],pE);
						break;
					}else{
						await bms.rotate(A,p,pE,t[0]);
						p+=t[0]-pE;
						pE=t[1];
						await bms.mergeBWExt(A,T,p,t[0],pE);
					}
				}
			}
			await bms.rotate(A,a,p,pE);
			return pE-p;
		}
		async function findBitsSM(A,a,b,a1,bw,n){
			let p=a,pE,cmp=bw?-1:1;
			while(p<b&&compareIndices(A,p,a1)-cmp)p++;
			a1++;
			if(p<b){
				pE=p+1;
				for(let i=pE;i<b&&pE-p<n;i++){
					if(compareIndices(A,i,a1)==cmp){
						await bms.rotate(A,p,pE,i);
						p+=i-pE;pE=i+1;a1++;
					}
				}
			}else pE=p;
			return[p,pE];
		}
		async function findBits(A,T,a,b,n,s){
			await laziestSortExt(A,T,a,a+n);
			let a0=a,a1=a+n,c=0,c0=0;
			for(let i=0;c<n&&i<2;i++){
				let p=a1,pE=p;
				while(1){
					let t=await findBitsSM(A,pE,b,a0,i==1,minVal(s,n-c));
					let bs=t[1]-t[0];
					if(!bs)break;
					a0+=bs;
					c+=bs;
					if(bs<s||c==n){
						await bms.rotate(A,pE,t[0],t[1]);
						t[0]=pE;
						pE+=bs;
						break;
					}else{
						await bms.rotate(A,p,pE,t[0]);
						p+=t[0]-pE;
						pE=t[1];
					}
				}
				await bms.rotate(A,a1,p,pE);
				a1+=pE-p;
				if(!i)c0=c;
			}
			if(c<n)return-1;
			else{
				await bms.multiSwap(A,a+c0,a+n+c0,n-c0);
				return c0;
			}
		}
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		async function unshuffle(A,a,b){
			let l=(b-a)>>1,c=0;
			for(let n=2;l>0;l>>=1,n*=2){
				if(l&1){
					let a1=a+c;
					await bitReversal(A,a1,a1+n);
					await bitReversal(A,a1,a1+n/2|0);
					await bitReversal(A,a1+n/2|0,a1+n);
					await bms.rotate(A,a+c/2|0,a1,a1+n/2|0);
					c+=n;
				}
			}
		}
		async function redistBuffer(A,T,a,m,b){
			let s=T.length;
			while(m-a>s&&m<b){
				let i=bms.leftBinSearch(A,m,b,A[a+s]);
				await bms.rotate(A,a+s,m,i);
				let t=i-m;
				m=i;
				await bms.mergeFWExt(A,T,a,a+s,m);
				a+=t+s;
			}
			if(m<b)await bms.mergeFWExt(A,T,a,m,b);
		}
		async function dualMergeBW(A,a,m,b,p){
			let i=m-1;b--;
			while(p>b+1&&b>=m){
				if(compareIndices(A,i,b)<1)
					await swap(A,--p,b--,1,true);
				else
					await swap(A,--p,i--,1,true);
			}
			if(b<m)await bms.shiftBW(A,a,i+1,p);
			else{
				i++;b++;p=m-i+a;
				while(a<i&&m<b){
					if(compareIndices(A,a,m)<1)
						await swap(A,p++,a++,1,true);
					else
						await swap(A,p++,m++,1,true);
				}
				while(a<i)await swap(A,p++,a++,1,true);
			}
		}
		async function dualMergeBWEXT(A,a,m,b,p){
			let i=m-1;b--;
			while(p>b+1&&b>=m){
				if(compareIndices(A,i,b)<1)
					await write(A,--p,A[b--],1,true);
				else
					await write(A,--p,A[i--],1,true);
			}
			if(b<m)await bms.shiftBWExt(A,a,i+1,p);
			else{
				i++;b++;p=m-i+a;
				while(a<i&&m<b){
					if(compareIndices(A,a,m)<1)
						await write(A,p++,A[a++],1,true);
					else
						await write(A,p++,A[m++],1,true);
				}
				while(a<i)await write(A,p++,A[a++],1,true);
			}
		}
		async function smartMerge(A,p,a,m,r){
			let i=m,cmp=r?0:1;
			while(a<m){
				if(compareIndices(A,a,i)<cmp)
					await write(A,p++,A[a++],1,true);
				else
					await write(A,p++,A[i++],1,true);
			}
			return i;
		}
		async function smartTailMerge(A,T,p,a,m,b){
			let i=m,bL=T.length;
			while(a<m&&i<b){
				if(compareIndices(A,a,i)<1)
					await write(A,p++,A[a++],1,true);
				else
					await write(A,p++,A[i++],1,true);
			}
			if(a<m){
				if(a>p)await bms.shiftFWExt(A,p,a,m);
				await arraycopy(T,0,A,b-bL,bL,1,true);
			}else{
				a=0;
				while(a<bL&&i<b){
					if(compareValues(T[a],A[i])<1)
						await write(A,p++,T[a++],1,true);
					else
						await write(A,p++,A[i++],1,true);
				}
				while(a<bL)await write(A,p++,T[a++],1,true);
			}
		}
		async function blockCycle(A,a,t,tIdx,tLen,bL){
			for(let i=0;i<tLen-1;i++){
				if(compareIndices(A,t+i,tIdx+i)>0||(i>0&&compareIndices(A,t+i,tIdx+i-1)<0)){
					await arraycopy(A,a+i*bL,A,a-bL,bL,1,true);
					let val=i,next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					do{
						await arraycopy(A,a+next*bL,A,a+val*bL,bL,1,true);
						await swap(A,t+i,t+next,1,true);
						val=next;
						next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					}while(next!=i);
					await arraycopy(A,a-bL,A,a+val*bL,bL,1,true);
				}
			}
		}
		async function blockMerge(A,T,a,m,b,tl,tLen,t,tIdx,bp1,bp2,bL){
			if(b-m<=bL){
				await bms.mergeBWExt(A,T,a,m,b);
				return;
			}
			await bms.insertTo(A,t+tl-1,t);
			let i=a+bL-1,j=m+bL-1,ti=t,tj=t+tl,tp=tIdx;
			while(ti<t+tl&&tj<t+tLen){
				if(compareIndices(A,i,j)<1){
					await swap(A,tp++,ti++,1,true);
					i+=bL;
				}else{
					await swap(A,tp++,tj++,1,true);
					await swap(A,bp1,bp2,1,true);
					j+=bL;
				}
				bp1++;bp2++;
			}
			while(ti<t+tl){
				await swap(A,tp++,ti++,1,true);
				bp1++;bp2++;
			}
			while(tj<t+tLen){
				await swap(A,tp++,tj++,1,true);
				await swap(A,bp1++,bp2++,1,true);
			}
			t^=tIdx;tIdx^=t;t^=tIdx;
			await hs.sort(A,tIdx,tIdx+tLen);
			arraycopy(A,m-bL,T,0,bL,0,false,true);
			await arraycopy(A,a,A,m-bL,bL,1,true);
			await blockCycle(A,a+bL,t,tIdx,tLen,bL);
			await bms.multiSwap(A,t,tIdx,tLen);
			bp1-=tLen;bp2-=tLen;
			let f=a+bL,a1=f,bp3=bp2+tLen;
			let rev=compareIndices(A,bp1,bp2)>0;
			while(1){
				do{
					if(rev)await swap(A,bp1,bp2,1,true);
					bp1++;bp2++;
					a1+=bL;
				}
				while(bp2<bp3&&compareIndices(A,bp1,bp2)==(rev?1:-1));
				if(bp2==bp3){
					await smartTailMerge(A,T,f-bL,f,rev?f:a1,b);
					return;
				}
				f=await smartMerge(A,f-bL,f,a1,rev);
				rev=!rev;
			}
		}
		async function blockCycleEasy(A,a,t,tIdx,tLen,bL){
			for(let i=0;i<tLen-1;i++){
				if(compareIndices(A,t+i,tIdx+i)>0||(i>0&&compareIndices(A,t+i,tIdx+i-1)<0)){
					let next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					do{
						await bms.multiSwap(A,a+i*bL,a+next*bL,bL);
						await swap(A,t+i,t+next,1,true);
						next=bms.leftBinSearch(A,tIdx,tIdx+tLen,A[t+i])-tIdx;
					}while(next!=i);
				}
			}
		}
		async function inPlaceMergeBW(A,a,m,b,rev){
			let f=rev?bms.rightBinSearch(A,m,b,A[m-1]):bms.leftBinSearch(A,m,b,A[m-1]);
			b=f;
			while(b>m&&m>a){
				let i=rev?bms.leftBinSearch(A,a,m,A[b-1]):bms.rightBinSearch(A,a,m,A[b-1]);
				await bms.rotate(A,i,m,b);
				let t=m-i;
				m=i;
				b-=t+1;
				if(m==a)break;
				b=rev?bms.rightBinSearch(A,m,b,A[m-1]):bms.leftBinSearch(A,m,b,A[m-1]);
			}
			return f;
		}
		async function blockMergeEasy(A,a,m,b,lA,lB,tl,tLen,t,tIdx,bp1,bp2,bL){
			if(b-m<=bL){
				await inPlaceMergeBW(A,a,m,b,false);
				return;
			}
			let a1=a+lA,b1=b-lB;
			let i=a1+bL-1,j=m+bL-1,ti=tIdx,tj=tIdx+tl,tp=t;
			while(ti<tIdx+tl&&tj<tIdx+tLen){
				if(compareIndices(A,i,j)<1){
					await swap(A,ti++,tp++,1,true);
					i+=bL;
				}else{
					await swap(A,tj++,tp++,1,true);
					await swap(A,bp1,bp2,1,true);
					j+=bL;
				}
				bp1++;bp2++;
			}
			while(ti<tIdx+tl){
				await swap(A,ti++,tp++,1,true);
				bp1++;bp2++;
			}
			while(tj<tIdx+tLen){
				await swap(A,tj++,tp++,1,true);
				await swap(A,bp1++,bp2++,1,true);
			}
			t^=tIdx;tIdx^=t;t^=tIdx;
			await hs.sort(A,tIdx,tIdx+tLen);
			await blockCycleEasy(A,a1,t,tIdx,tLen,bL);
			await bms.multiSwap(A,t,tIdx,tLen);
			bp1-=tLen;bp2-=tLen;
			let f=a1,a2=f,bp3=bp2+tLen;
			let rev=compareIndices(A,bp1,bp2)>0;
			while(1){
				do{
					if(rev)await swap(A,bp1,bp2,1,true);
					bp1++;bp2++;
					a2+=bL;
				}while(bp2<bp3&&compareIndices(A,bp1,bp2)==(rev?1:-1));
				if(bp2==bp3){
					if(!rev)await inPlaceMergeBW(A,a1,b1,b,false);
					await bms.inPlaceMerge(A,a,a1,b);
					return;
				}
				f=await inPlaceMergeBW(A,f,a2,a2+bL,rev);
				rev=!rev;
			}
		}
		async function sort(A,l){
			let a=0,b=l,n=b-a;
			if(n<128){
				if(n<32)await bms.binaryInsertion(A,a,b);
				else await Sorts.prototype.fifthMergeSort(l);
				return;
			}
			let cbr=2*ceilCbrt(n/4|0),bL=2*cbr;
			let kL=calcKeys(bL,n);
			let T=new Array(bL);
			let ks=await findKeys(A,T,a,b,2*kL,cbr);
			if(ks<8){
				for(let j=1;j<n;j*=2)
					for(let i=a+j;i<b;i+=2*j)
						await inPlaceMergeBW(A,i-j,i,minVal(i+j,b),false);
				return;
			}else if(ks<2*kL){
				ks-=ks%4;
				kL=ks/2|0;
			}
			let a1=a+ks,a2=a1+ks,bSep=await findBits(A,T,a1,b,kL,cbr);
			if(bSep==-1){
				await laziestSortExt(A,T,a,a2);
				await bms.inPlaceMerge(A,a,a2,b);
				return;
			}
			let a3=a2+bL,i,j=1;n=b-a3;
			await bms.binaryInsertion(A,a2,a3);
			arraycopy(A,a2,T,0,bL,0,false,true);
			for(;j<cbr;j*=2){
				let p=maxVal(2,j);
				for(i=a3;i+2*j<b;i+=2*j)
					await bms.mergeWithBufFWExt(A,i,i+j,i+2*j,i-p);
				if(i+j<b)await bms.mergeWithBufFWExt(A,i,i+j,b,i-p);
				else await bms.shiftFWExt(A,i-p,i,b);
				a3-=p;b-=p;
			}
			i=b-n%(2*j);
			if(i+j<b)await bms.mergeWithBufBWExt(A,i,i+j,b,b+j);
			else await bms.shiftBWExt(A,i,b,b+j);
			for(i-=2*j;i>=a3;i-=2*j)
				await bms.mergeWithBufBWExt(A,i,i+j,i+2*j,i+3*j);
			a3+=j;b+=j;j*=2;
			for(i=a3;i+2*j<b;i+=2*j)
				await bms.mergeWithBufFWExt(A,i,i+j,i+2*j,i-j);
			if(i+j<b)await bms.mergeWithBufFWExt(A,i,i+j,b,i-j);
			else await bms.shiftFWExt(A,i-j,i,b);
			a3-=j;b-=j;j*=2;
			i=b-n%(2*j);
			if(i+j<b)await dualMergeBWEXT(A,i,i+j,b,b+j/2|0);
			else await bms.shiftBWExt(A,i,b,b+j/2|0);
			for(i-=2*j;i>=a3;i-=2*j)
				await dualMergeBWEXT(A,i,i+j,i+2*j,i+2*j+j/2|0);
			a3+=j/2|0;b+=j/2|0;j*=2;
			if(ks>=j){
				await bms.rotate(A,a,a1,a3);
				a2=a1+bL;
				if(kL>=j){
					for(let mLvl=2*j;j<kL;j*=2){
						let p=maxVal(mLvl,j);
						for(i=a3;i+2*j<b;i+=2*j)
							await bms.mergeWithBufFW(A,i,i+j,i+2*j,i-p);
						if(i+j<b)await bms.mergeWithBufFW(A,i,i+j,b,i-p);
						else await bms.shiftFW(A,i-p,i,b);
						a3-=p;b-=p;
					}
					i=b-n%(2*j);
					if(i+j<b)await bms.mergeWithBufBW(A,i,i+j,b,b+j);
					else await bms.shiftBW(A,i,b,b+j);
					for(i-=2*j;i>=a3;i-=2*j)
						await bms.mergeWithBufBW(A,i,i+j,i+2*j,i+3*j);
					a3+=j;b+=j;j*=2;
				}
				if(ks>=j){
					for(i=a3;i+2*j<b;i+=2*j)
						await bms.mergeWithBufFW(A,i,i+j,i+2*j,i-j);
					if(i+j<b)await bms.mergeWithBufFW(A,i,i+j,b,i-j);
					else await bms.shiftFW(A,i-j,i,b);
					a3-=j;b-=j;j*=2;
					i=b-n%(2*j);
					if(i+j<b)await dualMergeBW(A,i,i+j,b,b+j/2|0);
					else await bms.shiftBW(A,i,b,b+j/2|0);
					for(i-=2*j;i>=a3;i-=2*j)
						await dualMergeBW(A,i,i+j,i+2*j,i+2*j+j/2|0);
					a3+=j/2|0;b+=j/2|0;j*=2;
				}
				await bms.rotate(A,a,a2,a3);
				a2=a1+ks;
				await hs.sort(A,a,a1);
			}
			await arraycopy(T,0,A,a2,bL,1,true);
			await unshuffle(A,a,a1);
			let limit=bL*(kL+2);
			for(let k=j/bL-1;j<n&&minVal(2*j,n)<=limit;j*=2,k=2*k+1){
				for(i=a3;i+2*j<=b;i+=2*j)
					await blockMerge(A,T,i,i+j,i+2*j,k,2*k,a,a+kL,a1,a1+kL,bL);
				if(i+j<b)
					await blockMerge(A,T,i,i+j,b,k,(b-i-1)/bL-1|0,a,a+kL,a1,a1+kL,bL);
			}
			for(;j<n;j*=2){
				bL=(2*j)/kL|0;
				let lA=j%bL,lB=lA;
				for(i=a3;i+2*j<=b;i+=2*j)
					await blockMergeEasy(A,i,i+j,i+2*j,lA,lB,kL/2|0,kL,a,a+kL,a1,a1+kL,bL);
				if(i+j<b)
					await blockMergeEasy(A,i,i+j,b,lA,(b-i-j)%bL,kL/2|0,(kL/2|0)+(b-i-j)/bL|0,a,a+kL,a1,a1+kL,bL);
			}
			await bms.multiSwap(A,a1+bSep,a1+kL+bSep,kL-bSep);
			await laziestSortExt(A,T,a,a3);
			await redistBuffer(A,T,a,a3,b);
		}
		await sort(arr,len);
	}
	async fifthMergeSort(len){
		async function mergeInPlaceForwards(A,b,s,m,e){
			let l=s,r=m;
			while(l<m&&r<e)
				if(compareIndices(A,l,r)<1)await write(A,b++,A[l++],.5,true);
				else await write(A,b++,A[r++],.5,true);
			while(l<m)
				await write(A,b++,A[l++],.5,true);
			while(r<e)
				await write(A,b++,A[r++],.5,true);
		}
		async function mergeInPlaceBackwards(A,b,bfL,m,e){
			let l=m-1,r=e-1;
			while(b>r&&r>=m)
				if(compareIndices(A,l,r)>0)await write(A,b--,A[l--],.5,true);
				else await write(A,b--,A[r--],.5,true);
			if(r==l)
				while(r>=0)
					await write(A,b--,A[r--],.5,true);
			else if(r<m)
				while(l>=0)
					await write(A,b--,A[l--],.5,true);
			return[l+1,r+1];
		}
		async function mergeForwardsWithBuffer(A,b,d,l,lE,m,e){
			let r=m;
			while(l<lE&&r<e)
				if(compareValueIndex(A,b[l],r)<1)await write(A,d++,b[l++],.5,true);
				else await write(A,d++,A[r++],.5,true);
			while(l<lE)
				await write(A,d++,b[l++],.5,true);
		}
		async function merge(A,b,co,s,m,e,fr){
			let f,t;
			let w;
			if(fr){
				f=b;t=A;w=s;s-=co;m-=co;e-=co;
			}else{
				f=A;t=b;w=s-co;
			}
			let l=s,r=m;
			while(l<m&&r<e)
				if(compareIndices(f,l,r)<1){
					write(t,w++,f[l++],.5,fr,!fr);
					if(fr)await sleep();
				}else{
					write(t,w++,f[r++],.5,fr,!fr);
					if(fr)await sleep();
				}
			while(l<m){
				write(t,w++,f[l++],.5,true,!fr);
				if(fr)await sleep();
			}
			while(r<e){
				write(t,w++,f[r++],.5,true,!fr);
				if(fr)await sleep();
			}
		}
		async function pingPong(A,b,s,e){
			let i;
			for(i=s;i+8<e;i+=8)
				await binaryInsertion(A,i,i+8);
			if(e-i>1)
				await binaryInsertion(A,i,e);
			let l=e-s;
			let fr=false;
			for(let g=8;g<l;g*=2){
				let fm=g*2;
				for(i=s;i+fm<e;i+=fm)
					await merge(A,b,s,i,i+g,i+fm,fr);
				if(i+g<e)await merge(A,b,s,i,i+g,e,fr);
				else
					if(fr)
						await arraycopy(b,i-s,A,i,e-i,.5,true);
					else
						await arraycopy(A,i,b,i-s,e-i,.5,true);
				fr=!fr;
			}
			if(fr)
				await arraycopy(b,0,A,s,l,.5,true);
		}
		async function fifthMergeSort(A,l){
			let fL=len/5|0;
			let bfL=len-fL*4;
			let b=new Array(bfL);
			await pingPong(A,b,0,bfL);
			for(let i=0,s=bfL;i<4;i++,s+=fL)
				await pingPong(A,b,s,s+fL);
			arraycopy(A,0,b,0,bfL,0,false,true);
			let tF=2*fL;
			for(let i=0,s=bfL;i<2;i++,s+=tF)
				await mergeInPlaceForwards(A,s-bfL,s,s+fL,s+tF);
			let fm=await mergeInPlaceBackwards(A,l-1,bfL,tF,2*tF);
			if(fm[1]>0)
				await mergeForwardsWithBuffer(A,A,bfL,0,fm[0],tF,l);
			await mergeForwardsWithBuffer(A,b,0,0,bfL,bfL,l);
		}
		await fifthMergeSort(arr,len);
	}
	async flanSort(len){
		const mwms=new MultiWayMergeSorting();
		function medianOfThree(A,a,m,b){
			if(compareIndices(A,m,a)>0){
				if(compareIndices(A,m,b)<0)return m;
				if(compareIndices(A,a,b)>0)return a;
				else return b;
			}else{
				if(compareIndices(A,m,b)>0)return m;
				if(compareIndices(A,a,b)<0)return a;
				else return b;
			}
		}
		function ninther(A,a,b){
			let s=(b-a)/9|0;
			return medianOfThree(A,medianOfThree(A,a,a+s,a+2*s),medianOfThree(A,a+3*s,a+4*s,a+5*s),medianOfThree(A,a+6*s,a+7*s,a+8*s));
		}
		function medianOfThreeNinthers(A,a,b){
			let s=(b-a)/3|0;
			return medianOfThree(A,ninther(A,a,a+s),ninther(A,a+s,a+2*s),ninther(A,a+2*s,b));
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await swap(A,--b,--m,1,true);
		}
		function leftBlockSearch(A,a,b,v){
			let s=15;
			while(a<b){
				let m=a+(((b-a)/s|0)/2|0)*s;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+s;
			}
			return a;
		}
		function rightBlockSearch(A,a,b,v){
			let s=15;
			while(a<b){
				let m=a+(((b-a)/s|0)/2|0)*s;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+s;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v,w){
			let c=w?1:-1;
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])==c)b=m;
				else a=m+1;
			}
			return a;
		}
		async function insertTo(A,t,a,b){
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,A[i],i,rightBinSearch(A,a,i,A[i],false));
		}
		async function kWayMerge(A,h,t,s,b,p,z){
			if(z<2){
				if(z)while(t[0]<b)await swap(A,p++,t[0]++,1,true);
				return;
			}
			let a=t[0];
			for(let i=0;i<z;i++)
				write(h,i,i,0,false,true);
			for(let i=(z-1)/2|0;i>=0;i--)
				mwms.siftDown(A,h,t,h[i],i,z);
			while(z>0){
				let m=h[0];
				await swap(A,p++,t[m],0,true);
				write(t,m,t[m]+1,0,false,true);
				if(t[m]==minVal(a+(m+1)*s,b))
					mwms.siftDown(A,h,t,h[--z],0,z);
				else
					mwms.siftDown(A,h,t,h[0],0,z);
			}
		}
		async function retrieve(A,i,p,pE,v,w){
			let j=i-1,m;
			for(let k=pE-15;k>p+14;){
				m=rightBinSearch(A,k-14,k,v,w)-1;
				k-=15;
				while(m>=k)await swap(A,j--,m--,1,true);
			}
			m=rightBinSearch(A,p,p+14,v,w)-1;
			while(m>=p)await swap(A,j--,m--,1,true);
		}
		async function librarySort(A,a,b,p,v,w){
			let l=b-a;
			if(l<32)return await bininsert(A,a,b);
			let rng=new Random();
			let s=l;
			while(s>31)s=(s-1)/4+1|0;
			let i=a+s,j=a+4*s,pE=p+(s+1)*15+14;
			await bininsert(A,a,i);
			for(let k=0;k<s;k++)
				await swap(A,a+k,p+k*15+14,1,true);
			while(i<b){
				if(i==j){
					await retrieve(A,i,p,pE,v,w);
					s=i-a;
					pE=p+(s+1)*15+14;
					j=a+(j-a)*4;
					for(let k=0;k<s;k++)
						await swap(A,a+k,p+k*15+14,1,true);
				}
				let bL=leftBlockSearch(A,p+14,pE-15,A[i]);
				if(compareIndices(A,i,bL)){
					let qE=rightBlockSearch(A,bL+15,pE-15,A[i]);
					bL+=rng.nextInt((qE-bL)/15|0)*15;
				}
				let o=rightBinSearch(A,bL-14,bL,v,w);
				if(o==bL){
					do bL+=15;while(bL<pE&&rightBinSearch(A,bL-14,bL,v,w)==bL);
					if(bL==pE){
						await retrieve(A,i,p,pE,v,w);
						s=i-a;
						pE=p+(s+1)*15+14;
						j=a+(j-a)*4;
						for(let k=0;k<s;k++)
							await swap(A,a+k,p+k*15+14,1,true);
					}else{
						let rp=rightBinSearch(A,bL-14,bL,v,w);
						let rs=bL-maxVal(rp,bL-7);
						await shiftBW(A,o-rs,bL-rs,bL);
					}
				}else{
					let t=A[i];
					await write(A,i++,A[o],1,true);
					await insertTo(A,t,o,rightBinSearch(A,bL-14,o,t,false));
				}
			}
			await retrieve(A,b,p,pE,v,w);
		}
		async function sort(A,l){
			let t=new Array(16).fill(0);
			let h=new Array(16).fill(0);
			let a=0,b=l;
			while(b-a>=32){
				let v=A[medianOfThreeNinthers(A,a,b)];
				let i1=a,i=a-1,j=b,j1=b;
				while(1){
					while(++i<j){
						let c=compareIndexValue(A,i,v);
						if(!c)await swap(A,i1++,i,1,true);
						else if(c<0)break;
					}
					while(--j>i){
						let c=compareIndexValue(A,j,v);
						if(!c)await swap(A,--j1,j,1,true);
						else if(c>0)break;
					}
					if(i<j)await swap(A,i,j,1,true);
					else{
						if(i1==b)return;
						else if(j<i)j++;
						while(i1>a)await swap(A,--i,--i1,1,true);
						while(j1<b)await swap(A,j++,j1++,1,true);
						break;
					}
				}
				let lo=i-a,hi=b-j,m,kC=0;
				if(lo<=hi){
					m=b-lo;
					lo=maxVal((hi+1)/15|0,16);
					for(let k=a;k<i;k+=lo){
						await librarySort(A,k,minVal(k+lo,i),j,v,true);
						write(t,kC++,k,0,false,true);
					}
					await kWayMerge(A,h,t,lo,i,m,kC);
					if(j-i<m-j){
						while(i<j)await swap(A,i++,--m,1,true);
						b=m;
					}else{
						while(m>j)await swap(A,i++,--m,1,true);
						b=i;
					}
				}else{
					m=a+hi;
					hi=maxVal((lo+1)/15|0,16);
					for(let k=j;k<b;k+=hi){
						await librarySort(A,k,minVal(k+hi,b),a,v,false);
						write(t,kC++,k,0,false,true);
					}
					await kWayMerge(A,h,t,hi,b,a,kC);
					if(i-m<j-i){
						while(m<i)await swap(A,m++,--j,1,true);
						a=j;
					}else{
						while(j>i)await swap(A,m++,--j,1,true);
						a=m;
					}
				}
			}
			await bininsert(A,a,b);
		}
		await sort(arr,len);
	}
	async weaveMergeSort(len){
		async function weaveInsert(A,s,e){
			let p;
			for(let j=s;j<e;j++){
				p=j;
				while(p>s&&compareIndices(A,p,p-1)<1)
					await swap(A,p,--p,.2,true);
			}
		}
		async function weaveMerge(A,n,x,m){
			let i=1;
			let t=m-n;
			for(;i<=t;i++)
				await multiSwap(A,m+i,n+i*2-1,.25,true);
			await weaveInsert(A,n,x+1);
		}
		async function weaveMergeSort(A,n,x){
			if(x-n==0){
			}else if(x-n==1){
				if(compareIndices(A,n,x)>0)
					await swap(A,n,x,.01,true);
			}else{
				let m=(n+x)/2|0;
				await weaveMergeSort(A,n,m);
				await weaveMergeSort(A,m+1,x);
				await weaveMerge(A,n,x,m);
			}
		}
		await weaveMergeSort(arr,0,len-1);
	}
	async remiSort(len){
		const mwms=new MultiWayMergeSorting();
		function ceilCbrt(n){
			let a=0,b=minVal(1291,n);
			while(a<b){
				let m=(a+b)/2|0;
				if(m*m*m>=n)b=m;
				else a=m+1;
			}
			return a;
		}
		function siftDown(A,k,r,l,a,t){
			let j=r;
			while(2*j+1<l){
				j=2*j+1;
				if(j+1<l){
					let c=compareIndices(A,a+k[j+1],a+k[j],.2,true);
					if(c>0||(!c&&compareIndices(k,j+1,j)>0))j++;
				}
			}
			for(let c=compareIndices(A,a+t,a+k[j]);c>0||(!c&&compareValues(t,k[j])>0);j=(j-1)/2|0,c=compareIndices(A,a+t,a+k[j]));
			for(let t2;j>r;j=(j-1)/2|0){
				t2=k[j];
				write(k,j,t,0,false,true);
				t=t2;
			}
			write(k,r,t,0,false,true);
		}
		async function tableSort(A,k,a,b){
			let l=b-a;
			for(let i=(l-1)/2|0;i>=0;i--)
				siftDown(A,k,i,l,a,k[i]);
			for(let i=l-1;i>0;i--){
				let t=k[i];
				write(k,i,k[0],1,false,true);
				siftDown(A,k,0,i,a,t);
			}
			for(let i=0;i<l;i++){
				if(compareValues(i,k[i])){
					let t=A[a+i];
					let j=i,n=k[i];
					do{
						await write(A,a+j,A[a+n],1,true);
						write(k,j,j,0,false,true);
						j=n;
						n=k[n];
					}while(compareValues(n,i));
					await write(A,a+j,t,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		async function blockCycle(A,b,k,a,bL,bC){
			for(let i=0;i<bC;i++){
				if(compareValues(i,k[i])){
					arraycopy(A,a+i*bL,b,0,bL,1,true,true);
					let j=i,n=k[i];
					do{
						await arraycopy(A,a+n*bL,A,a+j*bL,bL,1,true);
						write(k,j,j,1,false,true);
						j=n;
						n=k[n];
					}while(compareValues(n,i));
					await arraycopy(b,0,A,a+j*bL,bL,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		async function kWayMerge(A,r,y,h,b,d,p,bL,rL){
			let k=p.length,z=k,a=d[0],a1=d[1];
			for(let i=0;i<k;i++)
				write(h,i,i,0,false,true);
			for(let i=(k-1)/2|0;i>=0;i--)
				mwms.siftDown(A,h,d,h[i],i,k);
			for(let i=0;i<rL;i++){
				let n=h[0];
				await write(r,i,A[d[n]],0,false,true);
				await write(d,n,d[n]+1,1,false,true);
				if(d[n]==minVal(a+(n+1)*rL,b))
					mwms.siftDown(A,h,d,h[--z],0,z);
				else
					mwms.siftDown(A,h,d,h[0],0,z);
			}
			let t=0,cnt=0,c=0;
			while(d[c]-p[c]<bL)c++;
			do{
				let n=h[0];
				write(A,p[c],A[d[n]],0);
				write(d,n,d[n]+1,0,false,true);
				write(p,c,p[c]+1,1,false,true);
				if(d[n]==minVal(a+(n+1)*rL,b))
					mwms.siftDown(A,h,d,h[--z],0,z);
				else
					mwms.siftDown(A,h,d,h[0],0,z);
				if(++cnt==bL){
					await write(y,t++,c>0?p[c]/bL-bL-1|0:-1,0,false,true);
					c=cnt=0;
					while(d[c]-p[c]<bL)c++;
				}
			}while(z>0);
			while(cnt-->0){
				write(p,c,p[c]-1,0,false,true);
				await write(A,--b,A[p[c]],1,true);
			}
			write(d,k-1,b,0,false,true);
			write(y,y.length-1,-1,0,false,true);
			t=0;
			while(y[t]+1)t++;
			for(let i=1,j=a;j<p[0];i++){
				while(p[i]<d[i]){
					write(y,t++,p[i]/bL-bL|0,0,false,true);
					while(y[t]+1)t++;
					await arraycopy(A,j,A,p[i],bL,1,true);
					write(p,i,p[i]+bL,0,false,true);
					j+=bL;
				}
			}
			await arraycopy(r,0,A,a,rL,1,true);
			await blockCycle(A,r,y,a1,bL,(b-a1)/bL|0);
		}
		async function sort(A,l){
			let a=0,b=l;
			let bL=ceilCbrt(l);
			let rL=bL*bL;
			let rC=(l-1)/rL+1|0;
			if(rC<2){
				let k=new Array(l);
				for(let i=0;i<k.length;i++)
					write(k,i,i,1,false,true);
				await tableSort(A,k,a,b);
				return;
			}
			let k=new Array(rL);
			let r=new Array(rL);
			let h=new Array(rC).fill(0);
			let p=new Array(rC).fill(0);
			let pa=new Array(rC).fill(0);
			for(let i=0;i<k.length;i++)
				write(k,i,i,1,false,true);
			for(let i=a,j=0;i<b;i+=rL,j++){
				await tableSort(A,k,i,minVal(i+rL,b));
				write(pa,j,i,0,false,true);
			}
			arraycopy(pa,0,p,0,rC,0,false,true);
			await kWayMerge(A,r,k,h,b,pa,p,bL,rL);
		}
		await sort(arr,len);
	}
	async fireSort(len){
		let i=1,t1=0,t2=0,t3=-1,t4=1,t5=false,t6=false,t7=false;
		let j=0;
		while(!t5){
			if(t2<1){
				t1+=len;t2=t1;t3*=-1;
			}else t2--;
			t7=false;
			while(i+1<=len&&i>=1&&!t7){
				if(compareIndices(arr,i-1,i)*t3>0){
					swap(arr,i-1,i,0);
					if(++j>len*2)await mark(i-1,j=0);
					i-=t3;t7=true;
				}else i+=t3;
			}
			if(i<1){
				i=len-1;t4=1;t5=true;
				while(t4-len&&t5){
					if(compareIndices(arr,t4-1,t4)<1)t4++;
					else{
						t4=1;t5=false;t6=true;
						while(t4-len&&t6){
							if(compareIndices(arr,t4,t4-1)<1)t4++;
							else t6=false;
						}
					}
				}
				if(t6){
					i=1;t2=0;
				}
			}
			if(i+1>len){
				i=1;t4=1;t5=true;
				while(t4!=len&&t5){
					if(compareIndices(arr,t4-1,t4)<1)t4++;
					else{
						t4=1;t5=false;t6=true;
						while(t4!=len&&t6){
							if(compareIndices(arr,t4,t4-1)<1)t4++;
							else t6=false;
						}
					}
				}
				if(t6){
					i=len-1;t2=0;
				}
			}
		}
	}
	async mergeInsertionSort(len){
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a--,b--,0,true);
		}
		async function blockInsert(A,a,b,s){
			while(a-s>=b){
				await blockSwap(A,a-s,a,s);
				a-=s;
			}
		}
		async function blockReversal(A,a,b,s){
			b-=s;
			while(b>a){
				await blockSwap(A,a,b,s);
				a+=s;
				b-=s;
			}
		}
		function blockSearch(A,a,b,s,v){
			while(a<b){
				let m=a+(((b-a)/s|0)/2|0)*s;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+s;
			}
			return a;
		}
		async function order(A,a,b,s){
			for(let i=a,j=i+s;j<b;i+=s,j+=2*s)
				await blockInsert(A,j,i,s);
			let m=a+(((b-a)/s|0)/2|0)*s;
			await blockReversal(A,m,b,s,1);
		}
		async function sort(A,l){
			let k=1;
			while(2*k<=l){
				for(let i=2*k-1;i<l;i+=2*k)
					if(compareIndices(A,i-k,i)>0)
						await blockSwap(A,i-k,i,k,1);
				k*=2;
			}
			while(k>0){
				let a=k-1,i=a+2*k,g=2,p=4;
				while(i+2*k*g-k<=l){
					await order(A,i,i+2*k*g-k,k);
					let b=a+k*(p-1);
					i+=k*g-k;
					for(let j=i;j<i+k*g;j+=k)
						await blockInsert(A,j,blockSearch(A,a,b,k,A[j]),k);
					i+=k*g+k;
					g=p-g;
					p*=2;
				}
				while(i<l){
					await blockInsert(A,i,blockSearch(A,a,i,k,A[i]),k);
					i+=2*k;
				}
				k=k/2|0;
			}
		}
		await sort(arr,len);
	}
	async yujisBufferedMergeSort2(len){
		function ceilLog(n){
			let i;
			for(i=0;(1<<i)<n;i++);
			return i;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		function binarySearch(A,s,e,v,l){
			let a=s,b=e;
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,binarySearch(A,a,i,A[i],false));
		}
		async function mergeWithBufStatic(A,a,m,b,p,u){
			let i=0,j=m,k=a;
			if(u){
				while(i<m-a&&j<b){
					if(compareIndices(A,j,p+i)<0){
						let q=binarySearch(A,j,b,A[p+i],true);
						while(j<q)await swap(A,k++,j++,1,true);
					}
					await swap(A,k++,p+(i++),1,true);
				}
				while(i<m-a){
					await swap(A,k++,p+(i++),1,true);
				}
			}else{
				while(i<m-a&&j<b){
					if(compareIndices(A,p+i,j)<1)
						await swap(A,k++,p+(i++),1,true);
					else
						await swap(A,k++,j++,1,true);
				}
				while(i<m-a)
					await swap(A,k++,p+(i++),1,true);
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			}
			let lO=0;
			while(i<m)
				await swap(A,p++,i++,1,true);
			while(j<b){
				await swap(A,p++,j++,1,true);
				lO++;
			}
			return lO;
		}
		async function mergeSort(A,a,p,l){
			let i,j=16,cL=ceilLog(l);
			let ps=l>16&&(cL&1)?p:a
			for(i=ps;i+16<=ps+l;i+=16)
				await bininsert(A,i,i+16);
			await binaryInsertion(A,i,ps+l);
			let nx=ps,pn;
			while(j<l){
				ps=nx;
				nx^=a^p;
				pn=nx;
				for(i=ps;i+2*j<=ps+l;i+=2*j,pn+=2*j)
					await merge(A,i,i+j,i+2*j,pn);
				if(i+j<ps+l)
					await merge(A,i,i+j,ps+l,pn);
				else
					while(i<ps+l)await swap(A,i++,pn++,1,true);
				j*=2;
			}
		}
		async function bufferedMerge(A,a,b){
			if(b-a<=16){
				await bininsert(A,a,b);
				return;
			}
			let m=(a+b+1)/2|0;
			await mergeSort(A,m,2*m-b,b-m);
			let n=(a+m+1)/2|0;
			let lm=(b-a)/16|0;
			while(m-a>lm){
				await mergeSort(A,2*n-m,n,m-n);
				await mergeWithBufStatic(A,n,m,b,2*n-m,((b-m)/(m-n)|0)>=ceilLog(n-a));
				m=n;
				n=(a+m+1)/2|0;
			}
			await bufferedMerge(A,a,m);
			await multiSwap(A,a,b-m+a,m-a);
			let s=await merge(A,m,b-m+a,b,a);
			await bufferedMerge(A,b-m+a-s,b);
		}
		await bufferedMerge(arr,0,len);
	}
	async sqrtSort(len){
		async function msw(ar,a,b,l,x){
			while(l--)await swap(ar,a++,b++,1,true,x);
		}
		async function sqmr(ar,p,lL,rL,d,x){
			let mP=lL+rL+d-1,r=lL+rL-1,l=lL-1;
			while(l>=0)
				if(r<lL||compareIndices(ar,p+l,p+r)>0)await write(ar,p+mP--,ar[p+l--],1,true,x);
				else await write(ar,p+mP--,ar[p+r--],1,true,x);
			if(r!=mP)while(r>=lL)await write(ar,p+mP--,ar[p+r--],1,true,x);
		}
		async function sqmlwb(ar,p,lE,rE,d,x){
			let l=0,r=lE;rE+=lE;
			while(r<rE)
				if(l==lE||compareIndices(ar,p+l,p+r)>0)await write(ar,p+d++,ar[p+r++],1,true,x);
				else await write(ar,p+d++,ar[p+l++],1,true,x)
			if(d!=l)while(l<lE)await write(ar,p+d++,ar[p+l++],1,true,x);
		}
		async function sqmd(ar,aP,buf,bP,lL,rL,x){
			let aM=0,bM=0,d=-rL;
			while(bM<rL)
				if(aM==lL||compareValues(ar[aP+aM],buf[bP+bM])>=0)await write(ar,aP+d++,buf[bP+bM++],1,true,x);
				else await write(ar,aP+d++,ar[aP+aM++],1,true,x);
			if(d!=aM)while(aM<lL)await write(ar,aP+d++,ar[aP+aM++],1,true,x);
		}
		async function sqsmwb(ar,p,lol,lof,bL,x){
			let d=-bL,l=0,r=lol,lE=r,rE=r+bL,tF=1-lof;
			while(l<lE&&r<rE)
				if(compareIndices(ar,p+l,p+r)-tF<0)await write(ar,p+d++,ar[p+l++],1,true,x);
				else await write(ar,p+d++,ar[p+r++],1,true,x);
			let ln,fr=lof;
			if(l<lE){
				ln=lE-l;
				while(l<lE)await write(ar,p+--rE,ar[p+--lE],1,true,x);
			}else{ln=rE-r;fr=tF;}
			return[ln,fr];
		}
		async function smbflwb(keys,mK,ar,p,bC,rBL,aBC,lL,x){
			if(bC==0)return sqmlwb(ar,p,aBC*rBL,lL,-rBL,x);
			let lol=rBL,lof=compareValues(keys[0],mK)<0?0:1,pI=rBL,rTP;
			for(let kI=1;kI<bC;kI++,pI+=rBL){
				rTP=pI-lol;
				let nF=compareValues(keys[kI],mK)<0?0:1;
				if(nF==lof){
					await arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,1,true,x);
					rTP=pI;lol=rBL;
				}else[lol,lof]=await sqsmwb(ar,p+rTP,lol,lof,rBL,x);
			}
			rTP=pI-lol;
			if(lL!=0){
				if(lof!=0){
					await arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,1,true,x);
					rTP=pI;lol=rBL*aBC;lof=0;
				}else lol+=rBL*aBC;
				await sqmlwb(ar,p+rTP,lol,lL,-rBL,x);
			}else await arraycopy(ar,p+rTP,ar,p+rTP-rBL,lol,1,true,x);
		}
		async function sBBls(ar,p,ln,bL,x){
			let eD,pt;
			for(let d=1;d<ln;d+=2){
				eD=compareIndices(ar,p+(d-1),p+d)>0?1:0;
				await write(ar,p+d-3,ar[p+d-1+eD],1,true,x);
				await write(ar,p+d-2,ar[p+d-eD],1,true,x);
			}
			if(ln%2!=0)await write(ar,p+ln-3,ar[p+ln-1],1,true,x);
			p-=2;
			for(pt=2;pt<bL;pt*=2){
				let lf=0,rh=ln-2*pt;
				while(lf<=rh){
					await sqmlwb(ar,p+lf,pt,pt,-pt,x);
					lf+=2*pt;
				}
				let rs=ln-lf;
				if(rs>pt)await sqmlwb(ar,p+lf,pt,rs-pt,-pt,x);
				else while(lf<ln)await write(ar,p+lf-pt,ar[p+lf++],1,true,x);
				p-=pt;
			}
			let rTB=ln%(2*bL),loP=ln-rTB;
			if(rTB<=bL)await arraycopy(ar,p+loP,ar,p+loP+bL,rTB,1,true,x);
			else await sqmr(ar,p+loP,bL,rTB-bL,bL,x);
			while(loP>0){
				loP-=2*bL;
				await sqmr(ar,p+loP,bL,bL,bL,x);
			}
		}
		async function sqCmBl(ar,p,ln,bL,rBL,tags,x){
			let cmL=ln/(2*bL)|0,lO=ln%(2*bL),lI=0;
			if(lO<=bL){ln-=lO;lO=0}
			for(let i=0;i<=cmL;i++){
				if(i==cmL&&lO==0)break;
				let bP=p+i*2*bL,bC=(i==cmL?lO:2*bL)/rBL|0,tI=bC+(i==cmL?1:0),mK=bL/rBL|0;
				for(let j=0;j<=tI;j++)write(tags,j,j,true);
				for(tI=1;tI<bC;tI++){
					lI=tI-1;
					for(let rI=tI;rI<bC;rI++){
						let rC=compareIndices(ar,bP+lI*rBL,bP+rI*rBL);
						if(rC>0||(rC==0&&tags[lI]>tags[rI]))lI=rI;
					}
					if(lI!=tI-1){
						await msw(ar,bP+(tI-1)*rBL,bP+lI*rBL,rBL,x);
						swap(tags,tI-1,lI,0,false,true);
					}
				}
				let aBC=0,lL=0;
				if(i==cmL)lL=lO%rBL;
				if(lL!=0)while(aBC<bC&&compareIndices(ar,bP+bC*rBL,bP+(bC-aBC-1)*rBL)<0)aBC++;
				await smbflwb(tags,mK,ar,bP,bC-aBC,rBL,aBC,lL,x);
			}
			for(lI=ln-1;lI>=0;lI--)await write(ar,p+lI,ar[p+lI-rBL],1,true,x);
		}
		async function sqSort(ar,p,ln,eB,eBP,tags,x){
			if(ln<=16)return await insertSort(ar,p,ln,1,x);
			let bL=1;
			while(bL*bL<ln)bL*=2;
			await arraycopy(ar,p,eB,eBP,bL,1,true,x);
			await sqSort(eB,eBP,bL,ar,p,tags,!x);
			await sBBls(ar,p+bL,ln-bL,bL,x);
			let bL2=bL;
			while(ln>(bL2*=2))await sqCmBl(ar,p+bL,ln-bL,bL2,bL,tags,x);
			await sqmd(ar,p+bL,eB,eBP,ln-bL,bL,x);
		}
		let bL=1;
		while(bL*bL<len)bL*=2;
		let nK=(len-1)/bL+2|0,eB=new Array(bL),t=new Array(nK);
		await sqSort(arr,0,len,eB,0,t,false);
	}
	async introSort(len){
		const hs=new HeapSorting(true);
		function floorLog(a){
			return floor(log(a)/log(2));
		}
		async function m3(A,a,m,b){
			if(compareIndices(A,b,a)<0)await swap(A,a,b,1,true);
			if(compareIndices(A,m,a)<0)await swap(A,m,a,1,true);
			if(compareIndices(A,b,m)<0)await swap(A,b,m,1,true);
			return A[m];
		}
		async function partition(a,lo,hi,x){
			let i=lo,j=hi;
			while(1){
				while(compareValues(a[i],x)<0)i++;
				do j--;while(compareValues(x,a[j])<0);
				if(i>=j)return i;
				await swap(a,i++,j,1,true);
			}
		}
		async function introsortLoop(a,lo,hi,d){
			while(hi-lo>16){
				if(!d)return hs.sort(a,lo,hi);
				let p=await partition(a,lo,hi,await m3(a,lo,lo+(hi-lo)/2|0,hi-1));
				await introsortLoop(a,p,hi,--d);
				hi=p;
			}
		}
		await introsortLoop(arr,0,len,2*floorLog(len));
		await insertSort(arr,0,len);
	}
	async lazierestSort(len){
		function ceilCbrt(n){
			let a=0,b=minVal(1291,n);
			while(a<b){
				let m=(a+b)/2|0;
				if(m*m*m>=n)b=m;
				else a=m+1;
			}
			return a;
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertion(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMergeFW(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await IndexedRotations.cycleReverse(A,i,j,k,.75,true);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=rightExpSearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=i+1-k;i=k-1;
				}else j--;
			}
		}
		async function inPlaceMerge(A,a,m,b){
			if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function fragmentedMerge(A,a,m,b,s){
			let i=a+(m-a)%s;
			while(i<m){
				let j=leftExpSearch(A,m,b,A[i]);
				await IndexedRotations.cycleReverse(A,i,m,j,.75,true);
				let rL=j-m;
				j=i;i+=rL;m+=rL;
				await inPlaceMerge(A,a,j,a=i);
				i+=s;
			}
			await inPlaceMerge(A,maxVal(a,i-s),i,b);
		}
		async function lazierestStableSort(A,a,b){
			let l=b-a,s=ceilCbrt(l),s1=s*s;
			for(let i=l%s;i<=b;i+=s)
				await insertion(A,maxVal(a,i-s),i);
			for(let i=b-s,j=b;i>a;i-=s){
				if(j-i==s1){
					j-=s1;i-=s;
				}
				await inPlaceMergeFW(A,maxVal(a,i-s),i,j);
			}
			for(let i=b-s1;i>a;i-=s1)
				await fragmentedMerge(A,maxVal(a,i-s1),i,b,s);
		}
		if(len<17)await insertion(arr,0,len);
		else await lazierestStableSort(arr,0,len);
	}
	async laziestSort(len){
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
			}
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function bininsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function sort(A,s,e){
			let l=e-s;
			if(l<17)return await bininsert(A,s,e);
			let i,bL=maxVal(16,sqrt(len)|0);
			for(i=s;i+2*bL<e;i+=bL)
				await bininsert(A,i,i+bL);
			await bininsert(A,i,e);
			for(;i-bL>=s;i-=bL)
				await inPlaceMerge(A,i-bL,i,e);
		}
		await sort(arr,0,len);
	}
	async introCircleSortIterative(len){
		let th=0,n=1,i=0;
		for(;n<len;n*=2,th++);th=th/2|0;
		do{
			if(++i>=th){
				await binaryInsertion(arr,0,len);
				break;
			}
		}while(await iterativeCircleSortRoutine(arr,n,1));
	}
	async introCircleSortRecursive(len){
		let th=0,n=1,i=0;
		for(;n<len;n*=2,th++);th=th/2|0;
		do{
			if(++i>=th){
				await binaryInsertion(arr,0,len);
				break;
			}
		}while(await recursiveCircleSortRoutine(arr,0,n-1,0));
	}
	async medianMergeSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j;
			let ad=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s);
					await swap(A,j++,i+s/2,1,false);
				}
				if(i<e){
					await insertSort(A,i,e);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,1);
					if((e-i)%2==0)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		function getMinLevel(n){
			while(n>=32)n=(n+3)/4|0;
			return n;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,ps,j=getMinLevel(l);
			for(i=a;i+j<=b;i+=j)
				await binaryInsertion(A,i,i+j);
			await binaryInsertion(A,i,b);
			while(j<l){
				ps=p;
				for(i=a;i+2*j<=b;i+=2*j,ps+=2*j)await merge(A,i,i+j,i+2*j,ps);
				if(i+j<b)await merge(A,i,i+j,b,ps);
				else while(i<b)await swap(A,i++,ps++,1,true);
				j*=2;ps=a;
				for(i=p;i+2*j<=p+l;i+=2*j,ps+=2*j)await merge(A,i,i+j,i+2*j,ps);
				if(i+j<p+l)await merge(A,i,i+j,p+l,ps);
				else while(i<p+l)await swap(A,i++,ps++,1,true);
				j*=2;
			}
		}
		async function medianMergeSort(A,a,b){
			let s=a,e=b;
			let bP=false,med=false;
			while(e-s>16){
				if(bP){
					await medianOfMedians(A,s,e,5);
					med=true;
				}else await medianOfThree(A,s,e);
				let p=await partition(A,s+1,e,s);
				await swap(A,s,p,1,true);
				let l=p-s;
				let r=e-p-1;
				bP=!med&&((!l||!r)||((l/r|0)>=16||(r/l|0)>=16));
				if(l<=r){
					await mergeSort(A,s,p,p+1);
					s=p+1;
				}else{
					await mergeSort(A,p+1,e,2*p+1-e);
					e=p;
				}
			}
			await binaryInsertion(A,s,e);
		}
		await medianMergeSort(arr,0,len);
	}
	async grailSort(len){
		const GS=new GrailSorting();
		let bt=askForNum(0,"Buffer Type\n0:  in-place\n1:  static\n2:  dynamic",0,2);
		switch(bt){
			case 1:
				await GS.grailCommonSort(arr,0,len,new Array(32),0,32);
				break;
			case 2:
				let t=1;
				while(t*t<len)t*=2;
				let dex=new Array(t);
				await GS.grailCommonSort(arr,0,len,dex,0,t);
				break;
			default:await GS.grailCommonSort(arr,0,len,null,0,0);
		}
	}
	async optimizedLazyStableSort(len){
		const GS=new GrailSorting();
		async function insertionSort(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let c=A[i];
				let p=i-1;
				while(p>=a&&compareValues(A[p],c)>0)
					await write(A,p+1,A[p--],1,true);
				await write(A,p+1,c,1,true);
				i++;
			}
		}
		async function grailLazyStableSort(A,p,ln){
			let d;
			for(d=0;d+16<ln;d+=16)await insertionSort(A,p+d,p+d+16);
			if(d<ln)await insertionSort(A,p+d,p+ln,1);
			for(let pt=16;pt<ln;pt*=2){
				let l=0,r=ln-2*pt;
				while(l<=r){
					await GS.grailMergeWithoutBuffer(A,p+l,pt,pt);
					l+=2*pt;
				}
				let rs=ln-l;
				if(rs>pt)await GS.grailMergeWithoutBuffer(A,p+l,pt,rs-pt);
			}
		}
		await grailLazyStableSort(arr,0,len);
	}
	async optimizedWeaveMergeSort(len){
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.25,true);
			await write(A,b,t,.25,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
			}
		}
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		async function weaveInsert(A,a,b,r){
			let i=a,j=i+1;
			while(j<b){
				while(i<j&&compareIndices(A,i,j)<(r?1:0))i++;
				if(i-j){
					await insertTo(A,j,i++);
					j+=2;
				}else{
					r=!r;
					j++;
				}
			}
		}
		async function weaveMerge(A,a,m,b){
			if(b-a<2)return;
			let a1=a,b1=b,r=true;
			if((b-a)%2){
				if(m-a<b-m){
					a1--;
					r=false;
				}else b1++;
			}
			for(let e=b1,f;e-a1>2;e=f){
				m=(a1+e)/2|0;
				let p=1<<(log(m-a1)/log(2)|0);
				await rotate(A,m-p,m,e-p);
				m=e-p;
				f=m-p;
				await bitReversal(A,f,m);
				await bitReversal(A,m,e);
				await bitReversal(A,f,e);
			}
			await weaveInsert(A,a,b,r);
		}
		let n=len,d=1<<(log(n-1)/log(2)+1|0);
		while(d>1){
			let i=0,c=0;
			while(i<n){
				let j=i;
				c+=n;
				while(c>=d){
					c-=d;j++;
				}
				let k=j;
				c+=n;
				while(c>=d){
					c-=d;k++;
				}
				await weaveMerge(arr,i,j,k);
				i=k;
			}
			d=d/2|0;
		}
	}
	async optimizedRotateMergeSort(len){
		/**/
		async function rotateInPlace(A,p,lA,lB){
			if(lA<1||lB<1)return;
			let a=p,b=p+lA-1,c=p+lA,d=p+lA+lB-1;
			let t;
			while(a<b&&c<d){
				t=A[b];
				await write(A,b--,A[a],.5,true);
				await write(A,a++,A[c],.5,true);
				await write(A,c++,A[d],.5,true);
				await write(A,d--,t,.5,true);
			}
			while(a<b){
				t=A[b];
				await write(A,b--,A[a],.5,true);
				await write(A,a++,A[d],.5,true);
				await write(A,d--,t,.5,true);
			}
			while(c<d){
				t=A[c];
				await write(A,c++,A[d],.5,true);
				await write(A,d--,A[a],.5,true);
				await write(A,a++,t,.5,true);
			}
			if(a<d)await reversal(A,a,d,1,true);
		}
		async function rotate(A,p,l,r){
			if(l<1||r<1)return;
			let pa=p,pb=p+l,pc=p+r,pd=pb+r;
			if(l<r){
				let br=r-l;
				if(br<l){
					let o=l;
					if(br>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					arraycopy(A,pb,tmp,0,br,0,false,true);
					while(o-->0){
						await write(A,--pc,A[--pd],.5,true);
						await write(A,pd,A[--pb],.5,true);
					}
					await arraycopy(tmp,0,A,pa,br,1,true);
				}else{
					if(l>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					arraycopy(A,pa,tmp,0,l,0,false,true);
					await arraycopy(A,pb,A,pa,r,1,true);
					await arraycopy(tmp,0,A,pc,l,1,true);
				}
			}else if(r<l){
				let br=l-r;
				if(br<r){
					if(br>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					let o=r;
					arraycopy(A,pc,tmp,0,br,0,false,true);
					while(o-->0){
						await write(A,pc++,A[pa],.5,true);
						await write(A,pa++,A[pb++],.5,true);
					}
					await arraycopy(tmp,0,A,pd-br,br,1,true);
				}else{
					if(r>tmp.length){
						await rotateInPlace(A,p,l,r);
						return;
					}
					arraycopy(A,pb,tmp,0,r,0,false,true);
					while(l-->0)
						await write(A,--pd,A[--pb],1,true);
					await arraycopy(tmp,0,A,pa,r,1,true);
				}
			}else{
				while(l-->0)
					await swap(A,pa++,pb++,1,true);
			}
		}
		async function mergeUp(A,s,m,e){
			for(let i=0;i<m-s;i++)
				write(tmp,i,A[i+s],0,false,true);
			let bP=0;
			let l=s;
			let r=m;
			while(l<r&&r<e){
				if(compareValues(tmp[bP],A[r])<1)
					await write(A,l++,tmp[bP++],1,true);
				else
					await write(A,l++,A[r++],1,true);
			}
			while(l<r)
				await write(A,l++,tmp[bP++],.5,true);
		}
		async function mergeDown(A,s,m,e){
			for(let i=0;i<e-m;i++)
				write(tmp,i,A[i+m],0,false,true);
			let bP=e-m-1;
			let l=m-1;
			let r=e-1;
			while(r>l&&l>=s){
				if(compareValues(tmp[bP],A[l])>=0)
					await write(A,r--,tmp[bP--],1,true);
				else
					await write(A,r--,A[l--],1,true);
			}
			while(r>l)
				await write(A,r--,tmp[bP--],.5,true);
		}
		function monoboundLeft(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		function monoboundRight(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)<1)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)<1)return s+1;
			return s;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValueIndex(A,v,a-1+i)>=0)i*=2;
			return monoboundRight(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValueIndex(A,v,b-i)<1)i*=2;
			return monoboundLeft(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function merge(A,s,m,e){
			if(s>=m)return;
			e=rightExpSearch(A,m,e,A[m-1]);
			if(e<m)return;
			s=leftExpSearch(A,s,m,A[m]);
			if(compareIndices(A,s,e-1)>0){
				await rotate(A,s,m-s,e-m);
				return;
			}
			let lL=m-s,rL=e-m;
			if(((lL<rL)?lL:rL)>tmp.length){
				let m1,m2,m3;
				if(m-s>=e-m){
					m1=s+(m-s)/2|0;
					m2=monoboundLeft(A,m,e,A[m1]);
					m3=m1+(m2-m);
				}else{
					m2=m+(e-m)/2|0;
					m1=monoboundRight(A,s,m,A[m2]);
					m3=(m2++)-(m-m1);
				}
				await rotate(A,m1,m-m1,m2-m);
				await merge(A,m3+1,m2,e);
				await merge(A,s,m1,m3);
			}else{
				if(e-m<m-s){
					await mergeDown(A,s,m,e);
				}else{
					await mergeUp(A,s,m,e);
				}
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let d=monoboundRight(A,a,i,A[i]);
				let t=A[i];
				await arraycopy(A,d,A,d+1,i-d,.5,true);
				await write(A,d,t,.5,true);
				i++;
			}
		}
		let tmp=new Array(64).fill(0);
		let i;
		for(i=0;i+32<len;i+=32)await insertion(arr,i,i+32);
		if(i+1<len)await insertion(arr,i,len);
		let g,fM;
		for(g=32;g<len;g=fM){
			fM=g*2;
			for(i=0;i+fM<len;i+=fM)await merge(arr,i,i+g,i+fM);
			if(i+g<len)await merge(arr,i,i+g,len);
		}
		await insertSort(arr,0,len);
	}
	async optimizedDualPivotQuickSort(len){
		async function dualPivot(A,l,r,dv){
			let ln=r-l;
			if(ln<17)return insertSort(A,l,r+1);
			let th=ln/dv|0;
			let m1=l+th;
			let m2=r-th;
			if(m1<=l)m1=l+1;
			if(m2>=r)m2=r-1;
			if(compareIndices(A,m1,m2)<0){
				await swap(A,m1,l,1,true);
				await swap(A,m2,r,1,true);
			}else{
				await swap(A,m1,r,1,true);
				await swap(A,m2,l,1,true);
			}
			let p1=A[l],p2=A[r];
			let ls=l+1,gr=r-1;
			for(let k=ls;k<=gr;k++){
				if(compareIndexValue(A,k,p1)<0){
					await swap(A,k,ls++,.5,true);
				}else if(compareIndexValue(A,k,p2)>0){
					while(k<gr&&compareIndexValue(A,gr,p2)>0)gr--;
					await swap(A,k,gr--,.5,true);
					if(compareIndexValue(A,k,p1)<0)
						await swap(A,k,ls++,.5,true);
				}
			}
			let d=gr-ls;
			if(d<13)dv++;
			await swap(A,ls-1,l,1,true);
			await swap(A,gr+1,r,1,true);
			await dualPivot(A,l,ls-2,dv);
			await dualPivot(A,gr+2,r,dv);
			if(d>ln-13&&p1!=p2){
				for(let k=ls;k<=gr;k++){
					if(!compareIndexValue(A,k,p1))await swap(A,k,ls++,.5);
					else if(!compareIndexValue(A,k,p2)){
						await swap(A,k,gr--,.5,true);
						if(!compareIndexValue(A,k,p1))
							await swap(A,k,ls++,.5,true);
					}
				}
			}
			if(p1<p2)await dualPivot(A,ls,gr,dv);
		}
		await dualPivot(arr,0,len-1,3);
	}
	async optimizedBottomUpMergeSort(len){
		async function merge(c,d,lt,md,rt,x){
				let i=lt,j=md+1,k=lt;
			while(i<=md&&j<=rt){
				if(compareIndices(c,i,j)<1){
					if(x)write(d,k++,c[i++],0,false,true);
					else await write(d,k++,c[i++],.5,true);
				}else{
					if(x)write(d,k++,c[j++],0,false,true);
					else await write(d,k++,c[j++],.5,true);
				}
			}
			while(i<=md)await write(d,k++,c[i++],1,true,x);
			while(j<=rt)await write(d,k++,c[j++],1,true,x);
		}
		async function mergePass(x,y,s,n,d){
			let i=0;
			while(i<=n-2*s){
				await merge(x,y,i,i+s-1,i+2*s-1,d);
				i=i+2*s;
			}
			if(i+s<n)await merge(x,y,i,i+s-1,n-1,d);
			else for(let j=i;j<=n-1;j++)
				await write(y,j,x[j],1,false,d);
		}
		async function stableSort(a,n){
			let s=16,i;
			if(n<s)return await binaryInsertion(a,0,s);
			let b=new Array(n);
			for(i=0;i<=n-s;i+=s)await binaryInsertion(a,i,i+s);
			await binaryInsertion(a,i,n);
			while(s<n){
				await mergePass(a,b,s,n,true);
				s+=s;
				await mergePass(b,a,s,n,false);
				s+=s;
			}
		}
		await stableSort(arr,len);
	}
	async synchronousSqrtSort(len){
		const bms=new BlockMergeSorting();
		async function smartMergeBW(A,a,m,b,p,r){
			let i=m-1,j=b-1;
			let c=r?-1:0;
			while(i>=a&&j>=m){
				if(compareIndices(A,i,j)>c)
					await write(A,--p,A[i--],1,true);
				else
					await write(A,--p,A[j--],1,true);
			}
			return++i;
		}
		async function blockSelection(A,tags,a,b,bL,t,tj){
			for(let i=0;i<minVal(tj+1,tags.length-t);i++)
				write(tags,t+i,i+(i<=(tj/2|0)?0:tags.length),1,false,true);
			for(let j=a,p=a;j<b-bL;j+=bL){
				let n=p==j?j+bL:j;
				for(let i=n+bL;i<b;i+=bL){
					if(i-p){
						let c=compareIndices(A,i,n);
						if(c<0||(!c&&compareIndices(tags,t+(i-a)/bL|0,t+(n-a)/bL|0)<0))
							n=i;
					}
				}
				if(n>j){
					if(p==j){
						await arraycopy(A,n,A,j,bL,1,true);
						await write(tags,t+(j-a)/bL|0,tags[t+(n-a)/bL|0],1,true,false);
						p=n;
					}else{
						await bms.multiSwap(A,j,n,bL);
						await swap(tags,t+(j-a)/bL|0,t+(n-a)/bL|0,1,true,false);
					}
				}
			}
		}
		async function mergeBlocksBW(A,tags,a,b,ti,tb,bL){
			let tj=tb-1,mkv=tags.length;
			let f=b,a1=f-bL;
			let r=compareValues(tags[tj],mkv)<0;
			while(1){
				do{
					tj--;
					a1-=bL;
				}while(tj>=ti&&(r?compareValues(tags[tj],mkv)<0:compareValues(tags[tj],mkv)>=0));
				if(tj<ti){
					await bms.shiftBWExt(A,a,f,f+bL);
					break;
				}
				f=await smartMergeBW(A,a1,a1+bL,f,f+bL,r);
				r=!r;
			}
		}
		async function sort(A,l){
			if(l<17)return await bms.binaryInsertion(A,0,l);
			let bL=1;
			while(bL*bL<l)bL*=2;
			let mod=l%bL;
			let a=bL+mod,b=l,ln=b-a;
			let i,j=1;
			let temp=new Array(bL+mod);
			let tags=new Array((l-1)/bL+1|0);
			await bms.binaryInsertion(A,0,a);
			arraycopy(A,0,temp,0,a,0,false,true);
			for(;j<bL;j*=2){
				let p=maxVal(2,j);
				for(i=a;i+2*j<b;i+=2*j)
					await bms.mergeWithBufFWExt(A,i,i+j,i+2*j,i-p);
				if(i+j<b)await bms.mergeWithBufFWExt(A,i,i+j,b,i-p);
				else await bms.shiftFWExt(A,i-p,i,b);
				a-=p;b-=p;
			}
			let p=ln%(2*j);
			i=b-p;
			if(i+j<b)await bms.mergeWithBufBWExt(A,i,i+j,b,b+j);
			else await bms.shiftBWExt(A,i,b,b+j);
			for(i-=2*j;i>=a;i-=2*j)
				await bms.mergeWithBufBWExt(A,i,i+j,i+2*j,i+3*j);
			a+=j;b+=j;j*=2;
			for(let ti,tj=4;j<len;j*=2,tj*=2){
				for(i=a,ti=0;i+2*j<b;i+=2*j,ti+=tj)
					await blockSelection(A,tags,i-bL,i+2*j,bL,ti,tj);
				let nF=i+j<b;
				p=(b-i)/bL|0;
				if(nF)await blockSelection(A,tags,i-bL,b,bL,ti,tj);
				a-=bL;b-=bL;i-=bL;
				if(nF)await mergeBlocksBW(A,tags,i,b,ti,ti+p,bL);
				for(i-=2*j,ti-=tj;i>=a;i-=2*j,ti-=tj)
					await mergeBlocksBW(A,tags,i,i+2*j,ti,ti+tj,bL);
				a+=bL;b+=bL;
			}
			p=0;i=0;j=a;
			while(i<a&&j<b){
				if(compareValues(temp[i],A[j])<1)
					await write(A,p++,temp[i++],1,true);
				else
					await write(A,p++,A[j++],1,true);
			}
			while(i<a)
				await write(A,p++,temp[i++],1,true);
		}
		await sort(arr,len);
	}
	async stacklessDualPivotQuickSort(len){
		async function partition(A,a,b,p){
			let m1=(a+a+b)/3|0,m2=(a+b+b)/3|0;
			if(compareIndices(A,m1,m2)>0){
				await swap(A,m1,a,1,true);
				await swap(A,m2,--b,1,true);
			}else{
				await swap(A,m2,a,1,true);
				await swap(A,m1,--b,1,true);
			}
			let i=a,j=b;
			for(let k=i+1;k<j;k++){
				if(compareIndices(A,k,b)<0)
					await swap(A,k,++i,1,true);
				else if(compareIndices(A,a,k)<1){
					do j--;while(j>k&&compareIndices(A,a,j)<1);
					await swap(A,k,j,1,true);
					if(compareIndices(A,k,b)<0)
						await swap(A,k,++i,1,true);
				}
			}
			await swap(A,a,i,1,true);
			let t=A[b];
			await write(A,b,A[j],1,true);
			await write(A,j,A[p],1,true);
			await write(A,p,t,1,true);
			return i;
		}
		function leftBinSearch(A,a,b,p){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,p,m)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function quickSort(A,a,b){
			let x=A[a];
			for(let i=a+1;i<b;i++)if(compareValues(A[i],x)>0)x=A[i];
			for(let i=b-1;i>=0;i--)
				if(!compareValues(A[i],x))
					await swap(A,i,--b,1,true);
			let b1=b;
			let m=true;
			do{
				while(b1-a>24){
					if(!m)await swap(A,a,(a+a+b1)/3|0,1,true);
					b1=await partition(A,a,b1,b);
				}
				await binaryInsertion(A,a,b1);
				a=b1+1;
				if(a>=b){
					if(a-1<b)await swap(A,a-1,b,1,true);
					return;
				}
				b1=leftBinSearch(A,a,b,a-1);
				await swap(A,a-1,b,1,true,false);
				m=true;
				while(a<b1&&!compareIndices(A,a-1,a)){
					m=false;
					a++;
				}
				if(a==b1)m=true;
			}while(1);
		}
		await quickSort(arr,0,len);
	}
	async stacklessHybridQuickSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function partition(A,a,b){
			let i=a,j=b;
			await medianOfThree(A,a,b);
			do{
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,a,j)<1);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,a,j,1,true);
					return j;
				}
			}while(1);
		}
		function leftBinSearch(A,a,b,p){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,p,m)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function quickSort(A,a,b){
			let x=A[a];
			for(let i=a+1;i<b;i++)if(compareValues(A[i],x)>0)x=A[i];
			for(let i=b-1;i>=0;i--)
				if(!compareValues(A[i],x))
					await swap(A,i,--b,1,true);
			let b1=b;
			let m=true;
			do{
				while(b1-a>16){
					if(m)await medianOfThree(A,a,b1);
					let p=await partition(A,a,b1);
					await swap(A,b1=p,b,1,true);
				}
				await binaryInsertion(A,a,b1,.25);
				a=b1+1;
				if(a>=b){
					if(a-1<b)await swap(A,a-1,b,1,true);
					return;
				}
				b1=leftBinSearch(A,a,b,a-1);
				await swap(A,a-1,b,1,true);
				m=true;
				while(a<b1&&!compareIndices(A,a-1,a)){
					m=false;
					a++;
				}
				if(a==b1)m=true;
			}while(1);
		}
		await quickSort(arr,0,len);
	}
	async PDQBranchedSort(len){
		const pdq=new PDQSorting();
		await pdq.pdqLoop(arr,0,len,false,pdq.pdqLog(len));
	}
	async PDQBranchlessSort(len){
		const pdq=new PDQSorting();
		await pdq.pdqLoop(arr,0,len,true,pdq.pdqLog(len));
	}
	async wikiSort(len){
		class Range{
			constructor(s=0,e=0){
				this.s=s;
				this.e=e;
			}
			set(s,e){
				this.s=s;
				this.e=e;
			}
			l(){return this.e-this.s}
		}
		class Pull{
			r=new Range();
			reset(){
				this.r.set(0,0);
				this.f=this.t=this.c=0;
			}
		}
		class Iterator{
			constructor(s,m){
				this.s=s;
				let x=s;
				for(let i=0;i<5;i++)x|=x>>2**i;
				this.d=(x-(x>>1))/m|0;
				this.ns=s%this.d;
				this.ds=s/this.d|0;
				this.b();
			}
			b(){this.n=this.dc=0}
			nR(){
				let s=this.dc;
				this.dc+=this.ds;this.n+=this.ns;
				if(this.n>=this.d){
					this.n-=this.d;
					this.dc++;
				}
				return new Range(s,this.dc);
			}
			dn(){return this.dc>=this.s}
			nL(){
				this.ds*=2;this.ns*=2;
				if(this.ns>=this.d){
					this.ns-=this.d;
					this.ds++;
				}
				return this.ds<this.s;
			}
			l(){return this.ds}
		}
		let bt=ask(`Cache Size\n0:  0\n1:  32\n2:  ${(len+1)/2|0}\n3:  ${sqrt((len+1)/2+1)|0}`,0),csz=0;
		switch(Number(bt)){
			case 1:csz=32;break;
			case 2:csz=len/2|0;break;
			case 3:csz=sqrt((len+1)/2+1)|0;break;
		}
		let ref=csz?new Array(csz):null;
		function binF(A,v,r){
			let{s,e}=r;e--;
			while(s<e){
				let m=s+(e-s)/2|0;
				if(compareValues(A[m],v)<0)s=m+1;
				else e=m;
			}
			if(s==r.e-1&&compareValues(A[s],v)<0)s++;
			return s;
		}
		function binL(A,v,r){
			let{s,e}=r;e--;
			while(s<e){
				let m=s+(e-s)/2|0;
				if(compareValues(A[m],v)<1)s=m+1;
				else e=m;
			}
			if(s==r.e-1&&compareValues(A[s],v)<1)s++;
			return s;
		}
		function findFF(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.s+sk;compareValues(A[i-1],v)<0;i+=sk)
				if(i>=r.e-sk)return binF(A,v,new Range(i,r.e));
			return binF(A,v,new Range(i-sk,i));
		}
		function findLF(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.s+sk;compareValues(A[i-1],v)<1;i+=sk)
				if(i>=r.e-sk)return binL(A,v,new Range(i,r.e));
			return binL(A,v,new Range(i-sk,i));
		}
		function findFB(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.e-sk;i>r.s&&compareValues(v,A[i-1])<1;i-=sk)
				if(i<r.s+sk)return binF(A,v,new Range(r.s,i));
			return binF(A,v,new Range(i,i+sk));
		}
		function findLB(A,v,r,u){
			if(!r.l())return r.s;
			let i,sk=maxVal(r.l()/u|0,1);
			for(i=r.e-sk;i>r.s&&compareValues(v,A[i-1])<0;i-=sk)
				if(i<r.s+sk)return binL(A,v,new Range(r.s,i));
			return binL(A,v,new Range(i,i+sk));
		}
		async function insertion(A,r){
			await insertSort(A,r.s,r.e,.5);
		}
		async function reverse(A,r){
			await reversal(A,r.s,r.e-1,1,true);
		}
		async function blockSwap(A,s1,s2,b){
			for(let i=0;i<b;i++)
				await swap(A,s1+i,s2+i,1,true);
		}
		async function rotate(A,am,r,u){
			if(!r.l())return;
			let spl=am>=0?r.s+am:r.e+am;
			let r1=new Range(r.s,spl),r2=new Range(spl,r.e);
			if(u){
				if(r1.l()<=r2.l()){
					if(r1.l()<=csz){
						if(ref){
							arraycopy(A,r1.s,ref,0,r1.l(),0,false,true);
							await arraycopy(A,r2.s,A,r1.s,r2.l(),1,true);
							await arraycopy(ref,0,A,r1.s+r2.l(),r1.l(),1,true);
						}
						return;
					}
				}else{
					if(r2.l()<=csz){
						if(ref){
							arraycopy(A,r2.s,ref,0,r2.l(),0,false,true);
							await arraycopy(A,r1.s,A,r2.e-r1.l(),r1.l(),1,true);
							await arraycopy(ref,0,A,r1.s,r2.l(),1,true);
						}
						return;
					}
				}
			}
			await reverse(A,r1);
			await reverse(A,r2);
			await reverse(A,r);
		}
		async function merge(f,A,B,to,ati,x){
			let A1=A.s,B1=B.s;
			let insi=ati;
			let A2=A.e,B2=B.e;
			while(1){
				if(compareIndices(f,A1,B1)<1){
					await write(to,insi++,f[A1++],1,false,x);
					if(A1==A2){
						await arraycopy(f,B1,to,insi,B2-B1,1,false,x);
						break;
					}
				}else{
					await write(to,insi++,f[B1++],1,false,x);
					if(B1==B2){
						await arraycopy(f,A1,to,insi,A2-A1,1,true,x);
						break;
					}
				}
			}
		}
		async function mergeExt(a,A,B){
			let A1=0,B1=B.s;
			let insi=A.s;
			let A2=A.l(),B2=B.e;
			if(B.l()>0&&A.l()>0){
				while(1){
					if(compareValues(ref[A1],a[B1])<1){
						await write(a,insi++,ref[A1++],1,true);
						if(A1==A2)break;
					}else{
						await write(a,insi++,a[B1++],1,true);
						if(B1==B2)break;
					}
				}
			}
			if(ref!=null)
				await arraycopy(ref,A1,a,insi,A2-A1,1,true);
		}
		async function mergeInt(a,A,B,b){
			let Ac=0,Bc=0,ins=0;
			if(B.l()>0&&A.l()>0){
				while(1){
					if(compareIndices(a,b.s+Ac,B.s+Bc)<1){
						await swap(a,A.s+ins++,b.s+Ac++,0,true);
						if(Ac>=A.l())break;
					}else{
						await swap(a,A.s+ins++,B.s+Bc++,0,true);
						if(Bc>=B.l())break;
					}
				}
			}
			await blockSwap(a,b.s+Ac,A.s+ins,A.l()-Ac);
		}
		async function mergeInPlace(a,A,B){
			if(!A.l()||!B.l())return;
			A=new Range(A.s,A.e);
			B=new Range(B.s,B.e);
			while(1){
				let m=binF(a,a[A.s],B);
				let am=m-A.e;
				await rotate(a,-am,new Range(A.s,m),true);
				if(B.e==m)break;
				A.set(A.s+am,B.s=m);
				A.s=binL(a,a[A.s],A);
				if(!A.l())break;
			}
		}
		async function netSwap(A,o,r,x,y){
			let c=compareIndices(A,r.s+x,r.s+y);
			if(c>0||(compareIndices(o,x,y)>0&&!c)){
				await swap(A,r.s+x,r.s+y,1,true);
				await swap(o,x,y,0);
			}
		}
		async function sort(A,len){
			let z=len;
			if(z<4){
				if(z>2){
					if(compareIndices(A,1,0)<0)
						await swap(A,0,1,1,true);
					if(compareIndices(A,2,1)<0){
						await swap(A,1,2,1,true);
						if(compareIndices(A,1,0)<0)
							await swap(A,0,1,1,true);
					}
				}else if(z>1)
					if(compareIndices(A,1,0)<0)
						await swap(A,0,1,1,true);
				return;
			}
			let itr=new Iterator(z,4);
			while(!itr.dn()){
				let r=itr.nR(),sws=[];
				switch(r.l()){
					case 8:sws=[[0,1],[2,3],[4,5],[6,7],[0,2],[1,3],[4,6],[5,7],[1,2],[5,6],[0,4],[3,7],[1,5],[2,6],[1,4],[3,6],[2,4],[3,5],[3,4]];break;
					case 7:sws=[[1,2],[3,4],[5,6],[0,2],[3,5],[4,6],[0,1],[4,5],[2,6],[0,4],[1,5],[0,3],[2,5],[1,3],[2,4],[2,3]];break;
					case 6:sws=[[1,2],[4,5],[0,2],[3,5],[0,1],[3,4],[2,5],[0,3],[1,4],[2,4],[1,3],[2,3]];break;
					case 5:sws=[[0,1],[3,4],[2,4],[2,3],[1,4],[0,3],[0,2],[1,3],[1,2]];break;
					case 4:sws=[[0,1],[2,3],[0,2],[1,3],[1,2]];break;
				}
				for(let i=0;i<sws.length;i++)
					await netSwap(A,[0,1,2,3,4,5,6,7],r,...sws[i]);
			}
			if(z<8)return;
			let br1=new Range(),br2=new Range();
			let blA=new Range(),blB=new Range();
			let lsA=new Range(),lsB=new Range();
			let fA=new Range();
			let rA=new Range(),rB=new Range();
			let pl=[new Pull(),new Pull()];
			while(1){
				if(itr.l()<csz){
					if(itr.l()*4+3<csz&&itr.l()*4<=z){
						itr.b();
						while(!itr.dn()){
							let A1=itr.nR(),B1=itr.nR();
							let A2=itr.nR(),B2=itr.nR();
							if(compareValues(A[B1.e-1],A[A1.s])<0){
								arraycopy(A,A1.s,ref,B1.l(),A1.l(),0,false,true);
								arraycopy(A,B1.s,ref,0,B1.l(),0,false,true);
							}else if(compareIndices(A,B1.s,A1.e-1)<0){
								await merge(A,A1,B1,ref,0,true);
							}else{
								if(compareIndices(A,A2.e-1,B2.s)<1&&compareIndices(A,B1.e-1,A2.s)<1)continue;
								arraycopy(A,A1.s,ref,0,A1.l(),0,false,true);
								arraycopy(A,B1.s,ref,A1.l(),B1.l(),0,false,true);
							}
							A1.set(A1.s,B1.e);
							if(compareIndices(A,B2.e-1,A2.s)<0){
								arraycopy(A,A2.s,ref,A1.l()+B2.l(),A2.l(),0,false,true);
								arraycopy(A,B2.s,ref,A1.l(),B2.l(),0,false,true);
							}else if(compareIndices(A,B2.s,A2.e-1)<0){
								await merge(A,A2,B2,ref,A1.l(),true);
							}else{
								arraycopy(A,A2.s,ref,A1.l(),A2.l(),0,false,true);
								arraycopy(A,B2.s,ref,A1.l()+A2.l(),B2.l(),0,false,true);
							}
							A2.set(A2.s,B2.e);
							let A3=new Range(0,A1.l());
							let B3=new Range(A1.l(),A1.l()+A2.l());
							if(compareIndices(ref,B3.e-1,A3.s)<0){
								await arraycopy(ref,A3.s,A,A1.s+A2.l(),A3.l(),1,true);
								await arraycopy(ref,B3.s,A,A1.s,B3.l(),1,true);
							}else if(compareIndices(ref,B3.s,A3.e-1)<0){
								await merge(ref,A3,B3,A,A1.s,false);
							}else{
								await arraycopy(ref,A3.s,A,A1.s,A3.l(),1,true);
								await arraycopy(ref,B3.s,A,A1.s+A1.l(),B3.l(),1,true);
							}
						}
						itr.nL();
					}else{
						itr.b();
						while(!itr.dn()){
							rA=itr.nR();
							rB=itr.nR();
							if(compareIndices(A,rB.e-1,rA.s)<0)await rotate(A,rA.l(),new Range(rA.s,rB.e),true);
							else if(compareIndices(A,rB.s,rA.e-1)<0){
								arraycopy(A,rA.s,ref,0,rA.l(),0,false,true);
								await mergeExt(A,rA,rB);
							}
						}
					}
				}else{
					let blz=sqrt(itr.l())|0;
					let brz=itr.l()/blz+1|0;
					let i,ls,cn,pl_i=0;
					br1.set(0,0);
					br2.set(0,0);
					pl[0].reset();
					pl[1].reset();
					let f=brz+brz;
					let fs=false;
					if(blz<=csz)f=brz;
					else if(f>itr.l()){
						f=brz;
						fs=true;
					}
					itr.b();
					while(!itr.dn()){
						rA=itr.nR();
						rB=itr.nR();
						for(ls=rA.s,cn=1;cn<f;ls=i,cn++){
							i=findLF(A,A[ls],new Range(ls+1,rA.e),f-cn);
							if(i==rA.e)break;
						}
						i=ls;
						if(cn>=brz){
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rA.s;
							pl_i=1;
							if(cn==2*brz){
								br1.set(rA.s,rA.s+brz);
								br2.set(rA.s+brz,rA.s+cn);
								break;
							}else if(f==2*brz){
								br1.set(rA.s,rA.s+cn);
								f=brz;
							}else if(blz<=csz){
								br1.set(rA.s,rA.s+cn);
								break;
							}else if(fs){
								br1=new Range(rA.s,rA.s+cn);
								fs=false;
							}else{
								br2.set(rA.s,rA.s+cn);
								break;
							}
						}else if(!pl_i&&cn>br1.l()){
							br1.set(rA.s,rA.s+cn);
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rA.s;
						}
						for(ls=rB.e-1,cn=1;cn<f;ls=i-1,cn++){
							i=findFB(A,A[ls],new Range(rB.s,ls),f-cn);
							if(i==rB.s)break;
						}
						i=ls;
						if(cn>=brz){
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rB.e;
							pl_i=1;
							if(cn==2*brz){
								br1.set(rB.e-cn,rB.e-brz);
								br2.set(rB.e-brz,rB.e);
								break;
							}else if(f==2*brz){
								br1.set(rB.e-cn,rB.e);
								f=brz;
							}else if(blz<=csz){
								br1.set(rB.e-cn,rB.e);
								break;
							}else if(fs){
								br1=new Range(rB.e-cn,rB.e);
								fs=false;
							}else{
								if(pl[0].r.s==rA.s)pl[0].r.e-=pl[1].c;
								br2.set(rB.e-cn,rB.e);
								break;
							}
						}else if(!pl_i&&cn>br1.l()){
							br1.set(rB.e-cn,rB.e);
							pl[pl_i].r.set(rA.s,rB.e);
							pl[pl_i].c=cn;
							pl[pl_i].f=i;
							pl[pl_i].t=rB.e;
						}
					}
					for(pl_i=0;pl_i<2;pl_i++){
						let l=pl[pl_i].c;
						if(pl[pl_i].t<pl[pl_i].f){
							i=pl[pl_i].f;
							for(cn=1;cn<l;cn++){
								i=findFB(A,A[i-1],new Range(pl[pl_i].t,pl[pl_i].f-(cn-1)),l-cn);
								let r=new Range(i+1,pl[pl_i].f+1);
								await rotate(A,r.l()-cn,r,true);
								pl[pl_i].f=i+cn;
							}
						}else if(pl[pl_i].t>pl[pl_i].f){
							i=pl[pl_i].f+1;
							for(cn=1;cn<l;cn++){
								i=findLF(A,A[i],new Range(i,pl[pl_i].t),l-cn);
								let r=new Range(pl[pl_i].f,i-1);
								await rotate(A,cn,r,true);
								pl[pl_i].f=i-1-cn;
							}
						}
					}
					brz=br1.l();
					blz=itr.l()/brz+1|0;
					itr.b();
					while(!itr.dn()){
						rA=itr.nR();
						rB=itr.nR();
						let st=rA.s;
						if(st==pl[0].r.s){
							if(pl[0].f>pl[0].t){
								rA.s+=pl[0].c;
								if(!rA.l())continue;
							}else if(pl[0].f<pl[0].t){
								rB.e-=pl[0].c;
								if(rB.l()==0)continue;
							}
						}
						if(st==pl[1].r.s){
							if(pl[1].f>pl[1].t){
								rA.s+=pl[1].c;
								if(!rA.l())continue;
							}else if(pl[1].f<pl[1].t){
								rB.e-=pl[1].c;
								if(!rB.l())continue;
							}
						}
						if(compareValues(A[rB.e-1],A[rA.s])<0){
							await rotate(A,rA.l(),new Range(rA.s,rB.e),true);
						}else if(compareIndices(A,rA.e,rA.e-1)<0){
							blA.set(rA.s,rA.e);
							fA.set(rA.s,rA.s+blA.l()%blz);
							let iA=br1.s;
							for(i=fA.e;i<blA.e;i+=blz){
								await swap(A,iA,i,10,true);
								iA++;
							}
							lsA.set(fA.s,fA.e);
							lsB.set(0,0);
							blB.set(rB.s,rB.s+minVal(blz,rB.l()));
							blA.s+=fA.l();
							iA=br1.s;
							if(lsA.l()<=csz&&ref!=null){
								arraycopy(A,lsA.s,ref,0,lsA.l(),0,false,true);
							}else if(br2.l()>0)
								await blockSwap(A,lsA.s,br2.s,lsA.l());
							if(blA.l()>0){
								while(1){
									if((lsB.l()>0&&compareIndices(A,iA,lsB.e-1)<1)||!blB.l()){
										let B_sp=binF(A,A[iA],lsB);
										let B_rm=lsB.e-B_sp;
										let minA=blA.s;
										for(let fA=minA+blz;fA<blA.e;fA+=blz)
											if(compareIndices(A,fA,minA)<0)
												minA=fA;
										await blockSwap(A,blA.s,minA,blz);
										await swap(A,blA.s,iA++,1,true);
										if(lsA.l()<=csz)
											await mergeExt(A,lsA,new Range(lsA.e,B_sp));
										else if(br2.l()>0)
											await mergeInt(A,lsA,new Range(lsA.e,B_sp),br2);
										else
											await mergeInPlace(A,lsA,new Range(lsA.e,B_sp));
										if(br2.l()>0||blz<=csz){
											if(blz<=csz)
												arraycopy(A,blA.s,ref,0,blz,0,false,true);
											else
												await blockSwap(A,blA.s,br2.s,blz);
											await blockSwap(A,B_sp,blA.s+blz-B_rm,B_rm);
										}else
											await rotate(A,blA.s-B_sp,new Range(B_sp,blA.s+blz),true);
										lsA.set(blA.s-B_rm,blA.s-B_rm+blz);
										lsB.set(lsA.e,lsA.e+B_rm);
										blA.s+=blz;
										if(!blA.l())break;
									}else if(blB.l()<blz){
										await rotate(A,-blB.l(),new Range(blA.s,blB.e),false);
										lsB.set(blA.s,blA.s+blB.l());
										blA.s+=blB.l();
										blA.e+=blB.l();
										blB.e=blB.s;
									}else{
										await blockSwap(A,blA.s,blB.s,blz);
										lsB.set(blA.s,blA.s+blz);
										blA.s+=blz;
										blA.e+=blz;
										blB.s+=blz;
										blB.e+=blz;
										if(blB.e>rB.e)
											blB.e=rB.e;
									}
								}
							}
							if(lsA.l()<=csz)
								await mergeExt(A,lsA,new Range(lsA.e,rB.e));
							else if(br2.l()>0)
								await mergeInt(A,lsA,new Range(lsA.e,rB.e),br2);
							else
								await mergeInPlace(A,lsA,new Range(lsA.e,rB.e));
						}
					}
					await insertion(A,br2);
					for(pl_i=0;pl_i<2;pl_i++){
						let u=pl[pl_i].c*2;
						if(pl[pl_i].f>pl[pl_i].t){
							let br=new Range(pl[pl_i].r.s,pl[pl_i].r.s+pl[pl_i].c);
							while(br.l()>0){
								i=findFF(A,A[br.s],new Range(br.e,pl[pl_i].r.e),u);
								let am=i-br.e;
								await rotate(A,br.l(),new Range(br.s,i),true);
								br.s+=am+1;
								br.e+=am;
								u-=2;
							}
						}else if(pl[pl_i].f<pl[pl_i].t){
							let br=new Range(pl[pl_i].r.e-pl[pl_i].c,pl[pl_i].r.e);
							while(br.l()>0){
								i=findLB(A,A[br.e-1],new Range(pl[pl_i].r.s,br.s),u);
								let am=br.s-i;
								await rotate(A,am,new Range(i,br.e),true);
								br.s-=am;
								br.e-=am+1;
								u-=2;
							}
						}
					}
				}
				if(!itr.nL())break;
			}
		}
		await sort(arr,len);
	}
	async apollyonSort(len){
		let dir=!Number(ask("0: Forward\n1: Backward",0));
		function gPOT(n){
			let k=1;
			while(k<n)k=k<<1;
			return k>>1;
		}
		async function compare(A,i,j,d){
			let c=compareIndices(A,i,j);
			if(d==(c>0))await swap(A,i,j,.5,true);
		}
		async function apollyonMerge(A,lo,n,d){
			if(n>1){
				let m=gPOT(n);
				for(let i=lo;i<lo+n-m;i++)await compare(A,i,i+m,d);
				await apollyonMerge(A,lo,m,d);
				await apollyonMerge(A,lo+m,n-m,d);
			}
		}
		async function apollyonSort(A,lo,n,d){
			if(n>1){
				let m=n/2|0;
				await apollyonSort(A,lo,m,!d);
				await apollyonMerge(A,lo,n,d);
			}
		}
		let th=0,n=1;
		for(;n<len;n*=2,th++);
		th=th/2|0;
		let it=0;
		await apollyonSort(arr,0,len,dir);
		while(await recursiveCircleSortRoutine(arr,0,len-1,0)){
			if(++it>=th){
				await insertSort(arr,0,len);
				break;
			}
		}
	}
	async optimizedOddEvenMergeSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		async function compRange(A,a,m,s){
			for(let i=s;a+i<m;i++)
				await compSwap(A,a+i,m+i);
		}
		async function compRangeExtd(A,a,m,p){
			let l=m-a;
			if(l>p){
				let i=a,j,d=l-p;
				for(j=0;j<d;j++,i++)await compSwap(A,i,i+p);
				for(j=0;j<p-d;j++,i++)await compSwap(A,i,i+l);
				for(j=0;j<d;j++,i++)await compSwap(A,i+d,i+l);
			}else await compRange(A,a,m,0);
		}
		async function merge(A,a,b){
			let m,s=(b-a)%2;
			a-=s;
			m=(a+b)/2|0;
			await compRange(A,a,m,s);
			let l=b-a;
			if(l<4)return;
			let p;
			for(p=1;2*p<l;p*=2);
			while(p>0){
				let i=a+p;
				while(i+2*p<=m){
					await compRange(A,i,i+p,0);
					i+=2*p;
				}
				await compRangeExtd(A,i,m,p);
				i=2*m-i;
				while(i<b-p){
					await compRange(A,i,i+p,0);
					i+=2*p;
				}
				p=p/2|0;
			}
		}
		async function mergeSort(A,a,b){
			let m=(a+b)/2|0;
			if(m-a>1)await mergeSort(A,a,m);
			if(b-m>1)await mergeSort(A,m,b);
			await merge(A,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async inPlaceMSDRadixSort(len){
		let base=askForNum(10,"Base");
		async function radixMSD(A,l,n,x,r,p){
			if(n>=x||p<0)return;
			let ids=new Array(r).fill(0);
			for(let i=0;i<r;i++)
				ids[i]=n;
			for(let i=n;i<x;i++){
				let t=A[i];
				let d=getDigit(t,p,r);
				for(let j=r-1;j>d;j--){
					if(ids[j]-ids[j-1])
						await write(A,ids[j],A[ids[j-1]],0,true);
					write(ids,j,ids[j]+1,0,false,true);
				}
				await write(A,ids[d],t,0,true);
				write(ids,d,ids[d]+1,0,false,true);
			}
			for(let i=0;i<r;i++){
				let sn=!i?n:ids[i-1];
				await radixMSD(A,l,sn,ids[i],r,p-1);
			}
		}
		let hp=analyzeMaxLog(arr,len,base);
		await radixMSD(arr,len,0,len,base,hp);
	}
	async LMSDRadixSort(len){
		let base=askForNum(10,"Base");
		async function radixSort(A,s,e,p){
			let rgs=new Array(base);
			for(let i=0;i<base;i++)rgs[i]=[];
			for(let i=s;i<e;i++){
				let d=getDigit(A[i],p,base);
				rgs[d].push(A[i]);
			}
			let c=s;
			for(let i=0;i<base;i++)
				for(let j=0;j<rgs[i].length;j++)
					await write(A,c++,rgs[i][j],1,true);
			return rgs;
		}
		async function lmsdRadixSort(A,na,xa,p,mp){
			if(mp<p||xa-na<2)return;
			let rgs=await radixSort(A,na,xa,p);
			if(p-mp){
				rgs=await radixSort(A,na,xa,mp);
				let s=0;
				for(let i=0;i<rgs.length;i++){
					await lmsdRadixSort(A,s+na,s+na+rgs[i].length,p+1,mp-1);
					s+=rgs[i].length;
					rgs[i]=[];
				}
			}
		}
		let hp=analyzeMaxLog(arr,len,base);
		await lmsdRadixSort(arr,0,len,0,hp);
	}
	async quickBinaryRadixSort(len){
		let base=askForNum(10,"Base");
		async function partition(A,a,b,t){
			let i=a-1;
			let j=b;
			while(1){
				do i++;while(i<b&&!getBit(A[i],t));
				do j--;while(j>=a&&getBit(A[j],t));
				if(i<j)await swap(A,i,j,1,true);
				else return i;
			}
		}
		async function radixLSD(A,a,b,p,t){
			let m=p;
			for(let i=a;i<b;i++)
				if(!getBit(A[i],t))m++;
			for(let i=a;i<b;i++){
				if(getBit(A[i],t))
					await swap(A,i,m++,.5,true);
				else
					await swap(A,i,p++,.5,true);
			}
		}
		async function radixLSDSort(A,a,b,p,mb){
			let pw=0,l=b-a;
			while(pw<mb){
				await radixLSD(A,a,b,p,pw++);
				if(pw>=mb){
					for(let i=0;i<l;i++)
						await swap(A,a+i,p+i,.5,true);
					return;
				}else await radixLSD(A,p,p+l,a,pw++);
			}
		}
		async function quickRadixSort(A,a,b,mb){
			let s=a,e=b;
			while(mb>=0){
				let p=await partition(A,s,e,mb);
				let l=p-s,r=e-p;
				if(l<r){
					await radixLSDSort(A,s,p,p,mb);
					s=p;
				}else{
					await radixLSDSort(A,p,e,p-r,mb);
					e=p;
				}
				mb--;
			}
		}
		let mb=analyzeBit(arr,len);
		await quickRadixSort(arr,0,len,mb);
	}
	async optimizedIndexSort(len){
		let n=minVal(...arr);
		for(let i=0;i<len;i++){
			let c=arr[i];
			let cm=0;
			while(compareValues(i,c-n)&&cm<len){
				let t=arr[c-n];
				await write(arr,c-n,c,.5,true);
				c=t;cm++;
			}
			if(cm>=len-1)break;
			if(cm>0)
				await write(arr,i,c,.5,true);
		}
	}
	async divisorSort(len){
		let base=askForNum(10,"Base",1);
		async function safePush(aL,i,v){
			while(aL.length<=i)aL.push([]);
			aL[i].push(v);
		}
		async function divisorLoop(A,s,l,b,lg){
			let dv=b**lg;
			let bc=[];
			for(let i=s;i<s+l;i++)
				safePush(bc,(A[i]-s)/dv|0,A[i]);
			let cr=s;
			for(let i=0;i<bc.length;i++){
				let z=bc[i].length;
				for(let j=0;j<z;j++)
					await write(A,cr+j,bc[i][j],1,true);
				if(z>1)
					await divisorLoop(A,cr,z,b,lg/2|0);
				cr+=z;
			}
		}
		let hl=analyzeMaxLog(arr,len,base);
		await divisorLoop(arr,0,len,base,hl/2|0);
	}
	async cospoSort(len){
		function sortexternal(A,cr,l){
			let min=1/0;
			let max=-1/0;
			for(let i=0;i<len;i++){
				if(A[i]<min)min=A[i];
				if(A[i]>max)max=A[i];
			}
			let mi=min;
			let z=max-mi+1;
			let h=new Array(z).fill(0);
			for(let x=0;x<l;x++)
				write(h,A[x]-mi,h[A[x]-mi]+1,1,false,true);
			let j=0;
			for(let cn=0;cn<z;cn++)
				for(let i=0;i<h[cn];i++)
					write(cr,j++,cn+mi,1,false,true);
		}
		async function sort(A,l){
			let cr=new Array(l);
			sortexternal(A,cr,l);
			let s1=0,s2=0,vL=0;
			let vR=len-1;
			while(!compareValues(A[vL],cr[vL])){
				vL++;
				if(vL==vR)break;
			}
			if(vL-vR)
				while(!compareValues(A[vR],cr[vR]))
					vR--;
			while(vL<vR){
				let s1f=false;
				while(!s1f){
					s1=randInt(vL,vR+1);
					s1f=compareValues(A[s1],cr[s1]);
				}
				let s2f=false;
				while(!s2f){
					s2=randInt(vL,vR+1);
					if(s1-s2)
						s2f=compareValues(A[s2],cr[s2]);
				}
				await swap(A,s1,s2,0,true);
				while(!compareValues(A[vL],cr[vL])){
					vL++;
					if(vL==vR)break;
				}
				if(vL!=vR)
					while(!compareValues(A[vR],cr[vR]))
						vR--;
			}
		}
		await sort(arr,len);
	}
	async bovoSort(len){
		let p=1,j=0;
		while(!isArraySorted(arr,len)){
			p=randInt(0,len-1);
			let mp=p;
			while(p>=0)
				swap(arr,p+1,p--,0);
			mark(mp);
			if(++j>=sqrt(len))await sleep(j=0);
		}
	}
	async sliceBogoSort(len){
		let j=0;
		while(!isArraySorted(arr,len)){
			let i1=randInt(0,len),i2=randInt(0,len);
			if(i1<i2)bogoSwap(arr,i1,i2+1);
			else bogoSwap(arr,i2,i1+1);
			if(++j>=sqrt(len))await sleep(j=0);
		}
	}
	async optimizedPigeonholeSort(len){
		let n=1/0,x=-1/0;
		for(let i=0;i<len;i++){
			if(arr[i]<n)n=arr[i];
			if(arr[i]>x)x=arr[i];
		}
		let mi=n,z=x-mi+1,h=new Array(z).fill(0);
		for(let i=0;i<len;i++)await write(h,arr[i]-mi,h[arr[i]-mi]+1,1,true,true);
		for(let c=0,j=0;c<z;c++)for(let i=0;i<h[c];i++)await write(arr,j++,c+mi,1,true);
	}
	async asteraceaeSort(len){
		let i=1,fs=2,j=0;
		let as=true,ls=false;
		while(as){
			if(fs==1)i=1;
			else i=fs-1;
			as=ls=false;
			while(i<len){
				if(compareIndices(arr,i-1,i)>0){
					swap(arr,i-1,i++,0);
					if(++j>=sqrt(len))await mark(i-2,j=0);
					if(!as)fs=i-1;
					as=ls=true;
				}else{
					if(ls)i+=sqrt(len)|0;
					else i++;
					ls=false;
				}
			}
		}
	}
	async awkwardSort(len){
		let j=0;
		async function awkward(A,l,p){
			if(l<2)return;
			await awkward(A,l/2|0,p);
			await awkward(A,l/2+l%2|0,p+l/2|0);
			for(let i=0;i<l/2|0;i++){
				let a=p+i,b=p+l/2+l%2+i|0,sl=false
				if(++j>=sqrt(len)){
					await markSwap(a,b,j=0);
					draw();
					sl=true;
				}
				if(compareIndices(A,a,b)>0){
					swap(A,a,b,0);
					if(sl)await sleep();
				}
			}
			await awkward(A,l/2+l%2|0,p+l/4|0);
			await awkward(A,l/2|0,p);
			await awkward(A,l/2+l%2|0,p+l/2|0);
		}
		await awkward(arr,len,0);
	}
	async chinottoSort(len){
		let d=false,g=1;
		while(!d){
			let i=0;
			d=true;
			while(i+g<len){
				if(compareIndices(arr,i,i+g)>0){
					d=false;
					await multiSwap(arr,i,i+g++,.5,true);
				}else if(g>1)g--;
				i++;
			}
			while(i-g>0){
				if(compareValues(arr,i-g,i)>0){
					d=false;
					await multiSwap(arr,i,i-g++,.5,true);
				}else if(g>1)g--;
				i--;
			}
		}
	}
	async circleMergeSort(len){
		let n=1;
		for(;n<=len;n*=2)
			while(await iterativeCircleSortRoutine(arr,n));
	}
	async clamberSort(len){
		let k=0;
		for(let i=1;i<len;i++)
			for(let j=0;j<i;j++)
				if(compareIndices(arr,i,j)<0){
					swap(arr,i,j,0);
					if(++k>=sqrt(len)/2)await markSwap(i,j,k=0);
				}
	}
	async XSort(len){
		let g=len;
		let i=1,xl=1,xr=1;
		let as=false,d=false;
		while(!d){
			as=false;
			i=1;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					swap(arr,i-1,i-1+g);
					as=true;
					xl=i+1;xr=i+g-1;
					if(g-1)
						for(let r=0;r<g-1;r++){
							if(compareIndices(arr,xl-1,xr-1)>0)
								swap(arr,xl-1,xr-1);
							xl++;xr--;
						}
					await sleep();
				}
				i++;
			}
			if(g==1&&!as)d=true;
			else if(g-1&&!as)g--;
		}
	}
	async floatSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let g=len-1,h=0;g>0;g--){
				let i=h,j=h+1;
				while(i>=0&&compareIndices(arr,i,j)>0)await swap(arr,i--,j--,.5,true,s=false);
				if(i>=0){
					i++;j++;
					while(j<len&&compareIndices(arr,i,j)>0)await swap(arr,i++,j++,.5,true,s=false);
				}
				h++;
			}
		}
	}
	async reflectionSort(len){
		let as=true,i=0;
		while(as){
			i=0;as=false;
			while(i<len)
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,.125,as=true);
					i=len-1-i;
				}else i++;
			i=len;as=false;
			while(i>1)
				if(compareIndices(arr,i-1,i)>0){
					await swap(arr,i-1,i,.125,as=true);
					i=len-1-i;
				}else i--;
		}
	}
	async splitCenterSort(len){
		let d=1,i=1;
		for(let r=1;r<len;r++){
			i=len/2|0;
			while(i<len&&i>0){
				if(compareIndices(arr,i-1,i)>0)await swap(arr,i-1,i,.005,true);
				i+=d;
			}
			d=-d;
		}
	}
	async merryGoRoundSort(len){
		let i=1,v=1,d=1,j=0;
		let csp=false,str=false;
		while(!str){
			i=v;
			csp=false;
			while(i<len){
				let mi=i;
				if(compareIndices(arr,i-1,i)>0){
					csp=true;
					d=i;
					while(d+1<=len){
						swap(arr,d-1,d,0);
						d+=2;
						if(++j>=len)await mark(mi,j=0);
					}
					if(i>1)i--;
				}else i+=2;
			}
			if(!csp){
				v=1;
				str=true;
				while(v-len&&str)
					if(compareIndices(arr,v-1,v)<1)v++;
					else str=false;
			}
		}
	}
	async indexQuickSort(len){
		async function indexSort(A,x,a,b){
			for(;a<b;a++){
				if(compareValues(a,x[a])){
					let t=A[a];
					let i=a,n=x[a];
					do{
						await write(A,i,A[n],0,true);
						write(x,i,i,0,false,true);
						i=n;
						n=x[n];
					}while(compareValues(n,a));
					await write(A,i,t,0,true);
					write(x,i,i,0,false,true);
				}
			}
		}
		async function partition(A,x,a,b){
			let c0=a,c1=c0,i,p;
			let r=new Random();
			let m=a+r.nextInt(b-a)|0;
			for(i=a;i<m;i++)if(compareIndices(A,i,m)<1)c1++;
			for(i++,c1++;i<b;i++)if(compareIndices(A,i,m)<0)c1++;
			for(p=c1-1,i=a;i<m;i++)
				if(compareIndices(A,i,m)<1)write(x,c0++,i,0,false,true);
				else write(x,c1++,i,0,false,true);
			write(x,p,i++,0,false,true);
			for(;i<b;i++)
				if(compareIndices(A,i,m)<0)write(x,c0++,i,0,false,true);
				else write(x,c1++,i,0,false,true);
			await indexSort(A,x,a,b);
			return p;
		}
		async function sort(A,i,a,b){
			if(b-a<2)return;
			let p=await partition(A,i,a,b);
			await sort(A,i,a,p);
			await sort(A,i,p+1,b);
		}
		await sort(arr,new Array(len),0,len);
	}
	async pushSort(len){
		let as=true;
		let i=1,g=1;
		while(as){
			as=false;
			i=g=1;
			while(i+g<=len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await mark(i);
					for(let j=1;j<=g;j++)
						swap(arr,i-1,i-1+j,0);
					as=true;
					g++;
				}else i++;
			}
		}
	}
	async playgroundSort(len){
		function selectLowest(A,l){
			let li=0;
			for(let j=0;j<l;j++)if(compareIndices(A,j,li)<0)li=j;
			return li;
		}
		function selectNext(A,l,t){
			let lh=-1,r=0;
			while(r<l){
				if(compareIndices(A,t,r)<0){
					if(lh==-1)lh=r;
					else if(compareIndices(A,lh,r)>0)lh=r;
				}
				r++;
			}
			return lh;
		}
		async function chase(A,i,t){
			let d=0,c=0;
			if(abs(t-i)-1){
				if(t-i>0)d=1;
				else d=-1;
				c=i;
				while(abs(t-c)-1){
					swap(A,c,c+d,0);
					c+=d;
				}
			}
		}
		async function quit(A,b,i){
			let p=i;
			while(p+1<b)
				swap(A,p,++p,0);
		}
		let b=len;
		let lt=0,t=0,j=0;
		while(b>1){
			lt=selectLowest(arr,b);
			t=lt;
			while(t+1){
				t=selectNext(arr,b,lt);
				if(++j>=sqrt(len))await mark(t,j=0);
				if(t+1)chase(arr,lt,lt=t);
				else quit(arr,b,lt);
			}
			b--;
		}
	}
	async zipperSort(len){
		let i=0,g=2,f=0;
		while(g>1){
			g=1;
			i=f>1?f-1:0;
			while(i+g<len){
				if(compareIndices(arr,i,i+g)>0){
					await swap(arr,i,i+g,.1,true);
					if(g++==1)f=i;
				}else i++;
			}
		}
	}
	async wiggleSort(len){
		async function sort(A,l,s,e){
			if(e-s<2)return;
			let lP=s,rP=e,mP=(lP+rP)/2|0;
			let sL=true,j=mP;
			for(let i=lP;i<mP;i++){
				for(let k=mP;k<e;k++){
					if(compareIndices(A,j,i)<1)
						await swap(A,i,j,1,true);
					j+=sL?1:-1;
				}
				j-=sL?1:-1;
				sL=!sL;
			}
			await sort(A,l,s,mP);
			await sort(A,l,mP,e);
		}
		await sort(arr,len,0,len);
	}
	async pancakeQuickSort(len){
		async function flip(A,i,s){
			await reversal(A,0,i,s,true);
		}
		async function rotate(A,a,b,s){
			await flip(A,a-1,s/3);
			await flip(A,b-1,s/3);
			await flip(A,b-a-1,s/3);
		}
		function medOf3(A,a,b,c){
			if(a==b)return a;
			if(b==c)return b;
			if(compareIndices(A,a,b)<1){
				if(compareIndices(A,b,c)<1)return b;
				if(compareValues(A,a,c)<1)return c;
				return a;
			}
			if(compareIndices(A,b,c)<1)return b;
			if(compareIndices(A,a,c)<1)return a;
			return c;
		}
		async function pancakeLLQS(A,l,s){
			if(l<3){
				if(compareIndices(A,0,1)>0)
					await flip(A,l-1,s*10);
				return;
			}else if(l<2)return;
			let j=0,m=(l-1)/2|0,p=A[medOf3(A,0,m,l-1)];
			for(let i=0;i<l;i++){
				let k=i;
				while(k<l&&compareValues(p,A[k])+1){
					k++;
					j++;
				}
				if(k>i){
					await flip(A,i-1,s/4);
					await flip(A,k-1,s/4);
					i=k-1;
				}
			}
			await pancakeLLQS(A,j,s);
			await rotate(A,j,l,s);
			await pancakeLLQS(A,l-j,s);
			await rotate(A,l-j,l,s);
		}
		await pancakeLLQS(arr,len,.5);
	}
	async timSort(len){
		await TimSorting.sort(new TimSorting(arr,len),arr,0,len);
	}
	async cocktailMergeSort(len){
		let mRL=new TimSorting().minRunLength(len);
		if(len==mRL){
			await cocktailShaker(arr,0,len);
		}else{
			let i=0;
			for(;i<=len-mRL;i+=mRL)
				await cocktailShaker(arr,i,i+mRL);
			if(i+mRL>len)await cocktailShaker(arr,i,len);
			await TimSorting.sort(new TimSorting(arr,len),arr,0,len);
		}
	}
	async LLQuickSortMiddlePivot(len){
		async function partition(A,a,b){
			let i=a,j=i,m=(a+b)/2|0;
			while(j<m){
				if(compareValues(A[j],A[m])<1)
					await swap(A,i++,j,1,true);
				j++;
			}
			await swap(A,i,m,1,true);
			j=m+1;
			m=i++;
			while(j<b){
				if(compareValues(A[j],A[m])<0)
					await swap(A,i++,j,1,true);
				j++;
			}
			await swap(A,--i,m,1,true);
			return i;
		}
		async function quickSort(A,a,b){
			if(b-a>1){
				let p=await partition(A,a,b);
				await quickSort(A,a,p);
				await quickSort(A,p+1,b);
			}
		}
		await quickSort(arr,0,len);
	}
	async dandelionSort(len){
		let j=0;
		for(let b=0;b<len;){
			let p=b;
			let as=false;
			while(p<len-1&&compareIndices(arr,p+1,p)<0){
				swap(arr,p,++p,.5,true);
				if(++j>=sqrt(len))await sleep(j=0);
				as=true;
			}
			if(as){
				if(b>0)b--;
				continue;
			}
			b++;
		}
	}
	async cocktailGrateSort(len){
		let s=false;
		while(!s){
			s=true;
			let i;
			for(i=0;i<len-1;i++){
				for(let j=len-1;j>i;j--){
					if(compareIndices(arr,i,j)>0){
						s=false;
						await swap(arr,i,j,.1,true);
						break;
					}
				}
			}
			if(s)break;
			for(i=0;i<len-1;i++){
				for(let j=i+1;j<len;j++){
					if(compareIndices(arr,i,j)>0){
						await swap(arr,i,j,.1,true);
						break;
					}
				}
			}
		}
	}
	async cocktailPushSort(len){
		let as=true,i=1,g=1;
		while(as){
			as=false;
			i=g=1;
			while(i+g<=len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await mark(i-1);
					for(let j=1;j<=g;j++)swap(arr,i-1,i-1+j,.01);
					as=true;
					g++;
				}else i++;
			}
			i=len;
			g=1;
			while(i-g>0){
				if(compareIndices(arr,i-1-g,i-1)>0){
					await mark(i-1);
					for(let j=1;j<=g;j++)swap(arr,i-1,i-1-j,.01);
					as=true;
					g++;
				}else i--;
			}
		}
	}
	async fibonacciGnomeSort(len){
		function fibonacciSearch(A,s,e,i){
			let fM2=0,fM1=1,fM=1;
			while(fM<=e-s){
				fM2=fM1;
				fM1=fM;
				fM=fM2+fM1;
			}
			let o=s-1;
			while(fM>1){
				let j=minVal(o+fM2,e);
				if(compareValues(A[j],i)<1){
					fM=fM1;
					fM1=fM2;
					fM2=fM-fM1;
					o=j;
				}else{
					fM=fM2;
					fM1-=fM2;
					fM2=fM-fM1;
				}
			}
			let p=++o;
			if(compareValues(A[p],i)<1)p++;
			return p;
		}
		async function sort(A,l){
			let k=0;
			for(let i=1;i<l;i++){
				let t=A[i],p=fibonacciSearch(A,0,i-1,t);
				let j=i;
				while(j>p){
					swap(A,j,--j,0,true);
					if(++k>=sqrt(len))await sleep(k=0);
				}
			}
		}
		await sort(arr,len);
	}
	async noisySort(len){
		let base=askForNum(16,"Noise intensity",1);
		async function sort(A,ln){
			let l=1,r=1,vi=1,vp=false;
			while(!vp){
				r=vi+1;
				while(r<=ln){
					l=vi;
					while(l<=r&&r<=ln){
						if(compareIndices(A,l-1,r-1)>0){
							await swap(A,l-1,r-1,.005,true);
							if(r-1>vi)r--;
							l=vi;
						}else l++;
					}
					r+=base;
				}
				if(vi-1>0)vi--;
				vp=true;
				while(vi<ln&&vp){
					if(compareValues(A[vi-1],A[vi])<=0)vi++;
					else vp=false;
				}
			}
		}
		await sort(arr,len);
	}
	async gambitGnomeSort(len){
		function binSearch(A,b,e,t){
			while(true){
				let d=e-b;
				if(d<1)break;
				let p=b+d/2|0;
				if(!compareIndices(A,p,t))return p;
				if(compareIndices(A,p,t)>0){
					e=p;
					continue;
				}
				b=p+1;
			}
			return e;
		}
		async function binInsert(A,l,s,e){
			let o=1;
			for(;o*o<l;o*=2);
			for(let bs=0,be=e,i=s+o;i<e;i++){
				let t=binSearch(A,bs,be,i);
				let tm=A[i],j=i;
				while(j>t&&A[j]>=tm)
					await swap(A,j--,j,0,true);
			}
		}
		await binInsert(arr,len,0,len);
		await insertSort(arr,0,len,1/3);
	}
	async headPullSort(len){
		let i=1,p=1;
		i=1;
		while(i+1<=len){
			if(compareIndices(arr,i-1,i)>0){
				p=i;
				while(p>0)
					await swap(arr,p--,p,.1,true);
				i=1;
			}else i++;
		}
	}
	async markovSort(len){
		let j=0;
		for(let i=0;i<len-1;++i){
			let w=i+1;
			while((!w?0:compareIndices(arr,w-1,w)>0)||(w>i?0:compareIndices(arr,w,w+1)>0)){
				let c=(!w||w<=i&&randBool())?1:-1;
				swap(arr,w,w+c,0);
				if(++j>=len)await markSwap(w,w+c,j=0);
				w+=c;
			}
		}
	}
	async meanQuickSort(len){
		function compare(a,b){
			return compareValues(a,b);
		}
		async function partition(A,s,e,sm){
			let l=s,r=e;
			let c=r-l+1;
			if(c<2)return;
			let m=sm/c;
			let lsm=0,rsm=0;
			while(l<=r){
				while(compare(A[l],m)<0)
					lsm+=A[l++];
				while(compare(A[r],m)>0)
					rsm+=A[r--];
				if(l<=r){
					await swap(A,l,r,1,true);
					lsm+=A[l++];
					rsm+=A[r--];
				}
			}
			if(s<r)await partition(A,s,r,lsm);
			if(l<e)await partition(A,l,e,rsm);
		}
		let s=0;
		for(let i=0;i<len;i++)s+=arr[i];
		await partition(arr,0,len-1,s);
	}
	async cupcakeWrapperSort(len){
		let r;
		for(let l=len-1;l+1;l--){
			for(r=l;r>0;r--)
				if(compareIndices(arr,0,r)>0)
					await reversal(arr,0,r,.1,true);
			await reversal(arr,0,len-1,.1,true);
			await reversal(arr,0,len-2,.1,true);
		}
	}
	async pancakeBogoSort(len){
		for(let i=len-1;i>=0;i--)
			while(!isMaxSorted(arr,0,i+1))
				await reversal(arr,0,randInt(0,i+1),1/len,true);
	}
	async cubeRootQuickSort(len){
		async function sort(A,s,e){
			let l=e-s;
			if(l>=2){
				let r=cbrt(l)|0;
				let nS=s+r;
				await sort(A,s,nS);
				let pv=new Array(r).fill(0);
				for(let i=0;i<r;i++)
					write(pv,i,i+s,0,false,true);
				for(let i=nS;i<e;i++){
					let a=0,b=r;
					while(a<b){
						let m=(b-a)/2+a|0;
						if(compareIndices(A,pv[m],i)>0)b=m;
						else a=m+1;
					}
					let p=i;
					for(let j=r-1;j>=a;j--){
						await swap(A,pv[j]+1,p,0,true);
						await swap(A,p=pv[j],pv[j]+1,0,true);
						write(pv,j,pv[j]+1,0,false,true);
					}
				}
				await sort(A,s,pv[0]);
				for(let i=1;i<r;i++)
					await sort(A,pv[i-1]+1,pv[i]);
				await sort(A,pv[r-1]+1,e);
			}
		}
		await sort(arr,0,len);
	}
	async magneticaQuickSort(len){
		let random=new Random();
		let rpv=false,mpv=false,none=false,ins=false;
		async function magnetica(A,l,r){
			let th=ins?17:0;
			let i,j,pl,pr,p,mm,cmp;
			let ln=r-l+1;
			let T=new Array(ln).fill(0);
			let spr=2,gr=0;
			let lb=l,rb=r;
			write(T,1,l,0,false,true);
			write(T,2,r,0,false,true);
			do{
				r=T[spr];
				l=T[spr-1];
				spr-=2;
				for(;l+th<r;){
					j=r;
					pl=pr=l;
					if(mpv||(mpv&&ins&&r-l>31)){
						mm=l+((r-l)>>2);
						if(!gr){
							await insertSort(A,mm,mm+3,.5);
							await swap(A,mm+1,pr,2,true);
						}else{
							await insertSort(A,mm,mm+7,.5);
							await swap(A,mm+3,pr,2,true);
						}
					}else if(rpv)await swap(A,random.nextInt(r-l)+l,pr,2,true);
					else await swap(A,(l+r)>>1,pr,2,true);
					p=A[pr];
					for(;pr<j;){
						cmp=compareValues(p,A[++pr]);
						if(cmp>0)await swap(A,pl++,pr,2,true);
						else if(cmp<0){
							for(;compareValues(p,A[j])<0;)j--;
							if(pr<j)await swap(A,pr,j,2,true);
							j--;
							pr--;
						}
					}
					j=pl-1;
					i=pr+1;
					if(ins)
						gr=maxVal(r-i,j-l)>(minVal(r-i,j-l)<<6)?1:0;
					if(i+th<r){
						spr+=2;
						write(T,spr-1,i,0,false,true);
						write(T,spr,r,0,false,true);
						if(ins){
							spr*=spr+2<ln?1:0;
							r*=spr+2<ln?1:0;
						}
					}
					r=j;
				}
			}while(spr);
			if(ins)
				await insertSort(A,lb,rb+1,.5);
		}
		let t=ask("Enter variant:\n1: Mid Pivot Standalone\n2: Mid Pivot + Insertion\n3: Mo3/7 Pivot Standalone\n4: Mo3/7 Pivot + Insertion\n5: Random Pivot Standalone\n6: Random Pivot + Insertion",4);
		if(t==3||t==4)mpv=true;
		if(t==5||t==6)rpv=true;
		if(t==1||t==3||t==5)none=true;
		else ins=true;
		await magnetica(arr,0,len-1);
	}
	async shellUnstableSingularityQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function unstablepd(A,s,e){
			let r=s;
			let d=false;
			let c=compareIndices(A,r,r+1);
			while(c+1&&r+1<e){
				if(c>0)d=true;
				c=compareIndices(A,++r,r+1);
			}
			if(r>s&&d){
				if(r<s+4)await swap(A,s,r,1,true);
				else await reversal(A,s,r,1,true);
			}
			return r;
		}
		async function shellPass(A,s,e,g){
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		async function shell(A,s,e){
			let g=(e-s)/2|0;
			while(g>=2){
				await shellPass(A,s,e,g);
				g=g/2|0;
			}
			await shellPass(A,s,e,1);
		}
		async function singularityQuick(A,s,o,e,d,rp){
			if(d==dlim||rp==4)return await shell(A,s-1,e);
			if(e-s>ilim){
				let l=o;
				while(compareIndices(A,l-1,l)<1&&l<e)l++;
				if(l<e){
					let pvp=l-1;
					let pv=A[pvp];
					let op=pvp;
					let r=l+1;
					let i=1;
					let bl=false,bc=false,f=false;
					while(r<=e){
						if(compareValues(pv,A[r-1])>0){
							if(r-l==1){
								if(!f)i=A[l-1];
								f=true;
								await write(A,l-1,A[l],.1,true);
							}else bl=true;
							if(bl&&!bc){
								await write(A,l-1,i,.5,true);
								bc=true;
							}
							if(r-l>1)await swap(A,l-1,r-1,.5,true);
							if(pvp==l-1)pvp=r-1;
							l++;
						}
						r++;
					}
					if(r>e&&!bl)await write(A,l-1,i,.5,true);
					if(pvp-l+1)await swap(A,pvp,l-1,.5,true);
					let lsm=l-s<e-(l+1);
					if(lsm&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
					if(e-l-1>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,l+1,l+1,e,d+1,rp+1);
						else await singularityQuick(A,l+1,l+1,e,d+1,0);
					}
					if(!lsm&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
				}
			}else await shell(A,s-1,e);
		}
		let dlim=minVal(sqrt(len),2*log2(len))|0;
		let ilim=maxVal(dlim/2-1,15)|0;
		let rlim=maxVal(dlim/4,2)|0;
		let rs=await unstablepd(arr,0,len);
		if(rs+1<len)
			await singularityQuick(arr,1,rs+1,len,0,0);
	}
	async singularityQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.075,true);
			else await reversal(A,s,e,.05,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,.75,true);
					else await reversal(A,l,r,.75,true);
				}
				i++;
			}
		}
		async function pd(A,s,e){
			let r=s;
			let ls=false;
			let d=false;
			let c=compareIndices(A,r,r+1);
			while(c>=0&&r+1<e){
				if(c==0)ls=true;
				else d=true;
				c=compareIndices(A,++r,r+1);
			}
			if(r>s&&d){
				if(ls)await stableSegmentReversal(A,s,r);
				else if(r<s+3)await swap(A,s,r,.75,true);
				else await reversal(A,s,r,.75,true);
			}
			return r;
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binsert(A,s,e){
			await binaryInsertion(A,s-1,e,.1);
		}
		async function singularityQuick(A,s,o,e,d,rep){
			if(e-s>ilim&&d<dlim&&rep<4){
				let l=o;
				while(compareIndices(A,l-1,l)<1&&l<e)l++;
				if(l<e){
					let r=l+1;
					let p=1;
					let op=l-1;
					let pv=A[op];
					let bl=false,bc=false;
					while(r<=e){
						if(compareValues(pv,A[r-1])>0){
							if(r-l==1)await write(A,l-1,A[l],.1,true);
							else bl=true;
							if(bl&&!bc)await write(A,l-1,pv,.1,bc=true);
							if(r-l>1){
								p=r-1;
								let i=A[p];
								while(p>=l)await write(A,p,A[--p],.1,true);
								await write(A,p,i,.1,true);
							}
							l++;
						}
						r++;
					}
					if(r>e&&!bl)await write(A,l-1,pv,.1,true,false);
					let ls=l-s<e-(l+1);
					if(ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rep+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
					if(e-(l+1)>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,l+1,l+1,e,d+1,rep+1);
						else await singularityQuick(A,l+1,l+1,e,d+1,0);
					}
					if(!ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rep+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,0);
					}
				}
			}else await binsert(A,s,e);
		}
		let dlim=minVal(sqrt(len),2*log2(len))|0;
		let ilim=maxVal(dlim/2-1,15)|0;
		let rlim=maxVal(dlim/4,2)|0;
		let rs=await pd(arr,0,len);
		if(rs+1<len)await singularityQuick(arr,1,rs+1,len,0,0);
	}
	async unboundedUnstableSingularityQuickSort(len){
		async function singularityQuick(A,s,o,e,d){
			let l=o;
			while(compareIndices(A,l-1,l,.05,true)<=0&&l<e)l++;
			if(l<e&&d<2048&&!sorted){
				let pv=A[l-1];
				let pvp=l-1,op=l-1,r=l+1,i=1;
				let bl=false,bc=false,f=false;
				while(r<=e){
					if(compareValues(pv,A[r-1])>0){
						if(r-l==1){
							if(!f)i=A[l-1];
							f=true;
							await write(A,l-1,A[l],.1,true);
						}else bl=true;
						if(bl&&!bc){
							await write(A,l-1,i,.5,true);
							bc=true;
						}
						if(r-l>1)await swap(A,l-1,r-1,.5,true);
						if(pvp==l-1)pvp=r-1;
						l++;
					}
					r++;
				}
				if(r>e&&!bl)await write(A,l-1,i,.5,true);
				if(pvp-l+1)await swap(A,pvp,l-1,.5,true);
				let ls=l-s<e-(l+1);
				if(ls&&(l-1)-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
				if(e-(l+1)>0)await singularityQuick(A,l+1,l+1,e,d+1);
				if(!ls&&(l-1)-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
			}else if(d==2048&&!sorted){
				await Sorts.prototype.unstableSingularityQuickSort(len);
				sorted=true;
			}
		}
		let full=len;
		let sorted=false
		await singularityQuick(arr,1,1,len,0);
	}
	async unboundedSingularityQuickSort(len){
		async function singularityQuick(A,s,o,e,d){
			let l=o;
			while(compareIndices(A,l-1,l)<1&&l<e)l++;
			if(l<e&&d<2047&&!sorted){
				let r=l+1,p=1,op=l-1;
				let pv=A[op];
				let bl=false,bc=false;
				while(r<=e){
					if(compareValues(pv,A[r-1])>0){
						if(r-l==1)await write(A,l-1,A[l],.1,true);
						else bl=true;
						if(bl&&!bc)await write(A,l-1,pv,.1,bc=true);
						if(r-l>1){
							p=r-1;
							let i=A[p];
							while(p>=l)await write(A,p,A[--p],.1,true);
							await write(A,p,i,.1,true);
						}
						l++;
					}
					r++;
				}
				if(r>e&&!bl)await write(A,l-1,pv,.1,true);
				let ls=l-s<e-l-1;
				if(ls&&l-1-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
				if(e-l-1>0)await singularityQuick(A,l+1,l+1,e,d+1);
				if(!ls&&l-1-s>0)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1);
			}else if(!sorted){
				await Sorts.prototype.singularityQuickSort(len);
				sorted=true;
			}
		}
		let full=len;
		let sorted=false;
		await singularityQuick(arr,1,1,len,0);
	}
	async unstableSingularityQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function unstablepd(A,s,e){
			let r=s;
			let d=false;
			let c=compareIndices(A,r,r+1);
			while(c+1&&r+1<e){
				if(c>0)d=true;
				c=compareIndices(A,++r,r+1);
			}
			if(r>s&&d){
				if(r<s+3)await swap(A,s,r,.75,true);
				else await reversal(A,s,r,.75,true);
			}
			return r;
		}
		async function shuffle(A,s,e,x){
			let random=new Random(x*(x-s));
			for(let i=s;i<e;i++){
				let rI=random.nextInt(e-i)+i;
				if(rI-i)await swap(A,i,rI,.1,true);
			}
		}
		async function binsert(A,s,e){
			await binaryInsertion(A,s-1,e,.1);
		}
		async function singularityQuick(A,s,o,e,d,rd,rp){
			if(e-s>ilim&&(d==dlim||rp==4)){
				await shuffle(A,s-1,e-1,o);
				o=s;
				d=0;rp=0;
			}
			if(e-s>ilim&&d<dlim){
				let l=o;
				while(compareIndices(A,l-1,l)<1&&l<e)l++;
				if(l<e){
					let op=l-1,pvp=op,r=l+1,i=1;
					let pv=A[op];
					let bl=false,bc=false,f=false;
					while(r<=e){
						if(compareValues(pv,A[r-1])>0){
							if(r-l==1){
								if(!f)i=A[l-1];
								f=true;
								await write(A,l-1,A[l],.1,true);
							}else bl=true;
							if(bl&&!bc)await write(A,l-1,i,.5,bc=true);
							if(r-l>1)await swap(A,l-1,r-1,.5,true);
							if(pvp==l-1)pvp=r-1;
							l++;
						}
						r++;
					}
					if(r>e&&!bl)await write(A,l-1,i,.5,true);
					if(pvp!=l-1)await swap(A,pvp,l-1,.5,true);
					let ls=l-s<e-(l+1);
					if(ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,0);
					}
					if(e-(l+1)>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,l+1,l+1,e,d+1,rd+1,rp+1);
						else await singularityQuick(A,l+1,l+1,e,d+1,rd+1,0);
					}
					if(!ls&&(l-1)-s>0){
						if(e-rlim<=l||l<=s+rlim)await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,rp+1);
						else await singularityQuick(A,s,op-1>s?op-1:s,l-1,d+1,rd+1,0);
					}
				}
			}else await binsert(A,s,e);
		}
		let dlim=minVal(sqrt(len),2*log2(len))|0;
		let ilim=maxVal(dlim/2-1,15)|0;
		let rlim=maxVal(dlim/4,2)|0;
		let rs=await unstablepd(arr,0,len);
		if(rs+1<len)
			await singularityQuick(arr,1,rs+1,len,0,0,0);
	}
	async californiumSort(len){
		function sqrtrnd(v){
			let p=0;
			while(++p*p<v);
			return p;
		}
		async function californium(A,a,b,d){
			if(b-a==2)
				if(compareIndices(A,a,a+1)>0)
					await swap(A,a,a+1,1,true);
			if(--d<1){
				for(let i=a;++i<b;){
					if(compareIndices(A,i-1,i)>0){
						await swap(A,i-1,i,1,true);
						i=a;
					}
				}
				return;
			}
			if(a>=b-2)return;
			let R=[],M=[];
			let i=b,j,k,m,me=0,b0=b;
			let shd=false;
			bndchk:while(i>a+1){
				R.unshift(i=b0);
				M=[];
				for(k=sqrtrnd(i-a);k-->0;){
					shd=M.length&&compareIndexValue(A,a,M[0])+1;
					me=0;
					for(j=(m=a)+1;j<i;j++){
						let p=compareIndices(A,m,j);
						if(!p)me++;
						if(p<0||shd)
							if(M.length<1||compareIndexValue(A,j,M[0],1,true)<0){
								m=j;
								shd=false;
								me=0;
							}
					}
					if(shd)break bndchk;
					M.unshift(A[m]);
					k-=me;
				}
				cnt:for(j=b0=a;j<i;j++){
					for(let v of M){
						if(!compareIndexValue(A,j,v)){
							await reversal(A,b0,j-1,.1,true);
							continue cnt;
						}
					}
					await reversal(A,b0,j-1,.1,true);
					await reversal(A,a,b0-1,.1,true);
					await multiSwap(A,j,b0++,.1,true);
				}
			}
			if(me==b-a-1)return;
			j=a;
			for(k=0;k<R.length;k++)
				await californium(A,j,j=R[k],d);
		}
		await californium(arr,0,len,(32-clz32(len-1))/2|0);
	}
	async ternarySlowSort(len){
		async function cswap(A,s,e){
			if(compareIndices(A,s,e)>0)
				await swap(A,s,e,1,true);
		}
		async function sort(A,s,e){
			if(e-s==1)return await cswap(A,s,e,1);
			if(e-s+1>2){
				let t=(e-s+1)/3|0;
				let m1=s+t,m2=s+2*t;
				await sort(A,s,m1-1);
				await sort(A,m1,m2-1);
				await sort(A,m2-1,e);
				await cswap(A,m1-1,e,1);
				await cswap(A,m1-1,m2-1,1);
				await cswap(A,m2-1,e,1);
				await sort(A,s,e-1);
			}
		}
		await sort(arr,0,len-1);
	}
	async napoleonSort(len){
		async function tilsit(A,l){
			for(let i=0,j=l-1;i<l/2|0;i++,j--)
				if(compareIndices(A,i,j)>0)
					await swap(A,i,j,.01,true);
		}
		async function napoleon(A,e){
			let lo=0;
			let hi=e;
			let p=A[0];
			let g=true;
			let n=false;
			while(hi>lo){
				if(g){
					let nx=lookEast(A,p,lo+1,hi);
					if(nx==lo){
						if(n){
							lo++;
							hi--;
						}
						p=A[(g=n)?lo:hi];
						n=!n;
					}else if(nx==hi){
						p=A[hi];
						await conquer(A,hi,lo);
						n=false;
					}else{
						p=A[nx];
						await conquer(A,nx,hi);
						n=g=false;
					}
				}else{
					let nx=lookWest(A,p,hi-1,lo);
					if(nx==hi){
						if(n){
							lo++;
							hi--;
						}
						p=A[lo];
						g=true;
						n=!n;
					}else if(nx==lo){
						p=A[lo];
						await conquer(A,lo,hi);
						n=false;
					}else{
						p=A[nx];
						await conquer(A,nx,lo);
						n=false;
						g=true;
					}
				}
			}
		}
		function lookEast(A,p,s,e){
			for(let i=s;i<=e;i++){
				if(compareValues(A[i],p)<0)
					return i;
			}
			return s-1;
		}
		function lookWest(A,p,s,e){
			for(let i=s;i>=e;i--){
				if(compareValues(A[i],p)>0)
					return i;
			}
			return s+1;
		}
		async function conquer(A,i,t){
			let bZ=1;
			while(i+bZ-1<t){
				let mT=recruit(A,A[i],i+bZ,t);
				let s=mT-i-bZ+1;
				await march(A,i,bZ,s);
				i+=s;
				bZ++;
			}
			while(i-bZ+1>t){
				let mT=recruit(A,A[i],i-bZ,t);
				let s=i-bZ-mT+1;
				await march(A,mT,s,bZ);
				i-=s;
				bZ++;
			}
		}
		function recruit(A,iT,s,e){
			if(s<e){
				for(let i=s;i<=e;i++)
					if(!compareValues(A[i],iT))
						return i-1;
				return e;
			}
			for(let i=s;i>=e;i--)
				if(!compareValues(A[i],iT))
					return i+1;
			return e;
		}
		async function march(A,i,l1,l2){
			while(l1&&l2){
				if(l1<=l2){
					await attack(A,i,i+l1,l1);
					i+=l1;
					l2-=l1;
				}else{
					await attack(A,i+l1,i+l1-l2,l2);
					l1-=l2;
				}
			}
		}
		async function attack(A,a,b,l){
			while(l--)
				await swap(A,a++,b++,1,true);
		}
		await tilsit(arr,len);
		await napoleon(arr,len-1);
	}
	async gnomeWeaveHighSort(len){
		let g=len;
		let ic=1,i=1,b=1,ti=2,tr=1;
		let t=false,f=false;
		while(!f){
			i=b=ic;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await swap(arr,i-1,i-1+g,.25,true);
					if(i-g>0)i-=g;
				}else{
					b+=g;
					i=b;
				}
			}
			f=g==1;
			if(ic+1>g&&!f){
				tr=g;
				while(tr-1){
					t=false;
					ti=2;
					while(!t){
						if((tr/ti|0)==tr/ti){
							tr=tr/ti;
							t=true;
						}else ti++;
					}
				}
				g=g/ti|0;
				ic=1;
			}else ic++;
		}
	}
	async gnomeWeaveLowSort(len){
		let g=len;
		let ic=1,i=1,b=1,ti=2,tr=1;
		let t=false,f=false;
		while(!f){
			i=b=ic;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await swap(arr,i-1,i-1+g,.25,true);
					if(i-g>0)i-=g;
				}else{
					b+=g;
					i=b;
				}
			}
			f=g==1;
			if(ic+1>g&&!f){
				tr=g;
				while(tr==g){
					t=false;
					ti=2;
					while(!t){
						if((tr/ti|0)==tr/ti){
							tr=tr/ti;
							t=true;
						}else ti++;
					}
				}
				g=g/ti|0;
				ic=1;
			}else ic++;
		}
	}
	async grateSort(len){
		let s=false;
		while(!s){
			s=true;
			for(let i=0;i<len-1;i++){
				for(let j=len-1;j>i;j--){
					if(compareIndices(arr,i,j)>0){
						s=false;
						await swap(arr,i,j,.1,true);
						break;
					}
				}
			}
		}
	}
	async inOrderShoveSort(len){
		let l=0,p=0,r,j=0;
		while(l<len){
			r=l+1;
			while(r<len){
				if(compareIndices(arr,l,r)>0){
					p=l;
					while(p+1<len){
						swap(arr,p,++p,.125);
						if(++j>=len)await mark(p-1,j=0);
					}
					r=l+1;
				}else r++;
			}
			l++;
		}
	}
	async iterativeQuickSort(len){
		async function partition(A,l,h){
			let p=A[h],i=l-1;
			for(let j=l;j<=h-1;j++)
				if(compareValues(A[j],p)<1)
					await swap(A,++i,j,1,true);
			await swap(A,i+1,h,1,true);
			return i+1;
		}
		async function quickSort(A,s,e){
			let l=e-s+1,S=new Array(l),t=-1;
			write(S,++t,s,0,false,true);
			write(S,++t,e,0,false,true);
			while(t>=0){
				e=S[t--];
				s=S[t--];
				let p=await partition(A,s,e);
				if(compareValues(p-1,s)>0){
					write(S,++t,s,0,false,true);
					write(S,++t,p-1,0,false,true);
				}
				if(compareValues(p+1,e)<0){
					write(S,++t,p+1,0,false,true);
					write(S,++t,e,0,false,true);
				}
			}
		}
		await quickSort(arr,0,len-1);
	}
	async swapMapSort(len){
		let map=[],j=0;
		while(1){
			for(let i=0;i<len-1;i++)
				if(compareIndices(arr,i,i+1)>0)
					map.push(i);
			if(!map.length)break;
			for(let i=0;i<map.length;i++){
				swap(arr,map[i],map[i]+1);
				if(++j>=len)await mark(map[i],j=0);
			}
			map=[];
		}
	}
	async triSearchGnomeSort(len){
		function triSearch(A,l,h,v){
			let m=l+(h-l)/2|0;
			if(compareValues(v,A[l])<0)return l;
			else{
				if(compareValues(v,A[h])<0){
					if(compareValues(v,A[m])<0)
						return triSearch(A,l+1,m-1,v);
					else
						return triSearch(A,m+1,h-1,v);
				}else return h+1;
			}
		}
		async function triGnomeSort(A,s,e){
			for(let i=s+1;i<e;i++){
				let o=triSearch(A,s,i-1,A[i]);
				let j=i;
				while(j>o)
					await swap(A,j,--j,1,true);
			}
		}
		await triGnomeSort(arr,0,len);
	}
	async moreOptimizedBubbleSort(len){
		let c=1,s,f=1,a=false;
		for(let j=len-1;j>0;j-=c){
			s=f<1?0:f-1;
			a=false;
			c=1;
			for(let i=s;i<j;i++){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,1,true);
					if(!a)f=i;
					a=true;
					c=1;
				}else c++;
			}
		}
	}
	async oddEvenWeaveHighSort(len){
		let c=1,lb=2,lm=len,m=len,ns=0,g=len,ti=2,i=1,bi=1,tr=1;
		let t=false,as=false,tp=false,v=true;
		while(!tp){
			i=c;
			as=false;
			while((i-1)+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0)
					await swap(arr,i-1,(i-1)+g,.25,as=true);
				i+=m;
			}
			if(!as&&g-1){
				if(++ns==m){
					ns=0;
					lm=tr=m;
					if(!v){
						while(tr-1){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						m=m/ti|0;
					}
					v=false;
					if(m-1){
						tr=m;
						while(tr-1){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						g=m/ti|0;
					}else{
						m=lm;
						g=1;
					}
					c=0;
				}
			}else ns=0;
			if(g==1){
				bi=lb>1?lb-1:1;
				tp=true;
				while(bi<len&&tp){
					if(compareIndices(arr,bi-1,bi)<1)bi++;
					else{
						tp=false;
						lb=c=bi;
					}
				}
			}else c=c%m+1;
		}
	}
	async oddEvenWeaveLowSort(len){
		let c=1,lb=2,lm=len,m=len,ns=0,g=len,ti=2,i=1,bi=1,tr=1;
		let t=false,as=false,tp=false,v=true;
		while(!tp){
			i=c;
			as=false;
			while(i-1+g<len){
				if(compareIndices(arr,i-1,i-1+g)>0)
					await swap(arr,i-1,i-1+g,.25,as=true);
				i+=m;
			}
			if(!as&&g-1){
				if(++ns==m){
					ns=0;
					lm=tr=m;
					if(!v){
						while(tr==m){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						m=m/ti|0;
					}
					v=false;
					if(m-1){
						tr=m;
						while(tr==m){
							t=false;
							ti=2;
							while(!t){
								if((tr/ti|0)==tr/ti){
									tr=tr/ti;
									t=true;
								}else ti++;
							}
						}
						g=m/ti|0;
					}else{
						m=lm;
						g=1;
					}
					c=0;
				}
			}else ns=0;
			if(g==1){
				if(lb>1)bi=lb-1;
				else bi=1;
				tp=true;
				while(bi<len&&tp){
					if(compareIndices(arr,bi-1,bi)<1)bi++;
					else{
						tp=false;
						lb=c=bi;
					}
				}
			}else c=c%m+1;
		}
	}
	async stableStoogeSort(len){
		async function stableStooge(A,s,e){
			if(e-s+1==2){
				if(compareIndices(A,s,e)>0)
					await swap(A,s,e,.005,true);
			}else if(e-s+1>2){
				let t=(e-s+1)/3|0;
				await stableStooge(A,s,e-t);
				await stableStooge(A,s+t,e);
				await stableStooge(A,s,e-t);
			}
		}
		await stableStooge(arr,0,len-1);
	}
	async indexMergeSort(len){
		async function indexSort(A,I,a,b){
			while(a<b){
				if(compareValues(a,I[a])){
					let t=A[a];
					let i=a,n=I[a];
					do{
						await write(A,i,A[n],0,true);
						write(I,i,i,0,false,true);
						n=I[i=n];
					}while(compareValues(n,a));
					await write(A,i,t,0,true);
					write(I,i,i,0,false,true);
				}
				a++;
			}
		}
		function merge(A,I,a,m,b){
			let i=a,j=m,c=a;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)write(I,c++,i++,0,false,true);
				else write(I,c++,j++,0,false,true);
			while(i<m)write(I,c++,i++,0,false,true);
			while(j<b)write(I,c++,j++,0,false,true);
			return indexSort(A,I,a,b);
		}
		async function sort(A,I,a,b){
			if(b-a<2)return;
			let m=(a+b)/2|0;
			await sort(A,I,a,m);
			await sort(A,I,m,b);
			await merge(A,I,a,m,b);
		}
		await sort(arr,new Array(len),0,len);
	}
	async fallSort(len){
		let j=0,h=0,l=1,r=2;
		while(l<=len){
			r=l+1;
			h=0;
			while(r<=len){
				if(compareIndices(arr,l-1,r-1)>0){
					if(!h)h=r;
					else if(compareIndices(arr,h-1,r-1)<0)h=r;
				}
				r++;
			}
			if(!h)l++;
			else{
				swap(arr,l-1,h-1,0);
				if(++j>=sqrt(len))await mark(l-1,j=0);
			}
		}
	}
	async ecoloSort(len){
		let l=1,r=len,w=1,i=1;
		while(l<=r){
			if(w>0)i=l;
			else i=r;
			while(w>0&&i<r||w<0&&i>l){
				if(compareIndices(arr,l-1,i-1)>0)await swap(arr,l-1,i-1,.05,true);
				if(compareIndices(arr,i-1,r-1)>0)await swap(arr,i-1,r-1,.05,true);
				i+=w;
			}
			l++;r--;w=-w;
		}
	}
	async stupidFireSort(len){
		let i=1,j=0,a=0,b=0,c=-1,d=1;
		let p=false,r=false,s=false;
		while(!p){
			if(b<1){
				b=++a;c=-c;
			}else b--;
			s=false;
			while(i<len&&i>0&&!s){
				if(compareIndices(arr,i-1,i)*c>0){
					swap(arr,i-1,i,0);
					s=true;
					if(++j>=len)await mark(i-1,j=0);
					i-=c;
				}else i+=c;
			}
			if(i<1){
				i=len-1;
				d=1;p=true;
				while(d-len&&p){
					if(compareIndices(arr,d-1,d)<1)d++;
					else{
						p=false;d=1;r=!p;
						while(d-len&&r){
							if(compareIndices(arr,d,d-1)<1)d++;
							else r=false;
						}
					}
				}
				if(r){
					i=1;b=0;
				}
			}
			if(i>=len){
				i=d=1;
				p=true;
				while(d-len&&p){
					if(compareIndices(arr,d-1,d)<1)d++;
					else{
						p=false;d=1;r=!p;
						while(d-len&&r){
							if(compareIndices(arr,d-1,d)+1)d++;
							else r=false;
						}
					}
				}
				if(r){
					i=len-1;
					b=0;
				}
			}
		}
	}
	async stacklessQuickSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function partition(A,a,b){
			let i=a,j=b;
			await medianOfThree(A,a,b);
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)+1);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,a,j,1,true);
					return j;
				}
			}
		}
		function leftBinSearch(A,a,b,p){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,p,m)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function quickSort(A,a,b){
			let x=A[a];
			for(let i=a+1;i<b;i++)
				if(compareValues(A[i],x)>0)x=A[i];
			for(let i=b-1;i+1;i--)
				if(!compareValues(A[i],x))
					await swap(A,i,--b,1,true);
			let b1=b;
			while(1){
				while(b1-a>2){
					let p=await partition(A,a,b1);
					await swap(A,b1=p,b,1,true);
				}
				if(b1-a==2&&compareIndices(A,a,a+1)>0)
					await swap(A,a,a+1,1,true);
				a=b1+1;
				if(a>=b){
					if(a-1<b)await swap(A,a-1,b,1,true);
					return;
				}
				b1=leftBinSearch(A,a,b,a-1);
				await swap(A,a-1,b,1,true);
				while(a<b1&&!compareIndices(A,a-1,a))a++;
			}
		}
		await quickSort(arr,0,len);
	}
	async stableQuickSortMiddlePivot(len){
		async function copy(l,A,i){
			for(let n of l)
				await write(A,i++,n,0,true);
		}
		async function stablePartition(A,s,e){
			let p=s+(e-s)/2|0;
			let pV=A[p];
			let lL=[],rL=[];
			for(let i=s;i<=e;i++){
				if(i==p)continue;
				if(compareValues(A[i],pV)<0)lL.push(A[i]);
				else rL.push(A[i]);
			}
			await copy(lL,A,s);
			let nP=s+lL.length;
			await write(A,nP,pV,.25);
			await copy(rL,A,nP+1);
			return nP;
		}
		async function stableQuickSort(A,s,e){
			if(s<e){
				let p=await stablePartition(A,s,e);
				await stableQuickSort(A,s,p-1);
				await stableQuickSort(A,p+1,e);
			}
		}
		await stableQuickSort(arr,0,len-1);
	}
	async optimizedZipperSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function ending(A,f,ln){
			let r=f;
			if(r<1)r++;
			while(r<ln){
				if(compareIndices(A,r-1,r)>0){
					let l=binarySearch(A,0,r-1,A[r]);
					while(l<r)await swap(A,l++,r,.05,true);
				}
				r++;
			}
		}
		let i=0,f=0,g=len;
		while(g>maxVal(2*log2(len),sqrt(len)|0)){
			g=1;
			i=f>1?f-1:0;
			while(i+g<len){
				if(compareIndices(arr,i,i+g)>0){
					await swap(arr,i,i+g,.1,true);
					if(g++==1)f=i;
				}else i++;
			}
		}
		if(g-1)await ending(arr,f,len);
	}
	async reverseBubbleSort(len){
		for(let i=0;i<len-1;i++){
			let s=true;
			for(let j=len-1;j>i;j--){
				if(compareIndices(arr,j-1,j)>0){
					await swap(arr,j-1,j,.075,true);
					s=false;
				}
			}
			if(s)break;
		}
	}
	async optimizedGrateSort(len){
		let b=len-1,l=0,r=len-1,fs=0,ls=0,t=len-1;
		let s=false,h=false;
		while(!s){
			if(!s){
				while(!h){
					if(t<l){
						t=r;
						if(--b<r)h=true;
					}else{
						if(compareIndices(arr,t,b)>0)h=true;
						else t--;
					}
				}
			}
			s=true;
			for(let i=l;i<r;i++){
				for(let j=b;j>i;j--){
					if(compareIndices(arr,i,j)>0){
						if(s)fs=i;
						ls=i;
						s=false;
						await swap(arr,i,j,.125,true);
						break;
					}
				}
			}
			b--;t=r;l=fs;r=ls+1;h=false;
		}
	}
	async pseudoHeapSort(len){
		async function sd(A,s,l,r){
			let w=false,j=r;
			while(2*j<l){
				let k=2*j;
				if(k<l&&compareIndices(A,s+k-1,s+k)>0)k++;
				if(compareIndices(A,s+j-1,s+k-1)>0){
					await swap(A,s+j-1,s+k-1,1,true);
					j=k;
					w=true;
					continue;
				}
				break;
			}
			return w;
		}
		function sift(A,s,e){
			return sd(A,s,e-s+1,1);
		}
		let s=true;
		while(s){
			s=false;
			for(let i=len-2;i+1;i--)if(await sift(arr,i,len))s=true;
		}
	}
	async split16MergeSort(len){
		let meds=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
		async function cS1(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		async function cS2(A,a,b,g,s){
			if(compareIndices(A,s+a*g,s+b*g)>0){
				await swap(A,s+a*g,s+b*g,.5,true);
			}
		}
		async function medianOfSixteen(A,a,g){
			for(let i=0;i<meds.length;i+=2)
				await cS2(A,meds[i]-1,meds[i+1]-1,g,a);
		}
		async function merge(A,s,z){
			let g=z/16|0;
			for(let i=0;i<g;i++)
				await medianOfSixteen(A,s+i,g);
			for(let h=g/2|0;h>0;h=h/2|0)
				for(let i=0;i<z-h;i++)
					await cS1(A,s+i,s+i+h);
		}
		for(let i=0;i<len-15;i+=16)
			await medianOfSixteen(arr,i,1);
		let g;
		for(g=32;g<=len;g*=2)
			for(let i=0;i+g<=len;i+=g)
				await merge(arr,i,g);
	}
	async moduloMergeSort(len){
		async function merge(A,s,m,e,xE){
			let l=s;
			let r=m+1;
			let f=s;
			while(l<=m&&r<=e){
				if(compareValues(A[l]%xE,A[r]%xE)<1)
					await write(A,f,A[f]+(A[l++]%xE)*xE,1,true);
				else
					await write(A,f,A[f]+(A[r++]%xE)*xE,1,true);
				f++;
			}
			while(l<=m)await write(A,f,A[f++]+(A[l++]%xE)*xE,1,true);
			while(r<=e)await write(A,f,A[f++]+(A[r++]%xE)*xE,1,true);
			for(let i=s;i<=e;i++)
				await write(A,i,A[i]/xE,1,true);
		}
		async function mergeSort(A,s,e,xE){
			if(s<e){
				let m=s+(e-s)/2|0;
				await mergeSort(A,s,m,xE);
				await mergeSort(A,m+1,e,xE);
				await merge(A,s,m,e,xE);
			}
		}
		await mergeSort(arr,0,len-1,maxVal(...arr)+1);
	}
	async partialMergeSort(len){
		async function merge(A,c,lS,rS,e){
			arraycopy(A,lS,c,0,rS-lS,0,false,true);
			let l=lS,r=rS;
			for(let n=0;n<e-lS;n++){
				if(l>=rS&&r>=e)break;
				if(l<rS&&r>=e)await write(A,n+lS,c[l++-lS],1,true);
				else if(l>=rS&&r<e)await write(A,n+lS,A[r++],1,true);
				else if(compareValues(c[l-lS],A[r])<1)await write(A,n+lS,c[(l++)-lS],1,true);
				else await write(A,n+lS,A[r++],1,true);
			}
		}
		async function mergeRun(A,c,s,m,e){
			if(s==m)return;
			await mergeRun(A,c,s,(m+s)/2|0,m);
			await mergeRun(A,c,m,(m+e)/2|0,e);
			await merge(A,c,s,m,e);
		}
		let m=len/2|0;
		await mergeRun(arr,new Array(m),0,m,len);
	}
	async mobMergeSort(len){
		async function bubble(A,st,e){
			let c=1,s,f=st+(e-st)/2|0;
			let a=false;
			for(let j=e-1;j>0;j-=c){
				s=f-1<st?st:f-1;
				a=false;
				c=1;
				for(let i=s;i<j;i++){
					if(compareIndices(A,i,i+1)>0){
						await swap(A,i,i+1,.075,true);
						if(!a)f=i;
						a=true;
						c=1;
					}else c++;
				}
			}
		}
		async function sort(A,ln){
			let l=2,i=0;
			while(l<=ln){
				i=0;
				while(i+l<=ln){
					if(l==2){
						if(compareIndices(A,i,i+1)>0)await swap(A,i,i+1,.075,true);
					}else await bubble(A,i,i+l);
					i+=l;
				}
				if(i-ln)await bubble(A,i,ln);
				l*=2;
			}
			await bubble(A,0,ln);
		}
		await sort(arr,len);
	}
	async optimizedPancakeSort(len){
		async function flip(A,i){
			await reversal(A,0,i,.1,true);
		}
		async function cursedRotate(A,a,m,b){
			await flip(A,a-1);
			await flip(A,m-1);
			await flip(A,b-1);
			await flip(A,b-m+a-1);
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function pancakeMerge(A,m,b){
			let m1,m2,m3;
			if(m>=b-m){
				m1=m/2|0;
				m2=binarySearch(A,m,b,A[m1],false);
				m3=m1+(m2-m);
			}else{
				m2=m+(b-m)/2|0;
				m1=binarySearch(A,0,m,A[m2],true);
				m3=(m2++)-(m-m1);
			}
			await cursedRotate(A,m1,m,m2);
			if(m1>0&&m3>m1)await pancakeMerge(A,m1,m3);
			m3++;
			if(m2>m3&&b>m2){
				await cursedRotate(A,0,m3,b);
				await pancakeMerge(A,m2-m3,b-m3);
				await cursedRotate(A,0,b-m3,b);
			}
		}
		async function pancakeMergeSort(A,n){
			if(n>1){
				if(compareIndices(A,0,1)<1){
					let i=2;
					for(;i<n&&compareIndices(A,i-1,i)<1;i++);
					if(i==n)return;
				}else{
					let i=2;
					for(;i<n&&compareIndices(A,i-1,i)>0;i++);
					if(i==n){
						await flip(A,n-1);
						return;
					}
				}
				let m=n/2|0;
				await pancakeMergeSort(A,m);
				await cursedRotate(A,0,m,n);
				m=n-m;
				await pancakeMergeSort(A,m);
				await pancakeMerge(A,m,n);
			}
		}
		await pancakeMergeSort(arr,len);
	}
	async transposeModuloWeaveMergeSort(len){
		async function weave(A,p,s,l,b){
			let v=0;
			for(let i=0;i<b;i++)
				for(let j=i;j<l;j+=b)
					write(p,v++,A[s+j],0,false,true);
			await arraycopy(p,0,A,s,l,.25,true);
		}
		async function circle(A,a,b){
			let l=a,r=b;
			while(l<r){
				if(compareIndices(A,l,r)>0)await swap(A,l,r,.25,true);
				l++;r--;
			}
		}
		async function circlepass(A,s,l){
			let g=l;
			while(g>1){
				for(let o=0;o+g-1<l;o+=g)
					await circle(A,s+o,s+o+g-1);
				g=g/2|0;
			}
		}
		async function method(A,s,l){
			let p=new Array(l);
			if(compareIndices(A,s+l/2-1|0,s+l/2|0)>0){
				await weave(A,p,s,l,l/2|0);
				await circlepass(A,s,l);
			}
		}
		async function sort(A,ln){
			let l=2,i=0;
			while(l<ln){
				i=0;
				while(i+l-1<ln){
					if(l==2){
						if(compareIndices(A,i,i+1)>0)await swap(A,i,i+1,.25,true);
					}else await method(A,i,l);
					i+=l;
				}
				l*=2;
			}
			if(l-ln)await Sorts.prototype.quadSort(len);
			else await method(A,0,ln);
		}
		await sort(arr,len);
	}
	async reverseLazyStableSort(len){
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function merge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function sort(A,l){
			for(let i=0;i<l-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,0,true);
			let g;
			for(g=4;g<=l;g*=2)
				for(let i=0;i+g<=l;i+=g)
					await merge(A,i,i+g/2|0,i+g);
			if((l-g/2|0)>0)
				await merge(A,0,g/2|0,l);
		}
		await sort(arr,len);
	}
	async lazyStableQuickSort(len){
		function log2(x){
			let n=1;
			while(1<<n<x)n++;
			if(1<<n>x)n--;
			return n;
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function findPivot(A,s,m,e){
			if(compareIndices(A,s,m)<0){
				if(compareIndices(A,m,e)<0)return m;
				else if(compareIndices(A,s,e)<0)return e;
				return s;
			}else{
				if(compareIndices(A,m,e)>0)return m;
				else if(compareIndices(A,s,e)<0)return s;
				return e;
			}
		}
		async function stablePartition(A,s,e){
			let m=s+(e-s)/2|0;
			let pvp=findPivot(A,s,m,e-1);
			while(1){
				let pv=A[pvp];
				let ltL=s;
				let r=s;
				let z=0;
				let qC=0;
				for(let i=s;i<e;i++){
					let c=compareValues(A[i],pv);
					if(c<0){
						z++;
						continue;
					}else if(!c)qC++;
					if(z>0&&r>s)await rotateSmart(A,r,ltL,z);
					ltL+=z;
					r=i+1;
					z=0;
				}
				if(qC==e-s)return-1;
				if(z>0){
					await rotateSmart(A,r,ltL,z);
					ltL+=z;
				}
				if(ltL==s){
					if(++pvp==e)pvp=s;
					while(!compareValueIndex(A,pv,pvp))
						if(++pvp==e)pvp=s;
					continue;
				}
				return ltL;
			}
		}
		async function stableQuickSort(A,s,e,d){
			while(e-s>16){
				if(!d)return await binaryDoubleInsertion(A,s,e);
				let i=await stablePartition(A,s,e);
				if(i==-1)return;
				let l=i-s,r=e-i;
				if(l>r){
					await stableQuickSort(A,i,e,--d);
					e=i;
				}else await stableQuickSort(A,s,s=i,--d);
			}
			await insertSort(A,s,e,.25);
		}
		await stableQuickSort(arr,0,len,2*log2(len));
	}
	async optimizedBubbleBogoSort(len){
		let s=0,e=len-1,j=0;
		while(compareIndices(arr,s,s+1)<1&s<=e)s++;
		while(compareIndices(arr,e-1,e)<1&&s<=e)e--;
		while(s<=e){
			let i=randInt(s,e);
			if(compareIndices(arr,i,i+1)>0){
				swap(arr,i,i+1,1);
				if(++j>=sqrt(len))await markSwap(i,i+1,j=0);
				if(i==s){
					if(s>0)s--;
					while(compareIndices(arr,s,s+1)<1&&s<=e)s++;
				}
				if(i==e-1){
					if(e<len-1)e++;
					while(compareIndices(arr,e-1,e)<1&&s<=e)e--;
				}
			}
		}
	}
	async reversePushSort(len){
		let as=true,i=len,g=1;
		while(as){
			as=false;i=len;g=1;
			while(i-g>0){
				if(compareIndices(arr,i-1-g,i-1)>0){
					await mark(i);
					for(let j=1;j<=g;j++)
						swap(arr,i-1,i-1-j,0);
					as=true;
					g++;
				}else i--;
			}
		}
	}
	async reverseGrateSort(len){
		let s=false,k=0;
		while(!s){
			s=true;
			for(let i=0;i<len-1;i++){
				for(let j=i+1;j<len;j++){
					if(compareIndices(arr,i,j)>0){
						s=false;
						swap(arr,i,j,1);
						if(++k>=sqrt(len))await markSwap(i,j,k=0);
						break;
					}
				}
			}
		}
	}
	async optimizedCocktailGrateSort(len){
		let aB=len-1,aR=len-1,aT=len-1,bB=len-1;
		let l=0,aF=0,aL=0,bF=0,bL=0;
		let s=false,aH=false;
		while(!s){
			if(!s)
				while(!aH)
					if(aT<l){
						aB--;aT=aR;
						if(aB<aR)aH=true;
					}else{
						if(compareIndices(arr,aT,aB)>0)aH=true;
						else aT--;
					}
			s=true;
			for(let i=l;i<aR;i++)
				for(let j=aB;j>i;j--)
					if(compareIndices(arr,i,j)>0){
						if(s)aF=i;
						aL=i;s=false;
						await swap(arr,i,j,.125,true);
						break;
					}
			bB--;aT=aR;aH=false;l=aF;aR=aL+1;
			if(s)break;
			s=true;
			for(let i=l;i<bB;i++)
				for(let j=i+1;j<=bB;j++)
					if(compareIndices(arr,i,j)>0){
						if(s)bF=i;
						bL=i;s=false;
						await swap(arr,i,j,.125,true);
						break;
					}
			bB=bL;l=bF;aB=bB;
		}
	}
	async PDGnomeSort(len){
		async function gnomeSort(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let p=i++;
				while(p>a&&compareIndices(A,p-1,p)>0)
					await swap(A,p--,p,1,true);
			}
		}
		await gnomeSort(arr,0,len);
	}
	async reverseGnomeSort(len){
		async function reverseGnomeSort(A,l,u){
			let p=l;
			while(p<u&&compareIndices(A,p,p+1)>0)
				await swap(A,p++,p,1,true);
		}
		for(let i=len-1;i>=0;i--)
			await reverseGnomeSort(arr,i,len-1);
	}
	async optimizedReverseGrateSort(len){
		let b=len-1,l=0,f=0,t=0,k=0;
		let s=false;
		while(!s){
			s=true;
			for(let i=l;i<b;i++){
				for(let j=i+1;j<=b;j++){
					if(compareIndices(arr,i,j)>0){
						if(s)f=i;
						t=i;s=false;
						swap(arr,i,j,0);
						if(++k>=sqrt(len))await markSwap(i,j,k=0);
						break;
					}
				}
			}
			b=t;l=f;
		}
	}
	async strangePushSort(len){
		let base=askForNum(2,"Base");
		let as=true,i=1,g=1;
		while(as){
			as=false;
			i=g=1;
			while(i+g<=len){
				if(compareIndices(arr,i-1,i-1+g)>0){
					await mark(i);
					for(let j=1;j<=g;j++)
						swap(arr,i-1,i-1+j,0);
					as=true;
					g*=base;
				}else i++;
			}
		}
	}
	async safeBogoSort(len){
		function minSorted(A,l){
			let i=1;
			for(;i<l&&compareIndices(A,i-1,i)<1;i++);
			return i-1;
		}
		let r=new Random();
		let p=minSorted(arr,len),j=0;
		while(p<len-1){
			swap(arr,p,p+r.nextInt(len-p),0);
			if(++j>=sqrt(len))await mark(p,j=0);
			p=minSorted(arr,len);
		}
	}
	async heavyHeapSort(len){
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		let d=true,del=1/sqrt(len);
		for(let i=0;i<len;i++)
			await new HeapSorting(d=!d).heapify(arr,i,len,del);
		for(let i=1,j=len-1;i<j;i+=2,j-=2)
			await swap(arr,i,j,1,true);
		await bitReversal(arr,0,len);
		await bitReversal(arr,0,len/2|0);
		await bitReversal(arr,len/2|0,len);
	}
	async unbelievableSort(len){
		for(let i=0,k=0;i<len;i++)
			for(let j=0;j<len;j++)
				if(compareIndices(arr,i,j)<0){
					swap(arr,i,j,0);
					if(++k>=len/4)await markSwap(i,j,k=0);
				}
	}
	async naturalMergeSort(len){
		async function merge(A,l,r,e){
			let f=true,i=0,s=0,oR=r,oL=l;
			while(l<oR&&r<e)
				if(compareIndices(A,l,r)>0)
					write(mr,i++,A[r++],0,f=false,true);
				else
					if(f){
						s++;i++;l++;
					}else write(mr,i++,A[l++],0,false,true);
			while(l<oR)write(mr,i++,A[l++],0,false,true);
			for(let j=s;j<i;j++)
				await write(A,j+oL,mr[j],1,true);
		}
		let mr=new Array(len);
		async function sort(A,l){
			let d=false,s=0,e=l-1;
			while(!d){
				let p=0,f=-1;
				d=true;
				for(let i=s;i<e;i++)
					if(compareIndices(A,i,i+1)>0){
						if(f+1){
							await merge(A,f,p,p=i+1);
							if(d)s=i;
							f=-1;
							d=false;
						}else{
							f=p;
							p=i+1;
						}
					}
				if(f+1){
					await merge(A,e=f,p,l);
					d=false;
				}
			}
		}
		await sort(arr,len);
	}
	async outOfPlaceWeaveMergeSort(len){
		async function weave(A,T,s,e){
			let s2=s/2|0,e2=e/2|0;
			for(let i=0;i<=e-s;i+=2)
				await write(A,s+i,T[s+i/2|0],.25,true);
			for(let i=1;i<=e-s;i+=2)
				await write(A,s+i,T[s2+i/2+e2+1|0],.25,true);
		}
		function merge(A,T,s,e){
			let i=s,j=s+1,p=s;
			while(i<=e&&j<=e){
				if(compareIndices(A,i,j)>0){
					write(T,p,A[j],0,false,true);
					j+=2;
				}else{
					write(T,p,A[i],0,false,true);
					i+=2;
				}
				p++;
			}
			let k=i<j?i:j;
			while(k<=e){
				write(T,p++,A[k],0,false,true);
				k+=2;
			}
		}
		async function controller(A,T,s,e){
			if(e-s>=2){
				await controller(A,T,s,(e+s-1)/2|0);
				await controller(A,T,(e+s+1)/2|0,e);
			}
			await weave(A,T,s,e);
			merge(A,T,s,e);
		}
		let T=new Array(len);
		for(let i=0;i<len;i++)write(T,i,arr[i],0,false,true);
		await controller(arr,T,0,len-1);
		for(let i=0;i<len;i++)
			await write(arr,i,T[i],0,true);
	}
	async tumbleweedSort(len){
		let l=1,h=1,r=2,p=1,j=0;
		let a=false;
		while(l-len){
			h=l;
			r=l+1;
			while(r<=len){
				if(compareIndices(arr,l-1,r-1)<1){
					if(h==l)h=r;
					else{
						if(compareIndices(arr,h-1,r-1)>0)h=r;
					}
				}
				r++;
			}
			p=l;
			if(h==l)
				while(p<len){
					swap(arr,p-1,p++,0);
					if(++j>=len)await mark(p-2,j=0);
				}
			else{
				if(h==l+1){
					r=l+1;
					a=false;
					while(r<=len&&!a)
						if(compareIndices(arr,l-1,r-1)>0)a=true;
						else r++;
					if(!a)l++;
					else
						while(p<len){
							swap(arr,p-1,p++,0);
							if(++j>=len)await mark(p-2,j=0);
						}
				}else
					while(p+1-h){
						swap(arr,p-1,p++,0);
						if(++j>=len)await mark(p-2,j=0);
					}
			}
		}
	}
	async peelSort(len){
		let j=0;
		for(let l=0;l<len;l++){
			let s=0;
			for(let r=len-1;r>l;r--){
				if(compareIndices(arr,l,r+s)>0){
					let i=arr[r+s];
					for(let p=r+s;p>l;p--){
						if(++j>=sqrt(len))await mark(p,j=0);
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,.05,true);
					s++;
				}
			}
		}
	}
	async stableFallSort(len){
		let l=1,r=2,h=0,i=0,p=0,s=0,j=0;
		while(l<=len){
			r=l+1+s;h=0;
			while(r<=len){
				if(compareIndices(arr,l-1,r-1)>0)
					if(!h)h=r;
					else if(compareIndices(arr,h-1,r-1)<0)h=r;
				r++;
			}
			if(!h){
				l++;
				s=0;
			}else{
				i=arr[h-1];p=h;
				while(p>l){
					if(++j>=sqrt(len))await mark(p-1,j=0);
					write(arr,--p,arr[p-1],0);
				}
				await write(arr,l-1,i,.01,true);
				s++;
			}
		}
	}
	async sandpaperSort(len){
		let k=0;
		for(let i=0;i<len-1;i++)
			for(let j=i+1;j<len;j++)
				if(compareIndices(arr,i,j)>0){
					if(++k>=sqrt(len))await markSwap(i,j,k=0);
					swap(arr,i,j,0);
				}
	}
	async optimizedLazyHeapSort(len){
		function fM(A,p,a,b,s){
			let m=p;
			for(let i=a;i<b;i+=s)
				if(compareIndices(A,i,m)<0)m=i;
			return m;
		}
		async function sort(A,l){
			let s=sqrt(l-1)+1|0;
			let a=(l-1)%s+1;
			let f=fM(A,0,1,a,1);
			for(let j=a;j<l;j+=s){
				let m=fM(A,j,j+1,j+s,1);
				if(j-m)await swap(A,j,m,1,true);
			}
			for(let j=0;j<l;){
				let m=fM(A,f,a,l,s);
				if(m==f){
					if(j-m)await swap(A,j,m,1,true);
					if(++j==a)a=s;
					f=fM(A,j,j+1,a,1);
				}else{
					if(j==f)f=fM(A,j+1,j+2,a,1);
					let n=fM(A,j,m+1,m+s,1);
					if(n==j)await swap(A,j,m,1,true);
					else{
						let t=A[j];
						await write(A,j,A[m],.5,true);
						await write(A,m,A[n],.5,true,false);
						await write(A,n,t,.5,true);
					}
					if(++j==a)a+=s;
				}
			}
		}
		await sort(arr,len);
	}
	async cocktailPeelSort(len){
		let s=0,k=0;
		for(let l=0;l<len;l++){
			s=0;
			for(let r=len-1;r>l;r--){
				if(compareIndices(arr,l,r+s)>0){
					let i=arr[r+s];
					for(let p=r+s;p>l;p--){
						if(++k>=sqrt(len))await mark(p,k=0);
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,.05,true);
					s++;
				}
			}
			l++;
			for(let r=l+1;r<len;r++){
				if(compareIndices(arr,l,r)>0){
					let i=arr[r];
					for(let p=r;p>l;p--){
						if(++k>=sqrt(len))await mark(p,k=0);
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,.05,true);
				}
			}
		}
	}
	async forcedStableHeapSort(len){
		function stableComp(A,k,a,b){
			let c=compareIndices(A,a,b,.0,true);
			return c>0||(!c&&compareIndices(k,a,b)>0);
		}
		async function stableSwap(A,k,a,b){
			await swap(A,a,b,1,true);
			swap(k,a,b,0,false,true);
		}
		async function siftDown(A,k,r,d,s){
			while(r<=(d/2|0)){
				let l=2*r;
				if(l<d&&stableComp(A,k,s+l,s+l-1))l++;
				if(stableComp(A,k,s+l-1,s+r-1)){
					await stableSwap(A,k,s+l-1,s+r-1);
					r=l;
				}else break;
			}
		}
		async function heapify(A,k,a,b){
			let l=b-a;
			for(let i=l/2|0;i>0;i--)
				await siftDown(A,k,i,l,a);
		}
		async function heapSort(A,k,s,l){
			await heapify(A,k,s,l);
			for(let i=l-s;i>1;i--){
				await stableSwap(A,k,s,s+i-1);
				await siftDown(A,k,1,i-1,s);
			}
		}
		let k=new Array(len);
		for(let i=0;i<len;i++)
			write(k,i,i,0,false,true);
		await heapSort(arr,k,0,len);
	}
	async optimizedReverseSandpaperSort(len){
		let ae=true,s=1,le=len-1,e=len-1,ll=0,h;
		while(ae){
			let f=ae=false;
			h=0;
			for(let i=s>1?s-1:0;i<le;i++){
				if(compareIndices(arr,i,i+1)>0){
					if(!f)s=i;
					f=ae=true;
					ll=i;
					for(let j=e;j>i;j--){
						if(compareIndices(arr,i,j)>0){
							await swap(arr,i,j,0,true);
							if(j>h)h=j;
						}
					}
				}
			}
			le=ll;
			e=h-1;
		}
	}
	async reversePeelSort(len){
		let s=0,k=0;
		for(let l=0;l<len;l++){
			for(let r=l+s+1;r<len;r++){
				if(r==l+s+1)s=0;
				if(compareIndices(arr,l,r)>0){
					let i=arr[r];
					for(let p=r;p>l;p--){
						if(++k>=sqrt(len))await mark(p,k=0);
						write(arr,p,arr[p-1],0);
					}
					await write(arr,l,i,.05,true);
					s++;
				}
			}
		}
	}
	async reverseSandpaperSort(len){
		for(let i=0;i<len-1;i++)
			for(let j=len-1;j>i;j--)
				if(compareIndices(arr,i,j)>0)
					await swap(arr,i,j,.05,true);
	}
	async reverseSelectionSort(len){
		for(let i=len-1;i>=0;i--){
			let h=0;
			for(let j=1;j<i+1;j++)
				if(compareIndices(arr,j,h)>0)
					h=j;
			await swap(arr,i,h,.02,true);
		}
	}
	async reverseInsertionSort(len){
		let k=0;
		for(let i=len-1;i>=0;i--){
			let c=arr[i],p=i+1;
			while(p<=len-1&&compareValues(arr[p],c)<0){
				if(++k>=sqrt(len))await mark(p-1,k=0);
				write(arr,p-1,arr[p++],0);
			}
			await write(arr,p-1,c,0,true);
		}
	}
	async unstableInsertionSort(len){
		async function unstableInsertionSort(A,s,e){
			for(let i=s+1;i<e;++i){
				if(compareIndices(A,i,s)<0)
					await swap(A,i,s,1,true);
				let t=A[i],j=i-1;
				for(;compareValues(A[j],t)>0;--j)
					await write(A,j+1,A[j],1,true);
				await write(A,j+1,t,1,true);
			}
		}
		await unstableInsertionSort(arr,0,len);
	}
	async patternDefeatingInsertionSort(len){
		async function insert(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let c=A[i];
				let p=i-1;
				while(p>=a&&compareValues(A[p],c)>0){
					await write(A,p+1,A[p--],1,true);
				}
				await write(A,p+1,c,1,true);
				i++;
			}
		}
		await insert(arr,0,len);
	}
	async pairwiseCircleSort(len){
		async function pairs(A,l,r,g){
			if(l+g>=r)return;
			let a=l;
			while(a+g<=r){
				if(compareIndices(A,a,a+g)>0)
					await swap(A,a,a+g,1,true);
				a+=g*2;
			}
			await pairs(A,l,r,g*2);
			await pairs(A,l+g,r,g*2);
		}
		async function circle(A,l,r){
			for(let a=l,b=r;a<b;a++,b--)
				if(compareIndices(A,a,b)>0)
					await swap(A,a,b,1,true);
		}
		async function pairCircle(A,l,r){
			if(l>=r)return;
			let m=(l+r)/2|0;
			await pairs(A,l,r,1);
			await circle(A,l,r);
			await pairCircle(A,l,m);
			await pairCircle(A,m+1,r);
		}
		await pairCircle(arr,0,len-1);
		await insertSort(arr,0,len,.1);
	}
	async sinkingMergeSortRecursive(len){
		async function bubbleSort(A,s,e){
			let cS=1;
			for(let i=e-1;i>s;i-=cS){
				cS=1;
				for(let j=s;j<i;j++){
					if(compareIndices(A,j,j+1)>0){
						await swap(A,j,j+1,1,true);
						cS=1;
					}else cS++;
				}
			}
		}
		async function sort(A,s,e){
			if(e-s>16){
				let m=s+(e-s)/2|0;
				await sort(A,s,m);
				await sort(A,m,e);
				await bubbleSort(A,s,e);
			}else
				await bubbleSort(A,s,e);
		}
		await sort(arr,0,len);
	}
	async introPseudoHeapSort(len){
		async function sift(A,s,l,r){
			let sw=false,j=r;
			while(2*j<l){
				let k=2*j;
				if(k<l&&compareIndices(A,s+k-1,s+k)>0)k++;
				if(compareIndices(A,s+j-1,s+k-1)>0){
					await swap(A,s+j-1,s+k-1,1,sw=true);
					j=k;
					continue;
				}
				break;
			}
			return sw;
		}
		async function sort(A,l){
			let th=0,n=1;
			for(;n<l;n*=2,th++);
			th=th/2|0;
			let it=0,sw=true;
			while(sw){
				sw=false;it++;
				if(it>=th){
					await insertSort(A,0,l,.5);
					break;
				}
				for(let i=l-2;i>=0;i--)
					if(await sift(A,i,l-i+1,1))
						sw=true;
			}
		}
		await sort(arr,len);
	}
	async sinkingMergeSortIterative(len){
		async function bubbleSort(A,s,e){
			let cS=1;
			for(let i=e-1;i>s;i-=cS){
				cS=1;
				for(let j=s;j<i;j++){
					if(compareIndices(A,j,j+1)>0){
						await swap(A,j,j+1,1,true);
						cS=1;
					}else
						cS++;
				}
			}
		}
		async function sort(A,s,e){
			let m=e-s,i;
			for(;m>31;m=(m+1)/2|0);
			for(i=s;i+m<e;i+=m)
				await bubbleSort(A,i,i+m);
			await bubbleSort(A,i,e);
			for(let j=m;j<e-s;j*=2){
				for(i=s;i+2*j<=e;i+=2*j)
					await bubbleSort(A,i,i+2*j);
				if(i+j<e)
					await bubbleSort(A,i,e);
			}
		}
		await sort(arr,0,len);
	}
	async bufferedBlockSelectionMergeSort(len){
		function sqr(n){
			return sqrt(n-1)+1|0;
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function blockLesser(A,a,b,l){
			let c=compareIndices(A,a,b);
			return c<0||(!c&&compareIndices(A,a+l-1,b+l-1)<0);
		}
		async function mergeAboveBW(A,a1,b1,a,b){
			let p=(b1--)+(b--)-a;
			while(b>=a&&b1>=a1){
				if(compareIndices(A,b,b1)+1)
					await swap(A,--p,b--,1,true);
				else
					await swap(A,--p,b1--,1,true);
			}
			while(b>=a)await swap(A,--p,b--,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareIndices(A,p+i,j)+1)
					await swap(A,k--,p+(i--),1,true);
				else
					await swap(A,k--,j--,1,true);
			}
			while(i+1)await swap(A,k--,p+(i--),1,true);
		}
		async function inPlaceMergeUnstable(A,a,m,b){
			let bL=sqr(b-a),a1=a+(m-a-1)%bL+1,b1=b-(b-m)%bL;
			await multiSwap(A,a1,blockLesser(A,m-bL,b1-bL,bL)?b1-bL:m-bL,bL);
			for(a1+=bL;a1<b1;a1+=bL){
				let m=a1;
				for(let i=a1+bL;i<b1;i+=bL)
					if(blockLesser(A,i,m,bL))m=i;
				if(m>a1)await multiSwap(A,m,a1,bL);
				await mergeAboveBW(A,a,a1-bL,a1,a1+bL);
			}
			await mergeAboveBW(A,a,a1-bL,a1,b);
			await binaryInsertion(A,b-bL,b,.25);
			await mergeBW(A,a+bL,b-bL,b,a);
			await binaryInsertion(A,a,a+bL,.25);
		}
		async function mergeSort(A,a,b){
			if(b-a<32)return await binaryInsertion(A,a,b,.25);
			let m=(a+b)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await inPlaceMergeUnstable(A,a,m,b);
		}
		await mergeSort(arr,0,len);
	}
	async bubbleMergeSort(len){
		async function bubbleSort(a,s,e){
			for(let i=e-1;i>s;i--){
				let as=true;
				for(let j=s;j<i;j++){
					if(compareIndices(a,j,j+1)>0){
						await swap(a,j,j+1,1,true);
						as=false;
					}
				}
				if(as)break;
			}
		}
		let mRL=new TimSorting().minRunLength(len);
		if(len==mRL)await bubbleSort(arr,0,len);
		else{
			let i=0;
			for(;i<=len-mRL;i+=mRL)await bubbleSort(arr,i,i+mRL);
			if(i+mRL>len)await bubbleSort(arr,i,len);
			await TimSorting.sort(new TimSorting(arr,len),arr,0,len);
		}
	}
	async quarterMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function binarySearchMid(A,s,md,e){
			let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
			while(b>a){
				if(compareIndices(A,md-m-1,md+m)>0)a=m+1;
				else b=m;
				m=a+(b-a)/2|0;
			}
			return m;
		}
		async function multiSwapMerge(A,s,md,e){
			let m=binarySearchMid(A,s,md,e);
			while(m>0){
				await multiSwap(A,md-m,md,m);
				await multiSwapMerge(A,md,md+m,e);
				e=md;
				md-=m;
				m=binarySearchMid(A,s,md,e);
			}
		}
		async function merge(A,bL,s,m,e){
			await multiSwap(A,0,s,m-s);
			let bP=0;
			let l=s,r=m;
			while(l<r&&r<e)
				if(compareIndices(A,bP,r)<1)
					await swap(A,bP++,l++,.5,true);
				else
					await swap(A,l++,r++,.5,true);
			while(l<r)
				await swap(A,bP++,l++,.5,true);
		}
		function pow2lte(n){
			let v;
			for(v=1;v<=n;v<<=1);
			return v>>1;
		}
		async function quarterMergeSort(A,l){
			if(l<33)return await binaryInsertion(A,0,l,1/3);
			let qL=l/4|0;
			let uL=qL*4;
			for(let i=qL;i<uL-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,.5,true);
			let sS,sE=uL,sL=uL-qL,g;
			for(let pr=sL;pr>1;pr=sE-qL){
				sL=pow2lte(pr);
				sS=sE-sL;
				for(g=4;g<=sL;g*=2)
					for(let i=sS;i+g<=sE;i+=g)
						await merge(A,qL,i,i+g/2|0,i+g);
				if(pr-uL+qL)
					await merge(A,qL,sS,sE,uL);
				sE=sS;
			}
			let ex=l-uL;
			if(ex>0){
				if(ex>1&&compareIndices(A,l-2,l-1)>0)
					await swap(A,l-2,l-1,.5,true);
				await multiSwapMerge(A,qL,uL,l);
			}
			await quarterMergeSort(A,qL);
			await multiSwapMerge(A,0,qL,l);
		}
		await quarterMergeSort(arr,len);
	}
	async multiSelectionSort(len){
		function monoboundBw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)>0)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)>0)return s+1;
			return s;
		}
		function monoboundFw(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		async function moveFront(A,s,m,e){
			let st=maxVal(m,s+(e-s)/2|0);
			while(e>st)
				await swap(A,s++,e--,1,true);
		}
		async function moveBack(A,s,m,e){
			while(m>s)
				await swap(A,m--,e--,1,true);
		}
		async function selectSmallest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)<1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE-rS&&compareIndices(A,i,rS)<0)
					rS=monoboundBw(A,rS,rE+1,A[i]);
				i++;
			}
			await moveFront(A,l,rS-1,rE);
			return l+(rE-rS+1);
		}
		async function selectLargest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)+1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE!=rS&&compareIndices(A,i,rS)>0)
					rS=monoboundFw(A,rS,rE+1,A[i]);
				i++;
			}
			if(rE-r+1)await moveBack(A,rS-1,rE,r-1);
			return r-rE+rS-1;
		}
		let l=0,r=len;
		while(l<r-1){
			if(compareIndices(arr,l,l+1)>0)l=await selectSmallest(arr,l,l+1,r);
			else r=await selectLargest(arr,l,l+1,r);
		}
	}
	async improvedMultiSelectionSort(len){
		function monoboundBw(A,s,e,v){
			let t=e-s,m;
			while(t>1){
				m=t/2|0;
				if(compareIndexValue(A,s+m,v)>0)s+=m;
				t-=m;
			}
			if(compareIndexValue(A,s,v)>0)return s+1;
			return s;
		}
		function monoboundFw(A,s,e,v){
			let t,m;
			t=e-s;
			while(t>1){
				m=t/2|0;
				if(compareValueIndex(A,v,e-m)<1)e-=m;
				t-=m;
			}
			if(compareValueIndex(A,v,e-1)<1)return e-1;
			return e;
		}
		async function moveFront(A,s,m,e){
			let st=maxVal(m,s+(e-s)/2|0);
			while(e>st)
				await swap(A,s++,e--,1,true);
		}
		async function moveBack(A,s,m,e){
			while(m>s)
				await swap(A,m--,e--,1,true);
		}
		async function selectSmallest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)<1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE-rS&&compareIndices(A,i,rS)<0)
					rS=monoboundBw(A,rS,rE+1,A[i]);
				i++;
			}
			await moveFront(A,l,rS-1,rE);
			return l+(rE-rS+1);
		}
		async function selectLargest(A,l,rE,r){
			let rS=l,i=rE+1;
			while(i<r){
				if(compareIndices(A,i,rE)+1){
					if(rE<i-1)rS=i;
					rE=i;
				}else if(rE!=rS&&compareIndices(A,i,rS)>0)
					rS=monoboundFw(A,rS,rE+1,A[i]);
				i++;
			}
			if(rE-r+1)await moveBack(A,rS-1,rE,r-1);
			return r-rE+rS-1;
		}
		let l=0,r=len;
		let d=compareIndices(arr,l,l+1)>0;
		if(compareIndices(arr,l,l+1)>0)
			l=await selectSmallest(arr,l,l+1,r);
		else
			r=await selectLargest(arr,l,l+1,r);
		let sD=d,sDC=1,sDM=1;
		while(sDM*sDM<len)sDM*=2;
		while(l<r-1){
			let rE=l+1;
			d=compareIndices(arr,l,l+1)>0;
			if(d==sD){
				sDC++;
				if(sDC==sDM){
					sDC=0;
					d=!d;
					rE--;
				}
			}else{
				sDC=0;
			}
			if(d)l=await selectSmallest(arr,l,rE,r);
			else r=await selectLargest(arr,l,rE,r);
		}
	}
	async adaptiveShuffleQuickSort(len){
		const hs=new HeapSorting(true);
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function shuffle(A,a,b){
			let r=new Random();
			for(let i=a;i<b;i++){
				let j=i+r.nextInt(b-i);
				if(i-j)
					await swap(A,i,j,.75,true);
			}
		}
		async function partition(A,a,b){
			let pv=A[a];
			let f=a;
			let l=b;
			while(compareValues(A[++f],pv)<0);
			if(f-1==a)
				while(f<l&&compareValues(A[--l],pv)>0);
			else
				while(compareValues(A[--l],pv)>0);
			let aP=f>=l;
			while(f<l){
				await swap(A,f,l,1,true);
				while(compareValues(A[++f],pv)<0);
				while(compareValues(A[--l],pv)>0);
			}
			let pvp=f-1;
			await write(A,a,A[pvp],1,true);
			await write(A,pvp,pv,1,true);
			return[pvp,aP];
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,bA){
			while(b-a>16){
				await medianOfThree(A,a,b);
				let[p,aP]=await partition(A,a,b);
				let l=p-a,r=b-(p+1);
				if(l<((b-a)/16|0)||r<((b-a)/16|0)){
					if(!--bA)return await hs.sort(A,a,b);
					if(l>16)await shuffle(A,a,p);
					if(r>16)await shuffle(A,p+1,b);
				}else if(aP&&await partialInsert(A,a,p)&&await partialInsert(A,p+1,b))return;
				if(l>r){
					await quickSort(A,p+1,b,bA);
					b=p;
				}else{
					await quickSort(A,a,p,bA);
					a=p+1;
				}
			}
			await insertSort(A,a,b,.5);
		}
		await quickSort(arr,0,len,floorLog(len));
	}
	async quickSPSort(len){
		const GS=new GrailSorting();
		async function compSwap(A,a,b){
			if(compareIndices(A,--a,--b)>0)await swap(A,a,b,0,true);
		}
		function ipMerge(A,a,m,b){
			return GS.grailMergeWithoutBuffer(A,a,m-a,b-m);
		}
		async function quickSPSort2(A,l,r){
			if(r-l<12)for(let i=l;i<=r;i++)for(let j=i;j<=r;j++)await compSwap(A,i,j);
			else{
				let rb=l+ceil(sqrt(1+r-l)),m,j;
				for(let i=l;i<=rb;i++)for(j=i;j<=r;j++)await compSwap(A,i,j);
				m=A[rb];
				j=1+rb;
				for(let i=1+rb;i<=r;i++)
					if(compareValues(A[i-1],m)<0){
						m=A[i-1];
						await swap(A,i-1,j++,.125,true);
					}
				await reversal(A,rb,j-1,1,true);
				await quickSPSort2(A,1+j,r);
				await ipMerge(A,rb,j,r);
			}
		}
		await quickSPSort2(arr,1,len);
	}
	async lazierSort(len){
		const hs=new HeapSorting(true);
		function cbrt(n){
			let r=1;
			for(;r*r*r<n;r++);
			return r;
		}
		async function shift(A,a,m,b){
			while(m<b)await swap(A,a++,m++,1,true);
		}
		async function shiftBW(A,a,m,b){
			while(m>a)await swap(A,--b,--m,1,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0){
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;
					m-=r;
					l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;
					m+=l;
					r-=l;
				}
			}
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function findKeys(A,a,b,n){
			let nK=1,p=a,pE=a+nK;
			for(let i=pE;i<b&&nK<n;i++){
				let o=leftBinSearch(A,p,pE,A[i]);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,p,pE,i);
					let inc=i-pE;
					p+=inc;
					pE+=inc;
					await insertTo(A,pE++,o+=inc);
					nK++;
				}
			}
			await rotate(A,a,p,pE);
			return nK;
		}
		async function insertion(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;
					j=k;
				}else i++;
			}
		}
		async function lazierBlockMerge(A,a,m,b,bL){
			while(m-bL>=a)
				await inPlaceMerge(A,m-=bL,m,b);
			await inPlaceMerge(A,a,m,b);
		}
		async function inPlaceMergeSort(A,a,b){
			let l=b-a,i,j;
			for(j=l;j>31;j=(j+1)/2|0);
			for(i=a;i+j<=b;i+=j)
				await insertion(A,i,i+j);
			await insertion(A,i,b);
			for(;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await inPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await inPlaceMerge(A,i,i+j,b);
			}
		}
		async function lazierBlockMergeSort(A,a,b,k){
			let a1=a+k,b1=b,l=b-a1,i,j;
			for(j=l;j>31;j=(j+1)/2|0);
			for(i=a1;i+j<=b;i+=j)
				await insertion(A,i,i+j);
			await insertion(A,i,b);
			if(k>=2*j){
				for(i=a1;i+2*j<=b;i+=2*j)
					await mergeTo(A,i,i+j,i+2*j,i-2*j);
				if(i+j<b)await mergeTo(A,i,i+j,b,i-2*j);
				else await shift(A,i-2*j,i,b);
				j*=2;a1-=j;b1-=j;
				while(a1-j>=a){
					for(i=a1;i+2*j<=b1;i+=2*j)
						await mergeTo(A,i,i+j,i+2*j,i-j);
					if(i+j<b1)await mergeTo(A,i,i+j,b1,i-j);
					else await shift(A,i-j,i,b1);
					a1-=j;b1-=j;j*=2;
				}
				for(i=a1;i+2*j<=b1;i+=2*j);
				if(i+j<b1)await mergeToBW(A,i,i+j,b1,b);
				else await shiftBW(A,i,b1,b);
				for(;i>a1;i-=2*j)await mergeToBW(A,i-2*j,i-j,i,i+j);
				a1+=j;j*=2;
			}
			let c=1;
			for(;j<l;j*=2){
				while((c*c*c/2/j|0)<2*j)c++;
				for(i=a1;i+2*j<=b;i+=2*j)
					await lazierBlockMerge(A,i,i+j,i+2*j,c);
				if(i+j<b)
					await lazierBlockMerge(A,i,i+j,b,c);
			}
			await hs.sort(A,a,a1,1);
			await inPlaceMerge(A,a,a1,b);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			}
			if(p<i)while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		async function mergeToBW(A,a,m,b,p){
			let i=m-1,j=b-1;p--;
			while(i>=a&&j>=m){
				if(compareIndices(A,i,j)>0)
					await swap(A,p--,i--,1,true);
				else await swap(A,p--,j--,1,true);
			}
			if(p>j)while(j>=m)await swap(A,p--,j--,1,true);
			while(i>=a)await swap(A,p--,i--,1,true);
		}
		async function mergeFW(A,a,p,m,b){
			let i=a,j=m,k=p;
			while(j<b){
				while(i<p&&compareIndices(A,i,j)<1)
					await swap(A,k++,i++,1,true);
				if(i==p)return;
				let n=leftExpSearch(A,j+1,b,A[i]);
				while(j<n)await swap(A,k++,j++,1,true);
			}
			while(i<p)await swap(A,k++,i++,1,true);
		}
		async function sort(A,a,b){
			let l=b-a;
			if(l<65)return await insertion(A,a,b);
			let bL,mR;
			for(bL=1;(bL*bL*bL/l|0)<l;bL*=2);
			for(mR=1;(mR*mR*mR/l|0)<l;mR++);
			mR=(16*mR)/bL|0;
			bL=(bL*mR)/16|0;
			let k=await findKeys(A,a,b,bL);
			if(k<bL){
				if(k==1)return;
				else if(k<=cbrt(l)|0)await inPlaceMergeSort(A,a,b);
				else await lazierBlockMergeSort(A,a,b,k);
				return;
			}
			let a1=a+bL,b1=b,i,j=mR;
			for(i=a1;i+j<=b;i+=j)
				await insertion(A,i,i+j);
			await insertion(A,i,b);
			for(i=a1;i+2*j<=b;i+=2*j)
				await mergeTo(A,i,i+j,i+2*j,i-2*j);
			if(i+j<b)await mergeTo(A,i,i+j,b,i-2*j);
			else await shift(A,i-2*j,i,b);
			j*=2;a1-=j;b1-=j;
			while(a1>a){
				for(i=a1;i+2*j<=b1;i+=2*j)
					await mergeTo(A,i,i+j,i+2*j,i-j);
				if(i+j<b1)await mergeTo(A,i,i+j,b1,i-j);
				else await shift(A,i-j,i,b1);
				a1-=j;b1-=j;j*=2;
			}
			for(i=a;i+bL<b1;i+=bL);
			await shiftBW(A,i,b1,b);
			b1=i+bL;i-=bL;
			while(i>=a){
				await mergeFW(A,i,i+bL,b1,b);
				i-=bL;b1-=bL;
			}
			a1=a+bL;
			await hs.sort(A,a,a1,1);
			await inPlaceMerge(A,a,a1,b);
		}
		await sort(arr,0,len);
	}
	async blockSelectionMergeSort(len){
		async function swapBlocks(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s,m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;am-=z;m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d,m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;d+=m;s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function lzmerge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function blockSelection(A,s,e,bZ){
			for(let i=s;i<e-bZ;i+=bZ){
				let l=i;
				for(let j=i+bZ;j<e;j+=bZ)
					if(compareIndices(A,j,l)<0)
						l=j;
				if(l>i)
					await swapBlocks(A,i,l,bZ);
			}
		}
		async function merge(A,s,e){
			let bZ=(e-s)/16|0;
			while(bZ>=4){
				await blockSelection(A,s,e,bZ);
				bZ=bZ/8|0;
			}
			await binaryInsertion(A,s,e,1/3);
		}
		async function mergeRun(A,s,m,e,z){
			if(s==m)return;
			if(e-s==z)return await binaryInsertion(A,s,e,1/3);
			await mergeRun(A,s,(m+s)/2|0,m,z);
			await mergeRun(A,m,(m+e)/2|0,e,z);
			await merge(A,s,e);
		}
		async function sort(A,l){
			let z=(log(l)/log(2)|0)/3+2|0;
			z=2**z;
			if(l<=z)return await binaryInsertion(A,0,l,1/3);
			let uL=pow(2,log(l)/log(2)|0);
			let s=l-uL;
			let e=l;
			let m=s+((e-s)/2);
			await mergeRun(A,s,m,e,z);
			if(l>uL){
				await sort(A,l-uL);
				await lzmerge(A,0,l-uL,e);
			}
		}
		await sort(arr,len);
	}
	async bufferedMergeSort(len){
		function log2(v){
			return log(v)/log(2);
		}
		function getBufferSize(l){
			return pow(2,ceil(log2(log2(l)|0)))*2;
		}
		async function swapBlocks(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function merge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function blockSelection(A,s,e,bZ){
			for(let i=s;i<e-bZ;i+=bZ){
				let l=i;
				for(let j=i+bZ;j<e;j+=bZ)
					if(compareIndices(A,j,l)<0)
						l=j;
				if(l>i)
					await swapBlocks(A,i,l,bZ);
			}
		}
		async function mergeUnderBuffer(A,bZ,s,m,e){
			let bP=0,l=s,r=m;
			while(l<m&&r<e){
				if(compareIndices(A,l,r)<1)
					await swap(A,bP,l++,.25,true);
				else
					await swap(A,bP,r++,.25,true);
				bP++;
			}
			while(l<m)
				await swap(A,bP++,l++,.25,true);
			while(r<e)
				await swap(A,bP++,r++,.25,true);
			for(let i=0;i<e-s;i++)
				await swap(A,i,s+i,.5,true);
		}
		async function mergeOverBuffer(A,bZ,s,m,e){
			let blZ=bZ/2|0;
			await blockSelection(A,s,e,blZ);
			let cS=s;
			while(cS<e-blZ){
				if(compareIndices(A,cS+blZ-1,cS+blZ)>0)
					await mergeUnderBuffer(A,bZ,cS,cS+blZ,cS+bZ);
				cS+=blZ;
			}
		}
		async function sort(A,l){
			let bZ=getBufferSize(len);
			let ln=l-(l-bZ)%(bZ/2|0);
			if(bZ*2>=ln)return await binaryInsertion(A,0,l,1/3);
			for(let i=bZ;i<ln-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,.5,true);
			for(let g=4;g<=bZ;g*=2)
				for(let i=bZ;i+g<=ln;i+=g)
					await mergeUnderBuffer(A,bZ,i,i+g/2|0,i+g);
			for(let g=bZ*2;(g/2|0)<=ln;g*=2){
				let i;
				for(i=bZ;i+g<=ln;i+=g)
					await mergeOverBuffer(A,bZ,i,i+g/2|0,i+g);
				if(i+g>ln)
					await mergeOverBuffer(A,bZ,i,i+g/2|0,ln);
			}
			await sort(A,bZ);
			await merge(A,0,bZ,ln);
			if(l-ln>0){
				await binaryInsertion(A,ln,l,1/3);
				await merge(A,0,ln,l);
			}
		}
		await sort(arr,len);
	}
	async improvedWeaveMergeSort(len){
		function getMaxBit(n){
			let i=0;
			for(;(1<<i)<=n;i++);
			return i-1;
		}
		async function weaveMerge(A,a,b){
			let n=b-a,m=(n+1)/2;
			for(let j=1<<(getMaxBit(n-1)-1);j>0;j>>=1){
				let s=m>j?1:0;
				for(let i=a+m+(1-s)*(j<<1);i+j<=b;i+=j<<2)
					for(let k=0;k<j;k++)
						await swap(A,i-j+k,i+k,1,true);
				m-=s*j;
			}
			await insertSort(A,a,b,.2);
		}
		async function weaveMergeSort(A,a,b){
			if(b-a>2){
				let m=a+(b-a+1)/2|0;
				await weaveMergeSort(A,a,m);
				if(b-a>3)
					await weaveMergeSort(A,m,b);
			}
			await weaveMerge(A,a,b);
		}
		await weaveMergeSort(arr,0,len);
	}
	async medianOfSixteenAdaptiveQuickSort(len){
		const hs=new HeapSorting(true);
		let medianOfSixteenSwaps=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16,1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16,1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
		let incs=[48,21,7,3,1];
		function log2(n){
			return log(n)/log(2)|0;
		}
		async function shellSort(A,lo,hi){
			for(let k=0;k<5;k++){
				for(let h=incs[k],i=h+lo;i<hi;i++){
					let v=A[i],j=i;
					while(j>=h+lo&&compareValues(A[j-h],v)>0)
						await write(A,j,A[j-=h],1,true);
					await write(A,j,v,.5,true);
				}
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<b&&compareIndices(A,i,p)<0);
				do j--;while(j>=a&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function compNSwap(A,a,b,g,s){
			if(compareIndices(A,s+a*g,s+b*g)>0)
				await swap(A,s+a*g,s+b*g,1,true);
		}
		async function medianOfSixteen(A,a,b){
			let g=(b-1-a)/16|0;
			for(let i=0;i<medianOfSixteenSwaps.length;i+=2)
			await compNSwap(A,medianOfSixteenSwaps[i],medianOfSixteenSwaps[i+1],g,a);
			await swap(A,a,a+8*g,1,true);
		}
		async function getSortedRuns(A,a,b){
			let rS=true,as=true,c;
			for(let i=a;i<b-1;i++){
				c=compareIndices(A,i,i+1,.5,true);
				if(c>0)as=false;
				else rS=false;
				if(!rS&&!as)return false;
			}
			if(rS&&!as)
				await reversal(A,a,b-1,1,as=true);
			return as;
		}
		async function quickSort(A,a,b,d,u){
			while(b-a>32){
				if(await getSortedRuns(A,a,b))return;
				if(!d)return await hs.sort(A,a,b);
				let p;
				if(!u){
					await medianOfThree(A,a,b);
					p=await partition(A,a,b,a);
				}else p=a;
				let l=p-a;
				let r=b-p-1;
				if((!l||!r)||((l/r|0)>15||(r/l|0)>15)||u){
					if(b-a>80){
						await swap(A,a,p,1,true);
						if(l<r)await quickSort(A,a,a=p,d-1,true);
						else{
							await quickSort(A,p+1,b,d-1,true);
							b=p;
						}
						await medianOfSixteen(A,a,b);
						p=await partition(A,a+1,b,a);
					}else return await shellSort(A,a,b);
				}
				await swap(A,a,p,1,true);
				await quickSort(A,p+1,b,--d,false);
				b=p;
			}
			await insertSort(A,a,b);
		}
		await quickSort(arr,0,len,2*log2(len),false);
	}
	async swapMergeSort(len){
		async function moveDown(A,s,d){
			for(let i=d;i<s;i++)
				await swap(A,i,s,1,true);
		}
		async function merge(A,lS,rS,e){
			let l=lS,r=rS;
			while(l<r){
				if(l>=e||r>=e)break;
				else if(compareIndices(A,l,r)<1)l+=1;
				else await moveDown(A,r++,l++);
			}
		}
		async function mergeRun(A,s,m,e){
			if(s==m)return;
			await mergeRun(A,s,(m+s)/2|0,m);
			await mergeRun(A,m,(m+e)/2|0,e);
			if(e-s<32)return;
			else if(e-s==32)await binaryInsertion(A,s,minVal(A.length,e+1),1/3);
			else await merge(A,s,m,e);
		}
		async function sort(A,l){
			if(l<32)return await binaryInsertion(A,0,l,1/3);
			let m=l/2|0;
			await mergeRun(A,0,m,l);
		}
		await sort(arr,len);
	}
	async bubblescanQuickSort(len){
		const hs=new HeapSorting(true);
		async function partition(A,a,b,v){
			let i=a,j=b-1;
			while(i<=j){
				while(compareValues(A[i],v)<0)i++;
				while(compareValues(A[j],v)>0)j--;
				if(i<=j)await swap(A,i++,j--,1,true);
			}
			return i;
		}
		async function sort(A,a,b,d){
			let e=b,l=b-a;
			while(l>16){
				if(!d)return await hs.sort(A,a,e);
				let sum=0,sw=false;
				for(let i=a+1;i<e;i++){
					if(compareValues(A[i-1],A[i])>0)
						await swap(A,i-1,i,.5,sw=true);
					sum+=A[i-1];
				}
				if(!sw)return;
				let p=await partition(A,a,e-1,sum/(l-1)|0);
				await sort(A,p,e-1,--d);
				e=p;l=e-a;
			}
			await insertSort(A,a,e,.5);
		}
		await sort(arr,0,len,2*(log(len)/log(2)|0));
	}
	async stableQuarterMergeSort(len){
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function binarySearchMid(A,s,md,e){
			let a=0,b=minVal(md-s,e-md),m=a+(b-a)/2|0;
			while(b>a){
				if(compareIndices(A,md-m-1,md+m)>0)a=m+1;
				else b=m;
				m=a+(b-a)/2|0;
			}
			return m;
		}
		async function multiSwapMerge(A,s,md,e){
			let m=binarySearchMid(A,s,md,e);
			while(m>0){
				await multiSwap(A,md-m,md,m);
				await multiSwapMerge(A,md,md+m,e);
				e=md;
				md-=m;
				m=binarySearchMid(A,s,md,e);
			}
		}
		async function multiSwapMergeSort(A,a,b){
			let len=b-a,i;
			for(let j=1;j<len;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await multiSwapMerge(A,i,i+j,i+2*j);
				if(i+j<b)
					await multiSwapMerge(A,i,i+j,b);
			}
		}
		async function merge(A,bL,s,m,e){
			await multiSwap(A,0,s,m-s);
			let bP=0;
			let l=s,r=m;
			while(l<r&&r<e)
				if(compareIndices(A,bP,r)<1)
					await swap(A,bP++,l++,.5,true);
				else
					await swap(A,l++,r++,.5,true);
			while(l<r)
				await swap(A,bP++,l++,.5,true);
		}
		function pow2lte(n){
			let v;
			for(v=1;v<=n;v<<=1);
			return v>>1;
		}
		async function quarterMergeSort(A,l){
			if(l<33)return await binaryInsertion(A,0,l,1/3);
			let qL=l/4|0;
			let uL=qL*4;
			for(let i=qL;i<uL-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,.5,true);
			let sS,sE=uL,sL=uL-qL,g;
			for(let pr=sL;pr>1;pr=sE-qL){
				sL=pow2lte(pr);
				sS=sE-sL;
				for(g=4;g<=sL;g*=2)
					for(let i=sS;i+g<=sE;i+=g)
						await merge(A,qL,i,i+g/2|0,i+g);
				if(pr-uL+qL)
					await merge(A,qL,sS,sE,uL);
				sE=sS;
			}
			let ex=l-uL;
			if(ex>0){
				if(ex>1&&compareIndices(A,l-2,l-1)>0)
					await swap(A,l-2,l-1,.5,true);
				await multiSwapMerge(A,qL,uL,l);
			}
			await quarterMergeSort(A,qL);
			await multiSwapMerge(A,0,qL,l);
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;
					am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		async function rotateCommon(A,s,d,z){
			if(s>d)await rotateSmart(A,s,d,z);
			else await rotateSmart(A,s+z,s,d-s-z);
		}
		async function ejectDuplicates(A,s,m,e){
			let mb=s,ci=s+1,lG=ci,bC=0,c;
			for(c=1;c<m-s;c++){
				let n=A[ci],l=mb,h=lG,lB=bC;
				while(l<h){
					let m=l+(h-l)/2|0;
					let cm=compareValues(n,A[m]);
					if(cm<0)h=m;
					else if(!cm){
						bC++;
						break;
					}else l=m+1;
				}
				if(bC>0){
					if(bC>lB){
						c--;
						if(++ci>=e)break;
						continue;
					}
					await rotateCommon(A,lG,mb,bC);
					mb+=bC;
					lG=ci;
					l+=bC;
					bC=0;
				}
				let j=ci-1;
				while(j>=l)
					await write(A,j+1,A[j--],.1,true);
				await write(A,l,n,.1,true);
				ci++;
				lG++;
				if(ci>=e)break;
			}
			if(mb-s)await rotateSmart(A,mb,s,c);
			return c;
		}
		let req=len/4|0;
		if(await ejectDuplicates(arr,0,req,len)<req)
			await multiSwapMergeSort(arr,0,len);
		else
			await quarterMergeSort(arr,len);
	}
	async stupidQuickSort(len){
		let t=sqrt(len)|0;
		for(let c=0;c<t;c++){
			let i=0,j=len-1;
			let pvp=random()*len|0,pv=arr[pvp];
			while(i<j){
				while(compareValues(arr[i],pv)<0)i++;
				while(compareValues(arr[j],pv)>0)j--;
				if(i<j)
					await swap(arr,i++,j--,1,true);
			}
		}
		await insertSort(arr,0,len,.4);
	}
	async shellHighSort(len){
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		let tr=1,ti=2,g=len,t=false;
		while(g-1){
			tr=g;
			while(tr-1){
				t=false;ti=2;
				while(!t){
					if((tr/ti|0)==tr/ti){
						tr=tr/ti;
						t=true;
					}else ti++;
				}
			}
			g=g/ti|0;
			await shellPass(arr,len,g);
		}
	}
	async shellLowSort(len){
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		let tr=1,ti=2,g=len,t=false;
		while(g-1){
			tr=g;
			while(tr==g){
				t=false;ti=2;
				while(!t){
					if((tr/ti|0)==tr/ti){
						tr=tr/ti;
						t=true;
					}else ti++;
				}
			}
			g=g/ti|0;
			await shellPass(arr,len,g);
		}
	}
	async cocktailShellSort(len){
		let g=len/2|0,d=true;
		while(g>0){
			if(d){
				for(let i=g;i<len;i++){
					let t=arr[i],j=i;
					while(j>=g&&compareValues(arr[j-g],t)>0)
						await write(arr,j,arr[j-=g],.7,true);
					await write(arr,j,t,.7,true);
				}
			}else{
				for(let i=len-g;i>=0;i--){
					let t=arr[i],j=i;
					while(j<len-g&&compareValues(arr[j+g],t)<0)
						await write(arr,j,arr[j+=g],.7,true);
					await write(arr,j,t,.7,true);
				}
			}
			g=g/2|0;
			d=!d;
		}
	}
	async simpleHybridQuickSort(len){
		const hs=new HeapSorting(true);
		function medianOfThree(A,a,m,b){
			if(compareIndices(A,m,a)>0){
				if(compareIndices(A,m,b)<0)return m;
				if(compareIndices(A,a,b)>0)return a;
				else return b;
			}else{
				if(compareIndices(A,m,b)>0)return m;
				if(compareIndices(A,a,b)<0)return a;
				else return b;
			}
		}
		function ninther(A,a,b){
			let s=(b-a)/9|0;
			return medianOfThree(A,medianOfThree(A,a,a+s,a+2*s),medianOfThree(A,a+3*s,a+4*s,a+5*s),medianOfThree(A,a+6*s,a+7*s,a+8*s));
		}
		function medianOfThreeNinthers(A,a,b){
			let s=(b-a+2)/3|0;
			return medianOfThree(A,ninther(A,a,a+s),ninther(A,a+s,a+2*s),ninther(A,a+2*s,b));
		}
		async function partition(A,a,b,v){
			let i=a,j=b;
			while(i<=j){
				while(compareValues(A[i],v)<0)i++;
				while(compareValues(A[j],v)>0)j--;
				if(i<=j)await swap(A,i++,j--,1,true);
			}
			return i;
		}
		async function sort(A,a,b,d){
			while(b-a>16){
				if(!d)return await hs.sort(A,a,b,1.0);
				let pv=medianOfThreeNinthers(A,a,b-1);
				let p=await partition(A,a,b-1,A[pv]);
				await sort(A,p,b,--d);
				b=p;
			}
			await insertSort(A,a,b,.5);
		}
		await sort(arr,0,len,2*(log(len)/log(2)|0));
	}
	async adaptiveLogMedianQuickSort(len){
		const hs=new HeapSorting(true);
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function logMedian(A,a,b){
			let n=b-a,c=maxVal(floorLog(n),5);
			c-=1-c%2;
			let p=a,s=n/c|0;
			let r=random()*s|0;
			for(let i=a+r;c>0;c--,p++,i+=s)
				await swap(A,i,p,.5,true);
			await insertSort(A,a,p,.25);
			await swap(A,a,a+(p-a)/2,.5,true);
		}
		async function partition(A,a,b){
			let pv=A[a];
			let f=a,l=b;
			while(compareValues(A[++f],pv)<0);
			if(f-1==a)
				while(f<l&&compareValues(A[--l],pv)>0);
			else
				while(compareValues(A[--l],pv)>0);
			let aP=f>=l;
			while(f<l){
				await swap(A,f,l,1,true);
				while(compareValues(A[++f],pv)<0);
				while(compareValues(A[--l],pv)>0);
			}
			let pvp=f-1;
			await write(A,a,A[pvp],1,true);
			await write(A,pvp,pv,1,true);
			return[pvp,aP];
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,bA,lM){
			while(b-a>24){
				if(!lM)await medianOfThree(A,a,b);
				let lML=false,lMR=false;
				let[p,aP]=await partition(A,a,b);
				let l=p-a,r=b-p-1;
				if(l<((b-a)/16|0)||r<((b-a)/16|0)){
					if(!--bA)return await hs.sort(A,a,b);
					if(l>24){
						await logMedian(A,a,p);
						lML=true;
					}
					if(r>24){
						await logMedian(A,p+1,b);
						lMR=true;
					}
				}else if(aP&&await partialInsert(A,a,p)&&await partialInsert(A,p+1,b))return;
				if(l>r){
					await quickSort(A,p+1,b,bA,lMR);
					b=p;
					lM=lML;
				}else{
					await quickSort(A,a,p,bA,lML);
					a=p+1;
					lM=lMR;
				}
			}
			await insertSort(A,a,b,.25);
		}
		await quickSort(arr,0,len,floorLog(len));
	}
	async PDLaziestSort(len){
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b){
				let c=A[i],p=i-1;
				while(p>=a&&compareValues(A[p],c)>0)
					await write(A,p+1,A[p--],1,true);
				await write(A,p+1,c,1,true);
				i++;
			}
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,1.0,true,false);
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function laziestStableSort(A,s,e){
			let l=e-s;
			if(l<17)return await insertion(A,s,e);
			let i,bL=maxVal(16,sqrt(len)|0);
			for(i=s;i+2*bL<e;i+=bL)
				await insertion(A,i,i+bL);
			await insertion(A,i,e);
			while(i-bL>=s){
				await inPlaceMerge(A,i-bL,i,e);
				i-=bL;
			}
		}
		await laziestStableSort(arr,0,len);
	}
	async LAQuickSort(len){
		const hs=new HeapSorting(true);
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<b&&compareIndices(A,i,p)<0);
				do j--;while(j>=a&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function ghostPartition(A,a,b,v){
			let i=a,j=b-1;
			while(i<=j){
				while(compareValues(A[i],v)<0)i++;
				while(compareValues(A[j],v)>0)j--;
				if(i<=j){
					await swap(A,i++,j--,1,true);
				}
			}
			return i;
		}
		function log2(n){
			return log(n)/log(2)|0;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		function logarithmicAverage(A,l,h){
			let s=0,c=0,q=log2(h-l);
			if(2>q)q=2;
			for(let i=l;i<h;i+=(h-l)/q|0){
				s+=A[i];
				c++;
			}
			return s/c|0;
		}
		async function getSortedRuns(A,a,b){
			let rS=true,s=true,c;
			for(let i=a;i<b-1;i++){
				c=compareIndices(A,i,i+1);
				if(c>0)s=false;
				else rS=false;
				if(!rS&&!s)return false;
			}
			if(rS&&!s)await reversal(A,a,b-1,1,s=true);
			return s;
		}
		async function quickSort(A,l,h,d,bP,lA,qP){
			if(await getSortedRuns(A,l,h))return;
			if(h-l>16){
				let pi=l,pv=l;
				if(!lA){
					await medianOfThree(A,l,h);
					pi=await partition(A,l,h,l);
					let a=pi-l;
					let b=h-(pi+1);
					if((!a||!b)||((a/b|0)>15||(b/a|0)>15))lA=true;
					else{
						await swap(A,l,pi,1,true);
						pv=A[pi];
					}
				}
				if(lA){
					pv=logarithmicAverage(A,l,h);
					pi=await ghostPartition(A,l,h,pv);
				}
				if(bP==pv)qP++;
				if(d==0||qP>4){
					if(qP>4)qP=0;
					await hs.sort(A,l,h);
					return;
				}
				d--;
				await quickSort(A,l,pi,d,pv,lA,qP);
				await quickSort(A,pi+(lA?0:1),h,d,pv,lA,qP);
			}else await insertSort(A,l,h);
		}
		await quickSort(arr,0,len,2*log2(len),arr[1],false,0);
	}
	async adaptiveBinaryInsertionSort(len){
		async function abinaryinsert(A,s,e){
			let c=0,k=0;
			for(let i=s+1;i<e;i++){
				let n=A[i];
				let v=2*c/(i-s)+1|0;
				let lo=maxVal(i-v,s),hi=i;
				while(lo>=s&&compareValues(A[lo],n)>0){
					lo-=v;
					hi-=v;
				}
				if(++lo<s)lo=s;
				while(lo<hi){
					let m=lo+(hi-lo)/2|0;
					if(compareValues(n,A[m])<0)hi=m;
					else lo=m+1;
				}
				c+=i-lo;
				let j=i-1;
				if(j>=lo){
					while(j>=lo){
						write(A,j+1,A[j--],0);
						if(++k>=len)await mark(j+2,k=0);
					}
					await write(A,lo,n,1,true,false);
				}
			}
		}
		await abinaryinsert(arr,0,len);
	}
	async ciuraCocktailShellSort(len){
		let gs=[1,4,10,23,57,132,301,701];
		function ciura(n){
			if(n<=gs.length)return gs[n-1];
			return pow(2.25,n)|0;
		}
		async function sort(A,l){
			let g=1,k;
			for(k=1;g<l;k++)g=ciura(k);
			let d=true;
			while(--k>0){
				g=ciura(k);
				if(d){
					for(let i=g;i<l;i++){
						let t=A[i],j=i;
						while(j>=g&&compareValues(A[j-g],t)>0)
							await write(A,j,A[j-=g],.7,true);
						await write(A,j,t,.7,true);
					}
				}else{
					for(let i=l-g;i>=0;i--){
						let t=A[i],j=i;
						while(j<l-g&&compareValues(A[j+g],t)<0)
							await write(A,j,A[j+=g],.7,true);
						await write(A,j,t,.7,true,false);
					}
				}
				d=!d;
			}
		}
		await sort(arr,len);
	}
	async PCBoysParShellSort(len){
		let base=askForNum(10,"Division constant",1);
		function threshold(x){
			return sqrt(x);
		}
		async function par(A,l){
			let x=new Array(l).fill(!1);
			let mx=A[0];
			for(let i=1;i<l;i++){
				if(A[i]>mx){
					mx=A[i];
					x[i]=true;
				}
			}
			let i=l-1,p=1,j=l-1;
			while(j>=0&&i>=p){
				while(!x[j]&&j>0)j--;
				mx=A[j];
				while(mx<=A[i]&&i>=p)i--;
				if(A[j]>A[i]&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		async function shellPass(A,l,g){
			if(g>=lg)return;
			if(g==lg-1&&g-1)return;
			lg=g;
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)
					await write(A,j,v,.25,true);
			}
		}
		let td=base;
		let lp=len;
		let lg=len;
		while(1){
			let p=await par(arr,len);
			let psp=p;
			if(p>=lp)p=lp-td|0;
			if((p/td|0)<2){
				await shellPass(arr,len,1);
				break;
			}
			await shellPass(arr,len,(p/td|0)+p%td);
			if(lp-par<=threshold(lp))td*=1.5;
			lp=p;
		}
	}
	async anarchySort(len){
		function containsValue(l,v){
			for(let a=0;a<l.length;a++)
				if(l[a]==v)return true;
			return false;
		}
		async function swapper(A,B,a,b){
			swap(B,a,b,0,false,true);
			await swap(A,a,b,1,true);
		}
		async function convert(A,aux,l){
			let i=0,j=0;
			while(i<l){
				if(compareIndices(A,j,i)<0)
					j=i;
				i++;
			}
			await swap(A,0,j,1,true,true);
			for(let init=0;init<l;init++)
				write(aux,init,A[init],0,false,true);
			let t2=[];
			let m=0;
			while(m<l){
				i=j=0;
				while(i<l){
					if(compareIndices(A,i,j)<1&&!containsValue(t2,i))
						j=i;
					i++;
				}
				t2.push(j);
				await write(A,j,m++,1,true);
			}
		}
		async function sort(A,t,l){
			for(let i=0;i<l;i++)
				while(A[i]-i)
					await swapper(A,t,i,A[i]);
		}
		let aux=new Array(len);
		await convert(arr,aux,len);
		await sort(arr,aux,len);
		for(let i=0;i<len;i++)
			await write(arr,i,aux[i],1,true);
	}
	async adaptiveInsertionSort(len){
		async function findRun(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.5,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function moveFront(A,a,m,b){
			let mi=m,mv=A[m];
			for(let i=m+1;i<b;i++)
				if(compareIndexValue(A,i,mv)<0)
					mv=A[mi=i];
			m--;
			while(mi>m)
				await write(A,mi,A[--mi],1,true);
			--a;
			while(mi>a&&compareValues(A[mi],mv)>0)
				await write(A,mi+1,A[mi--],1,true);
			await write(A,mi+1,mv,1,true);
		}
		async function insertion(A,a,b){
			let i=await findRun(A,a,b),j=0;
			if(i<b){
				await moveFront(A,a,i++,b);
				while(i<b){
					let c=A[i],p=i-1;
					while(compareValues(A[p],c)>0){
						write(A,p+1,A[p--],0);
						if(++j>=len)await mark(p+2,j=0);
					}
					await write(A,p+1,c,1,true);
					i++;
				}
			}
		}
		await insertion(arr,0,len);
	}
	async bidirectionalInsertionSort(len){
		let j=0;
		async function insertFw(A,i,c){
			let p=i-1;
			while(compareValues(A[p],c)>0){
				write(A,p+1,A[p--],0);
				if(++j>=len)await mark(p+2,j=0);
			}
			await write(A,p+1,c,1,true);
		}
		async function insertBw(A,i,c){
			let p=i-1;
			while(compareValues(A[p],c)<1){
				write(A,p+1,A[p--],0);
				if(++j>=len)await mark(p+2,j=0);
			}
			await write(A,p+1,c,1,true);
		}
		async function insertion(A,a,b){
			let d=true;
			for(let i=a+1;i<b;i++){
				let c=A[i];
				if(d){
					if(compareValues(c,A[a])<0){
						await reversal(A,a,i-1,1,true);
						d=!d;
					}else
						await insertFw(A,i,c);
				}else{
					if(compareValues(c,A[a])+1){
						await reversal(A,a,i-1,1,true);
						d=!d;
					}else
						await insertBw(A,i,c);
				}
			}
			if(!d)await reversal(A,a,b-1,1,true);
		}
		await insertion(arr,0,len);
	}
	async exponentialInsertionSort(len){
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			let j=0;
			if(a>b){
				let t=A[a];
				do{
					write(A,a,A[--a],1);
					if(++j>=len)await sleep(j=0);
				}while(a>b);
				await write(A,b,t,1,true);
			}
		}
		for(let i=1;i<len;i++)
			await insertTo(arr,i,rightExpSearch(arr,0,i,arr[i]));
	}
	async roomSort(len){
		async function insertTo(A,a,b){
			let v=A[a--],j=0;
			while(a>=b&&compareValues(A[a],v)>0){
				write(A,a+1,A[a--],0);
				if(++j>=len)await sleep(j=0);
			}
			await write(A,a+1,v,1,true);
		}
		let rL=sqrt(len)+1|0;
		let e,i;
		for(e=len;e>rL;e-=rL){
			await insertSort(arr,0,rL);
			for(i=rL;i<e;i++)
				await insertTo(arr,i,i-rL);
		}
		await insertSort(arr,0,len);
	}
	async rendezvousSort(len){
		async function rendezvousSort(A,l){
			let ln=l,i,j,t,f,g;
			while(ln>0){
				i=0;j=ln;
				while(l>=j){
					t=i;f=0;
					while(!(i<1||!(compareIndices(A,j,i)<0))){
						await swap(A,i,j,1,true);
						f=1;g=1+j-i;i-=g;j-=g;
					}
					i++;j++;
					if(f==1){
						ln=ln/.25|0;
						i=0;
						j=ln;
					}
				}
				ln=ln/8|0;
			}
			i=0;j=1;
			while(l>=j){
				t=i;
				while(i>=0&&compareIndices(A,j,i)<0)
					await swap(A,i--,j--,1,true);
				i=t+1;
				j=t+2;
			}
		}
		await rendezvousSort(arr,len-1);
	}
	async gambitInsertionSort(len){
		function binSearch(A,b,e,t){
			while(1){
				let d=e-b;
				if(d<1)break;
				let p=b+d/2|0;
				if(!compareIndices(A,p,t))return p;
				if(compareIndices(A,p,t)>0){
					e=p;
					continue;
				}
				b=p+1;
			}
			return e;
		}
		async function binInsert(A,l,s,e){
			let o=1,k=0;
			for(;o*o<l;o*=2);
			for(let bS=0,bE=e,i=s+o;i<e;i++){
				let t=binSearch(A,bS,bE,i);
				let m=A[i],j=i-1;
				while(j>=t&&A[j]>m){
					write(A,j+1,A[j--],0);
					if(++k>=sqrt(len))await mark(j+2,k=0);
				}
				A[j+1]=m;
			}
		}
		await binInsert(arr,len,0,len);
		await insertSort(arr,0,len,.1);
	}
	async triSearchInsertionSort(len){
		function triSearch(A,l,h,v){
			let m=l+(h-l)/2|0;
			if(compareValues(v,A[l])<0)return l;
			else{
				if(compareValues(v,A[h])<0){
					if(compareValues(v,A[m])<0)return triSearch(A,l+1,m-1,v);
					else return triSearch(A,m+1,h-1,v);
				}else return h+1;
			}
		}
		async function triInsertSort(A,s,e){
			let k=0;
			for(let i=s+1;i<e;i++){
				let n=A[i];
				let lo=s;
				lo=triSearch(A,s,i-1,n);
				let j=i-1;
				while(j>=lo){
					write(A,j+1,A[j--],0,true);
					if(++k>=len)await mark(j+1,k=0);
				}
				await write(A,lo,n,1,true);
			}
		}
		await triInsertSort(arr,0,len);
	}
	async adaptiveMedianOfMediansQuickSort(len){
		const hs=new HeapSorting(true);
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,l=a,i,j,ad=true;
			while(e-l>1){
				j=l;
				for(i=l;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s,1/4);
					await swap(A,j++,i+s/2,1);
				}
				if(i<e){
					await insertSort(A,i,e,.25);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,1);
					if((e-i+1)%2)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b){
			let pv=A[a],f=a,l=b;
			while(compareValues(A[++f],pv)<0);
			if(f-1==a)while(f<l&&compareValues(A[--l],pv)>0);
			else while(compareValues(A[--l],pv)>0);
			let aP=f>=l;
			while(f<l){
				await swap(A,f,l,1,true);
				while(compareValues(A[++f],pv)<0);
				while(compareValues(A[--l],pv)>0);
			}
			let pvp=f-1;
			await write(A,a,A[pvp],1,true);
			await write(A,pvp,pv,1,true);
			return[pvp,aP];
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,bA,med){
			while(b-a>16){
				if(!med)await medianOfThree(A,a,b);
				let mL=false,mR=false;
				let[p,aP]=await partition(A,a,b);
				let l=p-a,r=b-p-1;
				if(l<((b-a)/16|0)||r<((b-a)/16|0)){
					if(!--bA)return await hs.sort(A,a,b,1);
					if(l>16){
						await medianOfMedians(A,a,p,5);
						mL=true;
					}
					if(r>16){
						await medianOfMedians(A,p+1,b,5);
						mR=true;
					}
				}else if(aP&&await partialInsert(A,a,p)&&await partialInsert(A,p+1,b))return;
				if(l>r){
					await quickSort(A,p+1,b,bA,mR);
					b=p;
					med=mL;
				}else{
					await quickSort(A,a,p,bA,mL);
					a=p+1;
					med=mR;
				}
			}
			await insertSort(A,a,b,.5);
		}
		await quickSort(arr,0,len,floorLog(len),false);
	}
	async blockInsertionSort(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return Rotations.holyGriesMills(A,p,a,b,.5,true);
		});
		async function insert1(A,a,l){
			let t=A[l--];
			while(l>=a&&compareValues(A[l],t)>0)
				await write(A,l+1,A[l--],1,true);
			await write(A,l+1,t,1,true);
		}
		async function insert2(A,a,l,r){
			let tL=A[l--],tR=A[r];
			while(l>=a&&compareValues(A[l],tR)>0)await write(A,l+2,A[l--],1,true);
			await write(A,l+2,tR,1,true);
			while(l>=a&&compareValues(A[l],tL)>0)await write(A,l+1,A[l--],1,true);
			await write(A,l+1,tL,1,true,false);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function insertion(A,a,b){
			let i=await findRun(A,a,b),j,l;
			while(i<b){
				j=await findRun(A,i,b);l=j-i;
				if(l<3){
					if(l>1)await insert2(A,a,i,i+1);
					else await insert1(A,a,i);
				}else await GS.grailMergeWithoutBuffer(A,a,i-a,l);
				i=j;
			}
		}
		await insertion(arr,0,len);
	}
	async adaptiveMedianMergeSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j;
			let ad=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s,.25);
					await swap(A,j++,i+s/2,0);
				}
				if(i<e){
					await insertSort(A,i,e,.25);
					await swap(A,j++,i+(e-(ad?1:0)-i)/2,0);
					if((e-i+1)%2)ad=!ad;
				}
				e=j;
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(true){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		function lBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1) b=m;
				else a=m+1;
			}
			return a;
		}
		function rBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function lBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+1)i*=2;
			return rBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return lBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function mergeWithBufRest(A,a,m,b,p,pL){
			let i=0,j=m,k=a;
			while(i<pL&&j<b){
				if(compareValues(A[p+i],A[j])<1)
					await swap(A,k++,p+(i++),1,true);
				else
					await swap(A,k++,j++,1,true);
			}
			while(i<pL)await swap(A,k++,p+(i++),1,true);
		}
		async function mergeWithBuf(A,a,m,b,p){
			let l=m-a;
			await multiSwap(A,p,a,l);
			await mergeWithBufRest(A,a,m,b,p,l);
		}
		async function mergeWithBufBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareValues(A[p+i],A[j])+1)
					await swap(A,k--,p+(i--),1,true);
				else
					await swap(A,k--,j--,1,true);
			}
			while(i>=0)await swap(A,k--,p+(i--),1,true);
		}
		async function smartMerge(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=lBoundSearch(A,a,m,A[m]);
			b=rBoundSearch(A,m,b,A[m-1]);
			if(b-m<m-a)await mergeWithBufBW(A,a,m,b,p);
			else await mergeWithBuf(A,a,m,b,p);
		}
		function getMinLevel(n){
			while(n>31)n=(n+1)/2|0;
			return n;
		}
		async function insertTo(A,a,b){
			if(a>b){
				let t=A[a];
				do await write(A,a,A[--a],.25,true);while(a>b);
				await write(A,b,t,.25,true);
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)await insertTo(A,i,rBinSearch(A,a,i,A[i]));
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)await insertTo(A,i,rBinSearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,j=getMinLevel(l);
			await buildRuns(A,a,b,j);
			while(j<l){
				for(i=a;i+2*j<=b;i+=2*j)
					await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b)
					await smartMerge(A,i,i+j,b,p);
				j*=2;
			}
		}
		async function medianMergeSort(A,a,b){
			let s=a,e=b;
			let bP=false,m=false;
			while(e-s>16){
				if(bP){
					await medianOfMedians(A,s,e,5);
					m=true;
				}else await medianOfThree(A,s,e);
				let p=await partition(A,s+1,e,s);
				await swap(A,s,p,1,true);
				let l=p-s,r=e-p-1;
				bP=!m&&((!l||!r)||((l/r|0)>15||(r/l|0)>15));
				if(l<=r){
					await mergeSort(A,s,p,p+1);
					s=p+1;
				}else{
					await mergeSort(A,p+1,e,s);
					e=p;
				}
			}
			await insertion(A,s,e);
		}
		await medianMergeSort(arr,0,len);
	}
	async twinSort(len){
		async function twinSwap(A,l,n){
			let i=0,s,e=n-2;
			while(i<=e){
				if(compareIndices(A,i+l,i+1+l)<1){
					i+=2;
					continue;
				}
				s=i;i+=2;
				while(1){
					if(i>e){
						if(!s){
							if(n%2<1||compareIndices(A,i-1+l,i+l)>0){
								counts.rev++;
								e=n-1;
								while(s<e)await swap(A,l+s++,l+e--,1,true);
								return 1;
							}
						}
						break;
					}
					if(compareIndices(A,i+l,i+1+l)>0){
						if(compareIndices(A,i-1+l,i+l)>0){
							i+=2;
							continue;
						}
						await swap(A,i+l,i+1+l,1,true);
					}
					break;
				}
				e=i-1;counts.rev++;
				while(s<e)
					await swap(A,l+s++,l+e--,1,true);
				e=n-2;
				i+=2;
			}
			return 0;
		}
		async function tailMerge(A,l,tmp,n,bl){
			let o,a,s=0,c,cx,d,dx,e;
			while(bl<n){
				for(o=0;o+bl<n;o+=bl*2){
					a=o;e=a+bl-1;
					if(compareIndices(A,e+l,e+1+l)<1)continue;
					if(o+bl*2<=n){
						cx=s+bl;
						dx=a+bl*2;
					}else{
						cx=s+n-o-bl;
						dx=n;
					}
					d=dx-1;
					while(compareIndices(A,e+l,d+l)<1){
						dx--;
						d--;
						cx--;
					}
					c=s;d=a+bl;
					while(c<cx)
						write(tmp,c++,A[l+d++],0,false,true);
					c--;d=a+bl-1;e=dx-1;
					if(compareIndices(A,a+l,a+bl+l)<1){
						await write(A,l+e--,A[l+d--],1,true);
						while(c>=s){
							while(compareValues(A[d+l],tmp[c])>0)
								await write(A,l+e--,A[l+d--],1,true);
							await write(A,l+e--,tmp[c--],1,true);
						}
					}else{
						await write(A,l+e--,A[l+d--],1,true);
						while(d>=a){
							while(compareValues(A[d+l],tmp[c])<1)
								await write(A,l+e--,tmp[c--],1,true);
							await write(A,l+e--,A[l+d--],1,true);
						}
						while(c>=s)
							await write(A,l+e--,tmp[c--],1,true);
					}
				}
				bl*=2;
			}
		}
		async function sort(A,n){
			if(!await twinSwap(A,0,n)){
				let tmp=[];
				await tailMerge(A,0,tmp,n,2);
			}
		}
		await sort(arr,len);
	}
	async PDExponentialInsertionSort(len){
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			if(a>b){
				let j=0,t=A[a];
				do{
					write(A,a,A[--a],1);
					if(++j>=len/2)await mark(a+1,j=0);
				}while(a>b);
				await write(A,b,t,1,true);
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i<b)
				await insertTo(A,i,rightExpSearch(A,a,i,A[i++]));
		}
		await insertion(arr,0,len);
	}
	async fibonacciInsertionSort(len){
		function fibonacciSearch(A,s,e,m){
			let fibM2=0,fibM1=1,fibM=1;
			while(fibM<=e-s){
				fibM2=fibM1;
				fibM1=fibM;
				fibM=fibM2+fibM1;
			}
			let o=s-1;
			while(fibM>1){
				let i=minVal(o+fibM2,e);
				if(compareValues(A[i],m)<1){
					fibM=fibM1;
					fibM1=fibM2;
					fibM2=fibM-fibM1;
					o=i;
				}else{
					fibM=fibM2;
					fibM1-=fibM2;
					fibM2=fibM-fibM1;
				}
			}
			let p=++o;
			if(compareValues(A[p],m)<1)p++;
			return p;
		}
		async function fibonacciInsertionSort(A,l){
			for(let i=1,k=0;i<l;i++){
				let t=A[i];
				let p=fibonacciSearch(A,0,i-1,t);
				let j=i-1;
				while(j>=p){
					write(A,j+1,A[j--],0);
					if(++k>=len)await mark(j+2,k=0);
				}
				await write(A,j+1,t,1,true);
			}
		}
		await fibonacciInsertionSort(arr,len);
	}
	async PDBinaryInsertionSort(len){
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,1,true);
			else await reversal(A,s,e,1,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,1,true);
					else await reversal(A,l,r,1,true);
				}
				i++;
			}
		}
		async function pd(A,s,e){
			let f=s;
			let c=compareIndices(A,f,f+1);
			let u=false;
			while(c<1&&f+1<e){
				if(!c)u=true;
				if(++f+1<e)c=compareIndices(A,f,f+1);
			}
			let r=s;
			if(f==s){
				let d=false;
				c=compareIndices(A,r,r+1);
				while(c+1&&r+1<e){
					if(!c)u=true;
					else d=true;
					if(++r+1<e)c=compareIndices(A,r,r+1);
				}
				if(r>s&&d){
					if(u)await stableSegmentReversal(A,s,r);
					else if(r<s+3)await swap(A,s,r,1,true);
					else await reversal(A,s,r,1,true);
				}
			}
			return maxVal(f,r);
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function pdbinsert(A,s,e){
			let p=await pd(A,s,e),j=0;
			for(let i=p+1;i<e;i++){
				let t=A[i];
				let l=binarySearch(A,s,i,t);
				let w=false;
				for(let r=i;r>l;r--){
					write(A,r,A[r-1],0);
					w=true;
					if(++j>=len)await mark(r,j=0);
				}
				if(w)await write(A,l,t,1,true);
			}
		}
		await pdbinsert(arr,0,len);
	}
	async stacklessTimSort(len){
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		function leftBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>=0)i*=2;
			return rightBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return leftBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			if(a>b){
				let t=A[a];
				do await write(A,a,A[--a],.25,true);while(a>b);
				await write(A,b,t,.25,true);
			}
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)
					await insertTo(A,i,rightBinSearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function mergeFW(A,tmp,a,m,b){
			let l1=m-a,t=a;
			arraycopy(A,a,tmp,0,l1,0,false,true);
			let i=0,mG=7,l=0,r=0;
			while(1){
				do{
					if(compareValues(tmp[i],A[m])<1){
						await write(A,a++,tmp[i++],1,true);
						l++;
						r=0;
						if(i==l1)return;
					}else{
						await write(A,a++,A[m++],1,true);
						r++;
						l=0;
						if(m==b){
							while(i<l1)await write(A,a++,tmp[i++],1,true);
							return;
						}
					}
				}while((l|r)<mG);
				do{
					l=leftExpSearch(A,m,b,tmp[i])-m;
					for(let j=0;j<l;j++)
						await write(A,a++,A[m++],1,true);
					await write(A,a++,tmp[i++],1,true);
					if(i==l1)return;
					else if(m==b){
						while(i<l1)await write(A,a++,tmp[i++],1,true);
						return;
					}
					r=leftBoundSearch(tmp,i,l1,A[m])-i;
					for(let j=0;j<r;j++)
						await write(A,a++,tmp[i++],1,true);
					await write(A,a++,A[m++],1,true);
					if(i==l1)return;
					else if(m==b){
						while(i<l1)await write(A,a++,tmp[i++],1,true);
						return;
					}
					mG--;
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function mergeBW(A,tmp,a,m,b){
			let l2=b-m,t=a;
			arraycopy(A,m--,tmp,0,l2,0,false,true);
			let i=l2-1,mG=7,l=0,r=0;
			while(1){
				do{
					if(compareValues(tmp[i],A[m])+1){
						await write(A,--b,tmp[i--],1,true);
						l++;
						r=0;
						if(i<0)return;
					}else{
						await write(A,--b,A[m--],1,true);
						r++;
						l=0;
						if(m<a){
							while(i>=0)await write(A,--b,tmp[i--],1,true);
							return;
						}
					}
				}while((l|r)<mG);
				do{
					l=(m+1)-rightExpSearch(A,a,m+1,tmp[i]);
					for(let j=0;j<l;j++)
						await write(A,--b,A[m--],1,true);
					await write(A,--b,tmp[i--],1,true);
					if(i<0)return;
					else if(m<a){
						while(i>=0)await write(A,--b,tmp[i--],1,true);
						return;
					}
					r=(i+1)-rightBoundSearch(tmp,0,i+1,A[m]);
					for(let j=0;j<r;j++)
						await write(A,--b,tmp[i--],1,true);
					await write(A,--b,A[m--],1,true);
					if(i<0)return;
					else if(m<a){
						while(i>=0)await write(A,--b,tmp[i--],1,true);
						return;
					}
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function smartMerge(A,tmp,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftBoundSearch(A,a,m,A[m]);
			b=rightBoundSearch(A,m,b,A[m-1]);
			if(b-m<m-a)await mergeBW(A,tmp,a,m,b);
			else await mergeFW(A,tmp,a,m,b);
		}
		let mR=len;
		let tmp=new Array(mR/2|0);
		for(;mR>31;mR=(mR+1)/2|0);
		await buildRuns(arr,0,len,mR);
		for(let i,j=mR;j<len;j*=2){
			for(i=0;i+2*j<=len;i+=2*j)
				await smartMerge(arr,tmp,i,i+j,i+2*j);
			if(i+j<len)await smartMerge(arr,tmp,i,i+j,len);
		}
	}
	async outOfPlaceBufferedMergeSort(len){
		function log2(v){
			return log(v)/log(2);
		}
		function getBufferSize(l){
			return pow(2,1+ceil(log2(log2(l)|0)));
		}
		async function rotateLeft(A,s,d,z){
			let am=s-d;
			if(z>1){
				while(am>=z){
					for(let i=s;i>s-z;i--)
						await swap(A,i-1,i+z-1,1,true);
					s-=z;am-=z;
				}
				if(am>0){
					let z2=z/2|0;
					await rotateSmart(A,s,d,z2);
					await rotateSmart(A,s+z2,d+z2,z-z2);
				}
			}else{
				let t=A[s];
				for(let i=s;i>d;i--)
					await write(A,i,A[i-1],1,true);
				await write(A,d,t,1,true);
			}
		}
		async function rotateRight(A,s,d,z){
			let am=d-s;
			let m=0;
			if(z>1){
				while(am>=z){
					for(let i=s;i<s+z;i++)
						await swap(A,i,i+z,1,true);
					s+=z;
					am-=z;
					m+=z;
				}
			}else{
				let t=A[s];
				for(let i=s;i<d;i++)
					await write(A,i,A[i+1],1,true);
				await write(A,d,t,1,true);
				m+=d-s;
			}
			return m;
		}
		async function rotateSmart(A,s,d,z){
			if(z>s-d){
				let sD=s-d;
				let m=await rotateRight(A,d,s+z-sD,sD);
				z-=m;
				d+=m;
				s=d+sD;
			}
			if(z>0)await rotateLeft(A,s,d,z);
		}
		function binSearch(A,s,i,n){
			let lo=s,hi=i;
			while(lo<hi){
				let m=lo+(hi-lo)/2|0;
				if(compareValues(n,A[m])<0)hi=m;
				else lo=m+1;
			}
			return lo;
		}
		async function merge(A,s,m,e){
			let bst=2;
			for(let l=m-s;l>=1;l=l/2|0)bst++;
			while(s<m&&m<e){
				if(compareIndices(A,s,m)<0){
					s++;
					let i;
					for(i=0;i<bst;i++)
						if(compareIndices(A,s,m)<0)s++;
						else break;
					if(i==bst)s=binSearch(A,s,m,A[m]);
				}
				if(s>=m)break;
				let z=binSearch(A,m,e,A[s])-m;
				await rotateSmart(A,m,s,z);
				s+=z+1;
				m+=z;
			}
		}
		async function mergeUnderBuffer(A,bS,s,m,e){
			let bP=0,l=s,r=m;
			while(l<m&&r<e){
				if(compareIndices(A,l,r)<1)write(B,bP,A[l++],0,false,true);
				else write(B,bP,A[r++],0,false,true);
				bP++;
			}
			while(l<m)
				write(B,bP++,A[l++],0,false,true);
			while(r<e)
				write(B,bP++,A[r++],0,false,true);
			for(let i=0;i<e-s;i++)
				await write(A,s+i,B[i],1,true);
		}
		async function blockCopy(A,s,e){
			let bZ=e-s;
			for(let i=e-1;i>=s;i--)
				await write(A,i,A[i-bZ],.125,true);
		}
		async function blockCopyFromBuffer(A,s,e){
			for(let i=e-1;i>=s;i--)
				await write(A,i,B[i-s],.125,true);
		}
		async function blockInsertionSort(A,s,m,e,bZ){
			for(let i=m;i<e;i+=bZ){
				let k=A[i];
				let j=i-bZ;
				if(compareValues(k,A[j])+1)continue;
				for(let k=i;k<i+bZ;k++)
					write(B,k-i,A[k],0,false,true);
				await blockCopy(A,j+bZ,j+2*bZ);
				j-=bZ;
				while(j>=s&&compareValues(k,A[j])<0){
					await blockCopy(A,j+bZ,j+2*bZ);
					j-=bZ;
				}
				await blockCopyFromBuffer(A,j+bZ,j+2*bZ);
			}
		}
		async function mergeOverBuffer(A,bS,s,m,e){
			let bZ=bS/2|0;
			await blockInsertionSort(A,s,m,e,bZ);
			let cS=s;
			while(cS<e-bZ){
				if(compareIndices(A,cS+bZ-1,cS+bZ)>0)
					await mergeUnderBuffer(A,bS,cS,cS+bZ,cS+bS);
				cS+=bZ;
			}
		}
		let B;
		async function sort(A,l){
			let bS=getBufferSize(l);
			let ln=l-(l-bS)%(bS/2|0);
			if(bS*2>=ln)return await binaryInsertion(A,0,l,.3);
			B=new Array(bS);
			for(let i=0;i<ln-1;i+=2)
				if(compareIndices(A,i,i+1)>0)
					await swap(A,i,i+1,.5,true);
			for(let g=4;g<=bS;g*=2)
				for(let i=0;i+g<=ln;i+=g)
					await mergeUnderBuffer(A,bS,i,i+g/2|0,i+g);
			for(let g=bS*2;(g/2|0)<=ln;g*=2){
				let i;
				for(i=0;i+g<=ln;i+=g)
					await mergeOverBuffer(A,bS,i,i+g/2|0,i+g);
				if(i+g>ln)
					await mergeOverBuffer(A,bS,i,i+g/2|0,ln);
			}
			if(l-ln>0){
				await binaryInsertion(A,ln,l);
				await merge(A,0,ln,l);
			}
		}
		await sort(arr,len);
	}
	async shuffledTreeSort(len){
		async function stableSwap(A,k,a,b){
			await swap(A,a,b,0,true);
			swap(k,a,b,1,false,true);
		}
		function traverse(A,k,l,u,r){
			if(l[r])traverse(A,k,l,u,l[r]);
			write(k,idx++,r,1,false,true);
			if(u[r])traverse(A,k,l,u,u[r]);
		}
		let idx=0;
		async function sort(A,l){
			let k=new Array(l);
			for(let i=0;i<k;i++)
				write(keys,i,i,0,false,true);
			let R=new Random();
			for(let i=0;i<l;i++){
				let r=R.nextInt(l-i)+i;
				await stableSwap(A,k,i,r);
			}
			let lo=new Array(l);
			let hi=new Array(l);
			let nx;
			for(let i=1;i<l;i++){
				mark(i);
				let c=0;
				while(true){
					mark(c);
					let cmp=compareIndices(A,i,c);
					nx=(cmp<0||(!cmp&&compareIndices(k,i,c)<0))?lo:hi;
					if(!nx[c]){
						write(nx,c,i,0,false,true);
						break;
					}else c=nx[c];
				}
			}
			idx=0;
			traverse(A,k,lo,hi,0);
			for(let i=0;i<l-1;i++){
				if(compareValues(i,k[i])){
					let t=A[i];
					let j=i,n=k[i];
					do{
						await write(A,j,A[n],1,true);
						write(k,j,j,0,false,true);
						j=n;
						n=k[n];
					}while(compareValues(n,i));
					await write(A,j,t,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		await sort(arr,len);
	}
	async adaptiveCreaseSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,.5,true);
				return true;
			}
			return false;
		}
		let m=2,sw;
		for(;2*m<len;m*=2);
		for(let k=m;k>0;k=k/2|0){
			for(let i=1;i<len;i+=2)
				await compSwap(arr,i-1,i);
			sw=false;
			for(let j=m;j>=k&&j>1;j=j/2|0){
				for(let i=1;i+j-1<len;i+=2)
					sw|=await compSwap(arr,i,i+j-1);
				if(!sw&&j==k)k=k/2|0;
			}
		}
	}
	async adaptiveFoldSort(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0){
				await swap(A,a,b,.5,true);
				return true;
			}
			return false;
		}
		let cL=1,e=len,sw;
		for(;(1<<cL)<len;cL++);
		len=1<<cL;
		for(let k=len/2|0;k>0;k=k/2|0){
			sw=false;
			for(let j=len;j>=k&&j>0;j=j/2|0){
				for(let i=0;i<len;i+=j)
					for(let m=0;m<(j/2|0);m++)
						sw|=await compSwap(arr,i+m,i+j-1-m);
				sw&=j<len;
				if(!sw&&j==k)k=k/2|0;
			}
		}
	}
	async burningSortRec(len){
		function comp(A,s,e){
			if(s-e&&compareIndices(A,s,e)>0)
				return swap(A,s,e,.5,true);
		}
		let j=0;
		async function sort(A,s,e){
			if(s==e)return;
			let m=(s+e)/2|0,g0=m-s;
			if(s==m)return;
			await sort(A,s,m);
			await sort(A,m,e);
			for(let i=0;i<g0;i++)if(comp(A,i+s,e-i-1)&&++j>=cbrt(len))await mark(i+s,j=0);
			await sort(A,s,m);
			await sort(A,m,e);
		}
		await sort(arr,0,len);
	}
	async circleHalverSort(len){
		async function compSwap(A,a,b){
			if(a<e&&b<e&&compareIndices(A,a,b)>0){
				await swap(A,a,b,.25,true);
				return true;
			}
			return false;
		}
		async function bwdComp(A,a,b){
			let d=false;
			for(let i=a,j=b-1;i<j;i++,j--)
				d=await compSwap(A,i,j)?true:d;
			return d;
		}
		async function fwdComp(A,a,m,l){
			for(let i=0;i<l;i++)
				await compSwap(A,a+i,m+i);
		}
		async function halver(A,a,b){
			let n=b-a,c=-1;
			let d=true;
			while(d){
				d=false;
				for(let j=1;j<(n/2|0);j*=2)
					for(let i=a;i<minVal(e,b);i+=2*j)
						await fwdComp(A,i,i+j,j);
				d=await bwdComp(A,a,b)?true:d;
				c++;
			}
		}
		let l=len;
		let e=l;
		l=1<<(log(l-1)/log(2)|0)+1;
		await halver(arr,0,l);
		for(let j=l/2|0;j>4;j=j/2|0)
			for(let i=0;i+(j/2|0)<e;i+=j)
				if(await bwdComp(arr,i,i+j))
					await halver(arr,i,i+j);
		for(let i=2;i<e;i+=4)
			await compSwap(arr,i-1,i);
	}
	async corruptSort(len){
		async function comp(A,s,e){
			if(compareIndices(A,s,e)>0)
				await swap(A,s,e,.5,true);
		}
		function cpotlt(l){
			let z=1;
			while(z<=l)z*=2;
			return z/2;
		}
		async function pass(A,s,e,l,g,t){
			for(let i=s;i<e;i++){
				let g2=g;
				while(g2>t){
					if(i+g2<l)
						await comp(A,i,i+g2);
					g2=g2/2|0;
				}
			}
		}
		async function merge(A,s,e,b){
			if(e<=s)return;
			let m=(s+e)/2|0,g0=m-s,g1=g0/2|0;
			if(!b)
				for(let i=s;i<m;i++){
					if(i+g0<e)
						await comp(A,i,i+g0);
				}
			if(s==m)return;
			if(e-s>4)await pass(A,s+g1,m,e,g1,1);
			await merge(A,s,m,true);
			await merge(A,m,e,true);
		}
		async function sort(A,s,e){
			if(e<=s)return;
			let m=(s+e)/2|0;
			if(s==m)return await merge(A,s,e);
			await sort(A,s,m);
			await sort(A,m,e);
			await merge(A,s,e);
		}
		await sort(arr,0,len);
		await pass(arr,0,len,len,cpotlt(len)-1,0);
	}
	async XORCircleSort(len){
		async function comp(A,s,e,d,x){
			if(e<x&&s<x&&s-e&&d==(compareIndices(A,s,e)>0))
				await swap(A,s,e,.5,true);
		}
		function xLess(l){
			let z=1;
			while(z<=l)z<<=1;
			return z>>1;
		}
		async function xorPass(A,s,e){
			let x=xLess(e-s);
			for(let i=s;i<e;i++)
				for(let j=x;j>0;j=j/2|0)
					if(!(i&j))await comp(A,i,i^j,true,e);
					else await comp(A,i,i^j,false,e);
		}
		async function circlePass(A,s,e){
			let m=s+(e-s)/2|0;
			for(let i=0;i<m-s;i++)
				await comp(A,s+i,e-i-1,true,e);
		}
		async function circleSort(A,s,e){
			let k=e-s;
			while(k>0&&!isRangeSorted(A,s,e)){
				for(let i=s;i<e;i+=k){
					await xorPass(A,i,i+k);
					await circlePass(A,i,i+k);
				}
				for(let i=s+k/2|0;i<e-(k/2|0);i+=k){
					await circlePass(A,i,i+k);
					await xorPass(A,i,i+k);
				}
				k=k/2|0;
			}
		}
		await circleSort(arr,0,len);
	}
	async matrixSortReal(len){
		async function bitonicSort(A,p,g,n,c){
			for(let k=n;k>1;k=k/2|0)
				for(let j=0;j<n;j+=k)
					for(let i=0;i<(k/2|0);i++)
						if(compareIndices(A,p+(j+i)*g,p+(j+i+k/2)*g)==c)
							await swap(A,p+(j+i)*g,p+(j+i+k/2|0)*g,1,true);
		}
		async function sort(A,p,g,n,c,l){
			if(n==2){
				if(compareIndices(A,p,p+g)==c)
					await swap(A,p,p+g,1,true);
				return;
			}
			let sqLR=(l+1)/2|0,sqLC=l/2|0;
			let it=sqLC;
			let sqR=1<<sqLR,sqC=1<<sqLC;
			while(it-->0){
				for(let i=0;i<sqC;i++)
					await sort(A,p+i*sqR*g,g,sqR,2*(i&1)*c-c,sqLR);
				for(let i=0;i<sqR;i++)
					await sort(A,p+i*g,sqR*g,sqC,c,sqLC);
			}
			for(let i=0;i<sqC;i++)
				await bitonicSort(A,p+(i*sqR)*g,g,sqR,c);
		}
		await sort(arr,0,1,len,1,31-clz32(len));
	}
	async vanVoorhisFourFourSortIterative(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		async function compRange(A,a,b,s){
			while(s-->0)await compSwap(A,a++,b++);
		}
		async function sort(A,l){
			for(let k=4;k<=l;k*=4){
				let f=k/4|0;
				for(let i=0;i<l;i+=k){
					await compRange(A,i,i+f,f);
					await compRange(A,i+2*f,i+3*f,f);
				}
				for(let i=0;i<l;i+=k){
					await compRange(A,i,i+2*f,f);
					await compRange(A,i+f,i+3*f,f);
				}
				for(let i=0;i<l;i+=k)
					await compRange(A,i+f,i+f+f,f);
				for(let m=16;m<=k;m*=4){
					let s=k/m|0;
					for(let i=0;i<l;i+=k){
						for(let j=2;j+7<m;j+=4){
							await compRange(A,i+j*s,i+(j+6)*s,s);
							await compRange(A,i+(j+1)*s,i+(j+7)*s,s);
						}
					}
					for(let i=0;i<l;i+=k){
						for(let j=1;j+5<m;j+=4){
							await compRange(A,i+j*s,i+(j+3)*s,s);
							await compRange(A,i+(j+2)*s,i+(j+5)*s,s);
						}
					}
					for(let i=0;i<l;i+=k){
						for(let j=2;j+3<m;j+=4){
							await compRange(A,i+j*s,i+(j+2)*s,s);
							await compRange(A,i+(j+1)*s,i+(j+3)*s,s);
						}
					}
					for(let i=0;i<l;i+=k)
						for(let j=3;j+3<m;j+=2)
							await compRange(A,i+j*s,i+(j+1)*s,s);
				}
			}
		}
		await sort(arr,len);
	}
	async pairwiseSortCursed(len){
		async function compSwap(A,a,b){
			if(b<N&&compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		async function pw(A,a,b,g){
			if(a>=b-g)return;
			for(let i=a;i<=b-2*g;i+=2*g)
				await compSwap(A,i,i+g);
			await pdw(A,a,b,2*g);
			await pdw(A,a+g,b+g,2*g);
			let p=1;
			while(p<(b-a)/g|0)p|=p<<1;
			while(p>0){
				for(let i=a+g;i+p*g<b;i+=2*g)
					await compSwap(A,i,i+p*g);
				p>>=1;
			}
		}
		async function pdw(A,a,b,g){
			if(a>=b-g)return;
			let n=(b-a)/g|0,m=n/2|0,o=m;
			m=a+m*g;
			for(let i=a;i<m;i+=g)
				await compSwap(A,i,m+i-a);
			await pw(A,a,m,g);
			await pw(A,m,b,g);
			for(let i=n>>2;i>0;i>>=1)
				for(let j=i;j<o-i<<1;j+=i<<1)
					for(let k=0;k<i;k++)
						await compSwap(A,a+(j+k)*g,a+(i+j+k)*g);
		}
		async function pairwise(A,a,b){
			let n=1;
			while(n<b-a)n*=2;
			N=b;
			await pdw(A,a,a+n,1);
		}
		let N;
		await pairwise(arr,0,len);
	}
	async XORSort(len){
		for(let k=len-1,j=0;k>0;k--)
			for(let l=1;l<=k;l++)
				for(let i=0;i<len;i++){
					let b=i^(k%(l+1));
					if(b<len&&compareIndices(arr,i,b)<0){
						swap(arr,i,b);
						if(++j>len)await markSwap(i,b,j=0);
					}
				}
	}
	async vanVoorhisFourFourSortRecursive(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		async function merge(A,p,n,g){
			if(n==4){
				await compSwap(A,p,p+g);
				await compSwap(A,p+2*g,p+3*g);
				await compSwap(A,p,p+2*g);
				await compSwap(A,p+g,p+3*g);
				await compSwap(A,p+g,p+2*g);
				return;
			}
			await merge(A,p,n/4|0,4*g);
			await merge(A,p+g,n/4|0,4*g);
			await merge(A,p+2*g,n/4|0,4*g);
			await merge(A,p+3*g,n/4|0,4*g);
			for(let i=2;i+7<n;i+=4){
				await compSwap(A,p+i*g,p+(i+6)*g);
				await compSwap(A,p+(i+1)*g,p+(i+7)*g);
			}
			for(let i=1;i+3<n;i+=2)
				await compSwap(A,p+i*g,p+(i+3)*g);
			for(let i=2;i+3<n;i+=4){
				await compSwap(A,p+i*g,p+(i+2)*g);
				await compSwap(A,p+(i+1)*g,p+(i+3)*g);
			}
			for(let i=3;i+3<n;i+=2)
				await compSwap(A,p+i*g,p+(i+1)*g);
		}
		async function sort(A,p,n){
			let f=n/4|0;
			if(f>1){
				await sort(A,p,f);
				await sort(A,p+f,f);
				await sort(A,p+2*f,f);
				await sort(A,p+3*f,f);
			}
			await merge(A,p,n,1);
		}
		await sort(arr,0,len);
	}
	async vanVoorhisThreeThreeSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		async function compRange(A,a,b,s){
			while(s-->0)await compSwap(A,a++,b++);
		}
		async function merge(A,p,n){
			let t=n/3|0;
			await compRange(A,p+t,p+t+t,t);
			await compRange(A,p,p+t,t);
			await compRange(A,p+t,p+t+t,t);
			for(let k=9;k<=n;k*=3){
				let s=n/k|0;
				for(let i=2;i+4<k;i+=3)
					await compRange(A,p+i*s,p+(i+4)*s,s);
				for(let i=1;i+2<k;i+=3)
					await compRange(A,p+i*s,p+(i+2)*s,s);
				for(let i=2;i+2<k;i+=3)
					await compRange(A,p+i*s,p+(i+2)*s,s);
				for(let i=2;i+1<k;i+=3)
					await compRange(A,p+i*s,p+(i+1)*s,s);
			}
		}
		for(let k=3;k<=len;k*=3)
			for(let i=0;i<len;i+=k)
				await merge(arr,i,k);
		await insertSort(arr,0,len,0);
	}
	async weavedVanVoorhisFourFourSortIterative(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				await swap(A,a,b,0,true);
		}
		async function compRange(A,a,b,s){
			while(s-->0)await compSwap(A,a++,b++);
		}
		let e;
		async function sort(A,l){
			let n=1<<(2*((33-clz32(l-1))/2|0));e=l;
			for(let k=4;k<=n;k*=4){
				let g=n/k|0;
				for(let i=0;i<k;i+=2)await compRange(A,i*g,(i+1)*g,g);
				for(let i=0;i<k;i+=4){
					await compRange(A,i*g,(i+2)*g,g);
					await compRange(A,(i+1)*g,(i+3)*g,g);
				}
				for(let i=0;i<k;i+=4)await compRange(A,(i+1)*g,(i+2)*g,g);
				for(let j=16;j<=k;j*=4){
					let s=k/j|0,g1=4*s-4;
					for(let i=2;i+7<j;i+=4)
						for(let m=0;m<s;m++){
							await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+6+((i+6)/4|0)*g1+4*m)*g,g);
							await compRange(A,(i+1+((i+1)/4|0)*g1+4*m)*g,(i+7+((i+7)/4|0)*g1+4*m)*g,g);
						}
					for(let i=1;i+5<j;i+=4)
						for(let m=0;m<s;m++){
							await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+3+((i+3)/4|0)*g1+4*m)*g,g);
							await compRange(A,(i+2+((i+2)/4|0)*g1+4*m)*g,(i+5+((i+5)/4|0)*g1+4*m)*g,g);
						}
					for(let i=2;i+3<j;i+=4)
						for(let m=0;m<s;m++){
							await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+2+((i+2)/4|0)*g1+4*m)*g,g);
							await compRange(A,(i+1+((i+1)/4|0)*g1+4*m)*g,(i+3+((i+3)/4|0)*g1+4*m)*g,g);
						}
					if(g1>0){
						for(let i=3;i+3<j;i+=4)
							for(let m=0;m<s;m++)
								await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+1+((i+1)/4|0)*g1+4*m)*g,g);
						for(let i=5;i+3<j;i+=4)
							for(let m=0;m<s;m++)
								await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+1+((i+1)/4|0)*g1+4*m)*g,g);
					}else
						for(let i=3;i+3<j;i+=2)
							for(let m=0;m<s;m++)
								await compRange(A,(i+(i/4|0)*g1+4*m)*g,(i+1+((i+1)/4|0)*g1+4*m)*g,g);
				}
			}
		}
		await sort(arr,len);
	}
	async weavedVanVoorhisFourFourSortRecursive(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		async function merge(A,p,n,g,g1){
			if(n<5){
				await compSwap(A,p,p+g);
				await compSwap(A,p+2*g,p+3*g);
				await compSwap(A,p,p+2*g);
				await compSwap(A,p+g,p+3*g);
				await compSwap(A,p+g,p+2*g);
				return;
			}
			await merge(A,p,n/4|0,g,4*(g1+3));
			await merge(A,p+(g1+4)*g,n/4|0,g,4*(g1+3));
			await merge(A,p+(g1+4)*g*2,n/4|0,g,4*(g1+3));
			await merge(A,p+(g1+4)*g*3,n/4|0,g,4*(g1+3));
			for(let i=2;i+7<n;i+=4){
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+6+((i+6)/4|0)*g1)*g);
				await compSwap(A,p+(i+1+((i+1)/4|0)*g1)*g,p+(i+7+((i+7)/4|0)*g1)*g);
			}
			for(let i=1;i+3<n;i+=2)
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+3+((i+3)/4|0)*g1)*g);
			for(let i=2;i+3<n;i+=4){
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+2+((i+2)/4|0)*g1)*g);
				await compSwap(A,p+(i+1+((i+1)/4|0)*g1)*g,p+(i+3+((i+3)/4|0)*g1)*g);
			}
			for(let i=3;i+3<n;i+=2)
				await compSwap(A,p+(i+(i/4|0)*g1)*g,p+(i+1+((i+1)/4|0)*g1)*g);
		}
		async function sort(A,p,n,g){
			let f=n/4|0;
			if(f>1){
				await sort(A,p,f,g*4);
				await sort(A,p+g,f,g*4);
				await sort(A,p+2*g,f,g*4);
				await sort(A,p+3*g,f,g*4);
			}
			await merge(A,p,n,g,0);
		}
		let e=len,n=1<<(2*(33-clz32(e-1))/2|0);
		await sort(arr,0,n,1);
	}
	async safeStalinSort(len){
		function oAdd(o,x){
			o.push(x);
			counts.aux++;
		}
		function oPop(o){
			return o.pop();
			counts.aux++;
		}
		async function remove(A,i,l){
			await arraycopy(A,i+1,A,i,l-i-1,0);
			await write(A,l-1,-1,1,true);
		}
		async function add(A,x,l){
			await write(A,l,x,1,true);
		}
		async function insert(A,i,x,l){
			await arraycopy(A,i,A,i+1,l-i,0);
			await write(A,i,x,1,true);
		}
		async function sort(A,l){
			let o=[];
			let p=false;
			let gL=l,xL=0,k=0;
			while(!p){
				let i=0;
				while(i<l){
					i++;
					while(i<gL){
						let compare=compareIndices(A,i-1,i);
						if(compare>0){
							oAdd(o,A[i]);
							mark(A[i]);
							await remove(A,i,l--);
							gL--;xL++;
						}else i++;
					}
					for(let j=0;j<xL;j++){
						await add(A,oPop(o),l++);
						gL++;
					}
					gL=l;
					xL=0;
				}
				let vI=1;
				p=true;
				while(vI-l&&p){
					let compare=compareIndices(A,vI-1,vI);
					if(compare<=0)vI++;
					else p=false;
				}
				if(!p){
					i=vI;
					mark(i);
					while(!(i+1>l)){
						oAdd(o,A[i]);
						await remove(A,i,l--);
						xL++;
					}
					i=1;
					for(let j=0;j<xL;j++)
						await insert(A,++i-2,oPop(o),l++);
					xL=0;
				}
			}
		}
		await sort(arr,len);
	}
	async calcium57Sort(len){
		async function t(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function b(A,l,r,k){
			while(l<r){
				let m=(l&r)+((l^r)>>1);
				if(compareValues(A[m],k)<0)r=m;
				else l=m+1;
			}
			return l;
		}
		async function milk(A,s,m,e){
			if(s-m&&m-e&&compareIndices(A,m-1,m)<1)return;
			if((e-s<17||s==m||m==e)&&s<e)return await insertSort(A,s,e,.5);
			let rz=e-m,r=m,z=s+(m-s)-rz,l=z;
			while(rz>0){
				if(compareIndices(A,l,r)>0)await t(A,l,r,rz);
				else{
					l++;
					rz--;
				}
			}
			await sort(A,m,e);
			if(z>s){
				let c=b(A,z,e,A[z-1]);
				for(let i=z;i<c;i+=z-s)
					await milk(A,i-(z-s),i,minVal(i+z-s,c));
			}
		}
		async function sort(A,s,e){
			let m=(e-s+1)/3|0;
			if(m<1)return;
			await sort(A,s+m,e);
			await sort(A,s,e-m);
			let z=e-s-2*m;
			await milk(A,s+minVal(m,z),e-m,e);
		}
		await sort(arr,0,len);
	}
	async calcium58Sort(len){
		async function t(A,a,b,l){
			for(let i=0;i<l;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function b(A,l,r,k){
			while(l<r){
				let m=(l&r)+((l^r)>>1);
				if(compareValues(A[m],k)<0)r=m;
				else l=m+1;
			}
			return l;
		}
		async function milk(A,s,m,e){
			if((e-s<17||s==m||m==e)&&s<e)return insertSort(A,s,e,0);
			let rz=e-m,r=m,z=s+(m-s)-rz,l=z;
			while(rz>0){
				if(compareIndices(A,l,r)>0)await t(A,l,r,rz);
				else{
					l++;
					rz--;
				}
			}
			await sort(A,m,e);
			if(z>s){
				let c=b(A,z,e,A[z-1]);
				for(let i=z;i<c;i+=z-s)
					await milk(A,i-(z-s),i,minVal(i+z-s,c));
			}
		}
		async function sort(A,s,e){
			let m=(e-s+1)/3|0;
			if(m<1)return;
			await sort(A,s+m,e);
			await sort(A,s,e-m);
			await milk(A,s,e-m,e);
		}
		await sort(arr,0,len);
	}
	async sunriseSort(len){
		async function insert(t,i,a,b){
			if(a+1&&!compareValues(t[a],i)){
				let r=randInt(a,b+1);
				await write(t,b,t[r],.5,true,true);
				await write(t,r,i,.5,true,true);
				return a;
			}else{
				await write(t,b,i,.5,true,true);
				return b;
			}
		}
		async function sunriseMerge(A,x,a,b,c){
			let m=b-1,t=a,l=c-a+1,t2=-1;
			while(a<=m&&b<=c)
				if(compareIndices(A,a,b)<0)t2=await insert(x,A[a++],t2,t++);
				else t2=await insert(x,A[b++],t2,t++);
			while(a<=m)t2=await insert(x,A[a++],t2,t++);
			while(b<=c)t2=await insert(x,A[b++],t2,t++);
			for(let i=0;i<l;i++,c--)await write(A,c,x[c],1,true);
		}
		async function sunrise(A,x,a,b){
			let m=a+(b-a)/2|0;
			if(a>=b)return;
			await sunrise(A,x,a,m);
			await sunrise(A,x,m+1,b);
			await sunriseMerge(A,x,a,m+1,b);
		}
		await sunrise(arr,new Array(len),0,len-1);
	}
	async ringSort(len){
		function getMinMax(A,l){
			let mn=[A[0],A[0]];
			for(let i=1;i<l;i++){
				if(mn[0]>A[i])mn[0]=A[i];
				if(mn[1]<A[i])mn[1]=A[i];
			}
			return mn;
		}
		async function sort(A,l){
			let nx=getMinMax(A,l),n=nx[0],x=nx[1],m=0,i=0,k=0,c=new Array(x-n+1).fill(0);
			for(let i=0;i<l;i++)write(c,A[i]-n,c[A[i]-n]+1,0,false,true);
			while(m<l){
				while(!c[i])i++;
				let w=i+n;
				for(let j=m;j<l;j++){
					if(c[i]>0){
						c[i]--;
						m++;
					}
					write(A,j,w,0);
					if(++k>=sqrt(l))await mark(j,k=0);
				}
			}
		}
		await sort(arr,len);
	}
	async adaptiveForcedStableQuickSort(len){
		let ofs;
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,1,true);
			else await reversal(A,s,e,.5,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(i<e&&!compareIndices(A,i,i+1))i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,1,true);
					else await reversal(A,l,r,1,true);
				}
				i++;
			}
		}
		function stableComp(A,k,a,b){
			let c=compareIndices(A,ofs+a,ofs+b);
			return c>0||(!c&&compareIndices(k,a,b)>0);
		}
		async function stableSwap(A,k,a,b){
			if(a==b)return;
			await swap(A,ofs+a,ofs+b,0,true);
			swap(k,a,b,0,false,true);
		}
		async function smallSort(A,k,a,b){
			for(let i=a+1;i<b;i++){
				let j=i;
				while(j>0&&stableComp(A,k,j-1,j))
					await stableSwap(A,k,j-1,j--);
			}
		}
		function medianOfThree(A,k,i0,i1,i2){
			let t;
			if(stableComp(A,k,i0,i1)){
				t=i1;
				i1=i0;
			}else t=i0;
			if(stableComp(A,k,i1,i2)){
				if(stableComp(A,k,t,i2))return t;
				return i2;
			}
			return i1;
		}
		async function medianOfMedians(A,k,a,b){
			while(b-a>2){
				let m=a,i=a;
				for(;i+2<b;i+=3)await stableSwap(A,k,m++,medianOfThree(A,k,i,i+1,i+2));
				while(i<b)await stableSwap(A,k,m++,i++);
				b=m;
			}
		}
		async function partition(A,k,a,b){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&!stableComp(A,k,i,a));
				do j--;while(j>=i&&stableComp(A,k,j,a));
				if(i>=j){
					await stableSwap(A,k,a,j);
					return j;
				}
				await stableSwap(A,k,i,j);
			}
		}
		async function innerSort(A,k,a,b,bA){
			while(b-a>16){
				if(bA)await medianOfMedians(A,k,a,b);
				else await stableSwap(A,k,a,medianOfThree(A,k,a,a+(b-a)/2|0,b-1));
				let p=await partition(A,k,a,b);
				let lL=p-a,rL=b-p-1;
				bA=lL<((b-a)/16||0)|rL<((b-a)/16|0);
				if(lL>rL){
					await innerSort(A,k,p+1,b,bA);
					b=p;
				}else{
					await innerSort(A,k,a,p,bA);
					a=p+1;
				}
			}
			await smallSort(A,k,a,b);
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0?1:0;
				e+=c?0:1;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(e>0)await stableSegmentReversal(A,a,b-1);
				else if(b-a<4)await swap(A,a,b-1,.75,true);
				else reversal(A,a,b-1,.75,true,false);
				return;
			}
			let l=b-a,k=new Array(l);
			for(let i=0;i<l;i++)
				write(k,i,i,0,false,true);
			ofs=a;
			await innerSort(A,k,0,l,false);
		}
		await quickSort(arr,0,len);
	}
	async headPullQuickSort(len){
		let l=1;
		while(l-len){
			let as=false;
			for(let r=l+1;r<=len;r++)
				if(compareIndices(arr,l-1,r-1)>0)
					await multiSwap(arr,r-1,0,.1,as=true);
			if(as)l=1;
			else l++;
		}
	}
	async LDQuickSort(len){
		async function partition(A,a,b){
			let p=A[a],i=a;
			for(let j=a;j<=b;j++){
				if(compareValues(A[j],p)<0){
					await swap(A,i,j,1,true);
					await swap(A,++i,j,1,true);
				}
			}
			return i;
		}
		async function quickSort(A,a,b){
			if(a<b){
				let p=await partition(A,a,b);
				await quickSort(A,a,p-1);
				await quickSort(A,p+1,b);
			}
		}
		await quickSort(arr,0,len-1);
	}
	async orpicSort(len){
		const hs=new HeapSorting(true);
		async function sort3(A,a,b,c){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,2.5,true);
			if(compareIndices(A,b,c)>0){
				await swap(A,b,c,2.5,true);
				if(compareIndices(A,a,b)>0)
					await swap(A,a,b,2.5,true);
			}
		}
		async function partition(a,p,r,pw){
			let mG,mZ=1,po=pw,mT=sqrt(r-p+1)|0;
			while(po-->0)mZ*=3;
			mG=(r-p+1)/mZ|0;
			if(mG<1)return hs.sort(a,p,r,.25);
			if(mG>1)
				for(let i=p+mG,j=p+1;i<=r;i+=mG)
					await swap(a,i,j++,2.5,true);
			for(let j=0;j<pw;j++){
				for(let i=p,k=p;i<p+mZ-2;i+=3,k++){
					await sort3(a,i,i+1,i+2);
					await swap(a,i+1,k,2.5,true);
				}
				mZ=(mZ+2)/3|0;
			}
			let pv=a[p],i=p,j=r,it=0,itn=0;
			while(i<=j){
				while(it<=mT&&compareValues(a[i],pv)<0){
					i++;
					it++;
					itn=0;
				}
				if(it+itn>mT&&i<=j)return await partition(a,p,r,pw+1);
				else{
					it=0;
					itn++;
				}
				while(it<=mT&&compareValues(a[j],pv)>0){
					j--;
					it++;
					itn=0;
				}
				if(it+itn>mT&&i<=j)return await partition(a,p,r,pw+1);
				else{
					it=0;
					itn++;
				}
				if(i<=j)
					await swap(a,i++,j--,1,true);
			}
			let m=maxVal(pw-1,1);
			await partition(a,p,j,m);
			await partition(a,i,r,m);
		}
		await partition(arr,0,len-1,1);
		await insertSort(arr,0,len,.1);
	}
	async adjacencyPancakeSort(len){
		function dualSwap(A,K,a,b){
			swap(K,a,b,0,false,true);
			swap(A,a,b,0);
		}
		async function reverse(A,K,a,b){
			let i=0;
			while(b-a>1){
				dualSwap(A,K,a++,--b);
				if(++i>=cbrt(len))await mark(a-1,i=0);
			}
		}
		function isAdjacent(K,a,b,N){
			return(K[a]+1)%N==K[b]||(K[b]+1)%N==K[a];
		}
		function findAdjacent(K,e,a,N){
			while(!isAdjacent(K,a,e,N))a++;
			return a;
		}
		async function sort(A,N){
			let a=0,b=N;
			if(N==2){
				if(compareIndices(A,a,a+1)>0)
					await reversal(A,a,a+1,.5,true);
				return;
			}
			let K=new Array(N);
			for(let j=a;j<b;j++){
				let c=0;
				for(let i=a;i<b;i++){
					if(i==j)continue;
					let cm=compareIndices(A,i,j);
					if(cm<0||(!cm&&i<j))c++;
				}
				write(K,j-a,c,0,false);
			}
			while(1){
				let i=a;
				while(i<b-1&&isAdjacent(K,i,i+1,N))i++;
				if(i==b-1)break;
				if(i==a){
					let j=findAdjacent(K,a,a+2,N);
					if(!isAdjacent(K,j-1,j,N))
						await reverse(A,K,a,j);
					else{
						let k=findAdjacent(K,a,j+1,N);
						if(!isAdjacent(K,k-1,k,N))
							await reverse(A,K,a,k);
						else{
							await reverse(A,K,a,j+1);
							await reverse(A,K,a,j);
							await reverse(A,K,a,k+1);
							await reverse(A,K,a,a+k-j);
						}
					}
				}else{
					let j=findAdjacent(K,a,i+1,N);
					if(!isAdjacent(K,j-1,j,N))
						await reverse(A,K,a,j);
					else{
						let k=findAdjacent(K,i,i+2,N);
						if(k+1<b&&isAdjacent(K,k+1,k,N)){
							await reverse(A,K,a,i+1);
							await reverse(A,K,a,k+1);
						}else if(isAdjacent(K,k-1,k,N)){
							await reverse(A,K,a,k+1);
							await reverse(A,K,a,a+k-i);
						}else{
							await reverse(A,K,a,k+1);
							await reverse(A,K,a,a+k-i);
							if(j<k){
								await reverse(A,K,a,k+1);
								await reverse(A,K,a,i+k-j+1);
							}else{
								await reverse(A,K,a,j+1);
								await reverse(A,K,a,a+j-k);
							}
						}
					}
				}
			}
			let i=a;
			while(K[i]&&K[i]!=N-1)i++;
			if(!K[i]){
				if(i==a)return;
				await reverse(A,K,a,b);
				i=b-2-i+a;
			}else if(i==a)return await reverse(A,K,a,b);
			await reverse(A,K,a,++i);
			await reverse(A,K,a,b);
			await reverse(A,K,a,b-i);
		}
		await sort(arr,len);
	}
	async rotatePancakeInsertionSort(len){
		let o;
		function compare(A,a,b){
			return compareIndices(A,o+a,o+b);
		}
		async function flip(A,i){
			if(i<1)return;
			if(i>2)
				await reversal(A,o,o+i,.1,true);
			else
				await swap(A,o,o+i,1,true);
		}
		async function sort(A,a,b){
			let ln=b-a;o=a;
			let v=false;
			let l,r,m;
			for(let i=1;i<ln;i++){
				if(v^compare(A,i-1,i)<1)continue;
				if(v^compare(A,0,i)>0){
					await flip(A,i-1);
					v=!v;
					continue;
				}
				l=0;r=i;
				while(l<r){
					m=l+(r-l)/2|0;
					if(v^compare(A,m,i)>0)r=m;
					else l=m+1;
				}
				await flip(A,l-1);
				await flip(A,i-1);
				await flip(A,i);
				await flip(A,l);
			}
			if(v)await flip(A,len-1);
		}
		await sort(arr,0,len);
	}
	async binaryQuasiPancakeSort(len){
		function binarySearch(A,s,e,v){
			while(s<e){
				let m=s+e>>>1;
				if(compareValues(A[m],v)<1)s=m+1;
				else e=m;
			}
			return s;
		}
		for(let i=1;i<len;++i){
			let j=binarySearch(arr,0,i,arr[i]);
			if(j-i){
				await reversal(arr,j,i-1,.2,true);
				await reversal(arr,j,i,.2,true);
			}
		}
	}
	async cubicPancakeSort(len){
		async function cubicReversal(A,i,j){
			for(let x=j;x>i;x--){
				for(let y=i;y<x;y++){
					reversal(A,i,y,0,true);
					reversal(A,i+1,y+1,0,true);
					reversal(A,i,y+1,0,true);
					await reversal(A,i,y-1,.1,true);
				}
			}
		}
		function sorted(A,l){
			for(let i=0;i<l;i++)
				if(compareIndices(A,i,i+1)>0)return false;
			return true;
		}
		function findMax(A,e){
			let j=0,m=-1/0;
			for(let i=0;i<=e;i++){
				if(compareValues(A[i],m)>0){
					m=A[i];
					j=i;
				}
			}
			return j;
		}
		for(let i=len-1;i>=0;i--){
			if(!sorted(arr,i)){
				let j=findMax(arr,i);
				if(!j)
					await cubicReversal(arr,0,i);
				else if(j-i){
					await cubicReversal(arr,0,j);
					await cubicReversal(arr,0,i);
				}
			}else break;
		}
	}
	async tinyPullSort(len){
		let k=0;
		for(let j=len;j>0;j--)
			for(let i=1;i<j;i++){
				swap(arr,i-1,i,0);
				if(++k>len)await mark(i-1,k=0);
				if(compareIndices(arr,i-1,i)>0)i=0;
			}
	}
	async inverseGnomeSort(len){
		for(let i=1;i<len;i++)
			for(let g=0;g<i;g++)
				if(compareIndices(arr,g,i)>0){
					multiSwap(arr,g,i,0);
					await markSwap(g,i);
					g=-1;
				}
	}
	async reverseClamberSort(len){
		for(let i=len-2,k=0;i>=0;i--)
			for(let j=len-1;j>i;j--)
				if(compareIndices(arr,i,j)>0){
					swap(arr,i,j,0);
					if(++k>sqrt(len))await markSwap(i,j,k=0);//Lwk
				}
	}
	async bottleSort(len){
		for(let i=0;i<len-1;i++){
			reversal(arr,0,i-1,0);
			if(compareIndices(arr,i,i+1)>0){
				await swap(arr,i,i+1,1,true);
				i=-1;
			}
		}
		for(let i=len-2;i>0;i--)reversal(arr,0,i-1,0);
	}
	async slightlyUnoptimizedBubbleSort(len){
		for(let i=len-1,k=0;i>0;i--)
			for(let j=0;j<i;j++)
				if(compareIndices(arr,j,j+1)>0){
					swap(arr,j,j+1,0);
					if(++k>sqrt(len)){
						markSwap(j,j+1);
						await sleep(k=0);
					}
				}
	}
	async jumpDownSort(len){
		let mP=len-1;
		for(let i=mP;i>0;i--){
			for(let j=0;j<i;j++){
				if(compareIndices(arr,i,j)<0){
					await swap(arr,i,j,.2,true);
				}
			}
		}
	}
	async inPlaceOptimizedSmartSafeStalinSortInserts(len){
		function scan(A,c,l){
			for(let i=c;i+1<l;i++)
				if(compareIndices(A,i,i+1)>0)
					return false;
			return true;
		}
		function stepDown(A,e){
			for(let i=e-1;i>0;i--)
				for(let j=i-1;j>=0;j--)
					if(compareIndices(A,j,i)>0)
						return i+1;
			return 0;
		}
		function checkSegments(A,e){
			sC=0;
			for(let i=0;i+1<e&&sC<2;i++)
				if(compareIndices(A,i,i+1)>0)sC++;
		}
		let sC;
		async function sort(A,l){
			let p=false;
			l=stepDown(A,l);
			let nC=true;
			while(!p){
				p=nC=true;
				let c=1;
				for(let i=1;i+1<l;i++){
					if(compareIndices(A,c-1,i)<1){
						if(c-i)await Wr.insert(A,i,c,.01,true,nC=false);
						p=false;
						c++;
					}
				}
				if(nC){
					checkSegments(A,l);
					if(sC<2)break;
				}
				if(p)p=scan(A,c,l);
				if(!p)await IndexedRotations.adaptable(A,0,c,l,.25,true);
				if(--l-1>0){
					let cmp=compareIndices(A,l-1,l);
					while(!cmp&&l>0)
						if(--l>0)cmp=compareIndices(A,l-1,l);
				}
				l=stepDown(A,l);
			}
			if(nC)
				await insertSort(A,0,l,.1);
		}
		await sort(arr,len);
	}
	async twoOptSort(len){
		function getDist(A,l){
			let d=0;
			for(let i=0;i<l-1;i++)d+=abs(A[i+1]-A[i]);
			return d;
		}
		async function sort(A,l){
			let d=false;
			while(!d){
				let bD=getDist(A,l);d=true;
				for(let i=0;i<l-1;i++)
					for(let j=i+1;j<l;j++){
						await reversal(A,i,j,.01,true);
						let t=getDist(A,l);
						if(t<bD){
							bD=t;d=false;
						}else await reversal(A,i,j,.01,true);
					}
			}
			await reversal(A,0,l-1,1,true);
		}
		await sort(arr,len);
	}
	async grossSort(len){
		async function comp(A,s,e,d){
			if(s-e&&d==(compareIndices(A,s,e)>0)){
				await swap(A,s,e,1,true);
				return true;
			}
			return false;
		}
		async function rot(A,p,lA,lB,sl,m,x){
			for(let i=0;i<lB;i++)
				await multiSwap(A,p+lA+lB-1,p,sl,m,x);
		}
		async function bitPass(A,s,e,d){
			if(s==e)return;
			let m=(e-s)/2|0;
			for(let i=0;i<m;i++)
				await comp(A,s+i,s+m+i,d);
			if(m==e-s)return;
			await bitPass(A,s,s+m,d);
			await bitPass(A,e-m,e,d);
		}
		async function circlePass(A,s,e){
			if(s==e)return 0;
			let m=(e-s)/2|0,sw=0;
			for(let i=0;i<m;i++)
				if(await comp(A,s+i,e-i-1,true))
					sw++;
			if(m==e-s)return 0;
			sw+=await circlePass(A,s,s+m);
			sw+=await circlePass(A,e-m,e);
			return sw;
		}
		async function circleSort(A,s,e){
			let a=1;
			while(a>0)
				a=await circlePass(A,s,e);
		}
		async function horrorPass(A,s,e){
			for(let i=0;i<e-s;i++){
				await bitPass(A,s,e,true);
				await bitPass(A,s+i,e);
			}
		}
		async function surpass(A,s,e){
			for(let i=s;i<e;i++)
				for(let j=s;j<e;j++)
					for(let k=0;k<e-s;k++)
						if(compareIndices(A,i,j)<0)
							await multiSwap(A,j,i,.05,true);
		}
		async function greenHerringPass(A,s,e){
			let h=(e-s)/2|0,a=s+h/2|0,b=e-h/2|0;
			if(a==s||b==e)return;
			await horrorPass(A,s,a);
			await surpass(A,s,a);
			await greenHerringPass(A,a,e);
			await circleSort(A,s,e);
		}
		async function grossPass(A,s,e,ln,l){
			let h=(e-s)/2|0,m=s+h;
			if (m==s)return;
			if(e-s<32)return await greenHerringPass(A,s,e);
			await grossPass(A,s,m,ln,true);
			if(l)await rot(A,s,h,h,.1,true);
			await grossPass(A,s,e-(m-s),ln,false);
			await circleSort(A,s,e);
			if(!l)await rot(A,s,e-s,minVal(ln-e,e-s),.1,true);
		}
		await grossPass(arr,0,len,len,true);
	}
	async greenHerringSort(len){
		async function comp(A,s,e,d){
			if(s-e&&d==(compareIndices(A,s,e)>0)){
				await swap(A,s,e,1,true);
				return true;
			}
			return false;
		}
		async function bitPass(A,s,e,d){
			if(s==e)return;
			let m=(e-s)/2|0;
			for(let i=0;i<m;i++)
				await comp(A,s+i,s+m+i,d);
			if(m==e-s)return;
			await bitPass(A,s,s+m,d);
			await bitPass(A,e-m,e,d);
		}
		async function horrorPass(A,s,e){
			for(let i=0;i<e-s;i++){
				await bitPass(A,s,e,true);
				await bitPass(A,s+i,e);
			}
		}
		async function surpass(A,s,e){
			for(let i=s;i<e;i++)
				for(let j=s;j<e;j++)
					for(let k=0;k<e-s;k++)
						if(compareIndices(A,i,j)<0)
							await multiSwap(A,j,i,.05,true);
		}
		async function circlePass(A,s,e){
			if(s==e)return 0;
			let m=(e-s)/2|0,sw=0;
			for(let i=0;i<m;i++)
				if(await comp(A,s+i,e-i-1,true))
					sw++;
			if(m==e-s)return 0;
			sw+=await circlePass(A,s,s+m);
			sw+=await circlePass(A,e-m,e);
			return sw;
		}
		async function circleSort(A,s,e){
			let a=1;
			while(a>0)
				a=await circlePass(A,s,e);
		}
		async function greenHerringPass(A,s,e){
			let h=(e-s)/2|0,a=s+h/2|0,b=e-h/2|0;
			if(a==s||b==e)return;
			await horrorPass(A,s,a);
			await surpass(A,s,a);
			await greenHerringPass(A,a,e);
			await circleSort(A,s,e);
		}
		await greenHerringPass(arr,0,len);
	}
	async weavedStalinSortReplace(len){
		function loprime2(n){
			let p=new Array(n).fill(0);
			pchk:for(let i=2,l=0;i<n;i++){
				for(let j=0;j<l;j++)
					if(i%p[j])continue pchk;
				if(!(n%i))return i;
				p[l++]=i;
			}
			return n;
		}
		let g=len;
		while(g>1){
			g=g/loprime2(g)|0;
			for(let j=0;j<g;j++)
				for(let i=j+g,i1=j;i<len;i+=g)
					if(compareIndices(arr,i1,i)<1)i1=i;
					else await write(arr,i,arr[i1],1,true);
		}
	}
	async miyskiyuSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,0,true);
				return true;
			}
			return false;
		}
		async function sort(A,a,b){
			let l=b-a;
			for(let i=1;i<=l;i++){
				let j=i,g=1;
				while(j+g<=l){
					if(await compSwap(A,j-1,j-1+g)&&j>1)j--;j++;g++;
				}
			}
			await insertSort(A,a,b,.5);
		}
		await sort(arr,0,len);
	}
	async grimmageSort(len){
		const GS=new GrailSorting();
		async function seek(A,s,e){
			let k=s+1,d=compareIndices(A,s,s+1);
			if(!d)d=-1;
			for(let i=s+2;i<e&&k<e-1;i++)if(compareIndices(A,k,i)==d)await multiSwap(A,i,++k,.01,true);
			if(d>0)await reversal(A,s,k,.1,true);
			return k;
		}
		let k=0,r=1;
		while(k<len){
			let t=k;k=await seek(arr,k,len);
			if(r++>1)await GS.grailMergeWithoutBuffer(arr,0,t,k-t);
		}
	}
	async adaptiveSwapMergeSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function insertTo(A,a,b){
			let t=A[a];
			let d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],.25,true);
			if(a-b)await write(A,b,t,.25,true);
		}
		async function insertion(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,rightExpSearch(A,a,i,A[i],false));
		}
		async function smartMerge(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			let i=a,j=m;
			while(i<j&&j<b){
				if(compareValues(A[i],A[j])>0)
					await multiSwap(A,j++,i,.1,true);
				i++;
			}
		}
		async function mergeSort(A,a,b){
			if(b-a<32)return await insertion(A,a,b);
			let m=a+(b-a)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await smartMerge(A,a,m,b);
		}
		await mergeSort(arr,0,len);
	}
	async adaptiveDualPivotQuickSort(len){
		async function insertion(A,a,b){
			for(let i=a+1;i<b;i++){
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
				}
			}
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function quickSort(A,a,b,d){
			let n=b-a;
			if(n<25)return await insertion(A,a,b);
			let p1,p2,s=n/d|0;
			if(compareIndices(A,a+s,b-1-s)>0){
				p1=A[b-1-s];
				p2=A[a+s];
			}else{
				p1=A[a+s];
				p2=A[b-1-s];
			}
			let i=a,j=b;
			for(let k=i;k<j;k++){
				if(compareIndexValue(A,k,p1)<0)
					await swap(A,k,i++,.5,true);
				else if(compareIndexValue(A,k,p2)>0){
					do j--;while(k<j&&compareIndexValue(A,j,p2)>0);
					await swap(A,k,j,.5,true);
					if(compareIndexValue(A,k,p1)<0)
						await swap(A,k,i++,.5,true);
				}
			}
			let lS=await partialInsert(A,a,i),mS=await partialInsert(A,i,j),rS=await partialInsert(A,j,b);
			if(lS&&mS&&rS)return;
			if(minVal(i-a,minVal(j-i,b-j))<25)d++;
			if(compareValues(p1,p2)<0)await quickSort(A,i,j,d);
			await quickSort(A,a,i,d);
			await quickSort(A,j,b,d);
		}
		await quickSort(arr,0,len,3);
	}
	async clarkSort(len){
		async function circle(A,s,e){
			let sw=false;
			for(;s<e;s++,e--)if(compareIndices(A,s,e)>0)await swap(A,s,e,1,sw=true);
			return sw;
		}
		async function sort(A,l){
			let ln=1,as=true,sA=false;
			while(ln*2<l)ln*=2;
			let m=ln,f=ln;
			while(as){
				as=false;
				ln=f;
				for(;ln>1;ln=ln/2|0)
					for(let i=0;i+ln-1<l;i+=ln)
						if(ln-1){
							sA=await circle(A,i,i+ln-1);
							as=as||sA;
						}
				if(as)f=f/4|0;
			}
			if(f-m)await Sorts.prototype.quadSort(l);
		}
		await sort(arr,len);
	}
	async crunchyCourtyardSort(len){
		async function merge(A,tmp,s,m,e){
			if(m-s<=e-m){
				arraycopy(A,s,tmp,0,m-s,0,false,true);
				let i=0,j=m,t=s;
				while(i<m-s&&j<e){
					if(compareValues(tmp[i],A[j])<1)
						await write(A,t++,tmp[i++],1,true);
					else
						await write(A,t++,A[j++],1,true);
				}
				while(i<m-s)
					await write(A,t++,tmp[i++],1,true);
			}else{
				arraycopy(A,m,tmp,0,e-m,0,false,true);
				let i=m-1,j=e-m-1,t=e-1;
				while(i>=s&&j>=0){
					if(compareValues(A[i],tmp[j])>0)
						await write(A,t--,A[i--],1,true);
					else
						await write(A,t--,tmp[j--],1,true);
				}
				while(j>=0)
					await write(A,t--,tmp[j--],1,true);
			}
		}
		async function weakPDMsort(A,s,e){
			let R=new Array(e-s),B=new Array((e-s)/2|0);
			let r=s,rf=0;
			while(r<e){
				write(R,rf++,r,0,false,true);
				while(r<e-1&&compareIndices(A,r,r+1)<1)r++;
				r++;
			}
			write(R,rf++,e,0,false,true);
			while(rf>1){
				let j=0;
				for(let i=0;i<rf;i+=2,j++){
					if(i+1>=rf){
						write(R,j,R[i],0,false,true);
						continue;
					}else if(i+2>=rf)
						await merge(A,B,R[i],R[i+1],e);
					else
						await merge(A,B,R[i],R[i+1],R[i+2]);
					await write(R,j,R[i],0,false,true);
				}
				rf=j;
			}
		}
		function isSorted(A,s,e){
			for(let i=s;i<e;i++){
				if(compareIndices(A,i,i+1)>0)
					return false;
			}
			return true;
		}
		async function sort3(A,a,b,c){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,1,true);
			if(compareIndices(A,b,c)>0){
				await swap(A,b,c,1,true);
				if(compareIndices(A,a,b)>0)
					await swap(A,a,b,1,true);
			}
		}
		async function partition(A,s,e){
			let m=s+(e-s)/2|0,t=(e-s)>>3;
			await sort3(A,s,s+t,s+2*t);
			await sort3(A,m-t,m,m+t);
			await sort3(A,e-2*t,e-t,e);
			await sort3(A,s+t,m,e-t);
			let p=A[m],i=s,j=e;
			while(i<j){
				while(compareValues(A[i],p)<0)i++;
				while(compareValues(A[j],p)>0)j--;
				if(i<j)await swap(A,i,j,1,true);
			}
			return i;
		}
		async function crunchyCourtyard(A,s,e,d){
			if(e-s<24)return await insertSort(A,s,e+1,.25);
			if(!d)return await weakPDMsort(A,s,e+1);
			if(isSorted(A,s,e))return;
			let p=await partition(A,s,e);
			await crunchyCourtyard(A,s,p-1,--d);
			await crunchyCourtyard(A,p,e,d);
		}
		let l=1;
		while(1<<l<=(len/2|0))l++;
		await crunchyCourtyard(arr,0,len-1,2*l);
	}
	async whippingCreamSort(len){
		async function M8FW(A,s,m,e){
			if(s>=m||m>=e)return;
			let l=s,r=m;
			while(r<e&&l<m){
				while(l<m&&compareIndices(A,l,r)<1)l++;
				if(l>=m)return;
				let z=l;
				while(l<m&&r<e&&compareIndices(A,l,r)>0){
					l++;r++;
				}
				await IndexedRotations.juggling(A,z,m,r,1,true);
				await M8(A,z,l,l+r-m);
				m=r;
			}
		}
		async function M8BW(A,s,m,e){
			if(s>=m||m>=e)return;
			let l=m-1,r=e-1;
			while(r>=m&&l>=s){
				while(r>=m&&compareIndices(A,l,r)<1)r--;
				if(r<m)return;
				let z=r;
				while(l>=s&&r>=m&&compareIndices(A,l,r)+1){
					l--;r--;
				}
				await IndexedRotations.juggling(A,l+1,m,z+1,1,true);
				await M8(A,r-m+l+1,r+1,z+1);
				m=l+1;
			}
		}
		async function M8(A,s,m,e){
			if(m-s<e-m)await M8FW(A,s,m,e);
			else await M8BW(A,s,m,e);
		}
		for(let i=1;i<len;i*=2)
			for(let j=0;j<len;j+=2*i){
				if(j+i>len)break;
				if(j+2*i<len)
					await M8(arr,j,j+i,j+2*i);
				else
					await M8(arr,j,j+i,len);
			}
	}
	async lazixioSort(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,l1,l2)=>{
			return Rotations.neon(A,p,l1,l2,.5,true);
		});
		function runs(n){
			let j=1,l=0;
			while(j<n){
				j*=10;
				l++;
			}
			return l*l;
		}
		function sqr(n){
			let l=0,h=n;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(m*m>n)h=m;
				else l=m+1;
			}
			return l;
		}
		function fcrt(n){
			let l=0,h=n;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(m*sqr(m)>n)h=m;
				else l=m+1;
			}
			return l;
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.5,true);
			else await reversal(A,s,e,.5,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,.5,true);
					else await reversal(A,l,r,.5,true);
				}
				i++;
			}
		}
		async function findRun(A,st,m){
			if(st>=m-1)return st+1;
			let c=compareIndices(A,st,++st),s=st-1,d=c,sR=false;
			if(!c){
				sR=true;
				c=-1;
			}
			while(st<m-1&&(d==c||!d)){
				d=compareIndices(A,st,st+1);
				if(!d)sR=true;
				st++;
			}
			if(c>0){
				if(sR)await stableSegmentReversal(A,s,st-1);
				else await reversal(A,s,st-1,.5,true);
			}
			return st;
		}
		async function mergeRuns(A,st,e){
			let z=runs(e-st),x=fcrt(e-st),s=st,r=st,d=0;
			while(r<e){
				let y=await findRun(A,r,e);
				if(y>=r+x){
					await GS.grailMergeWithoutBuffer(A,st,s-st,r-s);
					await GS.grailMergeWithoutBuffer(A,st,r-st,y-r);
					s=r=y;
					d=0;
					continue;
				}
				if(d>0)await GS.grailMergeWithoutBuffer(A,s,r-s,y-r);
				if(d+1==z){
					await GS.grailMergeWithoutBuffer(A,st,s-st,y-s);
					s=y;
				}
				r=y;
				d=(d+1)%z;
			}
			if(d>0)await GS.grailMergeWithoutBuffer(A,st,s-st,r-s);
		}
		await mergeRuns(arr,0,len);
	}
	async blockInsertionSortNeon(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return Rotations.neon(A,p,a,b,1,true);
		});
		async function insert1(A,a,l){
			let t=A[l--],k=0;
			while(l>=a&&compareValues(A[l],t)>0){
				write(A,l+1,A[l--],0);
				if(++k>=sqrt(len))await mark(l+2,k=0);
			}
			await write(A,l+1,t,1,true,false);
		}
		async function insert2(A,a,l,r){
			let tL=A[l--],tR=A[r],k=0;
			while(l>=a&&compareValues(A[l],tR)>0){
				write(A,l+2,A[l--],0);
				if(++k>=sqrt(len))await mark(l+3,k=0);
			}
			await write(A,l+2,tR,1,true);
			while(l>=a&&compareValues(A[l],tL)>0){
				write(A,l+1,A[l--],0);
				if(++k>sqrt(len))await mark(l+2,k=0);
			}
			await write(A,l+1,tL,1,true);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function sort(A,a,b){
			let i,j,l;
			i=await findRun(A,a,b);
			while(i<b){
				j=await findRun(A,i,b);l=j-i;
				if(l<3)
					if(l>1)await insert2(A,a,i,i+1);
					else await insert1(A,a,i);
				else await GS.grailMergeWithoutBuffer(A,a,i-a,l);
				i=j;
			}
		}
		let k=0,kn=sqrt(len);
		await sort(arr,0,len);
	}
	async lazionSort(len){
		const GS=new GrailSorting();
		let base=askForNum(2,"Base",2,sqrt(len)|0);
		GS.setRotation((A,p,a,b)=>{
			return Rotations.neon(A,p,a,b,.5,true);
		});
		function powlte(v,b){
			let n;
			for(n=1;n<=v;n*=b);
			return n/b|0;
		}
		async function merge(A,s,e,b){
			let bL=(e-s)/b|0;
			for(let i=s;i+bL<e;i+=bL)await GS.grailMergeWithoutBuffer(A,s,i-s+bL,bL);
		}
		async function insert1(A,a,l){
			let t=A[l--];
			while(l>=a&&compareValues(A[l],t)>0){
				write(A,l+1,A[l--],0);
				if(++k>=kn){
					mark(l+2);
					await sleep(k=0);
				}
			}
			await write(A,l+1,t,1,true);
		}
		async function insert2(A,a,l,r){
			let tL=A[l--],tR=A[r];
			while(l>=a&&compareValues(A[l],tR)>0){
				write(A,l+2,A[l--],0);
				if(++k>=kn){
					mark(l+3);
					await sleep(k=0);
				}
			}
			await write(A,l+2,tR,1,true);
			while(l>=a&&compareValues(A[l],tL)>0){
				write(A,l+1,A[l--],0);
				if(++k>=kn){
					mark(l+2);
					await sleep(k=0);
				}
			}
			await write(A,l+1,tL,1,true);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function nonBn(A,a,b){
			let i,j,l;
			i=await findRun(A,a,b);
			while(i<b){
				j=await findRun(A,i,b);
				l=j-i;
				if(l<3)
					if(l>1)await insert2(A,a,i,i+1);
					else await insert1(A,a,i);
				else await GS.grailMergeWithoutBuffer(A,a,i-a,l);
				i=j;
			}
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,1,true);
			else await reversal(A,s,e,1,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r)
					if(r-l<3)await swap(A,l,r,1,true);
					else await reversal(A,l,r,1,true);
				i++;
			}
		}
		async function pd(A,s,e){
			let f=s;
			let c=compareIndices(A,f,f+1);
			let u=false;
			while(c<1&&f+1<e){
				if(!c)u=true;
				if(++f+1<e)c=compareIndices(A,f,f+1);
			}
			let r=s;
			if(f==s){
				let d=false;
				c=compareIndices(A,r,r+1);
				while(c+1&&r+1<e){
					if(!c)u=true;
					else d=true;
					if(++r+1<e)c=compareIndices(A,r,r+1);
				}
				if(r>s&&d){
					if(u)await stableSegmentReversal(A,s,r);
					else if(r<s+3)await swap(A,s,r,1,true);
					else await reversal(A,s,r,1,true);
				}
			}
			return maxVal(f,r);
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function pdbinsert(A,s,e){
			let p=await pd(A,s,e),j=0;
			for(let i=p+1;i<e;i++){
				let t=A[i];
				let l=binarySearch(A,s,i,t);
				let w=false;
				for(let r=i;r>l;r--){
					write(A,r,A[r-1],0);
					w=true;
					if(++j>=len){
						mark(r);
						await sleep(j=0);
					}
				}
				if(w)await write(A,l,t,1,true);
			}
		}
		async function mergesLen(A,s,e,ls,b){
			let l=ls;
			for(;l<e-s;l*=b){
				let i=s;
				for(;i+l<=e;i+=l)
					await merge(A,i,i+l,b);
				if(i-e)await nonBn(A,i,e);
			}
			if(l==e-s)await merge(A,s,e,b);
			else await nonBn(A,s,e);
		}
		let k=0,kn=sqrt(len),bL=powlte(kn|0,base),i;
		for(i=0;i+bL<=len;i+=bL)await pdbinsert(arr,i,i+bL);
		if(i<len)await pdbinsert(arr,i,len);
		await mergesLen(arr,0,len,bL,base);
	}
	async lazicciSort(len){
		const GS=new GrailSorting();
		function runs(n){
			let j=1,l=0;
			while(j<n){
				j*=10;
				l++;
			}
			return l*l;
		}
		function sqr(n){
			let l=0,h=n;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(m*m>n)h=m;
				else l=m+1;
			}
			return l;
		}
		function fcrt(n){
			let l=0,h=n;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(m*sqr(m)>n)h=m;
				else l=m+1;
			}
			return l;
		}
		GS.setRotation((A,p,l1,l2)=>{
			return Rotations.cycleReverse(A,p,l1,l2,.5,true);
		});
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.5,true);
			else await reversal(A,s,e,.5,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,.5,true);
					else await reversal(A,l,r,.5,true);
				}
				i++;
			}
		}
		async function findRun(A,st,m){
			if(st>=m-1)return st+1;
			let c=compareIndices(A,st,++st),s=st-1,d=c;
			let sR=false;
			if(!c){
				sR=true;
				c=-1;
			}
			while(s<m-1&&(d==c||!d)){
				d=compareIndices(A,st,++st);
				if(!d)sR=true;
			}
			if(c>0){
				if(sR)await stableSegmentReversal(A,s,st-1);
				else await await reversal(A,s,st-1,1,true);
			}
			return st;
		}
		function findSortedRunBW(A,s,e){
			do e--;while(e>s&&compareIndices(A,e-1,e)<1);
			return maxVal(s,e);
		}
		async function mergeRuns(A,st,e){
			let z=runs(e-st),x=fcrt(e-st),s=st,r=st,d=0;
			while(r<e){
				let y=await findRun(A,r,e);
				if(y>=r+x){
					s=r=y;
					d=0;
					continue;
				}
				if(d>0)await GS.grailMergeWithoutBuffer(A,s,r-s,y-r);
				if(d+1==z)s=y;
				r=y;
				d=(d+1)%z;
			}
			return s;
		}
		async function blockBack(A,s,r,e){
			while(r>s){
				let i=findSortedRunBW(A,s,r);
				await GS.grailMergeWithoutBuffer(A,i,r-i,e-r);
				r=i;
			}
		}
		await blockBack(arr,0,await mergeRuns(arr,0,len),len);
	}
	async nitroSort(len){
		async function combSort(A,a,b,sh){
			let sw=false,g=b;
			let incs=[48,21,7,3,1];
			while(g>1||sw){
				if(g>1)g=g/sh|0;
				sw=false;
				for(let i=0;g+i<b;i++){
					if(g<=minVal(8,b/32)){
						g=0;
						for(let k=0;k<5;k++){
							for(let h=incs[k],l=h+a;l<b;l++){
								let v=A[l],j=l,c=false;
								while(j>=h&&compareValues(A[j-h],v)>0)
									await write(A,j,A[j-=h],1,c=true);
								if(c)await write(A,j,v,.5,true);
							}
						}
						break;
					}
					if(compareIndices(A,i,i+g)>0)
						await swap(A,i,i+g,.75,sw=true);
				}
			}
		}
		await combSort(arr,0,len,1.3);
	}
	async merkSort(len){
		async function circle(A,s,e){
			let i=s,j=e;
			while(i<j)
				if(compareIndices(A,i++,j--)>0)
					await swap(A,i-1,j+1,.1,true);
		}
		async function shellPass(A,a,b,g){
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g,c=false;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],.1,c=true);
					j-=g;
				}
				if(c)await write(A,j+g,k,.1,true);
			}
		}
		async function shell(A,s,e){
			for(let g=e-s;g>0;g=g/2|0)
				await shellPass(A,s,e,g);
		}
		async function sort(A,e){
			let n=2;
			for(;n<=e;n*=2);n/=2;
			let l=n;
			for(;l>1;l=l/2|0)
				for(let i=0;i+l<=n;i+=l)
					await circle(A,i,i+l-1);
			for(l=4;l<=n;l*=2)
				for(let i=0;i+l<=n;i+=l)
					await shell(A,i,i+l);
			if(n-e)await shell(A,0,e);
		}
		await sort(arr,len);
	}
	async naturalEctaSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function multiSwap(A,a,b,l,f){
			if(a==b)return;
			if(f)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i!=b;i+=d)
				await write(A,i,A[i+d],.5,true);
			if(a-b)
				await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3){
					if(p3-p0>2)await reversal(A,p0,p3,1,true);
					else await swap(A,p0,p3,1,true);
				}
			}
		}
		async function mergeFWExt(A,t,a,m,b){
			let s=m-a;
			arraycopy(A,a,t,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(t[i],A[j])<1)
					await write(A,a++,t[i++],1,true);
				else
					await write(A,a++,A[j++],1,true);
			while(i<s)
				await write(A,a++,t[i++],1,true);
		}
		async function mergeBWExt(A,t,a,m,b){
			let s=b-m;
			arraycopy(A,m,t,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(t[i],A[j])+1)
					await write(A,--b,t[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			while(i>=0)
				await write(A,--b,t[i--],1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,t,a,m,b){
			if(minVal(m-a,b-m)<9){
				if(m-a>b-m)
					await inPlaceMergeBW(A,a,m,b);
				else
					await inPlaceMergeFW(A,a,m,b);
			}else if(m-a>b-m)
				await mergeBWExt(A,t,a,m,b);
			else
				await mergeFWExt(A,t,a,m,b);
		}
		async function blockCycle(A,t,k,a,bL,bC){
			for(let i=0;i<bC;i++)
				if(compareValues(i,k[i])){
					arraycopy(A,a+i*bL,t,0,bL,0,false,true);
					let j=i,nx=k[i];
					do{
						await arraycopy(A,a+nx*bL,A,a+j*bL,bL,1,true);
						write(k,j,j,1,false,true);
						j=nx;nx=k[nx];
					}while(compareValues(nx,i));
					await arraycopy(t,0,A,a+j*bL,bL,1,true);
					write(k,j,j,1,true,true);
				}
		}
		async function blockMerge(A,u,g,a,m,b,bL){
			if(minVal(m-a,b-m)<=2*bL)return await merge(A,u,a,m,b);
			let c=0,t=2;
			let i=a,j=m,k=0;
			let l=0,r=0;
			while(c++<2*bL){
				if(compareIndices(A,i,j)<1){
					write(u,k++,A[i++],1,false,true);
					l++;
				}else{
					write(u,k++,A[j++],1,false,true);
					r++;
				}
			}
			let lf=l>=r;
			k=lf?i-l:j-r;
			c=0;
			do{
				if(i<m&&(j==b||compareIndices(A,i,j)<1)){
					await write(A,k++,A[i++],1,true);
					l++;
				}else{
					await write(A,k++,A[j++],1,true);
					r++;
				}
				if(++c==bL){
					write(g,t++,(k-a)/bL-1,0,false,true);
					if(lf)l-=bL;
					else r-=bL;
					lf=l>=r;
					k=lf?i-l:j-r;
					c=0;
				}
			}while(i<m||j<b);
			let b1=b-c;
			await arraycopy(A,k-c,A,b1,c,1,true);
			r-=c;t=k=0;
			while(l>0){
				await arraycopy(u,k,A,m-l,bL,1,true);
				write(g,t++,(m-a-l)/bL,0,false,true);
				k+=bL;l-=bL;
			}
			while(r>0){
				await arraycopy(u,k,A,b1-r,bL,1,true);
				write(g,t++,(b1-a-r)/bL,0,false,true);
				k+=bL;r-=bL;
			}
			await blockCycle(A,u,g,a,bL,(b-a)/bL|0);
		}
		async function smartBlockMerge(A,u,g,a,m,b,bL){
			if(compareIndices(A,m-1,m,.0,true)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareValues(A[a],A[b-1])>0)return await rotate(A,a,m,b);
			if(minVal(m-a,b-m)<=2*bL)
				await merge(A,u,a,m,b);
			else{
				let a1=a+(m-a)%bL;
				await blockMerge(A,u,g,a1,m,b,bL);
				if(a1>a)
					await mergeFWExt(A,u,a,a1,b);
			}
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)
						await swap(A,a,i-1,1.0,true);
					else
						await reversal(A,a,i-1,.5,true);
				}else
					while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			if(l<=32){
				for(let i=await findRun(A,a,b);i<b;i++)
					await insertTo(A,i,rightExpSearch(A,a,i,A[i],false));
				return;
			}
			let bL=1;
			while(bL*bL<l)bL*=2;
			let u=new Array(2*bL);
			let g=new Array(l/bL|0);
			let i,j,k;
			while(1){
				i=await findRun(A,a,b);
				if(i>=b)break;
				j=await findRun(A,i,b);
				await smartBlockMerge(A,u,g,a,i,j,bL);
				if(j>=b)break;
				k=j;
				while(1){
					i=await findRun(A,k,b);
					if(i>=b)break;
					j=await findRun(A,i,b);
					await smartBlockMerge(A,u,g,k,i,j,bL);
					if(j>=b)break;
					k=j;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async adaptiveBufferedMergeSort(len){
		function getMinLevel(n){
			while(n>31)n=(n+1)/2|0;
			return n;
		}
		async function multiSwap(A,a,b,l){
			if(a-b)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0)
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			return binSearch(A,a+i/2|0,minVal(b,a-1+i),v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			return binSearch(A,maxVal(a,b-i+1),b-i/2|0,v,l);
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a;
			await multiSwap(A,a,p,pL);
			let i=0,j=m,k=a;
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+i--,1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function inPlaceMerge(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function merge(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(b-m<m-a)await mergeBW(A,a,m,b,p);
			else await mergeFW(A,a,m,b,p);
		}
		async function lazyBufferedMergeFW(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			let pL=m-a;
			await multiSwap(A,a,p,pL);
			let i=0,j=m,k=a;
			while(i<pL&&j<b){
				if(compareIndices(A,j,p+i)<0){
					let q=leftExpSearch(A,j,b,A[p+i],true);
					while(j<q)await swap(A,k++,j++,1,true);
				}
				await swap(A,k++,p+i++,1,true);
			}
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			let nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,.1,true);
					else await reversal(A,j,i-1,.1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,j=getMinLevel(l);
			if(await buildRuns(A,a,b,j))return;
			while(j<l){
				for(i=a;i+2*j<=b;i+=2*j)await merge(A,i,i+j,i+2*j,p);
				if(i+j<b)await merge(A,i,i+j,b,p);
				j*=2;
			}
		}
		async function sort(A,a,b){
			if(b-a<33)return await buildRuns(A,a,b,b-a);
			let mL=maxVal(16,sqrt(b-a)|0),m=b-(b-a)/2|0;
			await mergeSort(A,m,b,a);
			while(m-a>mL){
				let m1=m-(m-a)/2|0;
				await mergeSort(A,m1,m,a);
				await lazyBufferedMergeFW(A,m1,m,b,a);
				m=m1;
			}
			await buildRuns(A,a,m,m-a);
			await inPlaceMerge(A,a,m,b);
		}
		await sort(arr,0,len);
	}
	async adaptiveEctaSort(len){
		function getMinLevel(n){
			while(n>31)n=(n+1)/2|0;
			return n;
		}
		async function insertTo(A,a,b){
			let t=A[a];
			for(let i=a;i>b;i--)
				await write(A,i,A[i-1],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			let lA=m-a,lB=b-m,p=a;
			let e=p+lA+lB;
			while(lA>0&&lB>0)
				if(lA<lB){
					for(let i=0;i<lA;i++){
						let t=A[p+i],j=p+i+lA;
						for(;j<e;j+=lA)
							await write(A,j-lA,A[j],1,true);
						await write(A,j-lA,t,1,true);
					}
					p+=lB;lB%=lA;lA-=lB;
				}else{
					for(let i=0;i<lB;i++){
						let t=A[p+i+lA],j=p+i+lA-lB;
						for(;j>=p;j-=lB)
							await write(A,j+lB,A[j],1,true);
						await write(A,j+lB,t,1,true);
					}
					e=p+lB;lA%=lB;lB-=lA;
				}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			let nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,1,true);
					else await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)
					await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function checkReverseBounds(A,a,m,b){
			if(compareIndices(A,a,b-1)>0){
				await rotate(A,a,m,b);
				return true;
			}
			return false;
		}
		async function boundCheck(A,a,m,b){
			if(a>=m||m>=b)return true;
			return compareIndices(A,m-1,m)<1||await checkReverseBounds(A,a,m,b);
		}
		async function mergeTo(f,t,a,m,b,p,x){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(f,i,j)<1){
					write(t,p++,f[i++],0,false,x);
					if(!x)await sleep();
				}else{
					write(t,p++,f[j++],0,false,x);
					if(!x)await sleep();
				}
			while(i<m){
				write(t,p++,f[i++],0,false,x);
				if(!x)await sleep();
			}
			while(j<b){
				write(t,p++,f[j++],0,false,x);
				if(!x)await sleep();
			}
		}
		async function mergeFWExt(A,t,a,m,b){
			let s=m-a;
			arraycopy(A,a,t,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(t[i],A[j])<1)
					await write(A,a++,t[i++],1,true);
				else
					await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,t[i++],1,true);
		}
		async function mergeBWExt(A,t,a,m,b){
			let s=b-m;
			arraycopy(A,m,t,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(t[i],A[j])+1)
					await write(A,--b,t[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			while(i>=0)
				await write(A,--b,t[i--],1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,t,a,m,b){
			if(minVal(m-a,b-m)<9){
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			}else if(m-a>b-m)await mergeBWExt(A,t,a,m,b);
			else await mergeFWExt(A,t,a,m,b);
		}
		async function blockCycle(A,b,k,a,bL,bC){
			for(let i=0;i<bC;i++)
				if(compareValues(i,k[i])){
					arraycopy(A,a+i*bL,b,0,bL,0,false,true);
					let j=i,nx=k[i];
					do{
						await arraycopy(A,a+nx*bL,A,a+j*bL,bL,1,true);
						write(k,j,j,0,false,true);
						j=nx;nx=k[nx];
					}while(compareValues(nx,i));
					await arraycopy(b,0,A,a+j*bL,bL,1,true);
					write(k,j,j,0,false,true);
				}
		}
		async function blockMerge(A,u,g,a,m,b,bL){
			let c=0,t=2;
			let i=a,j=m,k=0;
			let l=0,r=0;
			while(c++<2*bL){
				if(compareIndices(A,i,j)<1){
					write(u,k++,A[i++],1,false,true);
					l++;
				}else{
					write(u,k++,A[j++],1,false,true);
					r++;
				}
			}
			let lf=l>=r;
			k=lf?i-l:j-r;c=0;
			do{
				if(i<m&&(j==b||compareIndices(A,i,j)<1)){
					await write(A,k++,A[i++],1,true);
					l++;
				}else{
					await write(A,k++,A[j++],1,true);
					r++;
				}
				if(++c==bL){
					write(g,t++,(k-a)/bL-1,0,false);
					if(lf)l-=bL;
					else r-=bL;
					lf=l>=r;k=lf?i-l:j-r;c=0;
				}
			}while(i<m||j<b);
			let b1=b-c;
			await arraycopy(A,k-c,A,b1,c,1,true);
			r-=c;t=k=0;
			while(l>0){
				await arraycopy(u,k,A,m-l,bL,1,true);
				write(g,t++,(m-a-l)/bL,0,false,true);
				k+=bL;l-=bL;
			}
			while(r>0){
				await arraycopy(u,k,A,b1-r,bL,1,true);
				write(g,t++,(b1-a-r)/bL,0,false,true);
				k+=bL;r-=bL;
			}
			await blockCycle(A,u,g,a,bL,(b-a)/bL|0);
		}
		async function smartMerge(A,u,a,m,b){
			if(await boundCheck(A,a,m,b))return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(await checkReverseBounds(A,a,m,b))return;
			await merge(A,u,a,m,b);
		}
		async function pingPongMerge(A,u,a,m1,m2,m3,b){
			let p=0,p1=p+m2-a,pE=p+b-a;
			if(compareIndices(A,m1-1,m1)>0||(m3<b&&compareIndices(A,m3-1,m3)>0)){
				await mergeTo(A,u,a,m1,m2,p,true);
				await mergeTo(A,u,m2,m3,b,p1,true);
				await mergeTo(u,A,p,p1,pE,a,false);
			}else await smartMerge(A,u,a,m2,b);
		}
		async function smartBlockMerge(A,u,g,a,m,b,bL){
			if(await boundCheck(A,a,m,b))return;
			let s=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(await checkReverseBounds(A,s,m,b))return;
			if(minVal(m-s,b-m)<=2*bL)
				await merge(A,u,s,m,b);
			else{
				s-=(s-a)%bL;
				await blockMerge(A,u,g,s,m,b,bL);
			}
		}
		async function blockMergeSort(A,a,b){
			let l=b-a;
			if(l<128){
				let j=getMinLevel(l);
				if(await buildRuns(A,a,b,j))return;
				let t=new Array(l/2|0),i;
				for(;j<l;j*=2){
					for(i=a;i+2*j<=b;i+=2*j)
						await smartMerge(A,t,i,i+j,i+2*j);
					if(i+j<b)
						await smartMerge(A,t,i,i+j,b);
				}
				return;
			}
			let j=getMinLevel(l),bL;
			for(bL=j;bL*bL<l;bL*=2);
			let tL=l/bL|0,uL=2*bL;
			if(await buildRuns(A,a,b,j))return;
			let u=new Array(uL),i;
			for(;4*j<=uL;j*=4){
				for(i=a;i+2*j<b;i+=4*j)
					await pingPongMerge(A,u,i,i+j,i+2*j,minVal(i+3*j,b),minVal(i+4*j,b));
				if(i+j<b)
					await smartMerge(A,u,i,i+j,b);
			}
			for(;j<=uL;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await smartMerge(A,u,i,i+j,i+2*j);
				if(i+j<b)
					await smartMerge(A,u,i,i+j,b);
			}
			let g=new Array(tL);
			for(;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await smartBlockMerge(A,u,g,i,i+j,i+2*j,bL);
				if(i+j<b)
					await smartBlockMerge(A,u,g,i,i+j,b,bL);
			}
		}
		await blockMergeSort(arr,0,len);
	}
	async ghastSort(len){
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			let nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,1,true);
					else await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)
					await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function mergeFW(A,s,m,e){
			if(s>=m||m>=e)return;
			let l=s,r=m;
			while(r<e&&l<m){
				while(l<m&&compareIndices(A,l,r)<1)l++;
				if(l>=m)return;
				let z=l;
				while(l<m&&r<e&&compareIndices(A,l,r)>0){
					l++;
					r++;
				}
				await IndexedRotations.juggling(A,z,m,r,1,true);
				await merge(A,z,l,l+r-m);
				m=r;
			}
		}
		async function mergeBW(A,s,m,e){
			if(s>=m||m>=e)return;
			let l=m-1,r=e-1;
			while(r>=m&&l>=s){
				while(r>=m&&compareIndices(A,l,r)<1)r--;
				if(r<m)return;
				let z=r;
				while(l>=s&&r>=m&&compareIndices(A,l,r)+1){
					l--;
					r--;
				}
				await IndexedRotations.juggling(A,l+1,m,z+1,1,true);
				await merge(A,r-m+l+1,r+1,z+1);
				m=l+1;
			}
		}
		async function merge(A,l,m,r){
			if(compareIndices(A,m-1,m)<1)return;
			l=leftExpSearch(A,l,m,A[m],false);
			r=rightExpSearch(A,m,r,A[m-1],true);
			if(compareIndices(A,l,r-1)>0)return await IndexedRotations.juggling(A,l,m,r,1,true);
			if(m-l<=r-m)
				await mergeFW(A,l,m,r);
			else
				await mergeBW(A,l,m,r);
		}
		async function mergeSort(A,a,b){
			let j=16;
			if(await buildRuns(A,a,b,j))return;
			for(;j<b-a;j*=2)
				for(let i=a;i+j<b;i+=2*j)
					await merge(A,i,i+j,minVal(i+2*j,b));
		}
		await mergeSort(arr,0,len);
	}
	async holyGrailSort(len){
		let XB,XBL,CBL,CBO;
		let cmp={
			compare:function(a,b){
				return compareValues(a,b);
			}
		}
		async function swp(A,a,b){
			await swap(A,a,b,1,true);
		}
		async function swapBlocksForwards(A,a,b,l){
			for(let i=0;i<l;i++)
				await swp(A,a+i,b+i);
		}
		async function swapBlocksBackwards(A,a,b,l){
			for(let i=l-1;i>=0;i--)
				await swp(A,a+i,b+i);
		}
		async function shiftForwards(A,s,l){
			let i=A[s];
			await arraycopy(A,s+1,A,s,l,1,true);
			await write(A,s+l,i,1,true);
		}
		async function shiftBackwards(A,s,l){
			let i=A[s+l];
			await arraycopy(A,s,A,s+1,l,1,true);
			await write(A,s,i,1,true);
		}
		async function rotate(A,s,lL,rL){
			let mL=lL<=rL?lL:rL;
			while(mL>1){
				if(lL<=rL){
					do{
						await swapBlocksForwards(A,s,s+lL,lL);
						s+=lL;rL-=lL;
					}while(lL<=rL);
					mL=rL;
				}else{
					do{
						await swapBlocksBackwards(A,s+lL-rL,s+lL,rL);
						lL-=rL;
					}while(lL>rL);
					mL=lL;
				}
			}
			if(mL==1){
				if(lL==1)await shiftForwards(A,s,rL);
				else await shiftBackwards(A,s,lL);
			}
		}
		async function insertion(A,s,l,cmp){
			for(let i=1;i<l;i++){
				let j=s+i;
				let t=A[j];
				if(cmp.compare(A[j-1],t)<1)continue;
				if(cmp.compare(A[s],t)>0){
					await shiftBackwards(A,s,i);
					continue;
				}
				do await write(A,j,A[--j],1,true);while(cmp.compare(A[j-1],t)>0);
				await write(A,j,t,1,true);
			}
		}
		function binarySearchLeft(A,s,n,t,cmp){
			let l=0;
			let r=n;
			while(l<r){
				let m=(l+r)>>>1;
				if(cmp.compare(A[s+m],t)<0)l=m+1;
				else r=m;
			}
			return l;
		}
		function binarySearchRight(A,s,n,t,cmp){
			let l=0;
			let r=n;
			while(l<r){
				let m=(l+r)>>>1;
				if(cmp.compare(A[s+m],t)>0)r=m;
				else l=m+1;
			}
			return r;
		}
		function binarySearchExclusive(A,s,n,t,cmp){
			let l=0;
			let r=n;
			while(l<r){
				let m=(l+r)>>>1;
				let c=cmp.compare(A[s+m],t);
				if(!c)return-1;
				else if(c<0)l=m+1;
				else r=m;
			}
			return l;
		}
		async function collectKeys(A,s,l,iK,cmp){
			let kF=1;
			let fK=0;
			let cK=1;
			while(cK<l&&kF<iK){
				let iP=binarySearchExclusive(A,s+fK,kF,A[s+cK],cmp);
				if(iP+1){
					await rotate(A,s+fK,kF,cK-fK-kF);
					fK=cK-kF;
					if(kF-iP)
						await shiftBackwards(A,s+fK+iP,kF-iP);
					kF++;
				}
				cK++;
			}
			await rotate(A,s,fK,kF);
			return kF;
		}
		async function sortPairsWithKeys(A,s,l,cmp){
			let fK=A[s-1];
			let sK=A[s-2];
			await sortPairs(A,s,l,cmp);
			await write(A,s+l-2,fK,1,true);
			await write(A,s+l-1,sK,1,true);
		}
		async function sortPairs(A,s,n,cmp){
			let i;
			for(i=1;i<n;i+=2){
				let l=s+i-1;
				let r=s+i;
				if(cmp.compare(A[l],A[r])>0){
					await write(A,l-2,A[r],1,true);
					await write(A,r-2,A[l],1,true);
				}else{
					await write(A,l-2,A[l],1,true);
					await write(A,r-2,A[r],1,true);
				}
			}
			let l=s+i-1;
			if(l<s+n)
				await write(A,l-2,A[l],1,true);
		}
		async function mergeForwards(A,s,lL,rL,bO,cmp){
			let b=s-bO;
			let l=s;
			let m=s+lL;
			let r=m;
			let e=m+rL;
			while(r<e){
				if(l==m||cmp.compare(A[l],A[r])>0)await swp(A,b,r++);
				else await swp(A,b,l++);
				b++;
			}
			if(b-l)await swapBlocksForwards(A,b,l,m-l);
		}
		async function mergeBackwards(A,s,lL,rL,bO,cmp){
			let e=s-1;
			let l=e+lL;
			let m=l;
			let r=m+rL;
			let b=r+bO;
			while(l>e){
				if(r==m||cmp.compare(A[l],A[r])>0)await swp(A,b,l--);
				else await swp(A,b,r--);
				b--;
			}
			if(r-b)
				await swapBlocksBackwards(A,b,r,r-m);
		}
		async function mergeForwardsOutOfPlace(A,s,lL,rL,bO,cmp){
			let b=s-bO;
			let l=s;
			let m=s+lL;
			let r=m;
			let e=m+rL;
			while(r<e){
				if(l==m||cmp.compare(A[l],A[r])>0)await write(A,b,A[r++],1,true);
				else await write(A,b,A[l],1,true);
				b++;
			}
			if(b-l)
				await arraycopy(A,l,A,b,m-l,1,true);
		}
		async function mergeBackwardsOutOfPlace(A,s,lL,rL,bO,cmp){
			let e=s-1;
			let l=e+lL;
			let m=l;
			let r=m+rL;
			let b=r+bO;
			while(l>e){
				if(r==m||cmp.compare(A[l],A[r])>0)await write(A,b,A[l--],1,true);
				else await write(A,b,A[r--],1,true);
				b--;
			}
			if(r-b)
				await arraycopy(A,r,A,b,r-m,1,true);
		}
		async function buildInPlace(A,s,l,cL,bL,cmp){
			for(let mL=cL;mL<bL;mL*=2){
				let fM=2*mL;
				let mI;
				let mE=s+l-fM;
				let bO=mL;
				for(mI=s;mI<=mE;mI+=fM)
					await mergeForwards(A,mI,mL,mL,bO,cmp);
				let lo=l-mI+s;
				if(lo>mL)await mergeForwards(A,mI,mL,lo-mL,bO,cmp);
				else await rotate(A,mI-mL,mL,lo);
				s-=mL;
			}
			let fM=2*bL;
			let lB=l%fM;
			let lO=s+l-lB;
			if(lB<=bL)await rotate(A,lO,lB,bL);
			else await mergeBackwards(A,lO,bL,lB-bL,bL,cmp);
			for(let mI=lO-fM;mI>=s;mI-=fM)
				await mergeBackwards(A,mI,bL,bL,bL,cmp);
		}
		async function buildOutOfPlace(A,s,l,bL,xL,cmp){
			arraycopy(A,s-xL,XB,0,xL,0,false,true);
			await sortPairs(A,s,l,cmp);
			let mL;s-=2;
			for(mL=2;mL<xL;mL*=2){
				let fM=2*mL;
				let mI;
				let mE=s+l-fM;
				let bO=mL;
				for(mI=s;mI<=mE;mI+=fM)
					await mergeForwardsOutOfPlace(A,mI,mL,mL,bO,cmp);
				let lO=l-mI+s;
				if(lO>mL)await mergeForwardsOutOfPlace(A,mI,mL,lO-mL,bO,cmp);
				else await arraycopy(A,mI,A,mI-mL,lO,1,true);
				s-=mL;
			}
			if(xL==bL){
				let fM=2*bL;
				let lB=l%fM;
				let lO=s+l-lB;
				if(lB<=bL)await arraycopy(A,lO,A,lO+bL,lB,1,true);
				else await mergeBackwardsOutOfPlace(A,lO,bL,lB-bL,bL,cmp);
				for(let mI=lO-fM;mI>=s;mI-=fM)
					await mergeBackwardsOutOfPlace(A,mI,bL,bL,bL,cmp);
			}else{
				await arraycopy(XB,0,A,s+l,xL,1,true);
				await buildInPlace(A,s,l,mL,bL,cmp);
			}
		}
		async function buildBlocks(A,s,l,bL,cmp){
			if(XB!=null){
				let xL;
				if(bL<XBL)xL=bL;
				else{
					xL=1;
					while(xL*2<=XBL)xL*=2;
				}
				await buildOutOfPlace(A,s,l,bL,xL,cmp);
			}else{
				await sortPairsWithKeys(A,s,l,cmp);
				await buildInPlace(A,s-2,l,2,bL,cmp);
			}
		}
		async function sortBlocks(A,fK,s,kC,lBs,blL,sbt,cmp){
			if(kC==lBs)return;
			let cI=sbt?blL-1:0;
			let blI=s;
			let kI=fK;
			let rB=s+lBs*blL;
			let rK=fK+lBs;
			let sr=true;
			do{
				if(cmp.compare(A[rB+cI],A[blI+cI])<0){
					await swapBlocksForwards(A,blI,rB,blL);
					await swp(A,kI,rK);
					sr=false;
				}
				blI+=blL;
				kI++;
			}while(sr&&kI<rK);
			if(sr)return;
			let lK=fK+kC-1;
			let sE=rK<lK?rK+1:rK;
			while(kI<rK){
				let sBl=rB;
				let sK=rK;
				let cB=rB+blL;
				for(let cK=rK+1;cK<=sE;cK++,cB+=blL){
					let c=cmp.compare(A[cB+cI],A[sBl+cI]);
					if(c<0||(!c&&cmp.compare(A[cK],A[sK])<0)){
						sBl=cB;
						sK=cK;
					}
				}
				await swapBlocksForwards(A,blI,sBl,blL);
				await swp(A,kI,sK);
				if(sK==sE&&sE<lK)sE++;
				blI+=blL;
				kI++;
			}
			while(sE<lK){
				let sBl=blI;
				let sK=kI;
				let cB=blI+blL;
				for(let cK=kI+1;cK<=sE;cK++,cB+=blL){
					let c=cmp.compare(A[cB+cI],A[sBl+cI]);
					if(c<0||(!c&&cmp.compare(A[cK],A[sK])<0)){
						sBl=cB;
						sK=cK;
					}
				}
				if(sK!=kI){
					await swapBlocksForwards(A,blI,sBl,blL);
					await swp(A,kI,sK);
					if(sK==sE)sE++;
				}
				blI+=blL;kI++;
				if(kI==sE)return;
			}
			do{
				let sBl=blI;
				let sK=kI;
				let cB=blI+blL;
				for(let cK=kI+1;cK<=lK;cK++,cB+=blL){
					let c=cmp.compare(A[cB+cI],A[sBl+cI]);
					if(c<0||(!c&&cmp.compare(A[cK],A[sK])<0)){
						sBl=cB;
						sK=cK;
					}
				}
				if(sK!=kI){
					await swapBlocksForwards(A,blI,sBl,blL);
					await swp(A,kI,sK);
				}
				blI+=blL;
				kI++;
			}while(kI<lK);
		}
		function getSubA(A,c,m,cmp){
			return cmp.compare(A[c],m)<0?0:1;
		}
		function countLastMergeBlocks(A,o,bC,blL,cmp){
			let bTM=0;
			let lF=o+bC*blL;
			let pB=lF-blL;
			while(bTM<bC&&cmp.compare(A[lF],A[pB])<0){
				bTM++;pB-=blL;
			}
			return bTM;
		}
		async function localMergeForwards(A,s,lL,lO,rL,bO,cmp){
			let b=s-bO;
			let l=s;
			let m=s+lL;
			let r=m;
			let e=m+rL;
			if(!lO){
				while(l<m&&r<e){
					if(cmp.compare(A[l],A[r])<1)
						await swp(A,b,l++);
					else
						await swp(A,b,r++);
					b++;
				}
			}else{
				while(l<m&&r<e){
					if(cmp.compare(A[l],A[r])<0)
						await swp(A,b,l++);
					else
						await swp(A,b,r++);
					b++;
				}
			}
			if(l<m){
				let lF=m-l;
				await swapBlocksBackwards(A,l,e-lF,lF);
				CBL=lF;
			}else{
				CBL=e-r;
				if(!lO)CBO=1;
				else CBO=0;
			}
		}
		async function localMergeBackwards(A,s,lL,rL,rO,bO,cmp){
			let e=s-1;
			let l=e+lL;
			let m=l;
			let r=m+rL;
			let b=r+bO;
			if(rO){
				while(l>e&&r>m){
					if(cmp.compare(A[l],A[r])>0)
						await swp(A,b,l--);
					else
						await swp(A,b,r--);
					b--;
				}
			}else{
				while(l>e&&r>m){
					if(cmp.compare(A[l],A[r])+1)
						await swp(A,b,l--);
					else
						await swp(A,b,r--);
					b--;
				}
			}
			if(r>m){
				let rF=r-m;
				await swapBlocksForwards(A,e+1,m+1,rF);
				CBL=rF;
			}else{
				CBL=l-e;
				if(rO)CBO=0;
				else CBO=1;
			}
		}
		async function localLazyMerge(A,s,lL,lO,rL,cmp){
			let m=s+lL;
			if(!lO){
				if(cmp.compare(A[m-1],A[m])>0){
					while(lL){
						let mL=binarySearchLeft(A,m,rL,A[s],cmp);
						if(mL){
							await rotate(A,s,lL,mL);
							s+=mL;m+=mL;rL-=mL;
						}
						if(!rL){
							CBL=lL;
							return;
						}else{
							do{
								s++;
								lL--;
							}while(lL&&cmp.compare(A[s],A[m])<1);
						}
					}
				}
			}else{
				if(cmp.compare(A[m-1],A[m])+1){
					while(lL){
						let mL=binarySearchRight(A,m,rL,A[s],cmp);
						if(mL){
							await rotate(A,s,lL,mL);
							s+=mL;m+=mL;rL-=mL;
						}
						if(!rL){
							CBL=lL;
							return;
						}else{
							do{
								s++;
								lL--;
							}while(lL&&cmp.compare(A[s],A[m])<0);
						}
					}
				}
			}
			CBL=rL;
			if(!lO)CBO=1;
			else CBO=0;
		}
		async function localMergeForwardsOutOfPlace(A,s,lL,lO,rL,bO,cmp){
			let b=s-bO;
			let l=s;
			let m=s+lL;
			let r=m;
			let e=m+rL;
			if(!lO){
				while(l<m&&r<e){
					if(cmp.compare(A[l],A[r])<1)
						await write(A,b,A[l++],1,true);
					else
						await write(A,b,A[r++],1,true);
					b++;
				}
			}else{
				while(l<m&&r<e){
					if(cmp.compare(A[l],A[r])<0)
						await write(A,b,A[l++],1,true);
					else
						await write(A,b,A[r++],1,true);
					b++;
				}
			}
			if(l<m){
				let lF=m-l;
				await arraycopy(A,l,A,e-lF,lF,1,true);
				CBL=lF;
			}else{
				CBL=e-r;
				if(!lO)CBO=1;
				else CBO=0;
			}
		}
		async function localMergeBackwardsOutOfPlace(A,s,lL,rL,rO,bO,cmp){
			let e=s-1;
			let l=e+lL;
			let m=l;
			let r=m+rL;
			let b=r+bO;
			if(rO){
				while(l>e&&r>m){
					if(cmp.compare(A[l],A[r])>0)
						await write(A,b,A[l--],1,true);
					else
						await write(A,b,A[r--],1,true);
					b--;
				}
			}else{
				while(l>e&&r>m){
					if(cmp.compare(A[l],A[r])+1)
						await write(A,b,A[l--],1,true);
					else
						await write(A,b,A[r--],1,true);
					b--;
				}
			}
			if(r>m){
				let rF=r-m;
				await arraycopy(A,m+1,A,e+1,rF,1,true);
				CBL=rF;
			}else{
				CBL=l-e;
				if(rO)CBO=0;
				else CBO=1;
			}
		}
		async function mergeBlocksForwards(A,fK,mK,s,blC,blL,lMB,lL,cmp){
			let b;
			let cBl;
			let nB=s+blL;
			CBL=blL;
			CBO=getSubA(A,fK,mK,cmp);
			for(let kI=1;kI<blC;kI++,nB+=blL){
				cBl=nB-CBL;
				let nBO=getSubA(A,fK+kI,mK,cmp);
				if(nBO!=CBO){
					await localMergeForwards(A,cBl,CBL,CBO,blL,blL,cmp);
				}else{
					b=cBl-blL;
					await swapBlocksForwards(A,b,cBl,CBL);
					CBL=blL;
				}
			}
			cBl=nB-CBL;
			b=cBl-blL;
			if(lL){
				if(CBO){
					await swapBlocksForwards(A,b,cBl,CBL);
					cBl=nB;
					CBL=blL*lMB;
					CBO=0;
				}else
					CBL+=blL*lMB;
				await mergeForwards(A,cBl,CBL,lL,blL,cmp);
			}else
				await swapBlocksForwards(A,b,cBl,CBL);
		}
		async function lazyMergeBlocks(A,fK,mK,s,blC,blL,lMB,lL,cmp){
			let cB;
			let nB=s+blL;
			CBL=blL;
			CBO=getSubA(A,fK,mK,cmp);
			for(let kI=1;kI<blC;kI++,nB+=blL){
				cB=nB-CBL;
				let nBO=getSubA(A,fK+kI,mK,cmp);
				if(nBO!=CBO)
					await localLazyMerge(A,cB,CBL,CBO,blL,cmp);
				else
					CBL=blL;
			}
			cB=nB-CBL;
			if(lL){
				if(CBO){
					cB=nB;
					CBL=blL*lMB;
					CBO=0;
				}else
					CBL+=blL*lMB;
				await lazyMergeBackwards(A,cB,CBL,lL,cmp);
			}
		}
		async function mergeBlocksBackwards(A,fK,mK,s,blC,blL,lL,cmp){
			let nB,b;
			nB=s+blC*blL-1;
			b=nB+lL+blL;
			CBL=lL;
			CBO=1;
			for(let kI=blC-1;kI>=0;kI--,nB-=blL){
				let nBO=getSubA(A,fK+kI,mK,cmp);
				if(nBO!=CBO){
					await localMergeBackwards(A,nB-blL+1,blL,CBL,CBO,blL,cmp);
				}else{
					b=nB+blL+1;
					await swapBlocksBackwards(A,nB+1,b,CBL);
					CBL=blL;
				}
			}
			await swapBlocksBackwards(A,s,s+blL,CBL);
		}
		async function mergeBlocksForwardsOutOfPlace(A,fK,mK,s,blC,blL,lMB,lL,cmp){
			let b,cB;
			let nK=s+blL;
			CBL=blL;
			CBO=getSubA(A,fK,mK,cmp);
			for(let kI=1;kI<blC;kI++,nK+=blL){
				cB=nK-CBL;
				let nBO=getSubA(A,fK+kI,mK,cmp);
				if(nBO!=CBO)
					await localMergeForwardsOutOfPlace(A,cB,CBL,CBO,blL,blL,cmp);
				else{
					b=cB-blL;
					await arraycopy(A,cB,A,b,CBL,1,true);
					CBL=blL;
				}
			}
			cB=nK-CBL;
			b=cB-blL;
			if(lL){
				if(CBO){
					await arraycopy(A,cB,A,b,CBL,1,true);
					cB=nK;
					CBL=blL*lMB;
					CBO=0;
				}else
					CBL+=blL*lMB;
				await mergeForwardsOutOfPlace(A,cB,CBL,lL,blL,cmp);
			}else
				await arraycopy(A,cB,A,b,CBL,1,true);
		}
		async function mergeBlocksBackwardsOutOfPlace(A,fK,mK,s,blC,blL,lL,cmp){
			let nB;
			let b;
			nB=s+(blC*blL)-1;
			b=nB+lL+blL;
			CBL=lL;
			CBO=1;
			for(let kI=blC-1;kI>=0;kI--,nB-=blL){
				let nBO=getSubA(A,fK+kI,mK,cmp);
				if(nBO!=CBO)
					await localMergeBackwardsOutOfPlace(A,nB-blL+1,blL,CBL,CBO,blL,cmp);
				else{
					b=nB+blL+1;
					await arraycopy(A,nB+1,A,b,CBL,1,true);
					CBL=blL;
				}
			}
			await arraycopy(A,s,A,s+blL,CBL,1,true);
		}
		async function combineForwards(A,fK,s,l,sAL,blL){
			let c=cmp;
			let mL=2*sAL;
			let fMs=l/mL|0;
			let blC=mL/blL|0;
			let lBAS=l-mL*fMs;
			let fFL=0;
			if(lBAS<=sAL){
				if(fMs%2!=0){
					fFL=lBAS;
				}
				l-=lBAS;
				lBAS=0;
			}
			let lBs=sAL/blL|0;
			let mK=A[fK+lBs];
			for(let mI=0;mI<fMs;mI++){
				let o=s+(mI*mL);
				await sortBlocks(A,fK,o,blC,lBs,blL,false,c);
				await mergeBlocksForwards(A,fK,mK,o,blC,blL,0,0,c);
				await insertion(A,fK,blC,c);
			}
			let o=s+fMs*mL;
			if(lBAS!=0){
				blC=lBAS/blL|0;
				await sortBlocks(A,fK,o,blC,lBs,blL,false,c);
				let lFr=lBAS-(blC*blL);
				let lMB=0;
				if(lFr)lMB=countLastMergeBlocks(A,o,blC,blL,c);
				let sMs=blC-lMB;
				if(!sMs){
					let lL=lMB*blL;
					await mergeForwards(A,o,lL,lFr,blL,c);
				}else
					await mergeBlocksForwards(A,fK,mK,o,sMs,blL,lMB,lFr,c);
				await insertion(A,fK,blC,c);
				if(fMs%2<1&&fMs)
					await swapBlocksBackwards(A,o-blL,o,lBAS);
			}else{
				if(!fFL){
					if(fMs%2&&fMs-1)
						await swapBlocksBackwards(A,o-blL-mL,o-blL,mL);
				}else
					await swapBlocksForwards(A,o-blL,o,fFL);
			}
		}
		async function lazyCombine(A,fK,s,l,sAL,blL){
			let c=cmp;
			let fM=2*sAL;
			let mC=l/fM|0;
			let blC=fM/blL|0;
			let lSAS=l-(fM*mC);
			if(lSAS<=sAL){
				l-=lSAS;
				lSAS=0;
			}
			let lBs=sAL/blL|0;
			let mK=A[fK+lBs];
			for(let mI=0;mI<mC;mI++){
				let o=s+(mI*fM);
				await sortBlocks(A,fK,o,blC,lBs,blL,false,c);
				await lazyMergeBlocks(A,fK,mK,o,blC,blL,0,0,c);
				await insertion(A,fK,blC,c);
			}
			let o=s+(mC*fM);
			if(lSAS){
				blC=lSAS/blL|0;
				await sortBlocks(A,fK,o,blC,lBs,blL,false,c);
				let lFr=lSAS-(blC*blL);
				let lMB=0;
				if(lFr)lMB=countLastMergeBlocks(A,o,blC,blL,c);
				let sMs=blC-lMB;
				if(!sMs){
					let lL=lMB*blL;
					await lazyMergeBackwards(A,o,lL,lFr,c);
				}else
					await lazyMergeBlocks(A,fK,mK,o,sMs,blL,lMB,lFr,c);
				await insertion(A,fK,blC,c);
			}
		}
		async function combineBackwards(A,fK,s,l,sAL,blL){
			let c=cmp;
			let mL=2*sAL;
			let fMs=l/mL|0;
			let lSAS=l-mL*fMs;
			if(lSAS<=sAL){
				l-=lSAS;
				lSAS=0;
			}
			let blC=lSAS/blL|0;
			let lBs=sAL/blL|0;
			let mK=A[fK+lBs];
			if(lSAS){
				let o=s+fMs*mL;
				if(lSAS-sAL<=blL){
					await mergeBackwards(A,o,sAL,lSAS-sAL,blL,c);
				}else{
					await sortBlocks(A,fK,o,blC,lBs,blL,true,c);
					let lFr=lSAS-blC*blL;
					await mergeBlocksBackwards(A,fK,mK,o,blC,blL,lFr,c);
					await insertion(A,fK,blC,c);
				}
			}
			blC=mL/blL|0;
			for(let mI=fMs-1;mI>=0;mI--){
				let o=s+mI*mL;
				await sortBlocks(A,fK,o,blC,lBs,blL,true,c);
				await mergeBlocksBackwards(A,fK,mK,o,blC,blL,0,c);
				await insertion(A,fK,blC,c);
			}
		}
		async function combineForwardsOutOfPlace(A,fK,s,l,sAL,blL){
			let c=cmp;
			let fM=2*sAL;
			let mrC=l/fM|0;
			let blC=fM/blL|0;
			let lSAS=l-fM*mrC;
			let rsL=0;
			if(lSAS<=sAL){
				if(mrC%2)
					rsL=lSAS;
				l-=lSAS;
				lSAS=0;
			}
			let lBs=sAL/blL|0;
			let mK=A[fK+lBs];
			for(let mI=0;mI<mrC;mI++){
				let o=s+mI*fM;
				await sortBlocks(A,fK,o,blC,lBs,blL,false,c);
				await mergeBlocksForwardsOutOfPlace(A,fK,mK,o,blC,blL,0,0,c);
				await insertion(A,fK,blC,c);
			}
			let o=s+mrC*fM;
			if(lSAS){
				blC=lSAS/blL|0;
				await sortBlocks(A,fK,o,blC,lBs,blL,false,c);
				let lFr=lSAS-blC*blL;
				let lMB=0;
				if(lFr)lMB=countLastMergeBlocks(A,o,blC,blL,c);
				let sMs=blC-lMB;
				if(!sMs){
					let lL=lMB*blL;
					await mergeForwardsOutOfPlace(A,o,lL,lFr,blL,c);
				}else
					await mergeBlocksForwardsOutOfPlace(A,fK,mK,o,sMs,blL,lMB,lFr,c);
				await insertion(A,fK,blC,c);
				if(mrC%2<1&&mrC)
					await arraycopy(A,o-blL,A,o,lSAS,1,true);
			}else{
				if(!rsL){
					if(mrC%2&&mrC-1)
						await arraycopy(A,o-blL-fM,A,o-blL,fM,1,true);
				}else
					await StWrites.arraycopy(A,o,A,o-blL,rsL,1,true);
			}
		}
		async function combineBackwardsOutOfPlace(A,fK,s,l,sAL,blL){
			let c=cmp;
			let mL=2*sAL;
			let fMs=l/mL|0;
			let lSAS=l-mL*fMs;
			if(lSAS<=sAL){
				l-=lSAS;
				lSAS=0;
			}
			let blC=lSAS/blL|0;
			let lBs=sAL/blL|0;
			let mK=A[fK+lBs];
			if(lSAS){
				let o=s+fMs*mL;
				if(lSAS-sAL<=blL)
					await mergeBackwards(A,o,sAL,lSAS-sAL,blL,c);
				else{
					await sortBlocks(A,fK,o,blC,lBs,blL,true,c);
					let lFr=lSAS-blC*blL;
					await mergeBlocksBackwardsOutOfPlace(A,fK,mK,o,blC,blL,lFr,c);
					await insertion(A,fK,blC,c);
				}
			}
			blC=mL/blL|0;
			for(let mI=fMs-1;mI>=0;mI--){
				let o=s+mI*mL;
				await sortBlocks(A,fK,o,blC,lBs,blL,true,c);
				await mergeBlocksBackwardsOutOfPlace(A,fK,mK,o,blC,blL,0,c);
				await insertion(A,fK,blC,c);
			}
		}
		async function combineBlocks(A,s,l,bL,sAL,blL,kL,iB){
			let dr=0;
			sAL*=2;
			let xB=XB;
			if(iB){
				if(xB==null){
					while(l-bL>sAL){
						if(!dr){
							await combineForwards(A,s,s+bL,l-bL,sAL,blL);
							dr=1;
						}else{
							await combineBackwards(A,s,s+kL,l-bL,sAL,blL);
							dr=0;
						}
						sAL*=2;
					}
				}else{
					while((l-bL)>sAL){
						if(!dr){
							await combineForwardsOutOfPlace(A,s,s+bL,l-bL,sAL,blL);
							dr=1;
						}else{
							await combineBackwardsOutOfPlace(A,s,s+kL,l-bL,sAL,blL);
							dr=0;
						}
						sAL*=2;
					}
				}
			}else{
				let kB=kL/2|0;
				await insertion(A,s,kB,cmp);
				if(xB==null){
					while(kB>=(2*sAL/kB|0)){
						if(!dr){
							await combineForwards(A,s,s+kL,l-kL,sAL,kB);
							dr=1;
						}else{
							await combineBackwards(A,s,s+kB,l-kL, sAL,kB);
							dr=0;
						}
						sAL*=2;
					}
				}else{
					while(kB>=(2*sAL/kB|0)){
						if(!dr){
							await combineForwardsOutOfPlace(A,s,s+kL,l-kL,sAL,kB);
							dr=1;
						}else{
							await combineBackwardsOutOfPlace(A,s,s+kB,l-kL,sAL,kB);
							dr=0;
						}
						sAL*=2;
					}
				}
				if(dr){
					let bO=s+kB;
					await swapBlocksBackwards(A,bO,bO+kB,l-kL);
					dr=0;
				}
				await insertion(A,s,kL,cmp);
				while(l-kL>sAL){
					await lazyCombine(A,s,s+kL,l-kL,sAL,2*sAL/kL|0);
					sAL*=2;
				}
			}
			return dr;
		}
		async function lazyMergeForwards(A,s,lL,rL,cmp){
			let m=s+lL;
			while(lL){
				let mL=binarySearchLeft(A,m,rL,A[s],cmp);
				if(mL){
					await rotate(A,s,lL,mL);
					s+=mL;m+=mL;rL-=mL;
				}
				if(!rL)break;
				else{
					do{
						s++;
						lL--;
					}while(lL&&cmp.compare(A[s],A[m])<1);
				}
			}
		}
		async function lazyMergeBackwards(A,s,lL,rL,cmp){
			let e=s+lL+rL-1;
			while(rL){
				let mL=binarySearchRight(A,s,lL,A[e],cmp);
				if(mL!=lL){
					await rotate(A,s+mL,lL-mL,rL);
					e-=lL-mL;lL=mL;
				}
				if(!L)break;
				else{
					let m=s+lL;
					do{
						rL--;
						e--;
					}while(rL&&cmp.compare(A[m-1],A[e])<1);
				}
			}
		}
		async function lazyMergeBufferBackwards(A,s,lL,rL,cmp){
			let e=s+lL+rL-1;
			while(rL){
				let mL=binarySearchLeft(A,s,lL,A[e],cmp);
				if(mL!=lL){
					await rotate(A,s+mL,lL-mL,rL);
					e-=lL-mL;lL=mL;
				}
				if(!lL)break;
				else{
					let m=s+lL;
					do{
						rL--;
						e--;
					}while(rL&&cmp.compare(A[m-1],A[e])<1);
				}
			}
		}
		async function lazyStableSort(A,s,l,cmp){
			let i;
			for(i=0;i<l-15;i+=16)
				await insertion(A,i,16,cmp);
			await insertion(A,i,l-i,cmp);
			for(let mL=16;mL<l;mL*=2){
				let fM=2*mL,mI,mE=l-fM;
				for(mI=0;mI<=mE;mI+=fM)
					await lazyMergeBackwards(A,s+mI,mL,mL,cmp);
				let lO=l-mI;
				if(lO>mL)
					await lazyMergeBackwards(A,s+mI,mL,lO-mL,cmp);
			}
		}
		async function commonSort(A,s,l,xB,xBL){
			if(l<16)return await insertion(A,s,l,cmp);
			let blL=4;
			while(blL*blL<l)blL*=2;
			let kL=((l-1)/blL|0)+1;
			let iK=kL+blL;
			let kF=await collectKeys(A,s,l,iK,cmp);
			let iB;
			if(kF<iK){
				if(kF<4){
					if(kF==1)return;
					await lazyStableSort(A,s,l,cmp);
					return;
				}else{
					kL=blL;
					blL=0;
					iB=false;
					while(kL>kF)kL=kL/2|0;
				}
			}else iB=true
			let bL=blL+kL;
			let sAL;
			if(iB)sAL=blL;
			else sAL=kL;
			if(xB!=null){
				XB=xB;
				XBL=xBL;
			}
			await buildBlocks(A,s+bL,l-bL,sAL,cmp);
			let dr=await combineBlocks(A,s,l,bL,sAL,blL,kL,iB);
			if(!dr){
				await insertion(A,s+kL,blL,cmp);
				await lazyMergeForwards(A,s,bL,l-bL,cmp);
			}else{
				await lazyMergeForwards(A,s,kL,l-bL,cmp);
				await insertion(A,s+l-blL,blL,cmp);
				await lazyMergeBufferBackwards(A,s,l-blL,blL,cmp);
			}
		}
		await commonSort(arr,0,len,null,0);
	}
	async ittoSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,1,true);
					else await reversal(A,j,i-1,.5,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function mergeFWExt(A,t,a,m,b){
			let s=m-a;
			arraycopy(A,a,t,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(t[i],A[j])<1)
					await write(A,a++,t[i++],1,true);
				else
					await write(A,a++,A[j++],1,true);
			while(i<s)
				await write(A,a++,t[i++],1,true);
		}
		async function mergeBWExt(A,t,a,m,b){
			let s=b-m;
			arraycopy(A,m,t,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(t[i],A[j])+1)
					await write(A,--b,t[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			while(i>=0)
				await write(A,--b,t[i--],1,true);
		}
		async function merge(A,t,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(m-a>b-m)await mergeBWExt(A,t,a,m,b);
			else await mergeFWExt(A,t,a,m,b);
		}
		async function lazyBufferedMergeBW(A,t,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			let s=b-m;
			arraycopy(A,m,t,0,s,0,false,true);
			let i=s-1,j=m-1,k=b-1;
			while(i>=0&&j>=a){
				if(compareValues(A[j],t[i])>0){
					let q=rightExpSearch(A,a,j+1,t[i],false);
					while(j>=q)await write(A,k--,A[j--],1,true);
				}
				await write(A,k--,t[i--],1,true);
			}
			while(i>=0)
				await write(A,k--,t[i--],1,true);
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			if(l<65){
				let j=l,i;
				while(j>31)j=(j+1)/2|0;
				if(await buildRuns(A,a,b,j))return;
				let t=new Array(l/2|0);
				for(;j<l;j*=2){
					for(i=a;i+2*j<=b;i+=2*j)
						await merge(A,t,i,i+j,i+2*j);
					if(i+j<b)
						await merge(A,t,i,i+j,b);
				}
				return;
			}
			let bL,mR;
			for(bL=1;(bL*bL*bL/l|0)<l;bL*=2);
			for(mR=1;(mR*mR*mR/l|0)<l;mR++);
			mR=16*mR/bL|0;
			bL=bL*mR/16|0;
			if(await buildRuns(A,a,b,mR))return;
			let t=new Array(bL);
			let i,j=mR;
			for(;j<bL;j*=2)
				for(i=a;i+j<b;i+=2*j)
					await merge(A,t,i,i+j,minVal(i+2*j,b));
			for(i=a+bL;i<b;i+=bL)await lazyBufferedMergeBW(A,t,a,i,minVal(i+bL,b));
		}
		await mergeSort(arr,0,len);
	}
	async lazicciSortAdaRot(len){
		const GS=new GrailSorting();
		function runs(n){
			let j=1,l=0;
			while(j<n){
				j*=10;
				l++;
			}
			return l*l;
		}
		function sqr(n){
			let l=0,h=n;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(m*m>n)h=m;
				else l=m+1;
			}
			return l;
		}
		function fcrt(n){
			let l=0,h=n;
			while(l<h){
				let m=l+(h-l)/2|0;
				if(m*sqr(m)>n)h=m;
				else l=m+1;
			}
			return l;
		}
		GS.setRotation((A,p,a,b)=>{
			return Rotations.adaptable(A,p,a,b,.5,true);
		});
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.1,true);
			else await reversal(A,s,e,.1,true);
			for(let i=s,l,r;i<e;i++){
				l=i;while(!compareIndices(A,i,i+1)&&i<e)i++;r=i;
				if(l-r)
					if(r-l<3)await swap(A,l,r,.5,true);
					else await reversal(A,l,r,.5,true);
			}
		}
		async function findRun(A,l,h){
			if(l>h-2)return l+1;
			let c=compareIndices(A,l,++l),s=l-1,d=c,sR=!c;
			if(sR)c=-1;
			while(l<h-1&&(d==c||!d)){
				d=compareIndices(A,l,l+1);
				if(!d)sR=true;
				l++;
			}
			if(c>0)
				if(sR)await stableSegmentReversal(A,s,l-1);
				else await reversal(A,s,l-1,1,true);
			return l;
		}
		function findSortedRunBW(A,s,e){
			do e--;while(e>s&&compareIndices(A,e-1,e)<1);
			return maxVal(e,e);
		}
		async function mergeRuns(A,l,h){
			let z=runs(h-l),x=fcrt(h-l),s=l,r=l,d=0;
			while(r<h){
				let y=await findRun(A,r,h);
				if(y>=r+x){
					s=r=y;d=0;
					continue;
				}
				if(d>0)await GS.grailMergeWithoutBuffer(A,s,r-s,y-r);
				if(++d==z)s=y;
				r=y;d%=z;
			}
			return s;
		}
		async function blockBack(A,s,u,e){
			while(u>s){
				let r=findSortedRunBW(A,s,u);
				await GS.grailMergeWithoutBuffer(A,r,u-r,e-u);
				u=r;
			}
		}
		await blockBack(arr,0,await mergeRuns(arr,0,len),len);
	}
	async unstableKotaSort(len){
		const bms=new BlockMergeSorting();
		function boundCheck(A,a,m,b){
			return compareIndices(A,m-1,m)<1;
		}
		async function blockSelect(A,a,b,bL){
			for(;a<b;a+=bL){
				let m=a;
				for(let i=a+bL;i<b;i+=bL){
					let c=compareIndices(A,i,m);
					if(c<0||(!c&&compareIndices(A,i+bL-1,m+bL-1)<0))m=i;
				}
				if(a-m)await bms.multiSwap(A,a,m,bL);
			}
		}
		async function blockMerge(A,a,m,b,bL){
			if(boundCheck(A,a,m,b))return;
			let uL=2*bL;
			let a1=bms.rightBinSearch(A,a,m,A[m]);
			if(m-a1<=bL)a=m-uL;
			else a=a1-(a1-a)%bL;
			let r1=0,r2=minVal(b-m,uL);
			while(r1<r2){
				let ml=(r1+r2)/2|0;
				if(compareIndices(A,m+ml,a+uL-ml-1)>0)r2=ml;
				else r1=ml+1;
			}
			let l=uL-r1,r=r1,i=a+l,j=m+r;
			let lf=l>=r;
			let k=lf?i-l:j-r;
			let c=bL;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1){
					await swap(A,k++,i++,1,true);
					l++;
				}else{
					await swap(A,k++,j++,1,true);
					r++;
				}
				if(!--c){
					if(lf)l-=bL;
					else r-=bL;
					lf=l>=r;
					k=lf?i-l:j-r;
					c=bL;
				}
			}
			while(i<m){
				await swap(A,k++,i++,1,true);
				l++;
				if(!--c){
					if(lf)l-=bL;
					else r-=bL;
					lf=l>=r;
					k=lf?i-l:j-r;
					c=bL;
				}
			}
			while(j<b){
				await swap(A,k++,j++,1,true);
				r++;
				if(!--c){
					if(lf)l-=bL;
					else r-=bL;
					c=bL;
					break;
				}
			}
			let rem=bL-c,b1=minVal(j,b-rem);
			await bms.multiSwap(A,k-rem,b1,rem);
			r-=rem;
			await bms.multiSwap(A,m-l,a,l);
			await bms.multiSwap(A,b1-r,a+l,r);
			await binaryInsertion(A,a,a+uL,.5);
			await blockSelect(A,a+uL,b1,bL);
		}
		async function sort(A,l){
			let a=0,b=l,j=16;
			if(await bms.buildRuns(A,a,b))return;
			let s=4,c=2;
			for(;j<b;j*=2){
				if(!--c){
					s*=2;c=2;
				}
				for(let i=a;i+j<b;i+=2*j)
					await blockMerge(A,i,i+j,minVal(i+2*j,b),s);
			}
		}
		await sort(arr,len);
	}
	async redHerringSort(len){
		function CPO2LT(l){
			let z=1;
			while(z<l)z<<=1;
			return z>>1;
		}
		function bitComp(A,a,b,d){
			if(d==(compareIndices(A,a,b)>0))
				swap(A,a,b);
		}
		let j=0;
		async function bitMerge(A,a,b,d){
			if(b<2)return;
			let m=CPO2LT(b);
			for(let i=0;i<b-m;i++){
				bitComp(A,a+i,a+m+i,d);
				if(++j>len){
					markSwap(a+i,a+m+i);
					await sleep(j=0);
				}
			}
			if(m<1)return;
			await bitMerge(A,a,b-m,d);
			await bitMerge(A,a+b-m,m,d);
			return;
		}
		async function bitBitMerge(A,a,b,d){
			if(b<2)return;
			let m=CPO2LT(b);
			if(m<1)return;
			await bitMerge(A,a,b,d);
			await bitBitMerge(A,a,b-m,!d);
			await bitBitMerge(A,a+b-m,m,d);
			await bitMerge(A,a,b,!d);
			await bitBitMerge(A,a,b-m,d);
			await bitBitMerge(A,a+b-m,m,d);
			return;
		}
		async function tl1(A,a,l,m){
			if(l<2||a>m||a+l>=m)return;
			let k=(l-a)%2>0;
			await bitMerge(A,a,l,k);
			await tl1(A,a,l-1,m);
			await tl1(A,a+1,l,m);
			await bitBitMerge(A,a,l,false);
		}
		async function tl2(A,a,l,m){
			if(l<2||a>m||a+l>=m)return;
			let k=(l-a)%2>0;
			await tl1(A,a,l,m);
			while(l>1){
				await tl2(A,a,l-1,m);
				await tl2(A,a+1,l--,m);
			}
			await bitMerge(A,a,l,!k);
		}
		await tl2(arr,0,len,len+1);
	}
	async bzsurgeSort(len){
		async function merge(A,x,s,m,e){
			let l=s,r=m,t=s;
			while(l<m&&r<e){
				if(compareValues(A[l],A[r])<1)
					write(x,t++,A[l++],0,false,true);
				else
					write(x,t++,A[r++],0,false,true);
			}
			if(l==r)return true;
			while(l<m)
				write(x,t++,A[l++],0,false,true);
			while(r<e)
				write(x,t++,A[r++],0,false,true);
			await arraycopy(x,s,A,s,e-s,.5,true);
			return false;
		}
		async function surge(A,x,s,e){
			let m=s+(e-s)/2|0;
			if(s==m)return true;
			if(e-s<32){
				await binaryInsertion(A,s,e,1/4);
				return true;
			}
			let c=await merge(A,x,s,m,e),l=await surge(A,x,s,m),r=await surge(A,x,m,e);
			return c&&l&&r;
		}
		let t=new Array(len);
		while(!await surge(arr,t,0,len));
	}
	async SCPMergeSort(len){
		function isPrime(n){
			return(n%2&&n%3&&n%5&&n%7)||(n==2||n==3||n==5||n==7);
		}
		function prime(l){
			let p=0,n=1;
			while(1){
				if(p>=l){
					if(!isPrime(n))n--;
					return n;
				}
				n++;
				if(isPrime(n))p++;
			}
		}
		async function classicMerge(A,t,s,m,e){
			if(s==m)return;
			let l=s,h=m,n=0;
			while(l<m&&h<e){
				if(compareIndices(A,l,h)<1)
					write(t,n++,A[l++],0,false,true);
				else
					write(t,n++,A[h++],0,false,true);
			}
			while(l<m)
				write(t,n++,A[l++],0,false,true);
			await arraycopy(t,0,A,s,n,1,true);
		}
		async function scpMerge(A,t,s,e){
			if(s==e)return;
			let m=s+prime(e)%(e-s)|0;
			await scpMerge(A,t,s,m);
			if(m==s)m++;
			await scpMerge(A,t,m,e);
			await classicMerge(A,t,s,m,e);
		}
		let t=new Array(len);
		await scpMerge(arr,t,0,len);
	}
	async preAphiCycleSort(len){
		async function cycleSort(A,s,e){
			for(let c=s;c<e-1;c++){
				let v=A[c],p=c;
				for(let i=c+1;i<e;i++)if(compareValues(A[i],v)<0)p++;
				if(p==c)continue;
				while(v==A[p])p++;
				let t=A[p];
				await write(A,p,v,0,true);
				v=t;
				while(p-c){
					p=c;
					for(let i=c+1;i<e;i++)if(compareValues(A[i],v)<0)p++;
					while(v==A[p])p++;
					t=A[p];
					await write(A,p,v,0,true);
					v=t;
				}
			}
		}
		await cycleSort(arr,0,len);
	}
	async zeroMergeSort(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return IndexedRotations.neon(A,p,p+a,p+a+b,1,true);
		});
		async function zeromerge(A,s,m,e){
			let l=s,r=m;
			let lB=buf,rB=m,lSz=bz,rZ=0;
			while(l<m||r<e){
				while(l<m&&r<e&&lSz>0)
					if(compareIndices(A,l,r)<1)await swap(A,lB++,l++,1.25,true);
					else{
						await swap(A,lB++,r++,1.25,true);
						lSz--;rZ++;
					}
				if(lSz>0){
					while(l<m)await swap(A,lB++,l++,1.25,true);
					while(r<e&&lSz>0){
						await swap(A,lB++,r++,1.25,true);
						lSz--;rZ++;
					}
				}
				while(l<m&&r<e&&rZ>0)
					if(compareIndices(A,l,r)<1){
						await swap(A,rB++,l++,1.25,true);
						rZ--;lSz++;
					}else await swap(A,rB++,r++,1.25,true);
				if(rZ>0){
					while(l<m&&rZ>0){
						await swap(A,rB++,l++,1.25,true);
						rZ--;lSz++;
					}
					while(r<e)await swap(A,rB++,r++,1.25,true);
				}
				await IndexedRotations.neon(A,lB,m,rB+rZ,2.5,true);
				l+=rB-m+rZ;lB+=rB-m+rZ;m=r=rB+rZ;rZ=0;
			}
			buf=e-bz;
		}
		async function binsertruns(A,s,e){
			let m=maxVal(16,bz);
			for(let i=s;i<e;i+=m)await binaryInsertion(A,i,minVal(i+m,e),.1);
		}
		let buf,bz;
		async function runZero(A,s,e){
			buf=s;bz=sqrt(e-s)|0;
			if(bz<4)return await binaryInsertion(A,s,e,.5);
			await binsertruns(A,buf+bz,e);
			for(let j=maxVal(bz,16);j<e-s;j*=2){
				for(let i=buf+bz;i<e;i+=2*j){
					if(i+j>e)break;
					if(i+2*j>e)await zeromerge(A,i,i+j,e);
					else await zeromerge(A,i,i+j,i+2*j);
				}
				await IndexedRotations.neon(A,s,buf,buf+bz,1,true);
				buf=s;
			}
			await binaryInsertion(A,buf,buf+bz,.1);
			await GS.grailMergeWithoutBuffer(A,buf,bz,e-buf-bz);
		}
		await runZero(arr,0,len);
	}
	async cityscapeSort(len){
		async function csdep(A,i,j){
			if(i==j)return;
			let a=minVal(i,j),b=maxVal(i,j);
			if(compareIndices(A,a,b)>0)await swap(A,a,b,.1,true);
		}
		async function shellPass(A,s,e,g){
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i];
				let j=i;
				let w=false;
				for(;j>=h&&j-h>=s&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		async function shell(A,s,e){
			for(let g=(e-s)/2.25|0;g>=2;g=g/2.25|0)await shellPass(A,s,e,g);
			await shellPass(A,s,e,1);
		}
		function maxsorted(A,s,e){
			let a=e-1,b=e-1,t=true;
			while(t){
				if(b-1<s)return s;
				if(compareIndices(A,b-1,b,.1,true)>0)t=false;
				else b--;
			}
			let l=b-1;
			for(let i=b-2;i>=s;i--)if(compareIndices(A,l,i)<0)l=i;
			while(compareIndices(A,l,a)<1){
				if(--a<s)break;
			}
			return a+1;
		}
		async function shuffle(A,s,e){
			let r=new Random();
			for(let i=s;i<r.nextInt(e);i++){
				let rI=r.nextInt(e-i)+i;
				if(rI-i)await swap(A,i,rI,.1,true);
			}
		}
		let i=len;
		while(i>0){
			let h=i;
			let j=0;
			for(;j<i;j++){
				await csdep(arr,j,j+1);
				for(h=i-1;h>i-j-2;h--){
					await csdep(arr,j,h);
					if(h<=j)break;
				}
				if(h<=j)break;
			}
			await shell(arr,j,i);
			i=maxsorted(arr,0,i);
			await shuffle(arr,0,i);
		}
	}
	async clampSort(len){
		for(let i=1,k=0;i<len;i++){
			for(let j=0;j<i;j++){
				if(compareIndices(arr,i,j)<0){
					if(i-j>2)reversal(arr,j,i,0);
					else swap(arr,j,i,0);
					if(++k>len*1.5){
						markSwap(i,j);
						await sleep(k=0);
					}
					i=1;j=-1;
				}
			}
		}
	}
	async evubSort(len){
		let base=askForNum(3,"Base",1,4);
		async function compare(A,z){
			if(compareIndices(A,z,z+1)>0)await swap(A,z,z+1,0,true);
		}
		async function recur(A,a,k){
			if(k<2)for(let b=0;b<=a;b++)await compare(A,b);
			else for(let b=0;b<=a;b++)await recur(A,b,k-1);
		}
		for(let a=len-1;a>0;a--)for(let b=0;b+1<=a;b++)
			if(base<3)await compare(arr,b);
			else await recur(arr,b,base-2);
	}
	async debrisSort(len){
		let i=0,f=1,l=len-1,n=len-1,a=true;
		while(a){
			a=false;
			let o=false;
			if(f>0)i=f-1;
			else i=0;
			for(;i<l;i++){
				let s=i;
				for(;compareIndices(arr,i,i+1)>0&&i<l;i++){
					if(!o){
						f=i;
						o=true;
					}
					n=i+1;
				}
				let e=i;
				if(s-e)
					if(e-s<3)await swap(arr,s,e,.05,a=true);
					else await reversal(arr,s,e,.05,a=true);
			}
			if(n+1<len)l=n+1;
			else l=len-1;
		}
	}
	async eggSort(len){
		function maxsorted(A,s,e){
			let a=e-1;
			let b=e-1;
			let c=true;
			while(c){
				if(b-1<s)return s;
				if(compareIndices(A,b-1,b)>0)c=false;
				else b--;
			}
			let l=b-1;
			for(let i=b-2;i>=s;i--)if(compareIndices(A,l,i)<0)l=i;
			while(compareIndices(A,l,a)<1){
				if(--a<s)break;
			}
			return a+1;
		}
		async function sort(A,l){
			l=maxsorted(A,l,l);
			while(l>1){
				for(let i=0;i+1<l;i++){
					if(compareIndices(A,i,i+1)<0)await Wr.insert(A,i,0,.01,true);
					else await Wr.insert(A,i+1,0,.01,true);
				}
				l--;
				l=maxsorted(A,0,l);
			}
		}
		await sort(arr,len);
	}
	async crozeSort(len){
		while(!isArraySorted(arr,len))
			for(let i=0;i<len;i++)
				for(let j=0;j<i;j++)
					if(compareIndices(arr,j,i)>0){
						for(let k=j+1;k<len;k++)
							if(compareIndices(arr,j,k)>0)await multiSwap(arr,k,j,.02,true);
							else if(k>i)break;
					}else await multiSwap(arr,i,j+1,.02,true);
	}
	async opiumSort(len){
		function isLeast(A,t,j,e,l){
			for(let i=j+1;i<l-e;i++)if(compareIndices(A,j,i)>0)return false;
			for(let i=0;i<e;i++)if(compareIndexValue(A,j,t[i])>0)return false;
			return true;
		}
		async function sort(A,l){
			let i=0;
			let c=new Array(l);
			for(let j=0;j<l;j++)c[j]=-1;
			let cd=0;
			while(i<l){
				if(isLeast(A,c,i,cd,l)){
					if(++i+cd>=l){
						for(let j=0;j<cd;j++){
							await write(A,i+j,c[j],.01,true);
							c[j]=-1;
						}
						cd=0;
					}
				}else{
					if(cd+i>=l){
						for(let j=0;j<cd;j++){
							await write(A,i+j,c[j],.01,true);
							c[j]=-1;
						}
						cd=0;
					}else{
						write(c,cd,A[i],0,false,true);
						await arraycopy(A,i+1,A,i,l-cd++-i-1,.01,true);
					}
				}
			}
		}
		await sort(arr,len);
	}
	async zubbleSort(len){
		for(let i=len-1;i>0;i--){
			let r=true;
			for(let j=0;j<i;j++){
				let k=j,s=false;
				while(j<i&&compareIndices(arr,k,j+1)>0){
					j++;r=false;s=true;
				}
				if(s)await swap(arr,k,j,1,true);
			}
			if(r)break;
		}
	}
	async simpleFireSort(len){
		let t1=1,l=len,i=0,m=0,k=0;
		while(i<len||t1==-1){
			if(i==0&&t1==-1){
				t1*=-1;
				m=0;
			}
			for(let j=i;(t1==-1?j<len:j>0)&&compareIndices(arr,j-1,j)==t1;j-=t1){
				m++;
				swap(arr,j,j-1,0);
				if(++k>len*2){
					markSwap(j,j-1);
					await sleep(k=0);
				}
			}
			i+=t1;
			if(m>l){
				l+=len;
				m=0;
				t1*=-1;
			}
		}
	}
	async adaptiveClamberSort(len){
		for(let i=1,k=0;i<len;i++)
			if(compareIndices(arr,i-1,i)>0)
				for(let j=0;j<i;j++)
					if(compareIndices(arr,j,i)>0)
						while(j<i){
							swap(arr,j++,i,0);
							if(++k>=sqrt(len)/2){
								markSwap(j-1,i);
								await sleep(k=0);
							}
						}
	}
	async ABACStoogeSort(len){
		async function stoogeSort(A,i,j){
			let c=(j-i)**3;
			for(let k=0,n=0;k<c;k++){
				let a=i,b=j;
				for(let l=(b-a+1)/3|0,o=0;;l=(b-a+1)/3|0){
					switch(getDigit(k,o++,3)){
						case 0:case 2:b-=l;break;
						case 1:a+=l;break;
					}
					if((b-a==1&&l==1)||l<1)break;
				}
				if(compareIndices(A,a,b)>0){
					swap(A,a,b,0);
					if(++n>=sqrt(len)/2){
						markSwap(a,b);
						await sleep(n=0);
					}
				}
			}
		}
		await stoogeSort(arr,0,len-1);
	}
	async accelerateSort(len){
		let j=1;
		while(j<len){
			let i=j,k=1;
			while(j-1+pow(2,k)<=len){
				if(compareIndices(arr,i-1,j-1+pow(2,k++)-1)>0){
					await Wr.insert(arr,i-1,len-1,.01,true);
					k=j=i=1;
				}else i=j-1+pow(2,k++);
			}
			j++;
		}
	}
	async adaptiveBinaryClamberSort(len){
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		for(let r=1,i=0;r<len;r++)
			if(compareIndices(arr,r-1,r)>0){
				let l=binarySearch(arr,0,r-1,arr[r]);
				while(l<r){
					swap(arr,l++,r,0);
					if(++i>=sqrt(len)/2){
						markSwap(l-1,r);
						await sleep(i=0);
					}
				}
			}
	}
	async adaptiveExponentialClamberSort(len){
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function exponentSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return binarySearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		for(let r=1,i=0;r<len;r++){
			if(compareIndices(arr,r-1,r)>0){
				let l=exponentSearch(arr,0,r-1,arr[r]);
				while(l<r){
					swap(arr,l++,r,0);
					if(++i>=sqrt(len)/2){
						markSwap(l-1,r);
						await sleep(i=0);
					}
				}
			}
		}
	}
	async blueFlameSort(len){
		let k=0;
		async function ignite(A,i,j){
			if(i>=j)return;
			if(compareIndices(A,i,j)<0){
				swap(A,i,j,0);
				if(++k>len){
					markSwap(i,j);
					await sleep(k=0);
				}
				await ignite(A,i+1,j);
			}else await ignite(A,i+1,j-1);
			reversal(A,i,j,0);
			await ignite(A,i,j-1);
		}
		for(let i=0;i<len;i++)
			await ignite(arr,i,len-1);
	}
	async shipperSort(len){
		function minSorted(A,st,e){
			let i=st,sg=true;
			while(sg){
				if(i+1>e)return e;
				if(compareIndices(A,i,i+1)>0)sg=false;
				else i++;
			}
			let sl=i+1;
			for(let s=i+2;s<e;s++)if(compareIndices(A,sl,s)>0)sl=s;
			let w=sl;
			while(compareIndices(A,sl,st)+1)if(++st>=e)break;
			return st;
		}
		async function shipPass(A,a,b){
			ch=false;
			for(let h=1,i=h+a;i<b;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&j-h>=a&&compareValues(A[j-h],v)>0;j-=h){
					await write(A,j,A[j-h],.1,w=true);
				}
				if(w){
					await write(A,j,v,.1,true);
					if(h>4)ch=true;
					h++;
				}
			}
		}
		async function shellPass(A,s,e,g){
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&j-h>=s&&compareValues(A[j-h],v)>0;j-=h){
					await write(A,j,A[j-h],.5,w=true);
				}
				if(w)await write(A,j,v,.5,true);
			}
		}
		let ch=true,s=0;
		while(ch)await shipPass(arr,s=minSorted(arr,s,len),len);
		await shellPass(arr,s,len,1);
	}
	async bidiBinaryQuasiPancakeSort(len){
		async function reverse(A,a,b,s,m,x){
			if(b<=a)return;
			if(b-a>=3)await reversal(A,a,b,s,m,x);
			else await swap(A,a,b,s,m,x);
		}
		async function insertSort(A,s,e){
			let n=false,l,r,m;
			for(let i=s+1;i<e;i++){
				if(n^compareIndices(A,i-1,i)<1)continue;
				if(n^compareIndices(A,s,i)>0){
					await reversal(A,s,i-1,.2,true);
					n=!n;
					continue;
				}
				l=s+1;r=i-1;
				while(l<r){
					m=l+(r-l)/2|0;
					if(n^compareIndices(A,m,i)>0)r=m;
					else l=m+1;
				}
				if(l-i){
					await reverse(A,l,i-1,.2,true);
					await reverse(A,l,i,.2,true);
				}
			}
			if(n)await reversal(A,s,e-1,.2,true);
		}
		await insertSort(arr,0,len);
	}
	async sandpaperMergeSort(len){
		async function sandpaper(A,a,b){
			for(let i=a,k=0;i<b-1;i++)
				for(let j=b-1;j>i;j--)
					if(compareIndices(A,i,j)>0){
						swap(A,i,j,0);
						if(++k>sqrt(len)){
							markSwap(i,j);
							await sleep(k=0);
						}
					}
		}
		async function sort(A,a,b){
			if(b-a<2)return;
			let m=a+(b-a)/2|0;
			await sort(A,a,m);
			await sort(A,m,b);
			await sandpaper(A,a,b);
		}
		await sort(arr,0,len);
	}
	async selectionMergeSort(len){
		async function wrapper(A,s,e){
			if(e-s>2){
				await wrapper(A,s,(e-s)/2+s|0);
				await wrapper(A,(e-s)/2+s|0,e);
			}
			let l=(e-s)/2+s+1|0,o=l-1;
			for(let i=s;i<e-1;i++){
				if(o==i)o++;
				let m=i;
				for(let j=o;j<l;j++)if(compareIndices(A,m,j)>0)m=j;
				if(m-i)await swap(A,i,m,1,true);
				if(m==l-1&&l<e)l++;
			}
		}
		await wrapper(arr,0,len);
	}
	async splitCenterMergeSort(len){
		async function method1(A,a,b){
			for(let r=0,w=1,ls=0,f=a,nf=a,l=a+b-1,nl=a+b-1;ls<2&&r<b;r++,w*=-1){
				let sw=false,k=0;
				for(let i=b/2+a|0;i<l&&i>=f;i+=w){
					if(compareIndices(A,i,i+1)>0){
						swap(A,i,i+1,0);
						sw=true
						if(++k>cbrt(b)){
							markSwap(i,i+1);
							await sleep(k=0);
						}
						if(w>0)nl=i+1;else nf=i+1;
					}
				}
				if(w>0)l=nl;else f=nf;
				if(!sw)ls++;else ls=0;
			}
			if(b<5){
				for(let c=1,j=a+b-1,s,f=a+b/2|0;j>0;j-=c){
					if(f<=a)s=a;else s=f-1;
					let sw=false;
					c=1;
					for(let k=s;k<j;k++){
						if(compareIndices(A,k,k+1)>0){
							if(!sw)f=k;
							await swap(A,k,k+1,1,sw=true);
							c=1;
						}else c++;
					}
				}
			}
		}
		async function method2(A,n){
			for(let r=0,w=1,l=0;l<2&&r<n;r++,w*=-1){
				let a=false,k=0;
				for(let i=n/2|0;i<n&&i>0;i+=w)if(compareIndices(A,i-1,i)>0){
					swap(A,i-1,i,0);a=true;
					if(++k>cbrt(n)){
						markSwap(i-1,i);
						await sleep(k=0);
					}
				}
				if(a)l=0;else l++;
			}
		}
		let l=2;
		while(l<len){
			for(let i=0;i+l-1<len;i+=l)await method1(arr,i,l);
			l*=2;
		}
		if(l==len)await method1(arr,0,len);
		else await method2(arr,len);
	}
	async snowballMergeSort(len){
		async function snowballs(A,s,e){
			let g=0,b=s;
			while(g-1){
				g=1;
				for(let i=b-1>s?b-1:s;i+g<e;i++){
					if(compareIndices(A,i,i+g)>0){
						if(g>2)await reversal(A,i,i+g,.01,true);
						else await swap(A,i,i+g,.01,true);
						if(g<2)b=i;
						g*=2;
					}
				}
			}
		}
		let l=2;
		while(l<len){
			let i=0;
			for(;i+l<=len;i+=l){
				if(l==2){
					if(compareIndices(arr,i,i+1)>0)
						await swap(arr,i,i+1,.1,true);
				}else await snowballs(arr,i,i+l);
				i+=l;
			}
			if(i-len)await snowballs(arr,i,len);
			l*=2;
		}
		await snowballs(arr,0,len);
	}
	async surgeSort(len){
		async function merge(A,x,s,m,e){
			let l=s,r=m,t=s,f=false;
			while(l<m&&r<e)
				if(compareIndices(A,l,r)<1)write(x,t++,A[l++],0,false,true);
				else write(x,t++,A[r++],0,false,true);
			f=l==r;
			while(l<m)write(x,t++,A[l++],0,false,true);
			while(r<e)write(x,t++,A[r++],0,false,true);
			await arraycopy(x,s,A,s,e-s,.025,true);
			return f;
		}
		async function surge(A,t,s,e){
			let m=s+(e-s)/2|0;
			if(s==m)return true;
			let c=await merge(A,t,s,m,e),l=await surge(A,t,s,m),r=await surge(A,t,m,e);
			return c&&l&&r;
		}
		let t=new Array(len);
		while(!await surge(arr,t,0,len));
	}
	async flightMergeSort(len){
		async function method(A,s,l){
			let z=x-n+1,h=new Array(z).fill(0);
			for(let i=s;i<s+l;i++)
				write(h,A[i]-n,h[A[i]-n]+1,0,false,true);
			let j=s;
			for(let c=0;c<z;c++){
				for(let i=0;i<h[c];i++,j++){
					let d=c+n-A[j];
					if(d)for(let k=0,a=0;k<abs(d);k++){
						write(A,j,A[j]+(d<0?-1:1),0);
						if(++a>sqrt(len)){
							mark(j);
							await sleep(a=0);
						}
					}
				}
			}
		}
		let n=1/0,x=-1/0;
		for(let i=0;i<len;i++){
			if(arr[i]<n)n=arr[i];
			if(arr[i]>x)x=arr[i];
		}
		for(let l=2;l<len;l*=2)for(let i=0;i+l-1<len;i+=l)await method(arr,i,l);
		await method(arr,0,len);
	}
	async bingoMergeSort(len){
		async function bingoSort(A,a,b){
			let l=b-a;
			for(let j=l,k=1;;){
				for(let i=k;i<j;i++)
					if(compareIndices(A,a+i,a+k-1)+1)
						await swap(A,a+k++,a+i,.02,true);
				if(k==j)break;
				if(!compareIndices(A,a,a+k-1))
					while(k>0)await swap(A,a+--j,a+--k,.02,true);
				else{
					await swap(A,a+--j,a+--k,1,true);
					while(!compareIndices(A,a+--k,a+j))
						await swap(A,a+--j,a+k,.02,true);
				}
				if(!k)k=1;
			}
		}
		async function mergeSort(A,a,b){
			if(b-a<2)return;
			let m=a+(b-a)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await bingoSort(A,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async lazyStableSortNeon(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return Rotations.neon(A,p,a,b,.5,true);
		});
		await GS.grailLazyStableSort(arr,0,len);
	}
	async insertionMergeSort(len){
		async function sort(A,a,b){
			if(b-a<2)return;
			let m=a+(b-a)/2|0;
			await sort(A,a,m);
			await sort(A,m,b);
			await insertSort(A,a,b,.1);
		}
		await sort(arr,0,len);
	}
	async milkSort(len){
		async function t(A,a,b,len){
			for(let i=0;i<len;i++)
				await swap(A,a+i,b+i,1,true);
		}
		async function milk(A,s,m,e){
			if((e-s<17||s==m||m==e)&&s<e)return await insertSort(A,s,e,.25);
			let rz=e-m,r=m,l=s;
			while(rz>0){
				if(compareIndices(A,l,r)>0)await t(A,l,r,rz);
				else{
					l++;
					rz--;
				}
			}
			await sort(A,m,e);
		}
		async function sort(A,s,e){
			let m=s+(e-s)/2|0;
			if(m==s)return;
			await sort(A,s,m);
			await sort(A,m,e);
			await milk(A,s,m,e);
		}
		await sort(arr,0,len);
	}
	async smoothBingoMergeSort(len){
		async function bingoSort(A,a,b){
			let l=b-a,s=0,q=0;
			for(let i=l-1;i>s;){
				for(let j=s;j>0&&!compareIndices(A,a+j-1,a+j);j--,q++);
				for(let j=s+1;j<=i;j++){
					let c=compareIndices(A,a+j,a+s);
					if(c+1){
						if(j-++s)await swap(A,a+j,a+s,.125,true);
						if(c)q=0
						else q++;
					}
				}
				if(s>=i)return;
				do await swap(A,a+s--,a+i--,1,true);while(q-->0);
				if(q<0)q=0;
				if(s<0)s=0;
			}
		}
		async function mergeSort(A,a,b){
			if(b-a<2)return;
			let m=a+(b-a)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await bingoSort(A,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async zubbleMergeSort(len){
		async function zubble(A,a,b){
			let l=b-a;
			for(let i=l-1,c=1,f=1;i>=f;i-=c){
				let fs=false;
				for(let j=maxVal(f-1,0);j<i;j++){
					let k=j,s=false;
					while(j<i&&compareIndices(A,a+k,a+j+1)>0){
						j++;
						s=true;
					}
					if(s){
						await swap(A,a+k,a+j,1,true);
						c=1;
						if(!fs)f=k;
						fs=true;
					}else c++;
				}
			}
		}
		async function mergeSort(A,a,b){
			if(b-a<2)return;
			let m=a+(b-a)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await zubble(A,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async optimizedShoveMergeSort(len){
		async function merge(A,s,md,e){
			let m=e;
			while(s<md&&md<m){
				let c=compareIndices(A,s,md);
				if(!c)c--;
				if(c<0){
					let l=s,d;
					do d=compareIndices(A,++l,md);while(l<md&&c==d||!d);
					await IndexedRotations.juggling(A,s,l,e,.1,true);
					m-=l-s;
					md-=l-s;
				}else{
					let r=md,d;
					do d=compareIndices(A,s,++r);while(r<m&&c==d);
					await IndexedRotations.juggling(A,md,r,e,.1,true);
					m-=r-md;
				}
			}
			if(s<md)await IndexedRotations.juggling(A,s,md,e,.1,true);
			if(md<m)await IndexedRotations.juggling(A,s,m,e,.1,true);
		}
		async function sort(A,s,e){
			let m=s+(e-s)/2|0;
			if(s==m)return;
			await sort(A,s,m);
			await sort(A,m,e);
			await merge(A,s,m,e);
		}
		await sort(arr,0,len);
	}
	async iterativeSelectionMergeSort(len){
		async function selection(A,s,e){
			if(compareIndices(A,(e-s)/2+s-1,(e-s)/2+s)>0){
				for(let i=s,l=(e-s)/2+s+1|0,o=l-1;i<e-1;i++){
					if(o==i)o++;
					let n=i;
					for(let j=o;j<l;j++)if(compareIndices(A,n,j)>0)n=j;
					if(n-i)await swap(A,i,n,1,true);
					if(n==l-1&&l<e)l++;
				}
			}
		}
		async function non2n(A,s,e){
			let l=s+2;
			while(compareIndices(A,l-2,l-1)<1&&l<e)l++;
			if(l-1<e){
				for(let i=s,o=l-1;i<e-1;i++){
					if(o==i)o++;
					let n=i;
					for(let j=o;j<l;j++)if(compareIndices(A,n,j)>0)n=j;
					if(n-i)await swap(A,i,n,1,true);
					if(n==l-1&&l<e)l++;
				}
			}
		}
		let l=2;
		while(l<len){
			let i=0;
			for(;i+l<=len;i+=l)
				if(l==2){
					if(compareIndices(arr,i,i+1)>0)
						await swap(arr,i,i+1,1,true);
				}else await selection(arr,i,i+l);
			if(i-len)await non2n(arr,i,len);
			l*=2;
		}
		if(l==len)await selection(arr,0,len);
		else await non2n(arr,0,len);
	}
	async randomShellMergeSort(len){
		async function shellPass(A,a,b,g){
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g,c=false;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],.5,c=true);
					j-=g;
				}
				if(c)await write(A,j+g,k,.5,true);
			}
		}
		async function shellSort(A,a,b){
			let g=b-a;
			while(g-1){
				g=randInt(sqrt(g)|0,g>1?g:g-1);
				await shellPass(A,a,b,g);
			}
		}
		async function mergeSort(A,a,b){
			let mR=b-a,i;
			for(;mR>31;mR=(mR+1)/2|0);
			for(i=a;i+mR<b;i+=mR)
				await insertSort(A,i,i+mR,.5);
			await insertSort(A,i,b,.5);
			for(let j=mR;j<(b-a);j*=2){
				for(i=a;i+2*j<=b;i+=2*j)
					await shellSort(A,i,i+2*j);
				if(i+j<b)
					await shellSort(A,i,b);
			}
		}
		await mergeSort(arr,0,len);
	}
	async cocktailShellMergeSort(len){
		async function shellSort(A,a,b){
			let g=(b-a)/2|0,d=true;
			while(g>0){
				if(d){
					for(let i=a+g;i<b;i++){
						let t=A[i],j=i;
						while(j>=a+g&&compareValues(A[j-g],t)>0)
							await write(A,j,A[j-=g],.1,true);
						await write(A,j,t,.1,true);
					}
				}else{
					for(let i=b-g;i>=a;i--){
						let t=A[i],j=i;
						while(j<b-g&&compareValues(A[j+g],t)<0)
							await write(A,j,A[j+=g],.1,true);
						await write(A,j,t,.1,true);
					}
				}
				g=g/2|0;
				d=!d;
			}
		}
		async function sort(A,a,b){
			if(b-a<32)return await insertSort(A,a,b,.2);
			let m=a+(b-a)/2|0;
			await sort(A,a,m);
			await sort(A,m,b);
			await shellSort(A,a,b);
		}
		await sort(arr,0,len);
	}
	async stacklessTopDownMergeSort(len){
		async function merge(A,t,a,m,b){
			let s=b-m;
			arraycopy(A,m,t,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(t[i],A[j])+1)
					await write(A,--b,t[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,t[i--],1,true);
		}
		let n=len,t=new Array(n/2|0);
		for(let c=2,i=1;i<n;i++,c++)
			for(let j=1;(c/j&1)==0;j<<=1)
				await merge(arr,t,i+1-(j<<1),i+1-j,i+1);
		let j;
		for(j=1;!((n/j|0)&1);j<<=1);
		let k=j;
		for(j<<=1;n/j>0;j<<=1)
			if((n/j|0)&1){
				await merge(arr,t,n-k-j,n-k,n);
				k+=j;
			}
	}
	async ganyuSort(len){
		async function indexSort(A,k,a,b){
			for(let i=0;i<b-a;i++){
				if(compareValues(i,k[i])){
					let t=A[a+i],j=i,n=k[i];
					do{
						await write(A,a+j,A[a+n],0,true);
						write(k,j,j,0,false,true);
						j=n;n=k[n];
					}while(compareValues(n,i));
					await write(A,a+j,t,0,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		async function merge(A,t0,t1,o,a,m,b){
			let ta=a-o,tm=m-o,tb=b-o,ti=ta,tj=tm,i=a+t0[ti],j=m+t0[tj],t=0;
			while(ti<tm||tj<tb){
				if(ti<tm&&(tj>=tb||compareIndices(A,i,j)<1)){
					write(t1,t++,t0[ti],0,false,true);
					if(++ti<tm)
						i=a+t0[ti];
				}else{
					write(t1,t++,t0[tj]+(tm-ta),1,false,true);
					if(++tj<tb)
						j=m+t0[tj];
				}
			}
			for(let k=0;k<tb-ta;k++)
				write(t0,ta+k,t1[k],.5,false,true);
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			let t0=new Array(l).fill(0);
			let t1=new Array(l).fill(0);
			for(let j=1;j<l;j*=2)
				for(let i=a;i+j<b;i+=2*j)
					merge(A,t0,t1,a,i,i+j,minVal(i+2*j,b));
			await indexSort(A,t0,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async ignorantQuickSort(len){
		for(let l=1,f=1;l-len;){
			let a=false;
			for(let r=l+1;r<=len;r++){
				if(compareIndices(arr,l-1,r-1)>0){
					if(!a&&l-1)f=l;
					await multiSwap(arr,r-1,l++-1,.1,a=true);
				}
			}
			if(a)l=f;else l++;
		}
	}
	async swaplessIgnorantQuickSort(len){
		for(let l=1,f=1;l-len;){
			let a=false;
			for(let r=l+1;r<=len;r++){
				if(compareIndices(arr,l-1,r-1)>0){
					if(!a&&l-1)f=l;
					await Wr.insert(arr,r-1,l++-1,.05,a=true);
				}
			}
			if(a)l=f;else l++;
		}
	}
	async pseudomedianOf11LRQuickSort(len){
		function disparity(A,l,i,v){
			return abs(A[l[i]]-v);
		}
		function medianMean(a,...qs){
			let m=0,mI=0;
			for(let i in qs)m+=a[i];
			m=m/qs.length|0;
			for(let i=1;i<qs.length;i++)
				if(compareValues(disparity(a,qs,i,m),disparity(a,qs,mI,m))<0)
					mI=i;
			return qs[mI];
		}
		async function quickSort(A,p,r,low){
			let v=(r-p)/10;
			if(v<=1)return await insertSort(A,p,r+1,.1);
			v|=0;
			let a=p+v,b=p+2*v,c=p+3*v,d=p+4*v,e=r-4*v,f=r-3*v,g=r-3*v,h=r-2*v,i=r-v;
			let x=A[medianMean(A,p,a,b,c,d,e,f,g,h,i,r)],y=p,z=r;
			while(y<=z){
				while(compareValues(A[y],x)<0)y++;
				while(compareValues(A[z],x)>0)z--;
				if(y<=z)await swap(A,y++,z--,1,true);
			}
			if(p<z)await quickSort(A,p,z,true);
			if(y<r)await quickSort(A,y,r,false);
		}
		await quickSort(arr,0,len-1,true);
	}
	async dualPivotStableQuickSort(len){
		async function partition(A,t,a,b,p1,p2,pC){
			let i1=a,j=0,k=t.length;
			for(let i=a;i<b;i++){
				if(compareIndexValue(A,i,p1)==-pC)
					await write(A,i1++,A[i],.1,true);
				else if(compareIndexValue(A,i,p2)==pC)
					write(t,--k,A[i],0,false,true);
				else write(t,j++,A[i],0,false,true);
			}
			if(j<b-a){
				await arraycopy(t,0,A,i1,j,.5,true);
				while(k<t.length)await write(A,--b,t[k++],.5,true);
			}
			return[i1,i1+j];
		}
		async function quickSort(A,t,a,b){
			if(b-a<33)return await binaryInsertion(A,a,b,.25);
			let s=(b-a)/3|0,p1,p2;
			if(compareIndices(A,a+s,a+s+s)>0){
				p1=A[a+s+s];
				p2=A[a+s];
			}else{
				p1=A[a+s];
				p2=A[a+s+s];
			}
			let[m1,m2]=await partition(A,t,a,b,p1,p2,1);
			await quickSort(A,t,a,m1);
			await quickSort(A,t,m2,b);
			if(a==m1&&b==m2)[m1,m2]=await partition(A,t,m1,m2,p1,p2,0);
			await quickSort(A,t,m1,m2);
		}
		await quickSort(arr,new Array(len),0,len);
	}
	async naturalRandomShellMergeSort(len){
		async function shellPass(A,a,b,g){
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],.5,true);
					j-=g;
				}
				if(j+g!=i)await write(A,j+g,k,1,true);
			}
		}
		async function shellSort(A,a,b){
			let g=b-a;
			while(g-1){
				g=randInt(sqrt(g)|0,g>1?g:g-1);
				await shellPass(A,a,b,g);
			}
		}
		async function findRun(A,a,b){
			let i=a+1,d;
			if(i<b)d=compareIndices(A,i-1,i++)<1;
			else d=true;
			while(i<b){
				if(d^compareIndices(A,i-1,i)<1)break;
				i++;
			}
			if(!d)if(i-a<4)
				await swap(A,a,i-1,1,true);
			else
				await reversal(A,a,i-1,1,true);
			return i;
		}
		async function mergeSort(A,a,b){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)break;
				await shellSort(A,a,j=await findRun(A,i,b));
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await shellSort(A,k,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async naturalIndexMergeSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function indexSort(A,k,a,b){
			for(let i=0;i<b-a;i++)
				if(compareValues(i,k[i])){
					let t=A[a+i],j=i,n=k[i];
					do{
						await write(A,a+j,A[a+n],1,true);
						write(k,j,j,0,false,true);
						j=n;n=k[n];
					}while(compareValues(n,i));
					await write(A,a+j,t,1,true);
					write(k,j,j,0,false,true);
				}
		}
		async function merge(A,B,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			let i=a,j=m,c=0;
			while(i<m||j<b){
				if(i<m&&(j>=b||compareIndices(A,i,j)<1))
					write(B,c,i++-a,0,false,true);
				else
					write(B,c,j++-a,0,false,true);
				c++;
			}
			await indexSort(A,B,a,b);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function mergeSort(A,a,b){
			let B=new Array(b-a),i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)break;
				await merge(A,B,a,i,j=await findRun(A,i,b));
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await merge(A,B,k,i,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async naturalSelectionMergeSort(len){
		async function merge(A,s,m,e){
			if(compareIndices(A,m-1,m)<1)return;
			let l=m+1,o=m;
			for(let i=s;i<e-1;i++){
				if(o==i)o++;
				let mI=i;
				for(let j=o;j<l;j++)if(compareIndices(A,j,mI)<0)mI=j;
				if(mI-i)await swap(A,i,mI,1,true);
				if(mI==l-1&&l<e)l++;
			}
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function mergeSort(A,a,b){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)break;
				await merge(A,a,i,j=await findRun(A,i,b));
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await merge(A,k,i,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async naturalRotateMergeSort(len){
		function rotate(A,a,m,b){
			return IndexedRotations.adaptable(A,a,m,b,1,true);
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function merge(A,a,m,b){
			if(m-a<1||b-m<1)return;
			let m1,m2,m3;
			if(m-a>=b-m){
				m2=binarySearch(A,m,b,A[m1=a+(m-a)/2|0],true);
				m3=m1+m2-m;
			}else{
				m1=binarySearch(A,a,m,A[m2=m+(b-m)/2|0],false);
				m3=m2++-m+m1;
			}
			await rotate(A,m1,m,m2);
			await merge(A,m3+1,m2,b);
			await merge(A,a,m1,m3);
		}
		async function findRun(A,a,b){
			let i=a+1,d=i<b?compareIndices(A,i-1,i++)<1:!0;
			if(d)while(i<b&&compareIndices(A,i-1,i)<1)i++;
			else{
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}
			return i;
		}
		async function mergeSort(A,a,b){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)return;
				await merge(A,a,i,j=await findRun(A,i,b));
				if((k=j)>=b)return;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await merge(A,k,i,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async rotatePartitionMergeSort(len){
		function rotate(A,a,m,b){
			return IndexedRotations.griesMills(A,a,m,b,1,true);
		}
		async function partitionMerge(A,a,m,b){
			let lA=m-a,lB=b-m;
			if(lA<1||lB<1)return;
			let c=(lA+lB)/2|0;
			if(lB<lA){
				let r1=0,r2=lB;
				while(r1<r2){
					let ml=(r1+r2)/2|0;
					if(compareIndices(A,m-c+ml,b-ml-1)>0)r2=ml;
					else r1=ml+1;
				}
				await rotate(A,m-c+r1,m,b-r1);
				let m1=b-c;
				await partitionMerge(A,m1,b-r1,b);
				await partitionMerge(A,a,m1-lB+r1,m1);
			}else{
				let r1=0,r2=lA;
				while(r1<r2){
					let ml=(r1+r2)/2|0;
					if(compareIndices(A,a+ml,m+c-ml-1)>0)r2=ml;
					else r1=ml+1;
				}
				await rotate(A,a+r1,m,m+c-r1);
				let m1=a+c;
				await partitionMerge(A,m1,m1+lA-r1,b);
				await partitionMerge(A,a,a+r1,m1);
			}
		}
		async function rotatePartitionMergeSort(A,a,b){
			let l=b-a,i;
			for(let j=1;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await partitionMerge(A,i,i+j,i+2*j);
				if(i+j<b)await partitionMerge(A,i,i+j,b);
			}
		}
		await rotatePartitionMergeSort(arr,0,len);
	}
	async exponentialInsertionMergeSort(len){
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertTo(A,a,b,s){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a,k=0;i-b;i+=d){
					write(A,i,A[i+d]);
					if(++k*s>=1){
						mark(i);
						await sleep(k=0);
					}
				}
				await write(A,b,t,1,true);
			}
		}
		async function insertSort(A,a,m,b){
			for(let i=m;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function sort(A,a,b,s){
			if(b-a<2)return;
			let m=a+(b-a)/2|0;
			await sort(A,a,m);
			await sort(A,m,b);
			await insertSort(A,a,m,b,s);
		}
		await sort(arr,0,len,.5);
	}
	async ternaryMergeSort(len){
		function ternary(A,s,e,k){
			while(s<e-1){
				let th=(e-s+1)/3|0,a=s+th,b=e-th;
				if(compareValues(A[a],k)>0)e=a;
				else if(compareValues(A[b],k)<0)s=b;
				else{
					s=a;
					e=b;
				}
			}
			return compareValues(A[s],k)>0?s:e;
		}
		async function ternaryInsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await Wr.insert(A,i,ternary(A,a,i,A[i],1),1,true);
		}
		async function merge(A,t,s,m,e){
			if(s==m||e-s<32)return;
			if(e-s<64)await ternaryInsert(A,s,e);
			else{
				await merge(A,t,s,(m+s)/2|0,m);
				await merge(A,t,m,(m+e)/2|0,e);
				let l=s,h=m;
				for(let n=0;n<e-s;n++){
					if(l>=m&&h>=e)break;
					if(l<m&&h>=e)
						write(t,n,A[l++],0,false,true);
					else if(l>=m&&h<e)
						write(t,n,A[h++],0,false,true);
					else if(compareIndices(A,l,h)<1)
						write(t,n,A[l++],0,false,true);
					else
						write(t,n,A[h++],0,false,true);
				}
				for(let i=0;i<e-s;i++)await write(A,s+i,t[i],1,true);
			}
		}
		async function mergeSort(A,l){
			if(l<32)return await ternaryInsert(A,0,l);
			await merge(A,new Array(l),0,l/2|0,l);
		}
		await mergeSort(arr,len);
	}
	async improvedBufferedStoogeSort2(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function partition(A,a,b){
			let i=a,j=b;
			await medianOfThree(A,a,b);
			do{
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)>0);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,a,j,1,true);
					return j;
				}
			}while(1);
		}
		async function quickSelect(A,a,b,r){
			while(b-a>32){
				let m=await partition(A,a,b);
				if(m==r)return;
				else if(m>r)b=m;
				else a=m+1;
			}
			await binaryInsertion(A,a,b,.2);
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		function getMinLevel(n){
			while(n>31)n=(n+3)/4|0;
			return n;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,o,j=getMinLevel(l);
			for(i=a;i+j<=b;i+=j)await binaryInsertion(A,i,i+j,.2);
			await binaryInsertion(A,i,b,.2);
			while(j<l){
				o=p;
				for(i=a;i+2*j<=b;i+=2*j,o+=2*j)await merge(A,i,i+j,i+2*j,o);
				if(i+j<b)await merge(A,i,i+j,b,o);
				else while(i<b)await swap(A,i++,o++,1,true);
				j*=2;o=a;
				for(i=p;i+2*j<=p+l;i+=2*j,o+=2*j)await merge(A,i,i+j,i+2*j,o);
				if(i+j<p+l)await merge(A,i,i+j,p+l,o);
				else while(i<p+l)await swap(A,i++,o++,1,true);
				j*=2;
			}
		}
		async function mergeSortHalf(A,a,b,p){
			let m=a+(b-a)/2|0,m1=a+(m-a)/2|0;
			await mergeSort(A,a,m1,p);
			await mergeSort(A,m1,m,p);
			await mergeSort(A,m,b,p);
			await merge(A,a,m1,m,p);
			let i=p,j=m,k=a;
			while(i<p+m-a&&j<b){
				if(compareIndices(A,i,j)<1)
					await swap(A,k++,i++,1,true);
				else
					await swap(A,k++,j++,1,true);
			}
			while(i<p+m-a)await swap(A,k++,i++,1,true);
		}
		async function sort(A,l){
			let a=0,b=l,s=(b-a+2)/3|0,m=b-s;
			await quickSelect(A,a,b,m);
			await mergeSortHalf(A,a,m,m);
			let st=false;
			for(;s>32;s=(s+1)/2|0,st=!st){
				if(st)await mergeSortHalf(A,a,a+s,b-(s+1)/2|0);
				else await mergeSortHalf(A,b-s,b,a);
			}
			if(st)await binaryInsertion(A,a,a+s,.2);
			else await binaryInsertion(A,b-s,b,.2);
		}
		await sort(arr,len);
	}
	async optimizedMergeSort(len){
		function ceilLogOdd(v){
			let l=0;
			while(v>0){
				v=v/2|0;l++;
			}
			return l%2;
		}
		async function merge(A,B,s,m,e,rv){
			let t=s,l=s,r=m;
			let a=rv?B:A,b=rv?A:B;
			if(compareIndices(a,m-1,m)<1){
				await arraycopy(a,s,b,s,e-s,.1,true,!rv);
				return false;
			}
			if(compareIndices(a,s,e-1)+1){
				await arraycopy(a,s,b,s+e-m,m-s,.1,true,!rv);
				await arraycopy(a,m,b,s,e-m,.1,true,!rv);
				return false;
			}
			while(l<m&&r<e)
				if(compareIndices(a,l,r)<1)await write(b,t++,a[l++],1,true,!rv);
				else await write(b,t++,a[r++],1,true,!rv);
			while(l<m)await write(b,t++,a[l++],1,true,!rv);
			while(r<e)await write(b,t++,a[r++],1,true,!rv);
			return true;
		}
		async function mergeSort(A,t,s,e,x){
			let m=s+(e-s)/2|0;
			if(e-s<32&&!x){
				await insertSort(A,s,e,.1);
				return false;
			}
			await mergeSort(A,t,s,m,!x);
			await mergeSort(A,t,m,e,!x);
			return await merge(A,t,s,m,e,!x);
		}
		let dc=ceilLogOdd(len);
		let t=new Array(len);
		if(await mergeSort(arr,t,0,len,dc)&&dc)await arraycopy(t,0,arr,0,len,.1,true);
	}
	async PDRotateMergeSort(len){
		function rotate(A,a,m,b){
			return IndexedRotations.holyGriesMills(A,a,m,b,1,true);
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function merge(A,a,m,b){
			let m1,m2,m3;
			if(m-a>=b-m){
				m2=binarySearch(A,m,b,A[m1=a+(m-a)/2|0],true);
				m3=m1+m2-m;
			}else{
				m1=binarySearch(A,a,m,A[m2=m+(b-m)/2|0],false);
				m3=m2++-m+m1;
			}
			await rotate(A,m1,m,m2);
			if(m2-m3-1>0&&b-m2>0)await merge(A,m3+1,m2,b);
			if(m1-a>0&&m3-m1>0)await merge(A,a,m1,m3);
		}
		function compare(A,n){
			return compareIndices(A,n,n+1)<1;
		}
		async function identifyRun(A,i,mI){
			let sI=i;
			if(i>=mI)return-1;
			let c=compare(A,i++);
			while(i<mI){
				let cC=compare(A,i);
				if(cC!=c)break;
				i++;
			}
			if(!c)await reversal(A,sI,i,.5,true);
			if(i>=mI)return-1;
			return i+1;
		}
		async function findRuns(A,mI){
			let r=new Array(mI/2+2|0);
			rC=0;
			let lR=0;
			while(lR+1){
				write(r,rC++,lR,0,false,true);
				lR=await identifyRun(A,lR,mI);
			}
			return r;
		}
		let rC;
		async function sort(A,l){
			let r=await findRuns(A,l-1);
			while(rC>1){
				for(let i=0;i<rC-1;i+=2){
					let e=i+2>=rC?l:r[i+2];
					await merge(A,r[i],r[i+1],e);
				}
				for(let i=1,j=2;i<rC;i++,j+=2,rC--)
					write(r,i,r[j],0,false,true);
			}
		}
		await sort(arr,len);
	}
	async adaptiveClurgeNewSolSort(len){
		async function method(A,s,l){
			let r=s+l/2|0,sb=s,br=false;
			if(compareIndices(A,r-1,r)>0)
				for(;r<s+l&&!br;r++){
					while(compareIndices(A,sb,r)<1&&sb<r)sb++;
					if(sb==r)br=true;
					else{
						for(let j=sb,k=0;j<r;j++){
							swap(A,j,r);
							if(++k>cbrt(len)){
								markSwap(j,r);
								await sleep(k=0);
							}
						}
						sb++;
					}
				}
		}
		async function nonpow2(A,s,l,r){
			let sb=s;
			console.log(9);
			if(compareIndices(A,r-1,r)>0)
				for(;r<s+l;r++,sb++){
					let st=sb-s?sb-1:s;
					if(compareIndices(A,st,r)<1)while(compareIndices(A,sb,r)<1)sb++;
					else{
						sb=s;
						while(compareIndices(A,sb,r)<1)sb++;
					}
					for(let j=sb;j<r;j++)await swap(A,j,r,.2,true);
				}
		}
		async function sort(A,ln){
			let l=2;
			for(;l<ln;l*=2)
				for(let i=0,j=0;i+l-1<ln;i+=l)
					if(l==2){
						if(compareIndices(A,i,i+1)>0){
							swap(A,i,i+1);
							if(++j>cbrt(len)){
								markSwap(i,i+1);
								await sleep(j=0);
							}
						}
					}else await method(A,i,l);
			if(l==ln)await method(A,0,ln);
			else await nonpow2(A,0,ln,l/2|0);
		}
		await sort(arr,len);
	}
	async binaryIntroSort(len){
		function floorLogBaseTwo(a){
			return log(a)/log(2)|0;
		}
		async function medianof3(A,l,m,r){
			if(compareIndices(A,r,l)<0)await swap(A,l,r,1,true);
			if(compareIndices(A,m,l)<0)await swap(A,m,l,1,true);
			if(compareIndices(A,r,m)<0)await swap(A,r,m,1,true);
			md=m;
			return A[m];
		}
		async function partition(a,lo,hi,x){
			let i=lo,j=hi;
			while(1){
				while(compareValues(a[i],x)<0)i++;
				do j--;while(compareValues(x,a[j])<0);
				if(i>j)return i;
				await swap(a,i++,j,1,true);
			}
		}
		async function introsortLoop(a,lo,hi,d){
			while(hi-lo>32){
				if(!d--)return await new HeapSorting(true).heapify(a,lo,hi,.5);
				let p=await partition(a,lo,hi,await medianof3(a,lo,lo+(hi-lo)/2|0,hi-1));
				await introsortLoop(a,p,hi,d);
				hi=p;
			}
		}
		let md;
		await introsortLoop(arr,0,len,2*floorLogBaseTwo(len));
		await binaryInsertion(arr,0,len,.2);
	}
	async circleOptimizedWeaveMergeSort(len){
		const qds=new QuadSorting();
		async function bitReversal(A,a,b){
			let l=b-a,m=0;
			let d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		async function weave(A,s,l){
			await bitReversal(A,s,s+l/2|0);
			await bitReversal(A,s+l/2|0,s+l);
			await bitReversal(A,s,s+l);
		}
		async function circle(A,a,b){
			for(;a<b;a++,b--)
				if(compareIndices(A,a,b)>0)
					await swap(A,a,b,1,true);
		}
		async function circlepass(A,s,l){
			for(let g=l;g>1;g=g/2|0)
				for(let o=0;o+g-1<l;o+=g)
					await circle(A,s+o,s+o+g-1);
		}
		async function method(A,s,l){
			if(compareIndices(A,s+l/2-1|0,s+l/2|0)>0){
				await weave(A,s,l);
				await circlepass(A,s,l);
			}
		}
		async function sort(A,ln){
			let l=2;
			for(;l<ln;l*=2)
				for(let i=0;i+l-1<ln;i+=l)
					if(l==2){
						if(compareIndices(A,i,i+1)>0)
							await swap(A,i,i+1,1,true);
					}else await method(A,i,l);
			if(l==ln)await method(A,0,ln);
			else await qds.quadSort(A,ln,0);
		}
		await sort(arr,len);
	}
	async exponentialIntroSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)
					await write(A,i,A[i+d],.1,true);
				await write(A,b,t,1,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function siftDown(A,v,i,p,n){
			while(2*i+1<n){
				let mx=v,nx=i,c=2*i+1;
				for(let j=c;j<minVal(c+2,n);j++){
					if(compareValues(A[p+j],mx)>0){
						mx=A[p+j];
						nx=j;
					}
				}
				if(nx==i)break;
				await write(A,p+i,mx,1,true);
				i=nx;
			}
			await write(A,p+i,v,1,true);
		}
		async function heapSort(A,a,b){
			let n=b-a;
			for(let i=(n-1)/2|0;i>=0;i--)
				await siftDown(A,A[a+i],i,a,n);
			for(let i=n-1;i>0;i--){
				let t=A[a+i];
				await write(A,a+i,A[a],1,false);
				await siftDown(A,t,0,a,i);
			}
		}
		async function medianof3(A,l,m,r){
			if(compareValues(A,r,l)<0)
				await swap(A,l,r,1,true);
			if(compareValues(A,m,l)<0)
				await swap(A,m,l,1,true);
			if(compareValues(A,r,m)<0)
				await swap(A,r,m,1,true);
			md=m;
			return A[m];
		}
		async function partition(a,lo,hi,x){
			let i=lo,j=hi;
			while(1){
				while(compareValues(a[i],x)<0)i++;
				do j--;while(compareValues(x,a[j])<0);
				if(i>j)return i;
				await swap(a,i++,j,1,true);
			}
		}
		async function introsortLoop(a,lo,hi,d){
			while(hi-lo>32){
				if(!d--)return await heapSort(a,lo,hi);
				let p=await partition(a,lo,hi,await medianof3(a,lo,lo+(hi-lo)/2|0,hi-1));
				if(hi-p<p-lo){
					await introsortLoop(a,p,hi,d);
					hi=p;
				}else{
					await introsortLoop(a,lo,p,d);
					lo=p;
				}
			}
		}
		async function quickSort(A,a,b){
			await introsortLoop(A,a,b,2*log2(b-a));
			await insertSort(A,a,b);
		}
		let md;
		await quickSort(arr,0,len);
	}
	async improvedWeaveMergeSortIII(len){
		function log(v){
			return 31-clz32(v);
		}
		async function bitReversal(A,a,b){
			let l=b-a,m=0,d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<l-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		function bitreverse(n,l){
			for(var v=0;l>0;v|=(n&1)<<--l,n>>=1);
			return v;
		}
		async function circleBitReverse(A,a,s,z,b){
			let c=log(b-a);
			for(let i=s;i<s+(z-s)/2|0;i++){
				let l=a+bitreverse(i,c),r=a+bitreverse(z-i+s-1,c);
				if(compareIndices(A,l,r)>0)
					await swap(A,l,r,1,true);
			}
			let m=(z-s)/2|0;
			if(m>0){
				await circleBitReverse(A,a,s,s+m,b);
				await circleBitReverse(A,a,s+m,z,b);
			}
		}
		for(let i=2;i<=len;i*=2)
			for(let j=0;j<len;j+=i)
				await circleBitReverse(arr,j,0,i,j+i,0);
		await bitReversal(arr,0,len);
	}
	async indexQuickMergeSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		function equ(a,b){
			return(a-b>>31)+(b-a>>31)+1;
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.5,true);
			else await reversal(A,s,e,.5,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(i<e&&!compareIndices(A,i,i+1))i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,.5,true);
					else await reversal(A,l,r,.5,true);
				}
				i++;
			}
		}
		function medOf3(A,a,b,c){
			let t;
			if(compareIndices(A,a,b)>0){
				t=b;
				b=a;
			}else t=a;
			if(compareIndices(A,b,c)>0){
				if(compareIndices(A,t,c)>0)return t;
				return c;
			}
			return b;
		}
		function medP3(A,a,b,d){
			if(b-a==3||(b-a>3&&!d))return medOf3(A,a,a+(b-a)/2|0,b-1);
			if(b-a<3)return a+(b-a)/2|0;
			let t=(b-a)/3|0;
			let l=medP3(A,a,a+t,--d),c=medP3(A,a+t,b-t,d),r=medP3(A,b-t,b,d);
			return medOf3(A,l,c,r);
		}
		function medOfMed(A,a,b){
			if(b-a<7)return a+(b-a)/2|0;
			let p=1;
			while(6*p<b-a)p*=3;
			let l=medP3(A,a,a+p,-1),c=medOfMed(A,a+p,b-p),r=medP3(A,b-p,b,-1);
			return medOf3(A,l,c,r);
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			return binSearch(A,a+i/2|0,minVal(b,a-1+i),v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			return binSearch(A,maxVal(a,b-i+1),b-i/2|0,v,l);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function indexSort(A,B,a,b){
			for(let i=0;i<b-a;i++){
				let nx=B[i],t=A[a+i],ch=false;
				while(compareValues(i,nx)){
					let t1=A[a+nx];
					await write(A,a+nx,t,.5,true);
					t=t1;
					let t2=B[nx];
					write(B,nx,nx,0,false,true);
					nx=t2;
					ch=true;
				}
				if(ch){
					await write(A,a+i,t,.5,true);
					write(B,i,nx,0,false,true);
				}
			}
		}
		async function merge(A,B,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			let i=a,j=m,c=0;
			while(i<m||j<b){
				if(i<m&&(j>=b||compareIndices(A,i,j)<1))
					write(B,i++-a,c,0,false,true);
				else
					write(B,j++-a,c,0,false,true);
				c++;
			}
			await indexSort(A,B,a,b);
		}
		async function findRun(A,a,b,mR){
			let i=a+1;
			if(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			}
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++],false));
			return i;
		}
		function insertSort(A,a,b){
			return findRun(A,a,b,b-a);
		}
		async function mergeSort(A,B,a,b){
			let l=b-a;
			if(l<33)return insertSort(A,a,b);
			let mR=16,rn=new Array((l-1)/mR+2|0),r=a,rf=0;
			while(r<b){
				write(rn,rf++,r,0,false,true);
				r=await findRun(A,r,b,mR);
			}
			while(rf>1){
				for(let i=0;i<rf-1;i+=2){
					let eI;
					if(i+2>=rf)eI=b;
					else eI=rn[i+2];
					await merge(A,B,rn[i],rn[i+1],eI);
				}
				for(let i=1,j=2;i<rf;i++,j+=2,rf--)
					write(rn,i,rn[j],0,false,true);
			}
		}
		function pivCmp(v,p){
			return compareValues(v,p)+1;
		}
		async function partition(A,B,a,b,p){
			let pt=[0,0,0,0];
			for(let i=a;i<b;i++){
				let c=pivCmp(A[i],p);
				write(B,i-a,c,0,false,true);
				pt[c]++;
			}
			for(let i=1;i<pt.length;i++)pt[i]+=pt[i-1];
			for(let i=b-a-1;i>=0;i--)
				write(B,i,--pt[B[i]],0,false,true);
			await indexSort(A,B,a,b);
			for(let i=0;i<pt.length;i++)pt[i]+=a;
			return[pt[1],pt[2]];
		}
		async function sortHelper(A,B,a,b,bA,bd,dM){
			if(b-a<33)return await insertSort(A,a,b);
			if(dM){
				let m=a+(b-a)/2|0;
				await sortHelper(A,B,a,m,bA,bd,!dM);
				await sortHelper(A,B,m,b,bA,bd,!dM);
				await merge(A,B,a,m,b);
				return;
			}
			let pI;
			if(bd)pI=medOfMed(A,a,b);
			else pI=medP3(A,a,b,1);
			let pr=await partition(A,B,a,b,A[pI]),lL=pr[0]-a,rL=b-pr[1],qL=pr[1]-pr[0];
			if(qL==b-a)return;
			if(!rL)bd=qL<(lL/8|0);
			else if(!lL)bd=qL<(rL/8|0);
			else bd=(rL/8|0)>lL||(lL/8|0)>rL;
			if(bd)if(!--bA)return await mergeSort(A,B,a,b);
			dM=true;
			if(rL<lL){
				await sortHelper(A,B,pr[1],b,bA,bd,dM);
				await sortHelper(A,B,a,pr[0],bA,bd,dM);
			}else{
				await sortHelper(A,B,a,pr[0],bA,bd,dM);
				await sortHelper(A,B,pr[1],b,bA,bd,dM);
			}
		}
		async function quickMergeSort(A,a,b){
			let l=b-a,bl=0,eq=0,sr=0,ds,qd,lp,cnt=l,ps=a;
			while(cnt>16){
				for(qd=ds=0,lp=0;lp<16;lp++){
					let cmp=compareIndices(A,ps,ps+1);
					ds+=cmp>0?1:0;
					qd+=!cmp?1:0;
					ps++;
				}
				sr+=equ(ds,0)|equ(ds+qd,16);
				bl+=ds;
				eq+=qd;
				cnt-=16;
			}
			while(--cnt>0){
				let cmp=compareIndices(A,ps,ps+1);
				bl+=cmp>0?1:0;
				eq+=!cmp?1:0;
				ps++;
			}
			if(!bl)return;
			if(bl+eq==l-1){
				if(eq>0)await stableSegmentReversal(A,a,b-1);
				else if(b-a<4)await swap(A,a,b-1,.75,true);
				else await reversal(A,a,b-1,.75,true);
				return;
			}
			let B=new Array(l);
			let sx=l/6|0;
			if(sr>(l/20|0)||bl<=sx||bl+eq>=l-sx)
				await mergeSort(A,B,a,b);
			else await sortHelper(A,B,a,b,log2(l),false,false);
		}
		await quickMergeSort(arr,0,len);
	}
	async laziceSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,.5,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function findRun(A,a,b){
			let i=a+1,d=i<b?compareIndices(A,i-1,i++)<1:!0;
			while(i<b){
				if(d^compareIndices(A,i-1,i)<1)break;
				i++;
			}
			if(!d){
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}
			return i;
		}
		async function mergeSort(A,a,b){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)break;
				await merge(A,a,i,j=await findRun(A,i,b));
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await merge(A,k,i,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async MOMTernaryQuickSort(len){
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)
				await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let h=b,l=a,i,j,ad=true;
			while(h-l>1){
				j=l;
				for(i=l;i+2*s<=h;i+=s){
					await insertSort(A,i,i+s,.2);
					await swap(A,j++,i+s/2|0,1);
				}
				if(i<h){
					await insertSort(A,i,h,.2);
					await swap(A,j++,i+(h-(ad?1:0)-i)/2|0,1);
					if((h-i+1)%2)ad=!ad;
				}
				h=j;
			}
		}
		async function partition(A,a,b){
			let p=A[a],i=a,j=b;
			for(let k=i;k<j;k++){
				if(compareValues(A[k],p)<0)await swap(A,k,i++,1,true);
				else if(compareValues(A[k],p)>0){
					do j--;while(j>k&&compareValues(A[j],p)>0);
					await swap(A,k,j,1,true);
					if(compareValues(A[k],p)<0)
						await swap(A,k,i++,1,true);
				}
			}
			return{l:i,r:j};
		}
		async function quickSort(A,a,b,d){
			while(b-a>16){
				if(!d)return await new HeapSorting(true).heapify(A,a,b,.5);
				await medianOfThree(A,a,b);
				let mid=await partition(A,a,b);
				let l=mid.l-a,r=b-mid.r,qC=mid.r-mid.l;
				if(qC==b-a)return;
				if((!l||!r)||((l/r|0)>15||(r/l|0)>15)){
					await medianOfMedians(A,a,b,5);
					mid=await partition(A,a,b);
					l=mid.l-a;
					r=b-mid.r;
					qC=mid.r-mid.l;
					if(qC==b-a)return;
				}
				if(l>r){
					await quickSort(A,mid.r,b,--d);
					b=mid.l;
				}else{
					await quickSort(A,a,mid.l,--d);
					a=mid.r;
				}
			}
			await insertSort(A,a,b,.5);
		}
		await quickSort(arr,0,len,2*floorLog(len));
	}
	async miniWikiSort(len){
		async function multiSwap(A,a,b,len){
			for(let i=0;i<len;i++)
				await swap(A,a+i,b+i,1,true);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,1,true,false);
		}
		async function mergeFW(A,p,a,m,b,iP){
			if(iP){
				let i=a,j=m,k;
				while(i<j&&j<b)
					if(compareIndices(A,i,j)>0){
						k=j;
						while(++k<b&&compareIndices(A,i,k)>0);
						await rotate(A,i,j,k);
						i+=k-j;j=k;
					}else i++;
			}else{
				let l2=m-a,pE=p+l2;
				await multiSwap(A,p,a,l2);
				while(p<pE&&m<b){
					if(compareIndices(A,p,m)<1)
						await swap(A,a++,p++,1,true);
					else await swap(A,a++,m++,1,true);
				}
				while(p<pE)await swap(A,a++,p++,1,true);
			}
		}
		async function mergeBW(A,p,a,m,b,iP){
			if(iP){
				let i=m-1,j=b-1,k;
				while(j>i&&i>=a){
					if(compareIndices(A,i,j)>0){
						k=i;
						while(--k>=a&&compareIndices(A,k,j)>0);
						await rotate(A,k+1,i+1,j+1);
						j-=i-k;i=k;
					}else j--;
				}
			}else{
				let l2=b-m,pE=p+l2-1;
				await multiSwap(A,p,m--,l2);
				while(pE>=p&&m>=a){
					if(compareIndices(A,pE,m)+1)
						await swap(A,--b,pE--,1,true);
					else await swap(A,--b,m--,1,true);
				}
				while(pE>=p)await swap(A,--b,pE--,1,true);
			}
		}
		function selectMin(A,a,b,bL){
			let n=a;
			for(let i=n+bL;i<b;i+=bL)if(compareIndices(A,i,n)<0)n=i;
			return n;
		}
		async function blockMerge(A,a,m,b,p,t,bL,iP){
			if(compareIndices(A,m-1,m)<1)return;
			else if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			else if(b-m<=bL)return await mergeBW(A,p,a,m,b,iP);
			let b1=b-(b-m)%bL;
			let i=a+(m-a-1)%bL+1;
			for(let j=i,k=t;j<m;j+=bL,k++)
				await swap(A,j,k,1,true);
			while(i<m&&m<b1){
				if(compareIndices(A,i-1,m+bL-1)>0){
					await multiSwap(A,i,m,bL);
					await mergeBW(A,p,a,i,i+bL,iP);
					m+=bL;
				}else{
					let n=selectMin(A,i,m,bL);
					if(n-i)await multiSwap(A,i,n,bL);
					await swap(A,t++,i,1,true);
				}
				i+=bL;
			}
			if(i<m){
				do{
					let n=selectMin(A,i,m,bL);
					await multiSwap(A,i,n,bL);
					await swap(A,t++,i,1,true);
					i+=bL;
				}while(i<m);
				await mergeBW(A,p,a,b1,b,iP);
			}else{
				while(m<b1&&compareIndices(A,m-bL,m)>0)await mergeBW(A,p,a,m,m+=bL,iP);
				if(m==b1)await mergeBW(A,p,a,b1,b,iP);
				else await mergeFW(A,p,m-bL+1,m,b,iP);
			}
		}
		function countDistinct(A,a,b,nK){
			let r=1;
			for(let i=a+1;i<b&&r<nK;i++)if(compareIndices(A,i-1,i)<0)r++;
			return r;
		}
		async function extractKeys(A,a,b,nK){
			let p=a,f=1;
			for(let i=a+1;f<nK;i++)
				if(compareIndices(A,i-1,i)<0){
					await rotate(A,p,p+f,i);
					p=i-f++;
				}
			await rotate(A,a,p,p+f);
		}
		async function sort(A,l){
			let a=0,b=l;
			if(l<33)return binaryInsertion(A,a,b,.5);
			let j=l;
			while(j>16)j=(j+1)/2|0;
			for(let i=a;i<b;i+=j)
				await binaryInsertion(A,i,minVal(i+j,b),.25);
			let mK=4;
			for(let k=j,m=sqrt(j-1)+1|0;j<l;j*=2){
				let bL;
				if(j==k){
					bL=m;
					m*=2;
					k*=4;
				}else bL=m-(m+3)/4|0;
				let tL=j/bL|0,ky=bL+tL,iP=false,t=a;
				let kL=countDistinct(A,a,a+j,ky);
				if(kL<ky){
					for(let i=a+2*j;i+ky<b;i+=2*j){
						let c=countDistinct(A,i,minVal(i+j,b),ky);
						t=i;
						kL=c;
						if(c==ky)break;
					}
					if(kL<ky){
						iP=true;
						bL=2*((j-1)/kL+1|0);
						kL=kL/2|0;
					}
				}
				if(2*kL<=mK){
					for(let i=a;i+j<b;i+=2*j)
						await mergeBW(A,0,i,i+j,minVal(i+2*j,b),iP);
				}else{
					await extractKeys(A,t,minVal(t+j,b),kL);
					let p=t+tL;
					for(let i=a;i<t;i+=2*j)
						await blockMerge(A,i,i+j,i+2*j,p,t,bL,iP);
					if(t+j<b){
						await blockMerge(A,t+kL,t+j,minVal(t+2*j,b),p,t,bL,iP);
						for(let i=t+2*j;i<b;i+=2*j)
							await blockMerge(A,i,i+j,minVal(i+2*j,b),p,t,bL,iP);
					}
					await binaryInsertion(A,t,t+kL,.25);
					await mergeFW(A,0,t,t+kL,minVal(t+2*j,b),true);
				}
			}
		}
		await sort(arr,len);
	}
	async miniGrailSort(len){
		function tLCalc(n,l){
			let n1=n-l,a=0,b=l;
			while(a<b){
				let m=(a+b)/2|0;
				if(n1-m<(m+1)*l)b=m;
				else a=m+1;
			}
			return a;
		}
		async function multiSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,.5,true);
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<(l?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		async function findKeysBW(A,a,b,nK){
			let f=1,p=b-f;
			for(let i=p;i>a&&f<nK;i--){
				let o=binSearch(A,p,p+f,A[i-1],true)-p;
				if(o==f||compareIndices(A,i-1,p+o)){
					await rotate(A,i,p,p+f++);
					p=i-1;
					await rotate(A,i-1,i,p+o+1);
				}
			}
			await rotate(A,p,p+f,b);
			return f;
		}
		async function mergeBW(A,a,m,b,p,l){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a)
				if(compareIndices(A,j,p+i)<(l?1:0))
					await swap(A,k--,p+i--,1,true);
				else
					await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function inPlaceMergeBW(A,a,m,b,l){
			while(b>m&&m>a){
				let i=binSearch(A,a,m,A[b-1],!l);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m==a)break;
				b=binSearch(A,m,b,A[m-1],l);
			}
		}
		function mergeBlocks(A,a,m,b,p,l,hB){
			return hB?mergeBW(A,a,m,b,p,l):inPlaceMergeBW(A,a,m,b,l);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)
					await swap(A,p++,i++,1,true);
				else
					await swap(A,p++,j++,1,true);
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		async function pingPongMerge(A,a,m1,m,m2,b,p){
			let p1=p+m-a,pE=p+b-a;
			await mergeTo(A,a,m1,m,p);
			await mergeTo(A,m,m2,b,p1);
			await mergeTo(A,p,p1,pE,a);
		}
		async function blockSelect(A,a,ta,tm,tb,bL){
			let i1=ta,j1=tm,k=ta;
			while(k<j1&&j1<tb){
				if(compareIndices(A,a+(i1-ta+1)*bL-1,a+(j1-ta+1)*bL-1)<1){
					if(i1>k)await multiSwap(A,a+(k-ta)*bL,a+(i1-ta)*bL,bL);
					await swap(A,k++,i1,1,true);
					i1=k;
					for(let i=maxVal(k+1,tm);i<j1;i++)
						if(compareIndices(A,i,i1)<0)
							i1=i;
				}else{
					await multiSwap(A,a+(k-ta)*bL,a+(j1-ta)*bL,bL);
					await swap(A,k,j1++,1,true);
					if(i1==k++)i1=j1-1;
				}
			}
			while(k<j1-1){
				if(i1>k)await multiSwap(A,a+(k-ta)*bL,a+(i1-ta)*bL,bL);
				await swap(A,k++,i1,1,true);
				i1=k;
				for(let i=k+1;i<j1;i++)
					if(compareIndices(A,i,i1)<0)
						i1=i;
			}
		}
		async function blockMerge(A,a,m,b,t,p,bL,hB){
			let tL1=(m-a)/bL|0,bC=(b-a)/bL|0;
			let tm=t+tL1,tb=t+bC,b1=b-(b-m)%bL;
			let mK=A[tm];
			await blockSelect(A,a,t,tm,tb,bL);
			let f=a,l=compareIndexValue(A,t,mK)<0;
			for(let i=1;i<bC;i++){
				if(l^(compareIndexValue(A,t+i,mK)<0)){
					let n=a+i*bL;
					let nE=binSearch(A,n,n+bL,A[n-1],l);
					await mergeBlocks(A,f,n,f=nE,p,l,hB);
					l=!l;
				}
			}
			if(l)await mergeBlocks(A,f,b1,b,p,l,hB);
			await binaryInsertion(A,t,tb,.25);
		}
		async function sort(A,l){
			let a=0,b=l;
			if(l<33)return await binaryInsertion(A,a,b,.5);
			let bL=1<<((30-clz32(l))/2+1|0),
				tL=tLCalc(l,bL);
			let j=16;
			let k=await findKeysBW(A,a,b,bL+tL);
			if(k==1)return;
			else if(k<5){
				for(let i=a;i<b;i+=j)
					await binaryInsertion(A,i,minVal(i+j,b),.25);
				for(;j<l;j*=2)
					for(let i=a;i+j<b;i+=2*j)
						await inPlaceMergeBW(A,i,i+j,minVal(i+2*j,b),true);
				return;
			}
			if(k<bL+tL){
				k=1<<(31-clz32(k));
				bL=tL=k/2|0;
			}
			l-=k;
			let b1=b-k,t=b1,p=b1+tL;
			for(let i=a;i<b1;i+=j)
				await binaryInsertion(A,i,minVal(i+j,b1),.25);
			for(let i;4*j<=bL;j*=4){
				for(i=a;i+2*j<b1;i+=4*j)
					await pingPongMerge(A,i,i+j,i+2*j,minVal(i+3*j,b1),minVal(i+4*j,b1),p);
				if(i+j<b1)
					await mergeBW(A,i,i+j,b1,p,true);
			}
			for(;j<=bL;j*=2)
				for(let i=a;i+j<b1;i+=2*j)
					await mergeBW(A,i,i+j,minVal(i+2*j,b1),p,true);
			let lm=bL*(tL+1);
			for(let i;j<l&&minVal(2*j,l)<lm;j*=2){
				for(i=a;i+j+bL<b1;i+=2*j)
					await blockMerge(A,i,i+j,minVal(i+2*j,b1),t,p,bL,true);
				if(i+j<b1)
					await mergeBW(A,i,i+j,b1,p,true);
			}
			await binaryInsertion(A,p,b,.25);
			bL=2*j/k|0;
			for(let i;j<l;j*=2,bL*=2){
				for(i=a;i+j+bL<b1;i+=2*j)
					await blockMerge(A,i,i+j,minVal(i+2*j,b1),t,p,bL,false);
				if(i+j<b1)
					await inPlaceMergeBW(A,i,i+j,b1,true);
			}
			await inPlaceMergeBW(A,a,b1,b,true);
		}
		await sort(arr,len);
	}
	async lograilSort(len){
		let base=askForNum(1,"Block size",1);
		function productLog(n){
			let r=1;
			while((r<<r)+r-1<n)r++;
			return r;
		}
		function log2(n){
			return 31-clz32(n);
		}
		function leftBinSearch(A,a,b,val){
			while(a<b){
				let m=(a+b)>>>1;
				if(compareValues(val,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=(a+b)>>>1;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function pivCmp(v,p,c){
			return compareValues(v,p)<c;
		}
		async function pivBufXor(A,pa,pb,v,wL){
			while(wL-->0){
				if(v&1)await swap(A,pa+wL,pb+wL,1,true);
				v>>=1;
			}
		}
		function pivBufGet(A,pa,pv,pC,wL,bt){
			let r=0;
			while(wL-->0){
				r<<=1;
				r|=(pivCmp(A[pa++],pv,pC)?0:1)^bt;
			}
			return r;
		}
		async function blockCycle(A,p,n,p1,bL,wL,pv,pC,bt){
			for(let i=0;i<n;i++){
				let d=pivBufGet(A,p+i*bL,pv,pC,wL,bt);
				while(d-i){
					await blockSwap(A,p+i*bL,p+d*bL,bL);
					d=pivBufGet(A,p+i*bL,pv,pC,wL,bt);
				}
				await pivBufXor(A,p+i*bL,p1+i*bL,i,wL);
			}
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,1,true);
		}
		async function mergeFWExt(A,t,a,m,b){
			let s=m-a;
			arraycopy(A,a,t,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(t[i],A[j])<1)
					await write(A,a++,t[i++],1,true);
				else
					await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,t[i++],1,true);
		}
		async function mergeBWExt(A,tmp,a,m,b){
			let s=b-m;
			arraycopy(A,m,tmp,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a){
				if(compareValues(tmp[i],A[j])+1)
					await write(A,--b,tmp[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			}
			while(i>=0)await write(A,--b,tmp[i--],1,true);
		}
		async function blockMergeHelper(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(m-a<=bL)return await mergeFWExt(A,sw,a,m,b);
			arraycopy(A,m-bL,sw,0,bL,0,false,true);
			let bC=0,wL=log2((b-a)/bL-2|0)+1;
			let i=a,j=m,k=0,pc=p;
			while(i<m-bL&&j+bL-1<b){
				if(compareIndices(A,i+bL-1,j+bL-1)<1){
					await pivBufXor(A,i,pc,k++,wL);
					i+=bL;
				}else{
					await pivBufXor(A,j,pc,(k++<<1)|1,wL+1);
					j+=bL;
				}
				pc+=bL;
				bC++;
			}
			while(i<m-bL){
				await pivBufXor(A,i,pc,k++,wL);
				i+=bL;
				pc+=bL;
				bC++;
			}
			await arraycopy(A,a,A,m-bL,bL,.1,true);
			let a1=a+bL;
			await blockCycle(A,a1,bC,p,bL,wL,pv,pC,bt);
			let f=a1,l=pivCmp(A[a1+wL],pv,pC)^(bt!=0);
			if(!l)await swap(A,a1+wL,p+wL,1,true);
			for(k=1,j=a;k<bC;k++){
				let nx=a1+k*bL,fr=pivCmp(A[nx+wL],pv,pC)^(bt!=0);
				if(!fr)await swap(A,nx+wL,p+nx+wL-a1,1,true);
				if(l^fr){
					i=f;f=nx;
					while(i<nx){
						let c=compareIndices(A,i,f);
						if(c<0||(l&&!c))
							await write(A,j++,A[i++],1,true);
						else
							await write(A,j++,A[f++],1,true);
					}
					l=!l;
				}
			}
			if(l){
				k=a1+bC*bL;i=f;f=k;
				while(i<k&&f<b)
					if(compareIndices(A,i,f)<1)
						await write(A,j++,A[i++],1,true);
					else
						await write(A,j++,A[f++],1,true);
				if(f==b){
					while(i<k)await write(A,j++,A[i++],1,true);
					await arraycopy(sw,0,A,b-bL,bL,.1,true);
					return;
				}
			}
			i=0;
			while(i<bL&&f<b)
				if(compareValues(sw[i],A[f])<1)
					await write(A,j++,sw[i++],1,true);
				else
					await write(A,j++,A[f++],1,true);
			while(i<bL)
				await write(A,j++,sw[i++],1,true);
		}
		async function blockMergeEasy(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(b-m<=bL)return await mergeBWExt(A,sw,a,m,b);
			if(m-a<=bL)return await mergeFWExt(A,sw,a,m,b);
			let a1=a+(m-a)%bL;
			await blockMergeHelper(A,sw,a1,m,b,p,bL,pv,pC,bt);
			await mergeFWExt(A,sw,a,a1,b);
		}
		async function blockMerge(A,sw,a,m,b,bL){
			let l=m-a,r=b-m,lC=(l+r+1)/2|0,md;
			if(r<l){
				if(r<=bL)return await mergeBWExt(A,sw,a,m,b);
				let la=0,lb=r;
				while(la<lb){
					let lm=(la+lb)>>>1;
					if(compareIndices(A,m+lm,a+lC-lm-1)<1)la=lm+1;
					else lb=lm;
				}
				if(!la)md=A[a+lC-1];
				else md=compareIndices(A,m+la-1,a+lC-la-1)>0?A[m+la-1]:A[a+lC-la-1];
			}else{
				if(l<=bL)return await mergeFWExt(A,sw,a,m,b);
				let la=0,lb=l;
				while(la<lb){
					let lm=(la+lb)>>>1;
					if(compareIndices(A,a+lm,m+lC-lm-1)<0)la=lm+1;
					else lb=lm;
				}
				if(l==r&&la==l)md=A[m-1];
				else if(!la)md=A[m+lC-1];
				else md=compareIndices(A,a+la-1,m+lC-la-1)+1?A[a+la-1]:A[m+lC-la-1];
			}
			let m1=leftBinSearch(A,a,m,md);
			let m2=rightBinSearch(A,m,b,md);
			let ms2=m-rightBinSearch(A,m1,m,md);
			let ms1=leftBinSearch(A,m,m2,md)-m;
			await rotate(A,m-ms2,m,m2);
			await rotate(A,m1,m-ms2,m+ms1-ms2);
			await blockMergeEasy(A,sw,a,m1,m1+ms1,a+lC,bL,md,0,0);
			await blockMergeEasy(A,sw,m2-ms2,m2,b,a,bL,md,1,1);
		}
		async function pureLogMergeSort(A,s,a,b,bL){
			let j=16;
			for(let i=a;i<b;i+=j)
				await binaryInsertion(A,i,minVal(b,i+j),.25);
			for(;j<b-a;j*=2)
				for(let i=a;i+j<b;i+=2*j)
					await blockMerge(A,s,i,i+j,minVal(b,i+2*j),bL);
		}
		let bL=maxVal(productLog(len),minVal(base,len));
		await pureLogMergeSort(arr,new Array(bL),0,len,bL);
	}
	async smartLazyStableSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||(l&&!c))b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			return binSearch(A,a+i/2|0,minVal(b,a-1+i),v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			return binSearch(A,maxVal(a,b-i+1),b-i/2|0,v,l);
		}
		async function multiSwap(A,a,b,l,fw){
			if(a==b)return;
			if(fw)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a];
			let d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>1&&r>1)
				if(r<l){
					await multiSwap(A,m-r,m,r,false);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l,true);
					a+=l;m+=l;r-=l;
				}
			if(r==1)await insertTo(A,m,a);
			else if(l==1)await insertTo(A,a,b-1);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,.5,true);
					else await reversal(A,j,i-1,.5,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function smartInPlaceMerge(A,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function lazyStableSort(A,s,e){
			let mR=e-s;
			while(mR>31)mR=(mR+1)/2|0;
			if(await buildRuns(A,s,e,mR))return;
			for(let i,j=mR;j<e-s;j*=2){
				for(i=s;i+2*j<=e;i+=2*j)
					await smartInPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<e)await smartInPlaceMerge(A,i,i+j,e);
			}
		}
		await lazyStableSort(arr,0,len);
	}
	async weaveQuickSort(len){
		function medianOf3(A,t){
			if(!t.length)return-1;
			let[a,b,c]=t;
			if(t.length<3)return a;
			if(compareIndices(A,a,b)<1){
				if(compareIndices(A,b,c)<1)return b;
				if(compareIndices(A,a,c)<0)return c;
				return a;
			}
			if(compareIndices(A,b,c)+1)return b;
			if(compareIndices(A,a,c)<1)return a;
			return c;
		}
		function mOMHelper(A,s,l){
			if(l==1)return s;
			let m=[],t=l/3|0;
			m[0]=mOMHelper(A,s,t);
			m[1]=mOMHelper(A,s+t,t);
			m[2]=mOMHelper(A,s+2*t,t);
			return medianOf3(A,m);
		}
		function medianOfMedians(A,s,l){
			if(l==1)return s;
			let m=[],n=pow(3,round(log(l)/log(3)));
			if(n==l)return mOMHelper(A,s,l);
			n=n/3|0;
			if(2*n>=l)n=n/3|0;
			m[0]=mOMHelper(A,s,n);
			m[2]=mOMHelper(A,s+l-n,n);
			m[1]=medianOfMedians(A,s+n,l-2*n);
			return medianOf3(A,m);
		}
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.25,true);
			await write(A,a,t,.25,true);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,.5,true);
		}
		async function bitReversal(A,a,b){
			let l=b-a,m=0,d1=l>>1,d2=d1+(d1>>1);
			for(let i=1;i<len-1;i++){
				let j=d1;
				for(let k=i,n=d2;!(k&1);j-=n,k>>=1,n>>=1);
				m+=j;
				if(m>i)await swap(A,a+i,a+m,1,true);
			}
		}
		async function shuffle(A,a,b){
			let n=b-a;
			for(let j=a,m=0,k=2;(n/k|0)>0;k*=2){
				if((n/k|0)&1){
					await bitReversal(A,j,j+k);
					await bitReversal(A,j,j+k/2|0);
					await bitReversal(A,j+k/2|0,j+k);
					await rotate(A,j-m,j,j+k/2|0);
					m+=k/2|0;
					j+=k;
				}
			}
		}
		async function weavePartition(A,a,b,piv,cm){
			let c=0;
			for(let i=a;i<b;i++)
				if(compareValues(A[i],piv)<cm)
					await insertTo(A,i,i-(c--));
				else
					await insertTo(A,i,++c+i);
			let b1=b-abs(c);
			await shuffle(A,a,b1);
			let p=(a+b1)/2|0;
			if(c<0){
				await rotate(A,p,b1,b);
				p-=c;
			}
			return p;
		}
		async function weaveQuick(A,a,b){
			while(b-a>32){
				let n=b-a;n-=~n&1;
				let p=medianOfMedians(A,a,n);
				let m=await weavePartition(A,a,b,A[p],0);
				let l=m-a,r=b-m;
				if(m==a){
					m=await weavePartition(A,a,b,A[p],1);
					a=m;
				}else{
					if(r<l){
						await weaveQuick(A,m,b);
						b=m;
					}else{
						await weaveQuick(A,a,m);
						a=m;
					}
				}
			}
			await binaryInsertion(A,a,b,.25);
		}
		await weaveQuick(arr,0,len);
	}
	async ternaryIntroSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)
					await write(A,i,A[i+d],.1,true);
				await write(A,b,t,.5,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function siftDown(A,v,i,p,n){
			while(2*i+1<n){
				let mx=v,nx=i,c=2*i+1;
				for(let j=c;j<minVal(c+2,n);j++){
					if(compareValues(A[p+j],mx)>0){
						mx=A[p+j];
						nx=j;
					}
				}
				if(nx==i)break;
				await write(A,p+i,mx,1,true);
				i=nx;
			}
			await write(A,p+i,v,1,true);
		}
		async function heapSort(A,a,b){
			let n=b-a;
			for(let i=(n-1)/2|0;i>=0;i--)
				await siftDown(A,A[a+i],i,a,n);
			for(let i=n-1;i>0;i--){
				let t=A[a+i];
				write(A,a+i,A[a]);
				await siftDown(A,t,0,a,i);
			}
		}
		async function medianof3(A,l,m,r){
			if(compareValues(A,r,l)<0)await swap(A,l,r,1,true);
			if(compareValues(A,m,l)<0)await swap(A,m,l,1,true);
			if(compareValues(A,r,m)<0)await swap(A,r,m,1,true);
			return A[m];
		}
		async function partition(A,a,b,p){
			for(;a<b;a++)if(compareValues(A[a],p)+1)break;
			for(;b>a;b--)if(compareValues(A[b-1],p)<1)break;
			let i1=a,i=a-1,j=b,j1=b;
			while(1){
				while(++i<j){
					let c=compareIndexValue(A,i,p);
					if(!c)await swap(A,i1++,i,1,true);
					else if(c>0)break;
				}
				while(--j>i){
					let c=compareIndexValue(A,j,p);
					if(!c)await swap(A,--j1,j,1,true);
					else if(c<0)break;
				}
				if(i>=j){
					if(i1==b)return[a,b];
					if(j<i)j++;
					if(i1-a>i-i1){
						let i2=i;i=a;
						while(i1<i2)await swap(A,i++,i1++,1,true);
					}else while(i1>a)await swap(A,--i,--i1,1,true);
					if(b-j1>j1-j){
						let j2=j;j=b;
						while(j1>j2)await swap(A,--j,--j1,1,true);
					}else while(j1<b)await swap(A,j++,j1++,1,true);
					return[i,j];
				}
				await swap(A,i,j,1,true);
			}
		}
		async function introsortLoop(a,lo,hi,d){
			while(hi-lo>32){
				if(!d--)return await heapSort(a,lo,hi);
				let[p0,p1]=await partition(a,lo,hi,await medianof3(a,lo,lo+(hi-lo)/2|0,hi-1));
				if(hi-p1<p0-lo){
					await introsortLoop(a,p1,hi,d);
					hi=p0;
				}else{
					await introsortLoop(a,lo,p0,d);
					lo=p1;
				}
			}
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;
				e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.1,true);
				else await reversal(A,a,b-1,.1,true);
				return;
			}
			await introsortLoop(A,a,b,2*log2(b-a));
			await insertSort(A,a,b);
		}
		await quickSort(arr,0,len);
	}
	async cbrtGrailSort(len){
		const GS=new GrailSorting();
		let kLO=0,kHO,bfO,kLL,kHL,bfL;
		async function sort4Blocks(A,s,e){
			for(let i=s;i<e;i+=4)await insertSort(A,i,minVal(i+4,e),.25);
		}
		async function multiSwap(A,a,b,s){
			for(let i=0;i<s;i++)await swap(A,a+i,b+i,1,true);
		}
		async function pingPongMergeFW(A,s,m,e){
			let l=s,h=m;
			while(l<m&&h<e)
				if(compareIndices(A,l,h)<1)await swap(A,bfO++,l++,1,true);
				else await swap(A,bfO++,h++,1,true);
			while(l<m)await swap(A,bfO++,l++,1,true);
			while(h<e)await swap(A,bfO++,h++,1,true);
		}
		async function fragMergeFW(A,s,m,e){
			let l=s,h=m;
			while(l<m&&h<e)
				if(compareIndices(A,l,h)<1)await swap(A,bfO++,l++,1,true);
				else await swap(A,bfO++,h++,1,true);
			if(l<m){
				let f=m-l;
				await multiSwap(A,l,e-f,f);
				return f;
			}else return e-h;
		}
		async function blockSelectFW(A,s,m,e){
			let blL0=bfL;
			while(((e-s)/blL0|0)>kLL&&blL0<=((m-s)/2|0)&&blL0<((e-m)/2|0))blL0*=2;
			let blL1=maxVal(2*blL0/kHL|0,bfL),lOL=0,lOR=0,lOT=0;
			if((e-m)%bfL){
				lOR=(e-m)%bfL;
				e-=lOR;
				lOT+=lOR;
			}
			if((m-s)%bfL){
				lOL=(m-s)%bfL;
				await IndexedRotations.cycleReverse(A,m-lOL,m,e,.2,true);
				e-=lOL;m-=lOL;lOT+=lOL;
			}
			let k0=minVal((e-s-1)/blL0+1|0,kLL);
			for(let i=s,iK=kLO;i<=e-blL0;i+=blL0,iK++){
				let mn=i,mK=iK;
				for(let j=i+blL0,jK=iK+1;j<=e-blL0;j+=blL0,jK++){
					let c=compareIndices(A,mn,j);
					if(c>0||(!c&&compareIndices(A,mK,jK)>0)){
						mn=j;
						mK=jK;
					}
				}
				await multiSwap(A,i,mn,blL0);
				await swap(A,mK,iK,1,true);
			}
			if(blL0>bfL){
				for(let k=s;k<=e-blL0;k+=blL0){
					for(let i=k,iK=kHO;i<=e-blL1&&i<k+2*blL0;i+=blL1){
						let mn=i,mK=iK;
						for(let j=i+blL1,jK=iK+1;j<=e-blL1&&j<k+2*blL0;j+=blL1,jK++){
							let c=compareIndices(A,mn,j);
							if(c>0||(!c&&compareIndices(A,mK,jK)>0)){
								mn=j;
								mK=jK;
							}
						}
						await multiSwap(A,i,mn,blL1);
						await swap(A,mK,iK,1,true);
					}
					await insertSort(A,kHO,kHO+kHL,.1);
				}
				k0=(e-s-1)/blL1+1|0;blL0=blL1;
			}
			let fr=blL0>bfL?e:s;
			for(let i=1;i<k0;i++)
				if(blL0>bfL)await GS.grailMergeWithoutBuffer(A,s+(i-1)*blL0,blL0,blL0);
				else fr=s+(i+1)*blL0-await fragMergeFW(A,fr,s+i*blL0,minVal(s+(i+1)*blL0,e));
			await multiSwap(A,bfO,fr,e-fr);bfO+=e-fr;
			await IndexedRotations.helium(A,bfO,bfO+bfL,e,1,true);bfO=e-bfL;
			await GS.grailMergeWithoutBuffer(A,e,lOR,lOL);
			await IndexedRotations.holyGriesMills(A,bfO,e,e+lOT,1,true);
			await GS.grailMergeWithoutBuffer(A,s,e-s,lOT);bfO+=lOT;
			await insertSort(A,kLO,kLO+kLL,.1);
		}
		async function common(A,s,e){
			let l=e-s,kN=0;
			while(1<<(3*++kN)<l);
			kN=1<<kN;bfO=s;
			let k2=await GS.grailFindKeys(A,kLO,l-bfO,kN);kHO=bfO+k2;
			let k1=await GS.grailFindKeys(A,kHO,l-kHO,kN);kLO=kHO+k1;
			let k0=await GS.grailFindKeys(A,kLO,l-kLO,kN);
			kHL=k1;kLL=k0;bfL=k2;
			if(kHL<kN||kLL<kN)await GS.grailLazyStableSort(A,s,e-s);
			await IndexedRotations.helium(A,bfO,kHO,kLO+kLL,.5,true);
			kLO=bfO+k1;kHO=bfO;bfO+=kHL+kLL;
			let bS=bfO;
			await sort4Blocks(A,bfO+bfL,e);
			let tE=e,lB=bfO+bfL;e-=l%bfL;
			for(let i=4;i<=bfL;i*=2){
				for(let j=bfO+bfL;j<e;j+=2*i)await pingPongMergeFW(A,j,j+i,minVal(j+2*i,e));
				await IndexedRotations.holyGriesMills(A,bS,bfO,bfO+bfL,1,true);
				bfO=bS;lB=bfO+bfL+2*i;
			}
			for(let i=2*bfL;i<l;i*=2){
				while(bfO+bfL<e){
					await blockSelectFW(A,bfO+bfL,lB,minVal(lB+i,e));
					lB=bfO+bfL+i;
				}
				await IndexedRotations.holyGriesMills(A,bS,bfO,bfO+bfL,1,true);
				bfO=bS;lB=bfO+bfL+2*i;
			}
			if(e<tE){
				await insertSort(A,e,tE,.1);
				await pingPongMergeFW(A,bfO+bfL,e,tE);
				await GS.grailMergeWithoutBuffer(A,kHO,kHL,kLL);
				await GS.grailMergeWithoutBuffer(A,kHO,kHL+kLL,e-bfO);
				await IndexedRotations.holyGriesMills(A,s,tE-bfL,tE,1,true);
			}else{
				await GS.grailMergeWithoutBuffer(A,kHO,kHL,kLL);
				await IndexedRotations.holyGriesMills(A,kHO,bfO,bfO+bfL,1,true);
				await GS.grailMergeWithoutBuffer(A,kHO+bfL,kHL+kLL,e-bS);
			}
			await insertSort(A,s,s+bfL,.1);
			await GS.grailMergeWithoutBuffer(A,s,bfL,l-bfL);
		}
		await common(arr,0,len);
	}
	async sprawlSort(len){
		async function insert(A,k,e){
			while(e+1&&compareValues(k,A[e])<0)
				await write(A,e+1,A[e--],1,true);
			await write(A,e+1,k,1,true);
		}
		async function sprawl(A,s,m,e){
			let B=new Array(e-s),l=s,h=m,t=0;
			while(l<m&&h<e)
				if(compareIndices(A,l,h)>0){
					write(B,t++,A[h++],0,false,true);
					write(B,t++,A[l++],0,false,true);
				}else{
					write(B,t++,A[l++],0,false,true);
					write(B,t++,A[h++],0,false,true);
				}
			while(l<m)write(B,t++,A[l++],0,false,true);
			while(h<e)write(B,t++,A[h++],0,false,true);
			let d=-1;
			for(let i=0;i<t;i++){
				if(d++-1)await write(A,s+i,B[i],1,true);
				else{
					await insert(A,B[i],s+i-1);
					d=0;
				}
			}
			if(d==2)await insert(A,A[e-1],e-2);
		}
		async function merge(A,s,e){
			let m=s+(e-s)/2|0;
			if(s==e||s==m)return;
			await merge(A,s,m);
			await merge(A,m,e);
			await sprawl(A,s,m,e);
		}
		await merge(arr,0,len);
	}
	async iotaSort(len){
		async function mergeBack(A,a,p,b,q,t){
			let l=a+p-1,r=b+q-1;
			while(l>=a&&r>=b){
				t--;
				if(compareIndices(A,l,r)>0)await swap(A,t,l--,1,true);
				else await swap(A,t,r--,1,true);
			}
			let s=b+l-a;
			while(l>=a)await swap(A,--t,l--,1,true);
			while(r>=b)await swap(A,--t,r--,1,true);
			return s;
		}
		async function mergeBuf(A,a,m,b,t){
			await blockSwap(A,a,t,m-a);
			let l=t,le=l+(m-a),r=m;
			while(l<le&&r<b)
				if(compareIndices(A,l,r)<1)await swap(A,a++,l++,1,true);
				else await swap(A,a++,r++,1,true);
			while(l<le)await swap(A,a++,l++,1,true);
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function binSearchR(A,s,e,k){
			while(s<e){
				let m=s+(e-s)/2|0;
				if(compareValues(A[m],k)>0)e=m;
				else s=m+1;
			}
			return s;
		}
		async function mp2(A,a,b,t){
			if(b-a<8){
				await insertSort(A,a,b,.5);
				return false;
			}
			let r=false,n=false,z=2;
			for(;z<=b-a;z*=2){
				if(t>a&&a+2*z>b)r=true;
				await mergeBack(A,n?t>a?t:a+z:a,z/2|0,a+z/2|0,minVal(z/2|0,b-a-z/2|0),r?t+z:a+2*z);
				if(z<b-a)
					n=await mp2(A,a,a+z,maxVal(t,a+2*z));
			}
			return r;
		}
		async function mergefrag(A,st,e){
			if(e-st<32)return await insertSort(A,st,e,.1);
			let p=(31-clz32(e-st))/2|0,s=1<<p,l=st+s,R=0,t=st;
			for(let i=l;i<e;i+=s){
				let m=i;
				for(let j=i+s;j<e;j+=s)if(compareIndices(A,m,j)>0)m=j;
				await blockSwap(A,i,m,s);
				if(++R>1){
					let r=i,e=i+s;
					while(l<i&&r<e)
						if(compareIndices(A,l,r)<1)await swap(A,t++,l++,1,true);
						else await swap(A,t++,r++,1,true);
					if(l<i){
						let n=i+s-(i-l);
						await blockSwap(A,l,n,i-l);
						l=n;
					}else{
						l=r;
					}
				}
			}
			await blockSwap(A,t,l,e-l);
			t+=e-l;
			await sortrec(A,t,e);
			let pz=binSearchR(A,st,t,A[e-1]);
			let pb=binSearchR(A,st,t,A[t])-st;
			pz=st+((pz-st-1)/s+1|0)*s;
			pb=st+pb-pb%s;
			await IndexedRotations.cycleReverse(A,pz,t,e,1,true);
			await mergefrag(A,pb,pz+s);
		}
		async function sortrec(A,s,e){
			let l=e-s,h=l/2|0;
			if(l<9)return await insertSort(A,s,s+l,.1);
			while(l>8){
				await mp2(A,s,s+l/2|0,s);
				l=l/2|0;
			}
			await insertSort(A,s,s+l,.1);
			for(;l<h;l*=2)
				await mergeBuf(A,s,s+l,s+2*l,s+h);
			await sortrec(A,s+h,s+h+h/2|0);
			await mergefrag(A,s,e);
		}
		async function sort(A,st,e){
			if(st>=e)return;
			let ln=e-st,d=31-clz32(ln),c=d,f=1<<c;
			let s=st,l=-1,m=s;
			await sortrec(A,st,st+=1<<c);
			while(--c>=0)
				if(ln&(1<<c)){
					if(l<0)l=c;
					await sortrec(A,st,st+=(1<<c));
			}
			let L=1<<l;
			st=s+f;
			while(--d>=0){
				let e=1<<d;
				if(ln&e){
					await blockSwap(A,s,st,e);
					let z=await mergeBack(A,s,e,s+L,f-L,st+=e);
					if(z>m)m=z;
					f+=e;
				}
			}
			await sort(A,s,s+L);
			if(l>=0){
				let pz=binSearchR(A,s+L,end,A[s+L-1]);
				let p=(31-clz32(pz-s))/2|0,S=1<<p;
				pz=s+((pz-s-1)/S+1|0)*S;
				await mergefrag(A,s,pz);
			}
		}
		await sort(arr,0,len);
	}
	async onlineStacklessRotateMergeSort(len){
		function binSearch(A,l,r,k,b){
			while(l<r){
				let m=l+(r-l)/2|0;
				if(compareIndices(A,k,m)<b)r=m;
				else l=m+1;
			}
			return l;
		}
		async function merge(A,a,z,b){
			if(compareIndices(A,z-1,z)<1)return;
			let j,k,l,s,q=b-a,r,c;
			do{
				s=r=0;j=k=a;c=z==a;
				for(let i=z-(1-c);i<b-1;i++){
					if(c==0||compareIndices(A,i,i+1)>0){
						k=binSearch(A,l=i+1,minVal(l+q,b),i,1);
						j=binSearch(A,j,i,l,0);
						let m=l-j,n=k-l,o,p,t=maxVal(m,n);
						if(r<t)
							r=t;
						let h=minVal(m,n);
						if(h>s)s=h;
						if(m>n^h==1){
							o=j+(l-j)/2|0;
							p=binSearch(A,l,k,o,1);
						}else{
							p=l+(k-l)/2|0;
							o=binSearch(A,j,l,p++,0);
						}
						await IndexedRotations.cycleReverse(A,o,l,p,1,true);
						j=i=k;
						if(c++<1)z=o;
					}
				}
				q=r;
			}while(s>1);
		}
		async function sort(A,a,b){
			let zl=32-clz32(b-a-1),z=1;
			while(zl-->0)z*=3;
			stack:for(let i=2;i<z;){
				let l=a,r=b;
				for(let x=z/3|0;x>0;x=x/3|0)
					switch((i/x|0)%3){
						case 0:r=l+(r-l)/2|0;break;
						case 1:l+=(r-l)/2|0;break;
						case 2:await merge(A,l,l+(r-l)/2|0,r);i+=x;continue stack;
					}
				i+=2;
			}
		}
		await sort(arr,0,len);
	}
	async simpleNaturalMergeSort(len){
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)
					await write(A,a++,T[i++],1,true);
				else
					await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)
					await write(A,--b,T[i--],1,true);
				else
					await write(A,--b,A[j--],1,true);
			while(i>=0)
				await write(A,--b,T[i--],1,true);
		}
		function merge(A,B,a,m,b){
			return b-m<m-a?mergeBWExt(A,B,a,m,b):mergeFWExt(A,B,a,m,b);
		}
		async function findRun(A,a,b){
			let i=a+1,d=i<b?compareIndices(A,i-1,i++)<1:!0;
			if(d)while(i<b&&compareIndices(A,i-1,i)<1)i++;
			else{
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}
			return i;
		}
		async function mergeSort(A,B,a,b){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)return;
				j=await findRun(A,i,b);
				await merge(A,B,a,i,j);
				if((k=j)>=b)return;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await merge(A,B,k,i,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,new Array(len/2|0),0,len);
	}
	async iterativeMilkSort(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return Rotations.neon(A,p,a,b,1,true);
		});
		async function insert1(A,a,l){
			let t=A[l--];
			while(l>=a&&compareValues(A[l],t)>0){
				write(A,l+1,A[l--],0);
				if(++k>=kn){
					mark(l+2);
					await sleep(k=0);
				}
			}
			await write(A,l+1,t,1,true,false);
		}
		async function insert2(A,a,l,r){
			let tL=A[l--],tR=A[r];
			while(l>=a&&compareValues(A[l],tR)>0){
				write(A,l+2,A[l--],0);
				if(++k>=kn){
					mark(l+3);
					await sleep(k=0);
				}
			}
			await write(A,l+2,tR,1,true);
			while(l>=a&&compareValues(A[l],tL)>0){
				write(A,l+1,A[l--],0);
				if(++k>=kn){
					mark(l+2);
					await sleep(k=0);
				}
			}
			await write(A,l+1,tL,1,true);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function insort(A,a,b){
			let i,j,l;
			i=await findRun(A,a,b);
			while(i<b){
				j=await findRun(A,i,b);
				l=j-i;
				if(l<3){
					if(l>1)await insert2(A,a,i,i+1);
					else await insert1(A,a,i);
				}else await GS.grailMergeWithoutBuffer(A,a,i-a,l);
				i=j;
			}
		}
		async function milkpass(A,s,e){
			let b=s+(e-s)/2|0;
			if(compareIndices(A,b-1,b)>0){
				for(let a=s;a<b;a++)
					if(compareIndices(A,a,b)>0)
						for(let i=a;i<b;i++)
							await swap(A,i,b+i-a,1,true);
				await insort(A,b,e);
			}
		}
		async function non2ninsert(A,s,e){
			let ls=A[e-1];
			await insort(A,s,e);
			return ls==A[e-1];
		}
		async function non2n(A,s,e,l){
			let b=s+l/2|0,r=true,n=false;
			if(b<e){
				await insertionSort(A,b,e,.1);
				if(compareIndices(A,b-1,b)>0){
					for(let a=s;a<b;a++)
						if(compareIndices(A,a,b)>0){
							let ls=e;
							for(let i=a;i<b&&b+i-a<e;i++)
								if(b+i-a<e){
									await swap(A,i,b+(i-a),1,true);
									ls=b+i-a+1;
								}
							r=!r;
							if(ls==e&&r&&!n)n=await non2ninsert(A,b,ls);
						}
					await insort(A,b,e);
				}
			}
		}
		async function milksort(A,s,e){
			let l=2;
			for(;l<e-s;l*=2){
				let i=s;
				for(;i+l<=e;i+=l){
					if(l==2){
						if(compareIndices(A,i,i+1)>0)
							await swap(A,i,i+1,.1,true);
					}else await milkpass(A,i,i+l);
				}
				if(i-e)await non2n(A,i,e,l);
			}
			if(l==e-s)await milkpass(A,s,e);
			else await non2n(A,s,e,l);
		}
		let k=0,kn=sqrt(len);
		await milksort(arr,0,len);
	}
	async blockInsertionSortAdaRot(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return a%b<1||b%a<1?Rotations.holyGriesMills(A,p,a,b,1,true):Rotations.cycleReverse(A,p,a,b,1,true);
		});
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.2,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function insertionSort(A,a,b){
			let i,j,k;
			i=await findRun(A,a,b);
			while(i<b){
				j=await findRun(A,i,b);k=j-i;
				await GS.grailMergeWithoutBuffer(A,a,i-a,k);i=j;
			}
		}
		await insertionSort(arr,0,len);
	}
	async rougeLazyStableSort(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return a%b<1||b%a<1?Rotations.holyGriesMills(A,p,a,b,1,true):Rotations.cycleReverse(A,p,a,b,1,true);
		});
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.2,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function insertionSort(A,a,b){
			let i,j,k;i=await findRun(A,a,b);
			while(i<b){
				await GS.grailMergeWithoutBuffer(A,a,i-a,k=(j=await findRun(A,i,b))-i);
				i=j;
			}
		}
		for(let j=2;j<=len;j++)for(let i=0;i<len;i+=j)await insertionSort(arr,i,minVal(i+j,len));
	}
	async twoNSubPrimeShellSort(len){
		function lessPrime(n){
			let b=false;
			if(n<3)return 1;
			while(!b){
				n--;
				for(let i=sqrt(n)|0;i<n;i++){
					if(n%i<1)break;
					if(i==n-1)b=true;
				}
			}
			return n;
		}
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],0,w=true);
				if(w)await write(A,j,v,.2,true);
			}
		}
		let gaps=[1,3];
		for(let g=8;g<=len;g*=2)gaps.push(lessPrime(g));
		for(let i=gaps.pop();gaps.length;i=gaps.pop())await shellPass(arr,len,i);
		await shellPass(arr,len,1);
		gaps=[];
	}
	async ternaryInsertionSort(len){
		function ternary(A,s,e,k){
			while(s<e-1){
				let t=(e-s+1)/3|0,a=s+t,b=e-t;
				if(compareValues(A[a],k)>0)e=a;
				else if(compareValues(A[b],k)<0)s=b;
				else s=a,e=b;
			}
			return compareValues(A[s],k)>0?s:e;
		}
		for(let i=1;i<len;i++)
			await Wr.insert(arr,i,ternary(arr,0,i,arr[i]),.05,true);
	}
	async blockShellSort(len){
		function gappedBinary(A,P,l,K,G,i){
			let L=-1,R=l,C,M;
			while(L<R-1){
				M=L+(R-L>>1);
				C=compareIndices(A,P+M*G,K);
				if(C>0||(i&&!C))R=M;
				else L=M;
			}
			return R;
		}
		async function GSFW(A,P,L,G){
			let t=A[P];
			for(let i=0;i<L;i++)
				await write(A,P+i*G,A[P+(i+1)*G],1,true);
			await write(A,P+L*G,t,1,true);
		}
		async function GSBW(A,P,L,G){
			let t=A[P+L*G];
			for(let i=L;i>0;i--)
				await write(A,P+i*G,A[P+(i-1)*G],1,true);
			await write(A,P,t,1,true);
		}
		async function GMSFW(A,lA,lB,L,G){
			for(let i=0;i<L;i++)
				await swap(A,lA+i*G,lB+i*G,1,true);
		}
		async function GMSBW(A,lA,lB,L,G){
			for(let i=0;i<L;i++)
				await swap(A,lA+i*G,lB+i*G,1,true);
		}
		async function rotate(A,P,L,R,G){
			while(L>1&&R>1){
				if(L<=R){
					await GMSFW(A,P,P+L*G,L,G);
					P+=L*G;R-=L;
				}else{
					await GMSBW(A,P+(L-R)*G,P+L*G,R,G);
					L-=R;
				}
			}
			if(L>0&&R>0)
				if(L==1)await GSFW(A,P,R,G);
				else if(R==1)await GSBW(A,P,L,G);
		}
		async function merge(A,P,L0,L1,G){
			let S;
			if(L0<L1){
				while(L0){
					S=gappedBinary(A,P+L0*G,L1,P,G,true);
					if(S){
						await rotate(A,P,L0,S,G);
						P+=S*G;
						L1-=S;
					}
					if(!L1)break;
					do{
						P+=G;
						L0--;
					}while(L0&&compareIndices(A,P,P+L0*G)<1);
				}
			}else{
				while(L1){
					S=gappedBinary(A,P,L0,P+(L0+L1-1)*G,G,false);
					if(S-L0){
						await rotate(A,P+S*G,L0-S,L1,G);
						L0=S;
					}
					if(!L0)break;
					do L1--;while(L1&&compareIndices(A,P+(L0-1)*G,P+(L0+L1-1)*G)<1);
				}
			}
		}
		async function gappedReverse(A,s,e,g){
			while(s<=e-g){
				await swap(A,s,e,1,true);
				s+=g;e-=g;
			}
		}
		async function getRun(A,s,e,g){
			let t=s,iD=-compareIndices(A,s,s+g),l=1;
			if(e-s<g)return 1;
			if(!iD)iD=1;
			do{
				l++;
				s+=g;
			}while(s<=e-g&&compareIndices(A,s,s+g)-iD);
			if(iD<0)await gappedReverse(A,t,s,g);
			return l;
		}
		function ciura(n){
			let gaps=[1,4,10,23,57,132,301,701];
			if(n<=gaps.length)return gaps[n-1];
			return pow(2.25,n)|0;
		}
		async function shellPass(A,s,e,g){
			if(e-s<g)return;
			let ss=new Array(g),ls=new Array(g),es=new Array(g);
			for(let i=0;i<g;i++){
				ss[i]=s+i;
				ls[i]=0;
				es[i]=e-(e%g)+i;
				if(es[i]>=e)es[i]-=g;
			}
			let d;
			do{
				d=true;
				for(let i=0;i<g;i++){
					let v=ss[i]+ls[i]*g;
					if(v>es[i]||es[i]==-1)continue;
					d=false;
					let r=await getRun(A,v,es[i],g);
					await merge(A,ss[i],ls[i],r,g);
					write(ls,i,ls[i]+r,0,false,true);
				}
			}while(!d);
		}
		async function shellSort(A,s,e){
			let k=1;
			while(ciura(k++)<e-s);
			while(--k>1)
				await shellPass(A,s,e,ciura(k-1));
		}
		await shellSort(arr,0,len);
	}
	async cappedShipperSort(len){
		function minSorted(A,st,e){
			let i=st,sg=true;
			while(sg){
				if(i+1>e)return e;
				if(compareIndices(A,i,i+1)>0)sg=false;
				else i++;
			}
			let sl=i+1;
			for(let s=i+2;s<e;s++)if(compareIndices(A,sl,s)>0)sl=s;
			let w=sl;
			while(compareIndices(A,sl,st)+1)if(++st>=e)break;
			return st;
		}
		async function shipPass(A,a,b){
			cs=false;
			ps=1;
			for(let h=1,i=h+a;i<b;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&j-h>=a&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],.1,w=true);
				if(w){
					await write(A,j,v,.1,true);
					if(h>4)cs=true;
					if(h<c)h++;
					ps=h;
				}
			}
		}
		async function shellPass(A,s,e,g){
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&j-h>=s&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],.5,w=true);
				if(w)await write(A,j,v,.5,true);
			}
		}
		let cs=true,c,ps=1;
		async function sort(A,l){
			c=l-sqrt(l)-cbrt(l)|0;
			let s=0;
			while(cs&&c>1){
				await shipPass(A,s=minSorted(A,s,l),l);
				c=ps-sqrt(ps)-cbrt(ps)|0;
			}
			await shellPass(A,s,l,1);
		}
		await sort(arr,len);
	}
	async modifiedTernaryStableQuickSort(len){
		function medOf3(A,l0,l1,l2){
			let t;
			if(compareIndices(A,l0,l1)>0){
				t=l0;l0=l1;l1=t;
			}
			if(compareIndices(A,l1,l2)>0){
				t=l1;l1=l2;l2=t;
				if(compareIndices(A,l0,l1)>0)return l0;
			}
			return l1;
		}
		function medOfMed(A,s,e,d){
			if(e-s<9||d<1)return medOf3(A,s,s+(e-s)/2|0,e);
			let dv=(e-s)/8|0;
			return medOf3(A,medOfMed(A,s,s+2*dv,--d),medOfMed(A,s+3*dv,s+5*dv,d),medOfMed(A,s+6*dv,e,d));
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],0,true);
			if(a-b)await write(A,b,t,0,true);
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		function pivCmp(v,p){
			return compareValues(v,p)+1;
		}
		async function partition(A,B,a,b,p){
			let pt=[0,0,0,0];
			for(let i=a;i<b;i++){
				write(B,i-a,A[i],.5,false,true);
				let c=pivCmp(A[i],p);
				pt[c]++;
			}
			for(let i=1;i<pt.length;i++)pt[i]+=pt[i-1];
			for(let i=b-a-1;i>=0;i--){
				let c=pivCmp(B[i],p);
				await write(A,a+--pt[c],B[i],1,true);
			}
			for(let i=1;i<pt.length;i++)pt[i]+=a;
			return[pt[1],pt[2]];
		}
		async function sortHelper(A,B,a,b){
			while(b-a>16){
				let pI=medOfMed(A,a,b-1,log(b-a)/log(9)|0);
				let[p0,p1]=await partition(A,B,a,b,A[pI]);
				if(p1-p0==b-a)return;
				if(b-p1<p0-a){
					await sortHelper(A,B,p1,b);
					b=p0;
				}else{
					await sortHelper(A,B,a,p0);
					a=p1;
				}
			}
			await insertSort(A,a,b);
		}
		await sortHelper(arr,new Array(len),0,len);
	}
	async ternaryIndexQuickSort(len){
		function medOf3(A,l0,l1,l2){
			let t;
			if(compareIndices(A,l0,l1)>0){
				t=l0;l0=l1;l1=t;
			}
			if(compareIndices(A,l1,l2)>0){
				t=l1;l1=l2;l2=t;
				if(compareIndices(A,l0,l1)>0)return l0;
			}
			return l1;
		}
		function medOfMed(A,s,e,d){
			if(e-s<9||d<1)return medOf3(A,s,s+(e-s)/2|0,e);
			let dv=(e-s)/8|0;
			return medOf3(A,medOfMed(A,s,s+2*dv,--d),medOfMed(A,s+3*dv,s+5*dv,d),medOfMed(A,s+6*dv,e,d));
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],0,true);
			if(a-b)await write(A,b,t,0,true);
		}
		async function insertSort(A,a,b){
			let i=a+1;
			if(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			}
			for(;i<b;i++)await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function indexSort(A,I,a,b){
			for(let i=0;i<b-a;i++){
				let n=I[i],t=A[a+i],c=false;
				while(compareValues(i,n)){
					let t1=A[a+n];
					await write(A,a+n,t,.1,true);
					t=t1;
					let t2=I[n];
					write(I,n,n,0,false,true);
					n=t2;c=true;
				}
				if(c){
					await write(A,a+i,t,.1,true);
					write(I,i,n,0,false,true);
				}
			}
		}
		async function partition(A,I,a,b,p){
			let pt=[0,0,0,0];
			pt[0]=a;
			for(let i=a;i<b;i++){
				let c=compareIndexValue(A,i,p);
				if(c<0){
					write(I,i-a,0,0,false,true);
					pt[0]++;
				}else if(!c){
					write(I,i-a,1,0,false,true);
					pt[1]++;
				}else{
					write(I,i-a,2,0,false,true);
					pt[2]++;
				}
			}
			for(let i=1;i<pt.length;i++)pt[i]+=pt[i-1];
			for(let i=b-a-1;i>=0;i--)
				write(I,i,--pt[I[i]]-a,0,false,true);
			await indexSort(A,I,a,b);
			return[pt[1],pt[2]];
		}
		async function sortHelper(A,i,a,b){
			while(b-a>16){
				let pI=medOfMed(A,a,b-1,log(b-a)/log(9)|0);
				let[p0,p1]=await partition(A,i,a,b,A[pI]);
				if(p1-p0==b-a)return;
				if(b-p1<p0-a){
					await sortHelper(A,i,p1,b);
					b=p0;
				}else{
					await sortHelper(A,i,a,p0);
					a=p1;
				}
			}
			await insertSort(A,a,b);
		}
		await sortHelper(arr,new Array(len),0,len);
	}
	async ternaryStableQuickSort(len){
		function medOf3(A,l0,l1,l2){
			let t;
			if(compareIndices(A,l0,l1)>0){
				t=l0;l0=l1;l1=t;
			}
			if(compareIndices(A,l1,l2)>0){
				t=l1;l1=l2;l2=t;
				if(compareIndices(A,l0,l1)>0)return l0;
			}
			return l1;
		}
		function medOfMed(A,s,e,d){
			if(e-s<9||d<1)return medOf3(A,s,s+(e-s)/2|0,e);
			let dv=(e-s)/8|0;
			return medOf3(A,medOfMed(A,s,s+2*dv,--d),medOfMed(A,s+3*dv,s+5*dv,d),medOfMed(A,s+6*dv,e,d));
		}
		async function copyReverse(s,sp,d,dp,l,x){
			for(let i=0;i<l;i++)
				await write(d,dp+i,s[sp+l-1-i],1,!x,x);
		}
		async function insertTo(A,a,b){
			let t=A[a];
			for(let i=a;i>b;i--)await write(A,i,A[i-1],.2,true);
			if(a-b)await write(A,b,t,.1,true);
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function partition(A,B,a,b,p){
			let l=b-a;
			let p0=a,p1=0,p2=l;
			for(let i=a;i<b;i++){
				let c=compareIndexValue(A,i,p);
				if(c<0)await write(A,p0++,A[i],1,true);
				else if(!c)write(B,--p2,A[i],0,false,true);
				else write(B,p1++,A[i],0,false,true);
			}
			let qS=l-p2,gS=p1;
			await copyReverse(B,p2,A,p0,qS);
			await arraycopy(B,0,A,p0+qS,gS,1,true);
			return[p0,p0+qS];
		}
		async function sortHelper(A,B,a,b){
			while(b-a>16){
				let pI=medOfMed(A,a,b-1,log(b-a)/log(9)|0);
				let[p0,p1]=await partition(A,B,a,b,A[pI]);
				if(p1-p0==b-a)return;
				if(b-p1<p0-a){
					await sortHelper(A,B,p1,b);
					b=p0;
				}else{
					await sortHelper(A,B,a,p0);
					a=p1;
				}
			}
			await insertSort(A,a,b);
		}
		await sortHelper(arr,new Array(len),0,len);
	}
	async ternaryGnomeSort(len){
		function ternary(A,s,e,k){
			while(s<e-1){
				let t=(e-s+1)/3|0,a=s+t,b=e-t;
				if(compareValues(A[a],k)>0)e=a;
				else if(compareValues(A[b],k)<0)s=b;
				else{
					s=a;
					e=b;
				}
			}
			return compareValues(A[s],k)>0?s:e;
		}
		for(let i=1;i<len;i++)
			await multiSwap(arr,i,ternary(arr,0,i,arr[i]),.1,true);
	}
	async lazierQuickSort(len){
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		function medianOf3(A,v0,v1,v2){
			let t=[0,0],v;
			v=compareIndices(A,v0,v1)>0;t[0]=v;t[1]=v^1;
			v=compareIndices(A,v0,v2)>0;t[0]+=v;
			if(t[0]==1)return v0;
			v=compareIndices(A,v1,v2)>0;t[1]+=v;
			return t[1]==1?v1:v2;
		}
		function medianOf9(A,a,b){
			let d=(b-a)/9|0;
			return medianOf3(A,medianOf3(A,a,a+d*1,a+d*2),medianOf3(A,a+d*3,a+d*4,a+d*5),medianOf3(A,a+d*6,a+d*7,a+d*8));
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		function leftBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+1)i*=2;
			return rightBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return leftBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertionSort(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)await insertTo(A,i,rightExpSearch(A,a,i,A[i]));
		}
		function rotate(A,a,m,b){
			return IndexedRotations.holyGriesMills(A,a,m,b,1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftBinSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a){
				if(compareIndices(A,i,j)>0){
					k=rightBinSearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=i+1-k;i=k-1;
				}else j--;
			}
		}
		async function smartInPlaceMerge(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftBoundSearch(A,a,m,A[m]);
			b=rightBoundSearch(A,m,b,A[m-1]);
			if(compareIndices(A,a,b-1)>0)await rotate(A,a,m,b);
			else if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b)j=i-(i-j-1)%mR-1;
				while(i-j<mR&&i<b)await insertTo(A,i,rightBinSearch(A,j,i,A[i++]));
				j=i++;
			}
		}
		async function insertTo(A,a,b){
			let t=A[a],c=false,i=0;
			while(a>b){
				write(A,a,A[--a]);
				c=true;
				if(++i>sqrt(len)){
					mark(a+1);
					await sleep(i=0);
				}
			}
			if(c)await write(A,b,t,.1,true);
		}
		async function lazyStableSort(A,s,e){
			let mR=e-s;
			for(;mR>31;mR=(mR+1)/2|0);
			await buildRuns(A,s,e,mR);
			for(let i,j=mR;j<e-s;j*=2){
				for(i=s;i+2*j<=e;i+=2*j)await smartInPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<e)await smartInPlaceMerge(A,i,i+j,e);
			}
		}
		async function partition(A,a,b,p){
			let l=a,r=a;
			for(let i=a;i<b;i++){
				let c=compareIndexValue(A,i,p);
				if(c<0){
					await insertTo(A,i,l++);
					r++;
				}else if(!c)await insertTo(A,i,r++);
			}
			return{l,r};
		}
		async function quickSort(A,a,b,d){
			while(b-a>16){
				if(!d)return lazyStableSort(A,a,b);
				let p=medianOf3(A,a,a+(b-a)/2|0,b-1);
				let m=await partition(A,a,b,A[p]);
				let l=m.l-a,r=b-m.r,qC=m.r-m.l;
				if(qC==b-a)return;
				if((!l||!r)||((l/r|0)>15||(r/l|0)>15)){
					p=medianOf9(A,a,b);
					m=await partition(A,a,b,A[p]);
					l=m.l-a;
					r=b-m.r;
					qC=m.r-m.l;
					if(qC==b-a)return;
				}
				if(l>r){
					await quickSort(A,m.r,b,--d);
					b=m.l;
				}else{
					await quickSort(A,a,m.l,--d);
					a=m.r;
				}
			}
			await insertionSort(A,a,b);
		}
		await quickSort(arr,0,len,2*floorLog(len));
	}
	async recursivePushSort(len){
		async function method(A,s,e){
			let as=false,i=s,f=s,g=1;
			while(i+g<=e)
				if(compareIndices(A,i-1,i+g-1)>0){
					if(!as)f=i;
					await Wr.insert(A,i+g++-1,i-1,.01,as=true);
				}else i++;
			if(as){
				if(e-i>1)await method(A,i,e);
				if(i-1-f>1)await method(A,f,i);
			}
		}
		function sorted(A,s,l){
			let c=l;
			for(let i=maxVal(s-1,0);i<l-1;i++)
				if(compareIndices(A,i,i+1)>0){
					c=i;
					break;
				}
			return c;
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binsert(A,s,l){
			for(let i=s;i<l;i++)
				if(compareIndices(A,i-1,i)>0)
					await Wr.insert(A,i,binarySearch(A,s,i-1,A[i]),.05,true);
		}
		let lc=sorted(arr,0,len);
		for(;lc-len;){
			await method(arr,lc+1,len);
			lc=sorted(arr,lc,len);
		}
		await binsert(arr,lc,len);
	}
	async randomShellSort(len){
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],0,w=true);
				if(w)await write(A,j,v,0,true);
			}
		}
		let g=len;
		while(g-1){
			g=randInt(sqrt(g)|0,g>1?g:g-1);
			await shellPass(arr,len,g);
		}
	}
	async randomCocktailShellSort(len){
		async function shellSort(A,a,b){
			let l=b-a,g=l/2|0,rng=new Random();
			while(g>0){
				if(rng.nextBoolean()){
					for(let i=a+g;i<b;i++){
						let t=A[i],j=i;
						while(j>=a+g&&compareValues(A[j-g],t)>0)
							await write(A,j,A[j-=g],0,true);
						await write(A,j,t,0,true);
					}
				}else{
					for(let i=b-g;i>=a;i--){
						let t=A[i],j=i;
						while(j<b-g&&compareValues(A[j+g],t)<0)
							await write(A,j,A[j+=g],0,true);
						await write(A,j,t,0,true);
					}
				}
				g=g/2|0;
			}
		}
		await shellSort(arr,0,len);
	}
	async randomCiuraCocktailShellSort(len){
		function ciura(n){
			let g=[1,4,10,23,57,132,301,701];
			return n<=g.length?g[n-1]:pow(2.25,n)|0;
		}
		async function shellSort(A,a,b){
			let l=b-a,g=1,k,r=new Random();
			for(k=1;g<l;k++)g=ciura(k);
			while(--k>0){
				g=ciura(k);
				if(r.nextBoolean())
					for(let i=a+g;i<b;i++){
						let t=A[i],j=i;
						while(j>=a+g&&compareValues(A[j-g],t)>0)
							await write(A,j,A[j-=g],0,true);
						await write(A,j,t,0,true);
					}
				else
					for(let i=b-g;i>=a;i--){
						let t=A[i],j=i;
						while(j<b-g&&compareValues(A[j+g],t)<0)
							await write(A,j,A[j+=g],0,true);
						await write(A,j,t,0,true);
					}
			}
		}
		await shellSort(arr,0,len);
	}
	async inverseBinaryInsertionSort(len){
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a,j=0;i-b;i+=d){
					write(A,i,A[i+d]);
					if(++j>len**.75){
						mark(i);
						await sleep(j=0);
					}
				}
				await write(A,b,t,0,true);
			}
		}
		function binSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		for(let i=1;i<len;i++)
			await insertTo(arr,len-1,binSearch(arr,0,i,arr[len-1]));
	}
	async patternDefeatingDisparityBidirectionalExponentialLinearShellSort(len){
		function disparity(A,s,e){
			if(e-s<3)return e-1;
			let n=s,x=s;
			for(let i=s+1;i<e;i++){
				if(compareIndices(A,i,x)>0){
					n=i-1;
					while(n>s&&compareIndices(A,n,i)>0)n=(n-i)*2+i;
					x=i;
				}else if(compareIndices(A,i,n)<0)n=i;
			}
			return abs(x-n);
		}
		async function isSorted(A,e){
			let c=compareIndices(A,0,1);
			if(e==2){
				if(c>0)await swap(A,0,1,0,true);
				return true;
			}
			if(!c)c=-1;
			for(let i=0;i<e-1;i++)
				if(compareIndices(A,i,i+1)-c){
					if(c>0)await reversal(A,0,i,.1,true);
					return false;
				}
			if(c>0)await reversal(A,0,e-1,.1,true);
			return true;
		}
		async function gapReverse(A,s,e,g){
			for(let i=0;s<=e-g;s+=g,e-=g){
				swap(A,s,e);
				if(++i>cbrt(e/g)){
					markSwap(s,e);
					await sleep(i=0);
				}
			}
		}
		function exp(A,s,e,v,i,g){
			let n=1;
			while(n*g<e-s&&(i^(compareValues(A[e-n*g],v)>0)))n*=2;
			if(n*g>e-s)n=(e-s)/g|0;
			return e-((n/2|0)*g);
		}
		async function shell(A,s,e,g){
			if(e-s<=g)return;
			if(g<1)g=1;
			let l=e-s,gs=new Array(g).fill(!1);
			for(let i=s+g;i<e;i++){
				let t=A[i],g1=(i-s)%g;
				if(gs[g1]^(compareValues(A[s+g1],t)>=0)){
					await gapReverse(A,s+g1,i-g,g);
					gs[g1]=!gs[g1];
					continue;
				}
				let j=exp(A,s+g1,i,t,gs[g1],g),l=i-g;
				while(j>=s){
					if(gs[g1]^compareValues(A[j],t)<0)break;
					j-=g;
				}
				for(let k=0;l>j;l-=g){
					write(A,l+g,A[l]);
					if(++k>cbrt(e/g)){
						mark(l+g);
						await sleep(k=0);
					}
				}
				await write(A,l+g,t,.1,true);
			}
			let eg=e-l%g;
			for(let i=0;i<g;i++){
				let b=i+eg;
				if(b>=e)b-=g;
				if(gs[i])await gapReverse(A,s+i,b,g);
			}
		}
		async function sort(A,l){
			let z=l;
			while(z>1){
				let d=disparity(A,0,z);
				if(d<=sqrt(z)|0)z=sqrt(z)|0;
				if(d==z-1&&await isSorted(A,l))return;
				await shell(A,0,l,d);
				z=d;
			}
		}
		await sort(arr,len);
	}
	async disparityShellSort(len){
		function disparity(A,s,e){
			if(e-s<3)return e-1;
			let n=s,x=s;
			for(let i=s+1;i<e;i++)
				if(compareIndices(A,i,x)>0)x=i;
				else if(compareIndices(A,i,n)<0)n=i;
			return abs(x-n);
		}
		async function isSorted(A,e){
			let c=compareIndices(A,0,1);
			if(e==2){
				if(c>0)await swap(A,0,1,.1,true);
				return true;
			}
			if(!c)c=-1;
			for(let i=0;i<e-1;i++)
				if(compareIndices(A,i,i+1)-c){
					if(c>0)await reversal(A,0,i,.1,true);
					return false;
				}
			if(c>0)await reversal(A,0,e-1,.1,true);
			return true;
		}
		async function shell(A,s,e,g){
			if(e-s<=g||g<1)return;
			for(let i=s+g;i<e;i++){
				let t=A[i],j=i-g;
				while(j>=s){
					if(compareValues(A[j],t)<0)break;
					await write(A,j+g,A[j],.1,true);
					j-=g;
				}
				if(j<i-g)await write(A,j+g,t,.1,true);
			}
		}
		let z=len;
		while(z>1){
			let d=disparity(arr,0,z);
			if(d==z-1&&await isSorted(arr,len))return;
			await shell(arr,0,len,d);
			z=d;
		}
	}
	async disparityBinaryShellSort(len){
		function disparity(A,e){
			if(e<3)return e-1;
			let n=0,x=0;
			for(let i=1;i<e;i++)
				if(compareIndices(A,i,x)>0)x=i;
				else if(compareIndices(A,i,n)<0)n=i;
			return abs(x-n);
		}
		function isSorted(A,e){
			for(let i=0;i<e-1;i++)
				if(compareIndices(A,i,i+1)>0)
					return false;
			return true;
		}
		async function binaryShell(A,s,e,g){
			if(e-s<=g||g<1)return;
			for(let i=s+g;i<e;i++){
				let t=A[i],l=s+(i-s)%g,h=i;
				if(compareValues(A[i-g],t)<1)continue;
				while(l<h){
					let m=l+((h-l)/(2*g)|0)*g;
					if(compareValues(A[m],t)+1)h=m;
					else l=m+g;
				}
				for(let j=i-g,k=0;j>=l;j-=g){
					write(A,j+g,A[j]);
					if(++k>sqrt(e/g)){
						mark(j+g);
						await sleep(k=0);
					}
				}
				if(l<i)await write(A,l,t,.5,true);
			}
		}
		let z=len;
		while(z>1){
			let d=disparity(arr,z);
			if(d==z-1&&isSorted(arr,len))return;
			await binaryShell(arr,0,len,d);
			z=d;
		}
	}
	async skipSort(len){
		class Node{
			constructor(i){
				this.i=i;
				this.l=null;
				this.n=null;
			}
			async visualize(a,b){
				markSwap(a,b);
				counts.aux++;
				await sleep();
			}
			async setNext(n){
				draw();
				await this.visualize(this.i,n==null?this.i:n.i);
				this.n=n;
			}
			async setLower(l){
				draw();
				await this.visualize(this.i,l==null?this.i:l.i);
				this.l=l;
			}
		}
		async function insertNode(A,c,i){
			while(c.n!=null&&compareIndices(A,i,c.n.i)>0)c=c.n;
			if(c.l==null){
				let nN=new Node(i);
				nN.setNext(c.n);
				await c.setNext(nN);
				return nN;
			}
			let nL=await insertNode(A,c.l,i);
			if(nL!=null&&rng.nextBoolean()){
				let nN=new Node(i);
				await nN.setNext(c.n);
				await c.setNext(nN);
				await nN.setLower(nL);
				return nN;
			}
			return null;
		}
		let rng;
		async function sort(A,l){
			rng=new Random();
			let h=new Node(0),b=h,it=30-clz32(l);
			while(it-->0){
				let nH=new Node(0);
				await nH.setLower(h);
				h=nH;
			}
			for(let i=0;i<l;i++)await insertNode(A,h,i);
			let t=new Array(l);
			for(let i=0;i<l;i++){
				b=b.n;
				let id=b.i;
				write(t,i,A[id],0,false,true);
			}
			await arraycopy(t,0,A,0,l,.5,true);
		}
		await sort(arr,len);
	}
	async popPopSort(len){
		async function bubble(A,s,e,d){
			let l=e-1;
			while(l>s){
				let j=s;
				for(let i=s,k=0;i<=l;i++)
					if(compareIndices(A,i-1,i)==d){
						swap(A,i-1,j=i);
						if(++k>sqrt(e)*2){
							markSwap(i-1,i);
							await sleep(k=0);
						}
					}
				l=j;
			}
		}
		async function pop(A,s,e,d){
			await bubble(A,s,s+(e-s)/4|0,-d);
			await bubble(A,s+(e-s)/4+1|0,(s+e)/2|0,d);
			await bubble(A,(s+e)/2+1|0,s+(e-s)*3/4|0,-d);
			await bubble(A,s+(e-s)*3/4+1|0,e,d);
			await bubble(A,s,(s+e)/2|0,-d);
			await bubble(A,(s+e)/2+1|0,e,d);
			await bubble(A,s,e,d);
		}
		let A=arr,l=len;
		await pop(A,1,(l+1)/4|0,-1);
		await pop(A,(l+1)/4+1|0,(l+1)/2|0,1);
		await pop(A,(l+1)/2+1|0,(l+1)*3/4|0,-1);
		await pop(A,(l+1)*3/4+1|0,l,1);
		await pop(A,1,(l+1)/2|0,-1);
		await pop(A,(l+1)/2+1|0,l,1);
		await pop(A,1,l,1);
	}
	async stacklessStoogeSort(len){
		function trit(v,s){
			while(s-->0)v=v/3|0;
			return v%3;
		}
		function cuttrit(v,s){
			let p=1,w=v;
			while(s-->0){
				v=v/3|0;
				p*=3;
			}
			return w-p*(v%3);
		}
		function flerp(v,b){
			let i=0;
			while(v>0){
				v=(b-1)*v/b|0;
				i++;
			}
			return i;
		}
		async function stacklessStoogeSort(A,i,j){
			let c=3,m=flerp(j-i+1,3)-1;
			for(let k=0;k<m;k++)c*=3;
			for(let k=0;k<c;k++){
				let a=i,b=j;
				for(let t=(b-a+1)/3|0,d=m;;t=(b-a+1)/3|0){
					switch(trit(k,d--)){
						case 0:case 2:b-=t;break;
						case 1:a+=t;break;
					}
					if((b-a+t==2)||t<1)break;
				}
				if(compareIndices(A,a,b)>0)await swap(A,a,b,.1,true);
			}
		}
		await stacklessStoogeSort(arr,0,len-1);
	}
	async trainTrackSort(len){
		for(let a=0,b=0,l=len;b<l;b++){
			a=l-b-1;
			for(let i=0;i<l&&a<l;i++)
				for(let j=0;j<l&&a<l;j++)
					if((a>j)^compareIndices(arr,a,j)>0)
						await swap(arr,a++,j,1,true);
					else a=a+(a>i?-1:1);
		}
	}
	async reboundSort(len){
		let a=false,b=false;
		for(let d=1;!b;d=-d){
			let i=d>0||!a?0:len-2;
			a=b=true;
			for(;i>=0&&i<len-1;i+=d){
				if(compareIndices(arr,i,i+1)>0){
					await swap(arr,i,i+1,.1,true,b=false);
					d=-d;
				}
			}
		}
	}
	async thirtySort(len){
		for(let i=0,d=1;i<len;i++,d=-d){
			let e=false;
			for(let j=d>0?i+1:len-1;(d>0&&j<len||d<0&&j>i)&&!e;j+=d)
				if(compareIndices(arr,i,j)>0)
					await swap(arr,i--,j,.01,e=true);
		}
	}
	async weavedPopSort(len){
		let g=4,s=0,d=-1,f=false;
		while(!f){
			let o=false;
			for(let b=s,e=len;!o;){
				o=true;
				let ff=false,l=e;
				for(let i=b-g>s?b-g:s;i+g<e;i+=g)
					if(compareIndices(arr,i,i+g)==d){
						if(!ff)b=i;
						await swap(arr,i,l=i+g,0,ff=true,o=false);
					}
				e=l;
			}
			d=-d;
			if(++s==g){
				s=0;
				if(g==1)f=true;
				else{
					g=g/2|0;
					if(g==1){
						for(let i=0,j=len-len%2-2;i<j;i+=2,j-=2)await swap(arr,i,j,1,true);
						d=1;
					}else d=-1;
				}
			}
		}
	}
	async weavedIterativePopSort(len){
		let g=2,s=0,d=-1,f=false;
		while(g*2<=(len/2|0))g*=2;
		while(!f){
			let o=false;
			for(let b=s,e=len;!o;){
				o=true;
				let ff=false,l=e;
				for(let i=b-g>s?b-g:s;i+g<e;i+=g)
					if(compareIndices(arr,i,i+g)==d){
						if(!ff)b=i;
						await swap(arr,i,l=i+g,0,ff=true,o=false);
					}
				e=l;
			}
			d=-d;
			if(++s==g){
				s=0;
				if(g==1)f=true;
				else{
					g=g/2|0;
					if(g==1){
						for(let i=0,j=len-len%2-2;i<j;i+=2,j-=2)await swap(arr,i,j,1,true);
						d=1;
					}else d=-1;
				}
			}
		}
	}
	async iterativePopSort(len){
		async function bubble(A,st,e,d){
			let c=1,s,f=1;
			for(let j=e-1;j>0;j-=c){
				if(f-1<st)s=st;
				else s=f-1;
				let a=false;c=1;
				for(let i=s;i<j;i++)
					if(compareIndices(A,i,i+1)==d){
						await swap(A,i,i+1,0,true);
						if(!a)f=i;
						a=true;
						c=1;
					}else c++;
			}
		}
		for(let l=2;l<len;l*=2){
			let i=0,d=-1;
			for(;i+l<=len;i+=l,d=-d)await bubble(arr,i,i+l,d);
			if(i-len)await bubble(arr,i,len,d);
		}
		await bubble(arr,0,len,1);
	}
	async mapleSort(len){
		let pl=true;
		for(;pl;){
			pl=false;
			let p=0;
			for(let j=0;j<len;j+=2){
				if(j-len-1&&compareIndices(arr,j,j+1)>0){
					if(j+1-p)pl=true;
					await multiSwap(arr,j+1,p,.1,true);
				}else{
					if(j-p)pl=true;
					await multiSwap(arr,j,p++,.1,true);
					if(p>=j){
						j--;
						continue;
					}
				}
				if(p<=j)p++;
			}
		}
	}
	async deakSort(len){
		async function deak(A,a,b){
			if(b-a<2)return;
			if(compareIndices(A,a,b-1)>0)await swap(A,a,b-1,.1,true);
			let m=a+(b-a)/2|0;
			await deak(A,a,m);
			await deak(A,m,b);
		}
		function segmentCount(A,s,e){
			let c=1;
			for(let i=s;i<e-1;i++)
				if(compareIndices(A,i,i+1)>0)
					c++;
			return c;
		}
		async function sort(A,l){
			let t=0,sC=segmentCount(A,0,l);
			while(sC>2&&t<l){
				for(let i=0;i<=l;i++)await deak(A,0,i);
				sC=segmentCount(A,0,l);
				t++;
			}
			if(t>=l||sC>1){
				let c=true;
				while(c){
					c=false;
					for(let i=1;i<l;i++)
						if(compareIndices(A,i,i-1)<0)
							await swap(A,i,i-1,.1,change=true);
				}
			}
		}
		await sort(arr,len);
	}
	async adaptiveSquareClamberSort(len){
		function squareSearch(A,a,b,v){
			while(a<b){
				let m=sqrt(b*a)|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		for(let r=1;r<len;r++)
			if(compareIndices(arr,r-1,r)>0){
				let l=squareSearch(arr,0,r-1,arr[r]);
				while(l<r)await swap(arr,l++,r,0,true);
			}
	}
	async adaptiveClurgeSort(len){
		async function method(A,s,n){
			let sb=s,b=false;
			for(let r=s+n/2|0;r<s+n&&!b;r++){
				if(compareIndices(A,r-1,r)>0){
					while(compareIndices(A,sb,r)<1)sb++;
					for(let l=sb;l<r;l++)await swap(A,l,r,0,true);
					sb++;
				}else b=true;
			}
		}
		async function nonpow2(A,s,n,m){
			let sb=s;
			for(let r=m;r<s+n;r++){
				if(compareIndices(A,r-1,r)>0){
					let st=sb-s?sb-1:s;
					if(compareIndices(A,st,r)<1)while(compareIndices(A,sb,r)<1)sb++;
					else{
						sb=s;
						while(compareIndices(A,sb,r)<1)sb++;
					}
					for(let l=sb;l<r;l++)await swap(A,l,r,0,true);
					sb++;
				}
			}
		}
		let l=2;
		for(;l<len;l*=2)for(let i=0;i+l-1<len;i+=l)await method(arr,i,l);
		if(l==len)await method(arr,0,len);
		else await nonpow2(arr,0,len,l/2|0);
	}
	async inPlaceMergeSortII(len){
		async function inPlaceMerge2(A,a,m,b){
			let i=a,j=m,k;
			while(j<b){
				m=j;k=m;
				if(compareIndices(A,j-1,j)<1)return;
				while(compareIndices(A,i,j)<1)i++;
				await swap(A,i++,j++,1,true);
				while(i<m&&j<b){
					if(compareIndices(A,k,j)<1){
						await swap(A,i++,k++,1,true);
						if(k==j)k=m;
					}else{
						await IndexedRotations.cycleReverse(A,m,k,j,.2,true);
						await swap(A,i++,j++,1,true);
						k=m;
					}
				}
				await IndexedRotations.cycleReverse(A,m,k,j,.2,true);
			}
			await IndexedRotations.cycleReverse(A,i,m,b,.2,true);
		}
		for(let j=1;j<len;j*=2)
			for(let i=0;i+j<len;i+=2*j)
				await inPlaceMerge2(arr,i,i+j,minVal(i+2*j,len));
	}
	async inPlaceMergeSortIII(len){
		async function inPlaceMerge3(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			let i=a,j=m,k=m;
			while(compareIndices(A,i,j)<1)i++;j++;
			while(i<m&&j<b){
				if(compareIndices(A,i,j)<1){
					await swap(A,k++,i++,1,true);
					if(k==j)k=m;
				}else{
					IndexedRotations.cycleReverse(A,m,k,j++,.01,true);
					k=m;
				}
			}
			await IndexedRotations.cycleReverse(A,m,k,j,.01,true);
			await IndexedRotations.cycleReverse(A,i,m,j,.01,true);
		}
		for(let j=1;j<len;j*=2)
			for(let i=0;i+j<len;i+=2*j)
				await inPlaceMerge3(arr,i,i+j,minVal(i+2*j,len));
	}
	async inPlaceMergeSortIV(len){
		function binSearchR(A,a,b,k){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,m,k)>0)b=m;
				else a=m+1;
			}
			return a;
		}
		function binSearchL(A,a,b,k){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,m,k)+1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function maxShift(A,s,m,e){
			let g=m-s;
			for(let i=0;i<minVal(e-m,g);i++){
				let j=s+i,t=A[j];
				for(j+=g;j<e;j+=g)await write(A,j-g,A[j],1,true);
				await write(A,j-g,t,1,true);
			}
		}
		async function inPlaceMerge4(A,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			while(a<m&&m<b){
				a=binSearchR(A,a,m,m);
				if(a==m)return;
				let t=m;m=binSearchL(A,m,b,a);
				while(a<t){
					let w=m-t-1;w-=w%(t-a);
					await maxShift(A,a,t,m);
					a+=w;t+=w;
					let j=binSearchL(A,m,b,m-1);
					await inPlaceMerge4(A,t,m,j);
					if(m-t<=t-a){
						a+=m-t;m=j;
					}else{
						await IndexedRotations.juggling(A,a+=m-t,t=m,m=j,1,true);
						break;
					}
				}
			}
		}
		async function IPM4(A,s,e){
			for(let i=1;i<e-s;i*=2)
				for(let j=s;j<e;j+=2*i){
					if(j+i>=e)break;
					if(j+2*i<e)await inPlaceMerge4(A,j,j+i,j+2*i);
					else await inPlaceMerge4(A,j,j+i,e);
				}
		}
		await IPM4(arr,0,len);
	}
	async bufferedWeavedMergeSort(len){
		function binSearchR(A,a,b,k){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,m,k)>0)b=m;
				else a=m+1;
			}
			return a;
		}
		function binSearchL(A,a,b,k){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,m,k)+1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function maxShift(A,s,m,e){
			let g=m-s;
			for(let i=0;i<minVal(e-m,g);i++){
				let j=s+i,t=A[j];
				for(j+=g;j<e;j+=g)await write(A,j-g,A[j],1,true);
				await write(A,j-g,t,1,true);
			}
		}
		async function inPlaceMerge4(A,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			while(a<m&&m<b){
				a=binSearchR(A,a,m,m);
				if(a==m)return;
				let t=m;m=binSearchL(A,m,b,a);
				while(a<t){
					let w=m-t-1;w-=w%(t-a);
					await maxShift(A,a,t,m);
					a+=w;t+=w;
					let j=binSearchL(A,m,b,m-1);
					await inPlaceMerge4(A,t,m,j);
					if(m-t<=t-a){
						a+=m-t;m=j;
					}else{
						await IndexedRotations.juggling(A,a+=m-t,t=m,m=j,1,true);
						break;
					}
				}
			}
		}
		async function IPM4(A,s,e){
			for(let i=1;i<e-s;i*=2)
				for(let j=s;j<e;j+=2*i){
					if(j+i>=e)break;
					if(j+2*i<e)await inPlaceMerge4(A,j,j+i,j+2*i);
					else await inPlaceMerge4(A,j,j+i,e);
				}
		}
		async function mergepp(A,B,a,b,g){
			let dr=false,n=(b-a-1)/g+1|0;
			for(let i=1;i<n;i*=2){
				dr=!dr;
				let f=dr?g:1,t=dr?1:g,p=dr?a:B,q=dr?B:a;
				for(let j=0;j<n;j+=2*i){
					let h=j,l=j,m=minVal(j+i,n),r=m,e=minVal(j+2*i,n);
					while(l<m&&r<e){
						let c=p+l*f,d=p+r*f;
						if(compareIndices(A,c,d)<1){
							await swap(A,c,q+t*h++,1,true);
							l++;
						}else{
							await swap(A,d,q+t*h++,1,true);
							r++;
						}
					}
					while(l<m)await swap(A,p+l++*f,q+t*h++,1,true);
					while(r<e)await swap(A,p+r++*f,q+t*h++,1,true);
				}
			}
			if(dr)for(let i=0;i<n;i++)await swap(A,B+i,a+i*g,1,true);
		}
		async function weave(A,B,a,b,g){
			let pt=new Array(2*g).fill(0),f=new Array(g).fill(0);
			for(let i=0;i<g;i++){
				pt[2*i]=a+i;
				pt[2*i+1]=a+g+i;
			}
			let bz=a-B;
			while(B<b-bz){
				for(let i=0;i<g;i++,B++){
					let ld=pt[2*i]>=b,rd=pt[2*i+1]>=b;
					if(ld&&rd)continue;
					let m=minVal(pt[2*i],pt[2*i+1]),M=maxVal(pt[2*i],pt[2*i+1]);
					if(B>=m&&!(m==pt[2*i]?rd:ld)){
						let q=abs(f[i])*g,d=M-g,e=d,fc=0;
						while(e>=m+q){
							await swap(A,d,e,1,true);
							e-=2*g;d-=g;fc++;
						}
						if(!f[i]){
							let p=pt[2*i]+(ld?g:0)<pt[2*i+1]+(rd?g:0);
							write(pt,p?2*i:2*i+1,d+g,0,false,true);
							write(f,i,fc*(p?-1:1),0,false,true);
						}else{
							let k=d;
							for(let j=m+q;j>m;k-=g)await swap(A,j-=g,k,1,true);
							write(f,i,f[i]<0?f[i]-fc:f[i]+fc,0,false,true);
							write(pt,f[i]<0?2*i:2*i+1,k+g,0,false,true);
						}
					}
					if(!ld&&(rd||compareIndices(A,pt[2*i],pt[2*i+1])<1)){
						await swap(A,B,pt[2*i],1,true);
						if(f[i]<0){
							pt[2*i]+=(-1/f[i]+1|0)*g;
							write(f,i,f[i]+1,0,false,true);
						}else pt[2*i]+=2*g;
					}else{
						await swap(A,B,pt[2*i+1],1,true);
						if(f[i]>0){
							pt[2*i+1]+=(1/f[i]+1|0)*g;
							write(f,i,f[i]-1,0,false,true);
						}else pt[2*i+1]+=2*g;
					}
				}
			}
		}
		async function sort(A,l){
			let s=1;
			while(s*s<l)s*=2;
			if(l<64)return await IPM4(A,0,l);
			for(let i=s;i<2*s;i++)await mergepp(A,0,i,l,s);
			for(let i=s/2|0;i>0;i=i/2|0){
				await weave(A,0,s,l,i);
				await IndexedRotations.cycleReverse(A,0,l-s,l,1,true);
			}
			await sort(A,s);
			await inPlaceMerge4(A,0,s,l);
		}
		await sort(arr,len);
	}
	async moreUnoptimizedBubbleSort(len){
		for(let j=0,k=0;j<len-1;j++)
			for(let i=0;i<len-1;i++)
				if(compareIndices(arr,i,i+1)>0){
					swap(arr,i,i+1);
					if(++k>sqrt(len)){
						markSwap(i,i+1);
						await sleep(k=0);
					}
				}
	}
	async hesvoSort(len){
		let l=1;
		while(l<len){
			if(compareIndices(arr,l-1,len-1)>0)await reversal(arr,l-1,len-1,.5,true);
			if(compareIndices(arr,l-1,l)>0){
				await multiSwap(arr,l-1,len-1,0,true);
				if(l>1)l--;
			}else l++;
		}
	}
	async weirdInsertionSort(len){
		let s=false,k=0;
		while(!s){
			s=true;
			for(let i=1;i<len;i++)
				for(let j=i;j>0&&compareIndices(arr,j-1,j)>0;j--){
					swap(arr,i,j-1,0,s=false);
					if(++k>sqrt(len)){
						markSwap(i,j-1);
						await sleep(k=0);
					}
				}
		}
	}
	async inverseInsertionSort(len){
		for(let i=1;i<len;i++){
			let j=len-1,t=arr[j],k=0;
			while(j>=i||(j>=0&&compareValues(arr[j],t)+1)){
				if(j>0){
					write(arr,j,arr[j-1]);
					if(++k>sqrt(len)){
						mark(j);
						await sleep(k=0);
					}
				}
				j--;
			}
			await write(arr,j+1,t,0,true);
		}
	}
	async oreganoSort(len){
		async function sprinkle(A,s,e){
			if(e>=len||s>e)return;
			if(s-e&&compareIndices(A,s,e)>0){
				await multiSwap(A,s,e,.1,true);
				await sort(A,s+1,e-1);
			}
		}
		async function sort(A,s,e){
			await sprinkle(A,s,e);
			let q=(e-s+1)/4|0;
			if(!q)return;
			await sort(A,s,e-q);
			await sort(A,e-2*q,e);
			await sort(A,s+q,e);
			await sort(A,s,e-2*q);
		}
		await sort(arr,0,len);
	}
	async exponentialQuasiPancakeSort(len){
		async function rev(A,a,b){
			if(b<=a)return;
			if(b-a>2)await reversal(A,a,b,.1,true);
			else await swap(A,a,b,.1,true);
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function sort(A,a,b){
			for(let i=a+1;i<b;i++){
				let j=expSearch(A,a,i,A[i]);
				if(j-i){
					await rev(A,j,i-1);
					await rev(A,j,i);
				}
			}
		}
		await sort(arr,0,len);
	}
	async weavedIntrospectivePatternDefeatingIterativeHyperPopSort(len){
		async function gpedInsertion(A,s,e,g,dr){
			for(let i=s+g;i<e;i+=g){
				let t=A[i],j=i-g;
				while(j>=s){
					let c=compareValues(A[j],t);
					if(c==-dr||!c)break;
					await write(A,j+g,A[j],0,true);
					j-=g;
				}
				await write(A,j+g,t,sleep,true);
			}
		}
		async function greversal(A,s,e,g){
			let l=((e-s-1)/g|0)*g;
			for(let i=0,j=0;i<(l/2|0);i+=g)
				await swap(A,s+i,e-i-g,0,true);
		}
		async function defeatPatterns(A,s,e,g,dr){
			let c=compareIndices(A,s,s+g)*dr,n=c,t=s;
			if(!c)c=-dr;
			while(s<e-g&&(n==c||!n)){
				s+=g;
				n=compareIndices(A,s,s+g);
			}
			if(c==dr)await greversal(A,t,s+1,g);
			return s>=e-g;
		}
		async function introBubbleDown(A,s,e,g,dr){
			if(await defeatPatterns(A,s,e,g,dr))return;
			let cs=1,mC=1,uF=s,bn=pow((e-s)/g|0,.66)|0;
			for(let j=e-g,k=0;j>=uF;j-=cs*g){
				let sB=maxVal(uF-g,s),ff=false;
				for(let i=sB;i<j;i+=g){
					if(compareIndices(A,i,i+g)==dr){
						swap(A,i,i+g);
						if(++k>sqrt(len)){
							markSwap(i,i+g);
							await sleep(k=0);
						}
						if(!ff){
							uF=i;
							ff=true;
						}
						if(cs>mC)mC=cs;
						cs=1;
					}else cs++;
				}
				if(mC>bn)return await gpedInsertion(A,s,j,g,dr);
			}
		}
		async function wipdiPop(A,s,e,dr,gq,o){
			if(e-s<=gq)return;
			if(o<1)await introBubbleDown(A,s,e,gq,dr);
			else{
				let g=2,d=dr;
				while(g<2*(e-s)){
					let gr=gq*((e-s)/g|0);
					for(let i=s;i<s+gr;i++){
						await wipdiPop(A,i,e,d,gr,o-1);
						d=-d;
					}
					g*=2;
				}
				if(d==dr)await greversal(A,s,e,gq);
			}
		}
		await wipdiPop(arr,0,len,1,1,len);
	}
	async logSort(len){
		let base=askForNum(1,"Block size",1);
		function productLog(n){
			let r=1;
			while((r<<r)+r-1<n)r++;
			return r;
		}
		function medianOf3(A,i){
			if(!i.length)return-1;
			if(i.length<3)return i[0];
			if(compareIndices(A,i[0],i[1])<1){
				if(compareIndices(A,i[1],i[2])<1)return i[1];
				if(compareIndices(A,i[0],i[2])<0)return i[2];
				return i[0];
			}
			if(compareIndices(A,i[1],i[2])+1)return i[1];
			if(compareIndices(A,i[0],i[2])<1)return i[0];
			return i[2];
		}
		function medianOf9(A,s,e){
			let l=e-s,h=l/2|0,q=h/2|0,ei=q/2|0;
			return medianOf3(A,[medianOf3(A,[s,s+ei,s+q]),medianOf3(A,[s+q+ei,s+h,s+h+ei]),medianOf3(A,[s+h+q,s+h+q+ei,e-1])]);
		}
		function mOMHelper(A,s,l){
			if(l==1)return s;
			let t=l/3|0;
			return medianOf3(A,[mOMHelper(A,s,t),mOMHelper(A,s+t,t),mOMHelper(A,s+2*t,t)]);
		}
		function medianOfMedians(A,s,l){
			if(l==1)return s;
			let nP=pow(3,round(log(l)/log(3)));
			if(nP==l)return mOMHelper(A,s,l);
			nP=nP/3|0;
			if(2*nP>=l)nP=nP/3|0;
			return medianOf3(A,[mOMHelper(A,s,nP),mOMHelper(A,s+l-nP,nP),medianOfMedians(A,s+nP,l-2*nP)]);
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function pivCmp(v,p,c){
			return compareValues(v,p)<c;
		}
		async function pivBufSet(A,a,b,v,w){
			while(w-->0){
				if(v&1)await swap(A,a+w,b+w,1,true);
				v>>=1;
			}
		}
		function pivBufGet(A,a,p,c,w,b){
			let r=0;
			while(w-->0){
				r<<=1;
				r|=pivCmp(A[a++],p,c)?b:b^1;
			}
			return r;
		}
		async function partitionEasy(A,x,a,b,p,c){
			let j=0;
			for(let i=a;i<b;i++)
				if(pivCmp(A[i],p,c))await write(A,a++,A[i],0,true);
				else write(x,j++,A[i],0,false,true);
			await arraycopy(x,0,A,a,j,.5,true);
			return a;
		}
		async function blockPartition(A,x,a,b,bL,pv,c){
			if(b-a<=bL)return await partitionEasy(A,x,a,b,pv,c);
			let p=a,l=0,r=0,lb=0,rb=0;
			for(let i=a;i<b;i++){
				if(pivCmp(A[i],pv,c)){
					await write(A,p+l++,A[i],.25,true);
					if(l==bL){
						l=0;
						lb++;
						p+=bL;
					}
				}else{
					write(x,r++,A[i],.25,false,true);
					if(r==bL){
						await arraycopy(A,p,A,p+bL,l,.5,true);
						await arraycopy(x,0,A,p,bL,.5,true);
						r=0;
						rb++;
						p+=bL;
					}
				}
			}
			let mn=minVal(lb,rb);
			let m=a+lb*bL;
			if(mn>0){
				let bC=lb+rb,wL=32-clz32(mn-1);
				for(let i=0,j=0,k=0;i<mn;i++){
					while(!pivCmp(A[a+j*bL+wL],pv,c))j++;
					while(pivCmp(A[a+k*bL+wL],pv,c))k++;
					await pivBufSet(A,a+j++*bL,a+k++*bL,i,wL);
				}
				if(lb<rb){
					for(let i=bC-1,j=0;j<rb;i--)
						if(!pivCmp(A[a+i*bL+wL],pv,c))
							await blockSwap(A,a+i*bL,a+(bC-++j)*bL,bL);
					for(let i=0;i<lb;i++){
						let ds=pivBufGet(A,a+i*bL,pv,c,wL,0);
						while(ds-i){
							await blockSwap(A,a+i*bL,a+ds*bL,bL);
							ds=pivBufGet(A,a+i*bL,pv,c,wL,0);
						}
						await pivBufSet(A,a+i*bL,m+i*bL,i,wL);
					}
				}else{
					for(let i=0,j=0;j<lb;i++)
						if(pivCmp(A[a+i*bL+wL],pv,c))
							await blockSwap(A,a+i*bL,a+j++*bL,bL);
					for(let i=0;i<rb;i++){
						let ds=pivBufGet(A,m+i*bL,pv,c,wL,1);
						while(ds-i){
							await blockSwap(A,m+i*bL,m+ds*bL,bL);
							ds=pivBufGet(A,m+i*bL,pv,c,wL,1);
						}
						await pivBufSet(A,a+i*bL,m+i*bL,i,wL);
					}
				}
			}
			await arraycopy(x,0,A,b-r,r,1,true);
			if(l>0){
				arraycopy(A,b-r-l,x,0,l,0,false,true);
				await arraycopy(A,a+lb*bL,A,a+lb*bL+l,rb*bL,1,true);
				await arraycopy(x,0,A,a+lb*bL,l,1,true);
			}
			return a+lb*bL+l;
		}
		async function logSort(A,x,a,b,bL,bP){
			while(b-a>32){
				let p;
				if(bP){
					let n=b-a;n-=~n&1;
					p=medianOfMedians(A,a,n);
					bP=false;
				}else p=medianOf9(A,a,b);
				let m=await blockPartition(A,x,a,b,bL,A[p],0);
				let l=m-a,r=b-m;
				if(m==a){
					m=await blockPartition(A,x,a,b,bL,A[p],1);
					bP=l*8<r;
					a=m;
				}else{
					if(r<l){
						bP=r*8<l;
						await logSort(A,x,m,b,bL,bP);
						b=m;
					}else{
						bP=l*8<r;
						await logSort(A,x,a,m,bL,bP);
						a=m;
					}
				}
			}
			await binaryInsertion(A,a,b,.2);
		}
		let bL=maxVal(productLog(len),minVal(base,len));
		await logSort(arr,new Array(bL),0,len,bL);
	}
	async kitaSort(len){
		async function mergeTo(f,t,a,m,b,p,x){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(f,i,j)<1){
					write(t,p++,f[i++],0,!x,x);
					if(!x)await mark(p-1);
				}else{
					write(t,p++,f[j++],0,!x,x);
					if(!x)await mark(p-1);
				}
			while(i<m){
				write(t,p++,f[i++],0,!x,x);
				if(!x)await mark(p-1);
			}
			while(j<b){
				write(t,p++,f[j++],0,!x,x);
				if(!x)await mark(p-1);
			}
		}
		async function pingPongMerge(A,B,a,m1,m2,m3,b){
			let p=0,p1=p+m2-a,pE=p+b-a;
			await mergeTo(A,B,a,m1,m2,p,true);
			await mergeTo(A,B,m2,m3,b,p1,true);
			await mergeTo(B,A,p,p1,pE,a,false);
		}
		async function mergeBWExt(A,tmp,a,m,b){
			let s=b-m;
			arraycopy(A,m,tmp,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(tmp[i],A[j])+1)await write(A,--b,tmp[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,tmp[i--],1,true);
		}
		async function blockMerge(A,B,T,tT,a,m,b,bL){
			let ta=a/bL|0,tm=m/bL|0,tb=b/bL|0,ti=ta,tj=tm,i=a+T[ti]*bL,j=m+T[tj]*bL,c=0,ci=0,cj=0,bi=ti,bj=tj,l=0,r=0,t=2,p,lB,lL=true,rL=true;
			for(let k=0;k<2*bL;k++){
				if(lL&&(!rL||compareIndices(A,i,j)<1)){
					write(B,k,A[i++],0,false,true);
					l++;
					if(++ci==bL)
						if(++ti==tm)lL=false;
						else{
							i=a+T[ti]*bL;
							ci=0;
						}
				}else{
					write(B,k,A[j++],0,false,true);
					r++;
					if(++cj==bL)
						if(++tj==tb)rL=false;
						else{
							j=m+T[tj]*bL;
							cj=0;
						}
				}
			}
			lB=l>=r;p=lB?a+T[bi]*bL:m+T[bj]*bL;
			do{
				if(lL&&(!rL||compareIndices(A,i,j)<1)){
					await write(A,p++,A[i++],1,true);
					l++;
					if(++ci==bL)
						if(++ti==tm)lL=false;
						else{
							i=a+T[ti]*bL;
							ci=0;
						}
				}else{
					await write(A,p++,A[j++],1,true);
					r++;
					if(++cj==bL)
						if(++tj==tb)rL=false;
						else{
							j=m+T[tj]*bL;
							cj=0;
						}
				}
				if(++c==bL){
					if(lB){
						l-=bL;
						write(tT,t++,T[bi++],0,false,true);
					}else{
						r-=bL;
						write(tT,t++,T[bj++]+tm-ta,0,false,true);
					}
					lB=l>=r;
					p=lB?a+T[bi]*bL:m+T[bj]*bL;
					c=0;
				}
			}while(lL||rL);
			p=0;t=0;
			while(l>0){
				await arraycopy(B,p,A,a+T[bi]*bL,bL,1,true);
				write(tT,t++,T[bi++],0,false,true);
				p+=bL;
				l-=bL;
			}
			while(r>0){
				await arraycopy(B,p,A,m+T[bj]*bL,bL,1,true);
				write(tT,t++,T[bj++]+tm-ta,0,false,true);
				p+=bL;
				r-=bL;
			}
			arraycopy(tT,0,T,ta,tb-ta,0,false,true);
		}
		async function blockCycle(A,B,k,a,bL,bC){
			for(let i=0;i<bC;i++){
				if(compareValues(i,k[i])){
					arraycopy(A,a+i*bL,B,0,bL,0,false,true);
					let j=i,n=k[i];
					do{
						await arraycopy(A,a+n*bL,A,a+j*bL,bL,1,true);
						write(k,j,j,0,false,true);
						j=n;n=k[n];
					}while(compareValues(n,i));
					await arraycopy(B,0,A,a+j*bL,bL,1,true);
					write(k,j,j,0,false,true);
				}
			}
		}
		async function sort(A,l){
			let a=0,b=l;
			if(l<33)return await binaryInsertion(A,a,b,.5);
			let sL=(32-clz32(l-1))/2|0,bL=1<<sL,tL=l/bL|0,bfL=2*bL,B=new Array(bfL),t=new Array(tL),tT=new Array(tL),b1=b-l%bL,j=1;
			if(sL%2<1){
				for(let i=a+1;i<b1;i+=2)
					if(compareIndices(A,i-1,i)>0)
						await swap(A,i-1,i,.5,true);
				j*=2;
			}
			for(;j<bfL;j*=4)
				for(let i=a;i+j<b1;i+=4*j)
					await pingPongMerge(A,B,i,i+j,minVal(i+2*j,b1),minVal(i+3*j,b1),minVal(i+4*j,b1));
			for(let i=0;i<tL;i++)
				write(t,i,i&1,0,false,true);
			for(;j<l;j*=2)
				for(let i=a;i+j<b1;i+=2*j)
					await blockMerge(A,B,t,tT,i,i+j,minVal(i+2*j,b1),bL);
			await blockCycle(A,B,t,0,bL,tL);
			if(b1<b){
				await binaryInsertion(A,b1,b,.5);
				await mergeBWExt(A,B,a,b1,b);
			}
		}
		await sort(arr,len);
	}
	async miniTimSort(len){
		function getMinLevel(n){
			while(n>31)n=(n-1)/2+1|0;
			return n;
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		function leftBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+1)i*=2;
			return rightBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return leftBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			if(a>b){
				let t=A[a];
				do await write(A,a,A[--a],.25,true);while(a>b);
				await write(A,b,t,.25,true);
			}
		}
		async function insertSort(A,a,b){
			let i=a+1;
			if(i>=b)return;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)
				insertTo(A,i,rightExpSearch(A,a,i,A[i]));
		}
		async function mergeFW(A,tmp,a,m,b){
			let l1=m-a,t=a;
			arraycopy(A,a,tmp,0,l1,0,false,true);
			let i=0,mG=7,l=0,r=0;
			while(1){
				do
					if(compareValues(tmp[i],A[m])<1){
						await write(A,a++,tmp[i++],1,true);
						l++;r=0;
						if(i==l1)return;
					}else{
						await write(A,a++,A[m++],1,true);
						r++;l=0;
						if(m==b){
							while(i<l1)await write(A,a++,tmp[i++],1,true);
							return;
						}
					}
				while((l|r)<mG);
				do{
					l=leftExpSearch(A,m,b,tmp[i])-m;
					for(let j=0;j<l;j++)
						await write(A,a++,A[m++],1,true);
					await write(A,a++,tmp[i++],1,true);
					if(i==l1)return;
					if(m==b){
						while(i<l1)await write(A,a++,tmp[i++],1,true);
						return;
					}
					r=leftBoundSearch(tmp,i,l1,A[m])-i;
					for(let j=0;j<r;j++)
						await write(A,a++,tmp[i++],1,true);
					await write(A,a++,A[m++],1,true);
					if(i==l1)return;
					if(m==b){
						while(i<l1)await write(A,a++,tmp[i++],1,true);
						return;
					}
					mG--;
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function mergeBW(A,tmp,a,m,b){
			let l2=b-m,t=a;
			arraycopy(A,m,tmp,0,l2,0,false,true);
			let i=l2-1,mG=7,l=0,r=0;
			m--;
			while(1){
				do
					if(compareValues(tmp[i],A[m])+1){
						await write(A,--b,tmp[i--],1,true,false);
						l++;
						r=0;
						if(i<0)
							return;
					}else{
						await write(A,--b,A[m--],1,true,false);
						r++;
						l=0;
						if(m<a){
							while(i>=0)
								await write(A,--b,tmp[i--],1,true,false);
							return;
						}
					}
				while((l|r)<mG);
				do{
					l=(m+1)-rightExpSearch(A,a,m+1,tmp[i]);
					for(let j=0;j<l;j++)
						await write(A,--b,A[m--],1,true,false);
					await write(A,--b,tmp[i--],1,true,false);
					if(i<0)
						return;
					if(m<a){
						while(i>=0)
							await write(A,--b,tmp[i--],1,true,false);
						return;
					}
					r=(i+1)-rightBoundSearch(tmp,0,i+1,A[m]);
					for(let j=0;j<r;j++)
						await write(A,--b,tmp[i--],1,true,false);
					await write(A,--b,A[m--],1,true,false);
					if(i<0)
						return;
					if(m<a){
						while(i>=0)
							await write(A,--b,tmp[i--],1,true,false);
						return;
					}
				}while((l|r)>6);
				if(mG<0)
					mG=0;
				mG+=2;
			}
		}
		async function smartMerge(A,T,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftBoundSearch(A,a,m,A[m]);
			b=rightBoundSearch(A,m,b,A[m-1]);
			if(b-m<m-a)await mergeBW(A,T,a,m,b);
			else await mergeFW(A,T,a,m,b);
		}
		async function findRun(A,a,b,mR){
			let i=a+1,d=i<b?compareIndices(A,i-1,i++)<1:!0;
			if(d)while(i<b&&compareIndices(A,i-1,i)<1)i++;
			else{
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++]));
			return i;
		}
		async function mergeSortWithBuf(A,B,a,b){
			if(b-a<32)return await insertSort(A,a,b);
			let mR=getMinLevel(b-a);
			let runs=new Array((b-a-1)/mR+2|0);
			let r=a,rf=0;
			while(r<b){
				write(runs,rf++,r,0,false,true);
				r=await findRun(A,r,b,mR);
			}
			while(rf>1){
				for(let i=0;i<rf-1;i+=2)
					await smartMerge(A,B,runs[i],runs[i+1],i+3>rf?b:runs[i+2]);
				for(let i=1,j=2;i<rf;i++,j+=2,rf--)
					write(runs,i,runs[j],0,false,true);
			}
		}
		await mergeSortWithBuf(arr,new Array(len/2|0),0,len);
	}
	async doriSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0;
				let c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function multiSwap(A,a,b,l,fw){
			if(a==b)return;
			if(fw)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i!=b;i+=d)
				await write(A,i,A[i+d],.5,true);
			if(a-b)
				await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3)
					if(p3-p0>2)await reversal(A,p0,p3,1,true);
					else await swap(A,p0,p3,1,true);
			}
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,B,a,m,b){
			if(minVal(m-a,b-m)<9)
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			else if(m-a>b-m)await mergeBWExt(A,B,a,m,b);
			else await mergeFWExt(A,B,a,m,b);
		}
		async function blockCycle(A,B,K,a,bL,bC){
			for(let i=0;i<bC;i++){
				if(compareValues(i,K[i])){
					arraycopy(A,a+i*bL,B,0,bL,0,false,true);
					let j=i,n=K[i];
					do{
						await arraycopy(A,a+n*bL,A,a+j*bL,bL,1,true);
						write(K,j,j,0,false,true);
						j=n;n=K[n];
					}while(compareValues(n,i));
					await arraycopy(B,0,A,a+j*bL,bL,1,true);
					write(K,j,j,0,false,true);
				}
			}
		}
		async function blockMerge(A,B,T,a,m,b,bL){
			if(minVal(m-a,b-m)<=2*bL)return await merge(A,B,a,m,b);
			let c=0,t=2,i=a,j=m,k=0,l=0,r=0;
			while(c++<2*bL){
				if(compareIndices(A,i,j)<1){
					write(B,k++,A[i++],0,false,true);
					l++;
				}else{
					await write(B,k++,A[j++],0,false,true);
					r++;
				}
			}
			let lf=l>=r;
			k=lf?i-l:j-r;c=0;
			do{
				if(i<m&&(j==b||compareIndices(A,i,j)<1)){
					await write(A,k++,A[i++],1,true);
					l++;
				}else{
					await write(A,k++,A[j++],1,true);
					r++;
				}
				if(++c==bL){
					write(T,t++,(k-a)/bL-1,0,false,true);
					if(lf)l-=bL;
					else r-=bL;
					lf=l>=r;k=lf?i-l:j-r;c=0;
				}
			}while(i<m||j<b);
			let b1=b-c;
			await arraycopy(A,k-c,A,b1,c,1,true);
			r-=c;t=k=0;
			while(l>0){
				await arraycopy(B,k,A,m-l,bL,1,true);
				write(T,t++,(m-a-l)/bL,0,false,true);
				k+=bL;l-=bL;
			}
			while(r>0){
				await arraycopy(B,k,A,b1-r,bL,1,true);
				write(T,t++,(b1-a-r)/bL,0,false,true);
				k+=bL;r-=bL;
			}
			await blockCycle(A,B,T,a,bL,(b-a)/bL|0);
		}
		async function smartBlockMerge(A,B,T,a,m,b,bL){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(minVal(m-a,b-m)<=2*bL)await merge(A,B,a,m,b);
			else{
				let a1=a+(m-a)%bL;
				await blockMerge(A,B,T,a1,m,b,bL);
				if(a1>a)await mergeFWExt(A,B,a,a1,b);
			}
		}
		async function findRun(A,a,b,mR){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++],false));
			return i;
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			if(l<33)return await findRun(A,a,b,b-a);
			let mR=16,rs=new Array((b-a-1)/mR+2|0),r=a,rf=0;
			while(r<b){
				write(rs,rf++,r,.5,false,true);
				r=await findRun(A,r,b,mR);
			}
			let bL=1;
			while(bL*bL<l)bL*=2;
			let B=new Array(2*bL),T=new Array(l/bL|0);
			while(rf>1){
				for(let i=0;i<rf-1;i+=2)await smartBlockMerge(A,B,T,rs[i],rs[i+1],i+3>rf?b:rs[i+2],bL);
				for(let i=1,j=2;i<rf;i++,j+=2,rf--)write(rs,i,rs[j],0,false,true);
			}
		}
		await mergeSort(arr,0,len);
	}
	async cookieSort(len){
		const GS=new GrailSorting();
		function pow2lte(n){
			for(var v=1;v<=n;v<<=1);
			return v>>1;
		}
		function par(A,a,b){
			let ms=new Array(b-a).fill(!1);
			let m=A[a];
			for(let i=1;i<b-a;i++)
				if(A[a+i]>m){
					m=A[a+i];
					ms[i]=true;
				}
			let p=1;
			for(let j=b-a-1,i=b-a-1;j>=0&&i>=p;j--){
				while(!ms[j]&&j>0)j--;
				m=A[a+j];
				while(m<=A[a+i]&&i>=p)i--;
				if(A[a+j]>A[a+i]&&p<i-j)p=i-j;
			}
			return p;
		}
		async function pdUnstable(A,s,e){
			let f=s,c=compareIndices(A,f,f+1);
			while(c<1&&f+1<e)if(++f+1<e)c=compareIndices(A,f,f+1);
			let r=s;
			if(f==s){
				let d=false;
				c=compareIndices(A,r,r+1);
				while(c+1&&r+1<e){
					if(c)d=true;
					if(++r+1<e)c=compareIndices(A,r,r+1);
				}
				if(r>s&&d)
					if(r<s+3)await swap(A,s,r,1,true);
					else await reversal(A,s,r,1,true);
			}
			return maxVal(f,r);
		}
		async function pdUnstableNF(A,s,e){
			let r=s,d=false,c=compareIndices(A,r,r+1);
			while(c+1&&r+1<e){
				if(c)d=true;
				if(++r+1<e)c=compareIndices(A,r,r+1);
			}
			if(r>s&&d)
				if(r<s+3)await swap(A,s,r,1,true);
				else await reversal(A,s,r,1,true);
			return r;
		}
		async function pdUnstableCNF(A,s,e){
			let fr=s,f=true,r=s,ns=s;
			while(r+1<e){
				let d=false,c=compareIndices(A,r,r+1);
				while(c+1&&r+1<e){
					if(c)d=true;
					if(++r+1<e)c=compareIndices(A,r,r+1);
				}
				if(r>ns+1&&d)
					if(r<ns+3)await swap(A,ns,r,1,true);
					else await reversal(A,ns,r,1,true);
				if(f)fr=r;
				f=false;ns=++r;
			}
			return fr;
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function shellPass(A,a,b,g,p,lg){
			if(g>=lg)return lg;
			if(g==lg-1&&g-1)return lg;
			lg=g;
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g,c=false;
				for(;j>=a&&compareValues(k,A[j])<0;j-=g)await write(A,j+g,A[j],1,c=true);
				if(c)await write(A,j+g,k,1,true);
			}
			return g;
		}
		async function shellSort(A,a,b){
			let pd=await pdUnstableNF(A,a,b);
			if(pd+1<b){
				let td=3,lp=b-a,lg=b-a;
				while(1){
					let p=par(A,a,b),sp=p;
					if(p>=lp)p=lp-td|0;
					if((p/(td|0)|0)<2){
						await shellPass(A,a,b,1,p,lg);
						break;
					}
					lg=await shellPass(A,a,b,p/(td|0)+p%(td|0)|0,sp,lg);
					if(lp-p<=(sqrt(lp)|0))td*=1.5;
					lp=p;
				}
			}
		}
		async function blockFindRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a>3)await reversal(A,a,i-1,1,true);
				else await swap(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function blockInsertionSort(A,a,b){
			let i,j,k;
			i=await blockFindRun(A,a,b);
			while(i<b){
				j=await blockFindRun(A,i,b);k=j-i;
				await GS.grailMergeWithoutBuffer(A,a,i-a,k);i=j;
			}
		}
		async function pdbinsertUnstable(A,s,e){
			let p=await pdUnstable(A,s,e);
			for(let i=p+1;i<e;i++){
				let l=binarySearch(A,s,i,A[i]);
				await Wr.insert(A,i,l,1/20,true);
			}
		}
		async function milkPass(A,s,e){
			let b=s+(e-s)/2|0,la=s,cs=0,f=false;
			if(compareIndices(A,b-1,b)>0){
				for(let a=s;a<b&&!f;a++)
					if(compareIndices(A,a,b)>0){
						for(let i=a;i<b;i++)await swap(A,i,b+i-a,.5,true);
						if(a-la<3)
							if(++cs==8){
								await shellSort(A,a,e);
								f=true;
							}
						la=a;
					}else if(a-la>1)cs=0;
				if(!f)await blockInsertionSort(A,b,e);
			}
		}
		async function milkNon2N(A,s,e,l){
			let b=s+l/2|0;
			if(b<e)
				if(compareIndices(A,b-1,b)>0)
					if(e-b<=(l/8|0))await GS.grailMergeWithoutBuffer(A,s,b-s,e-b);
					else await shellSort(A,s,e);
		}
		async function milkSortLen(A,s,e,ls){
			let l=ls,i=s;
			for(;l<e-s;l*=2){
				i=s;
				for(;i+l<=e;i+=l)
					if(l==2){
						if(compareIndices(A,i,i+1)>0)await swap(A,i,i+1,1,true);
					}else await milkPass(A,i,i+l);
				if(i-e)await milkNon2N(A,i,e,l);
			}
			if(l==e-s)await milkPass(A,s,e);
			else await milkNon2N(A,s,e,l);
		}
		async function handleInsert(A,s,e){
			if(e-s<17)await pdbinsertUnstable(A,s,e);
			else await shellSort(A,s,e);
		}
		async function manageSize(A,s,l,bb){
			if(compareIndices(A,s+l-1,s+l)>0){
				for(let i=0;i<l;i++)await swap(A,s+i,bb+i,1,true);
				let x=0,y=0,b=s;
				while(x<l&&y<l){
					if(compareIndices(A,s+l+x,bb+y)<1){
						if(s+l+x-b)await swap(A,s+l+x,b,1,true);
						x++;
					}else await swap(A,bb+y++,b,1,true);
					b++;
					if(x>=l)while(y<l)await swap(A,bb+y++,b++,1,true);
				}
			}
		}
		async function cookie(A,s,l,pd){
			let bL=pow2lte(sqrt(l)|0),ep=bL;
			while(ep+bL<l)ep+=bL;
			for(let i=0;i+bL<=ep;i+=bL)if(s+i+bL>pd)await handleInsert(A,s+i,s+i+bL);
			for(let i=0;i+2*bL<=ep;i+=2*bL)await manageSize(A,s+i,bL,s+ep);
			await handleInsert(A,s+ep,s+l);
			await milkPass(A,s+ep-bL,s+l);
			await milkSortLen(A,s,s+l,4*bL);
		}
		async function cookieSort(A,s,e){
			if(par(A,s,e)<=((e-s)/8|0))await shellSort(A,s,e);
			else if(e-s<33)await handleInsert(A,s,e);
			else{
				let pd=await pdUnstableCNF(A,s,e);
				if(pd<e-1){
					let l=e-s,el=2;
					while(el<=l)el*=2;el/=2;
					await cookie(A,s,el,pd);
					if(el-l){
						await cookieSort(A,s+el,e);
						await milkNon2N(A,s,e,el*2);
					}
				}
			}
		}
		await cookieSort(arr,0,len);
	}
	async colleiSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function multiSwap(A,a,b,l,f){
			if(a==b)return;
			if(f)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		function insertToBWAux(A,a,b){
			let t=A[a];
			for(let i=a;i<b;i++)write(A,i,A[i+1],0,false,true);
			if(a-b)write(A,b,t,0,false,true);
		}
		async function shiftFWExt(A,a,m,b){
			while(m<b)await write(A,a++,A[m++],1,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3)
					if(p3-p0>2)await reversal(A,p0,p3,1,true);
					else await swap(A,p0,p3,1,true);
			}
		}
		async function mergeFromBuf(A,B,a,m,b,bL){
			let i=0;
			while(i<bL&&m<b)
				if(compareValues(B[i],A[m])<1)await write(A,a++,B[i++],1,true);
				else await write(A,a++,A[m++],1,true);
			while(i<bL)await write(A,a++,B[i++],1,true);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,B,a,m,b){
			if(minVal(m-a,b-m)<9)
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			else if(m-a>b-m)await mergeBWExt(A,B,a,m,b);
			else await mergeFWExt(A,B,a,m,b);
		}
		function getSubA(T,a,b){
			return compareIndices(T,a,b)<0;
		}
		async function blockSelect(A,T,p,r,d,lC,bC,bL){
			let mK=lC;
			for(let j=0,k=lC+1;j<k-1;j++){
				let m=j;
				for(let i=maxVal(lC-r,j+1);i<k;i++){
					let c=compareIndices(A,p+d+i*bL,p+d+m*bL);
					if(c<0||(!c&&compareIndices(T,i,m)<0))m=i;
				}
				if(m-j){
					await multiSwap(A,p+j*bL,p+m*bL,bL,true);
					swap(T,j,m,0,false,true);
					if(k<bC&&m==k-1)k++;
				}
				if(m==mK)mK=j;
			}
			return mK;
		}
		async function mergeBlocks(A,a,m,b,p,fE){
			let i=a,j=m;
			while(i<m&&j<b){
				let c=compareIndices(A,i,j);
				if(c<0||fE&&!c)await write(A,p++,A[i++],1,true);
				else await write(A,p++,A[j++],1,true);
			}
			if(i>p)await shiftFWExt(A,p,i,m);
			return j;
		}
		async function blockMerge(A,B,T,a,m,b,bL){
			if(minVal(m-a,b-m)<=bL)return await merge(A,B,a,m,b);
			let b1=b-(b-m-1)%bL-1,i=a+bL,j=a,K=-1,lC=(m-i)/bL|0,bC=(b1-i)/bL|0,l=-1,r=lC-1;
			for(let k=0;k<bL;k++){
				write(B,k,A[m-bL+k],0,false,true);
				await write(A,m-bL+k,A[a+k],.5,true);
			}
			for(let k=0;k<bC;k++)write(T,k,k,0,false,true);
			insertToBWAux(T,0,lC-1);
			let mK=await blockSelect(A,T,i,1,bL-1,lC,bC,bL);
			let f=true;
			while(l<lC&&r<bC){
				if(f){
					do{
						j+=bL;l++;K++;
					}while(l<lC&&getSubA(T,K,mK));
					if(l==lC){
						i=await mergeBlocks(A,i,j,b,i-bL,true);
						await mergeFromBuf(A,B,i-bL,i,b,bL);
					}else i=await mergeBlocks(A,i,j,j+bL-1,i-bL,true);
				}else{
					do{
						j+=bL;r++;K++;
					}while(r<bC&&!getSubA(T,K,mK));
					if(r==bC){
						await shiftFWExt(A,i-bL,i,b);
						await arraycopy(B,0,A,b-bL,bL,1,true);
					}else i=await mergeBlocks(A,i,j,j+bL-1,i-bL);
				}
				f=!f;
			}
		}
		async function smartBlockMerge(A,B,T,a,m,b,bL){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(minVal(m-a,b-m)<=bL)await merge(A,B,a,m,b);
			else{
				let a1=a+(m-a)%bL;
				await blockMerge(A,B,T,a1,m,b,bL);
				if(a1>a)await mergeFWExt(A,B,a,a1,b);
			}
		}
		async function findRun(A,a,b,mR){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++],false));
			return i;
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			if(l<33)return await findRun(A,a,b,b-a);
			let mR=16,rs=new Array((b-a-1)/mR+2|0),r=a,rf=0;
			while(r<b){
				write(rs,rf++,r,.5,false,true);
				r=await findRun(A,r,b,mR);
			}
			let bL=1;
			while(bL*bL<l)bL*=2;
			let B=new Array(bL),T=new Array(l/bL|0);
			while(rf>1){
				for(let i=0;i<rf-1;i+=2)await smartBlockMerge(A,B,T,rs[i],rs[i+1],i+3>rf?b:rs[i+2],bL);
				for(let i=1,j=2;i<rf;i++,j+=2,rf--)write(rs,i,rs[j],0,false,true);
			}
		}
		await mergeSort(arr,0,len);
	}
	async moreTernaryIntroSort(len){
		function ternary(A,s,e,k){
			while(s<e-1){
				let t=(e-s+1)/3|0,mA=s+t,mB=e-t;
				if(compareValues(A[mA],k)>0)e=mA;
				else if(compareValues(A[mB],k)<0)s=mB;
				else{
					s=mA;
					e=mB;
				}
			}
			return compareValues(A[s],k)>0?s:e;
		}
		async function ternaryInsert(A,a,b){
			for(let i=a+1;i<b;i++)
				await Wr.insert(A,i,ternary(A,0,i,A[i],1),.05,true);
		}
		let hS;
		async function maxHeapify(A,i){
			let lC=3*i+1,mC=lC+1,rC=lC+2,l;
			l=lC<=hS&&compareIndices(A,lC,i)>0?lC:i;
			l=rC<=hS&&compareIndices(A,rC,l)>0?rC:l;
			l=mC<=hS&&compareIndices(A,mC,l)>0?mC:l;
			if(l-i){
				await swap(A,i,l,1,true);
				await maxHeapify(A,l);
			}
		}
		async function buildMaxTernaryHeap(A,a,b){
			hS=b-1;
			for(let i=b-1/3|0;i>=a;i--)await maxHeapify(A,i);
		}
		async function ternaryHeap(A,a,b){
			await buildMaxTernaryHeap(A,a,b);
			for(let i=b-1;i>=a;i--){
				await swap(A,a,i,1,true);
				hS--;
				await maxHeapify(A,a);
			}
		}
		function log2(a){
			return log(a)/log(2)|0;
		}
		async function medianof3(A,l,m,r){
			if(compareIndices(A,r,l)<0)await swap(A,l,r,1,true);
			if(compareIndices(A,m,l)<0)await swap(A,m,l,1,true);
			if(compareIndices(A,r,m)<0)await swap(A,r,m,1,true);
			return A[m];
		}
		async function partition(A,a,b,p){
			for(;a<b;a++)if(compareValues(A[a],p)+1)break;
			for(;b>a;b--)if(compareValues(A[b-1],p)<1)break;
			let i1=a,i=a-1,j=b,j1=b;
			while(1){
				while(++i<j){
					let c=compareIndexValue(A,i,p);
					if(!c)await swap(A,i1++,i,1,true);
					else if(c>0)break;
				}
				while(--j>i){
					let c=compareIndexValue(A,j,p);
					if(!c)await swap(A,--j1,j,1,true);
					else if(c<0)break;
				}
				if(i>=j){
					if(i1==b)return[a,b];
					if(j<i)j++;
					if(i1-a>i-i1){
						let i2=i;i=a;
						while(i1<i2)await swap(A,i++,i1++,1,true);
					}else while(i1>a)await swap(A,--i,--i1,1,true);
					if(b-j1>j1-j){
						let j2=j;j=b;
						while(j1>j2)await swap(A,--j,--j1,1,true);
					}else while(j1<b)await swap(A,j++,j1++,1,true);
					return[i,j];
				}
				await swap(A,i,j,1,true);
			}
		}
		async function introsortLoop(A,l,h,d){
			while(h-l>32){
				if(!d)return await ternaryHeap(A,l,h);
				d--;
				let[a,b]=await partition(A,l,h,await medianof3(A,l,l+(h-l)/2|0,h-1));
				if(h-b<a-l){
					await introsortLoop(A,b,h,d);
					h=a;
				}else{
					await introsortLoop(A,l,a,d);
					l=b;
				}
			}
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.75,true);
				else await reversal(A,a,b-1,.75,true);
				return;
			}
			await introsortLoop(A,a,b,2*log2(b-a));
			await ternaryInsert(A,a,b);
		}
		await quickSort(arr,0,len);
	}
	async optimizedNaturalRotateMergeSort(len){
		const GS=new GrailSorting();
		GS.setRotation(MHT.grailRotate);
		function threeResolves(x){
			let y=1;
			while(1){
				let z=pow(2,y)+1;
				if(z>x)return false;
				else if(z==x)return true;
				y++;
			}
		}
		async function mergeFindRun(A,a,b){
			let i=await MHT.stableFindRun(A,a,b,.5,true);
			let j;
			for(;i<a+16&&i<b;i=j){
				j=await MHT.stableFindRun(A,i,b,.5,true);
				await GS.grailMergeWithoutBuffer(A,a,i-a,j-i);
			}
			return i;
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=MHT.minExponentialSearch(A,m,b,A[a],true);
				await MHT.rotateIndexed(A,a,m,i,1,true);
				let t=i-m;m=i;a+=t+1;
				if(a>=m)break;
				a=MHT.minExponentialSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=MHT.maxExponentialSearch(A,a,m,A[b-1],false);
				await MHT.rotateIndexed(A,i,m,b,1,true);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=MHT.maxExponentialSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,a,m,b){
			let lA=m-a,lB=b-m;
			if(lA<9||lB<9){
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
				return;
			}
			let c=lA+(lB-lA)/2|0;
			if(lB<lA){
				let r1=0,r2=lB;
				while(r1<r2){
					let ml=r1+(r2-r1)/2|0;
					if(compareIndices(A,m-c+ml,b-ml-1)>0)r2=ml;
					else r1=ml+1;
				}
				await MHT.rotateIndexed(A,m-c+r1,m,b-r1,1,true);
				let m1=b-c;
				await merge(A,m1,b-r1,b);
				await merge(A,a,m1-lB+r1,m1);
			}else{
				let r1=0,r2=lA;
				while(r1<r2){
					let ml=r1+(r2-r1)/2|0;
					if(compareIndices(A,a+ml,m+c-ml-1)>0)r2=ml;
					else r1=ml+1;
				}
				await MHT.rotateIndexed(A,a+r1,m,m+c-r1,1,true);
				let m1=a+c;
				await merge(A,a,a+r1,m1);
				await merge(A,m1,m1+lA-r1,b);
			}
		}
		async function attemptSmall(A,z,r){
			let m2=0;
			for(let i=0;i+1<r;i++)if(z[i]+z[i+1]<z[m2]+z[m2+1])m2=i;
			let s=0;
			for(let i=0;i<m2;i++)s+=z[i];
			await merge(A,s,s+z[m2],s+z[m2]+z[m2+1]);
		}
		async function sort(A,l){
			let i,j,k,eL=1;
			for(let e=32;e<l;e+=32,eL++);
			let z=new Array(eL);
			while(1){
				let n=0;
				if((i=await mergeFindRun(A,0,l))>=l)break;
				await merge(A,0,i,j=await mergeFindRun(A,i,l));
				write(z,n++,j,0,false,true);
				if(j>=l)break;k=j;
				while(1){
					if((i=await mergeFindRun(A,k,l))>=l){
						let s=0;
						for(let m=0;m<n;m++)s+=z[m];
						write(z,n++,l-s,0,false,true);
						break;
					}
					await merge(A,k,i,j=await mergeFindRun(A,i,l));
					let s=0;
					for(let m=0;m<n;m++)s+=z[m];
					write(z,n++,j-s,0,false,true);
					if(j>=l)break;
					k=j;
				}
				await attemptSmall(A,z,n);
				if(l<3)break;
			}
		}
		await sort(arr,len);
	}
	async shepherdSort(len){
		async function siftDown(A,r,d,s,sl){
			let v=1;
			while(r<=(d/2|0)){
				let l=2*r;
				if(l<d&&compareIndices(A,s+l-1,s+l)>0)l++;
				if(compareIndices(A,s+r-1,s+l-1)>0){
					swap(A,s+r-1,s+l-1,0);
					if(++j*sl>1)await mark(s+r-1,j=0);
					r=l;
				}else break;
			}
		}
		async function heapify(A,l,h,sl){
			let n=h-l;
			for(let i=n/2|0;i>=1;i--)
				await siftDown(A,i,n,l,sl);
		}
		let j=0;
		for(let i=0;i<len;i++)await heapify(arr,i,len,.1);
	}
	async rotateSelectSort(len){
		async function rotate(A,s,e){
			let m=s;
			for(let i=s+1;i<e;i++)if(compareIndices(A,i,m)<0)m=i;
			if(m-s)await IndexedRotations.adaptable(A,s,m,e,.1,true);
		}
		for(let i=0;i<len;i++)await rotate(arr,i,len);
	}
	async monoboundBubbleSort(len){
		for(let i=len-1;i>0;--i){
			for(let j=1;j<i;++j){
				while(j<i&&compareIndices(arr,j,0)<0)j++;
				if(j==i)break;
				await swap(arr,0,j,.01,true);
			}
			if(compareIndices(arr,i,0)<0)await swap(arr,0,i,.01,true);
			else if(--i>0)await swap(arr,0,i,.01,true);
		}
	}
	async fordSort(len){
		let q=0;
		while(!isArraySorted(arr,len)){
			for(let k=len/2|0;k>0;k--){
				for(let i=q;i<len;i+=2*k){
					let l=i,c=false;
					while(l>0&&compareIndices(arr,l,l-1)<0){
						await swap(arr,l,l-1,1,true);
						l-=2;
						if(i>0)i--;
						c=true;
					}
					if(c)i++;
					else i--;
				}
			}
			q=(q+1)&1;
		}
	}
	async pairwiseCombSort(len){
		function is3Smooth(n){
			while(!(n&1))n>>=1;
			return!(n&n+1);
		}
		for(let g=len/2|0;g>0;g--)
			if(is3Smooth(g))
				for(let i=g;i<len;i++)
					if(compareIndices(arr,i-g,i)>0)
						await swap(arr,i-g,i,.5,true);
	}
	async dragSort(len){
		function isSorted(A,a,b,d){
			let c=a,ce=c+1;
			for(let i=a;i<b;i++){
				if(i==d)continue;
				let m=compareIndices(A,i,d);
				c+=m<0;
				ce+=m<1;
			}
			return d>=c&&d<ce;
		}
		let a=0,b=len;
		while(1){
			let i=a;
			while(i<b&&isSorted(arr,a,b,i))i++;
			if(i==b)break;
			for(let j=i++,k=0;i<b;i++)
				if(!isSorted(arr,a,b,i)){
					swap(arr,j,i);
					if(++k>cbrt(len))await markSwap(j,i,k=0);j=i;
				}
		}
	}
	async dualAzimuthSort(len){
		let z=0;
		while(!isArraySorted(arr,len)){
			for(let i=z;i<len;i++){
				let p=-1,s=1;
				for(let j=i+1;j<len;j++)if(compareIndices(arr,i,j)>0&&p<0)p=j;
				if(p>=0){
					await Rotations.holyGriesMills(arr,z,s,p-z-s,.001,true);
					i+=s-1;
				}else await swap(arr,i,z++,1,true);
			}
			if(z>=len)z=0;
		}
	}
	async altstoogeSort(len){
		async function stoogeSort(A,i,j,b){
			if(compareIndices(A,i,j)>0)await swap(A,i,j,.005,true);
			if(j-i>1){
				let t=(j-i+1)/3|0;
				let m=i+t,m2=j-t;
				if(!b)await stoogeSort(A,m,m2,1);
				await stoogeSort(A,m,j,1);
				await stoogeSort(A,m2,j,1);
				await stoogeSort(A,i,m,1);
				await stoogeSort(A,m,m2,1);
				await stoogeSort(A,i,m2,1);
				await stoogeSort(A,m2,j,1);
				await stoogeSort(A,m,j,1);
			}
		}
		await stoogeSort(arr,0,len-1);
	}
	async hexaStoogeSort(len){
		async function stoogeSort(A,i,j){
			let l=j-i+1;
			if(l==2){
				if(compareIndices(A,i,j)>0)await swap(A,i,j,0,true);
			}else if(l==3){
				await stoogeSort(A,i,j-1);
				await stoogeSort(A,i+1,j);
				await stoogeSort(A,i,j-1);
			}else if(l==4){
				let h1=l/2|0,h2=(l+1)/2|0,h3=((h1+1)/2|0)+((h2+1)/2|0);
				await stoogeSort(A,i,i+h1);
				await stoogeSort(A,i+h1,i+h1+h2);
				await stoogeSort(A,i+h1/2|0,i+h1/2+h3|0);
				await stoogeSort(A,i+h1,i+h1+h2);
				await stoogeSort(A,i,i+h1);
				await stoogeSort(A,i+h1/2|0,i+h1/2+h3|0);
			}else if(l==5){
				let f=l/5|0;
				await stoogeSort(A,i,i+2*f);
				await stoogeSort(A,j-2*f,j);
				await stoogeSort(A,i+f,j-f);
				await stoogeSort(A,i,j-2*f);
				await stoogeSort(A,i+2*f,j);
			}else if(l>5){
				let s=l/6|0;
				await stoogeSort(A,i,j-3*s);
				await stoogeSort(A,i+3*s,j);
				await stoogeSort(A,i+s,j-2*s);
				await stoogeSort(A,i+2*s,j-s);
				await stoogeSort(A,i,i+3*s);
				await stoogeSort(A,j-3*s,j);
				await stoogeSort(A,i+2*s,j-2*s);
			}
		}
		await stoogeSort(arr,0,len-1);
	}
	async bestForNStoogeSort(len){
		let base=askForNum(64,"Block size",2,64);
		async function bestNStooge(A,s,l){
			let h=l/2|0,q=l/4|0;
			if(l<=2*mt){
				await bestNS.initNetwork(A,s,h);
				await bestNS.initNetwork(A,s+h,h);
				await bestNS.initNetwork(A,s+q,h);
				await bestNS.initNetwork(A,s,h);
				await bestNS.initNetwork(A,s+h,h);
				await bestNS.initNetwork(A,s+q,h);
			}else{
				await bestNStooge(A,s,h);
				await bestNStooge(A,s+h,h);
				await bestNStooge(A,s+q,h);
				await bestNStooge(A,s,h);
				await bestNStooge(A,s+h,h);
				await bestNStooge(A,s+q,h);
			}
		}
		async function bestNStoogeMain(A,s,l,b){
			if(l<=mt)await initNetwork(A,s,l);
			else{
				let ef=b;
				while(ef<=l)ef*=2;ef=ef/2|0;
				await bestNStooge(A,s,ef);
				if(ef-l){
					await bestNStoogeMain(A,s+ef,l-ef,b);
					await bestNStooge(A,s+(l-ef)/2|0,ef);
					await bestNStooge(A,s,ef);
					await bestNStooge(A,s+l-ef,ef);
					await bestNStooge(A,s+(l-ef)/2|0,ef);
				}
			}
		}
		let mt=base+base%2;
		await bestNStoogeMain(arr,0,len,mt);
	}
	async bestForNSort(len){
		let base=askForNum(64,"Block size",2,64);
		async function bestN(A,s,l,b){
			let j;
			for(j=s;j+b<=s+l;j+=b)await bestNS.initNetwork(A,j,b);
			await bestNS.initNetwork(A,j,l-j);
			if(l>b)await new QuadSorting().quadSort(A,0,l);
		}
		await bestN(arr,0,len,base);
	}
	async bestForNRoomSort(len){
		let base=askForNum(64,"Block size",2,64);
		for(let i=len;i>=0;i-=base-1)for(let j=0;j+base<=i;j++)await bestNS.initNetwork(arr,j,base);
		await bestNS.initNetwork(arr,0,base);
	}
	async adaptiveTriClamberSort(len){
		function triSearch(A,l,h,v){
			let m=l+(h-l)/2|0;
			if(compareValues(v,A[l])<0)return l;
			else if(compareValues(v,A[h])<0)
				if(compareValues(v,A[m])<0)return triSearch(A,l+1,m-1,v);
				else return triSearch(A,m+1,h-1,v);
			else return h+1;
		}
		for(let r=1,i=0;r<len;r++)
			if(compareIndices(arr,r-1,r)>0){
				let l=triSearch(arr,0,r-1,arr[r],0);
				while(l<r){
					swap(arr,l++,r);
					if(++i>sqrt(len))await mark(l-1,i=0);
				}
			}
	}
	async coprimeShellSort(len){
		function coprime(a,b){
			for(let i=2;i<=minVal(a,b);i++)if(a%i+b%i<1)return false;
			return true;
		}
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&compareValues(A[j-h],v)>0;j-=h)await write(A,j,A[j-h],0,w=true);
				if(w)await write(A,j,v,0,true);
			}
		}
		async function sort(A,l){
			let gs=[1,4];
			for(let g=gs.at(-1);g<l;g=gs.at(-1)){
				let l=true,k=g;
				for(let i=2.3601*g|0;l;i++)
					if(coprime(i,g)){
						k=i;
						l=false;
					}
				gs.push(k);
			}
			gs.pop();
			for(let i=gs.pop();gs.length;i=gs.pop())await shellPass(A,l,i);
			await shellPass(A,l,1);
		}
		await sort(arr,len);
	}
	async parShellSort(len){
		function par(A,l){
			let m=new Array(l).fill(!1),mx=A[0];
			for(let i=1;i<l;i++)
				if(A[i]>mx){
					mx=A[i];
					m[i]=true;
				}
			let i=l-1,p=1,j=l-1;
			while(j>=0&&i>=p){
				while(!m[j]&&j>0)j--;
				mx=A[j];
				while(mx<=A[i]&&i>=p)i--;
				if(A[j]>A[i]&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		async function sort(A,l){
			while(1){
				let p=par(A,l),d2=p/2;
				if((p/2|0)<2){
					await insertSort(A,0,l,1);
					break;
				}
				for(let i=0;i<((p%2<1?p/2:p/2+1)|0);i++)
					for(let j=1;i+(d2*j|0)<len;j++){
						let k=j,t=A[i+d2*j|0];
						while(k>0&&compareValues(A[i+d2*(k-1)|0],t)>0)
							await write(A,i+d2*k,A[i+d2*--k|0],0,true);
						await write(A,i+d2*k,t,0,true);
					}
			}
		}
		await sort(arr,len);
	}
	async dunsparceSort(len){
		function medianOf3(A,a,b,c){
			if(compareIndices(A,a,b)<1){
				if(compareIndices(A,b,c)<1)return b;
				if(compareIndices(A,a,c)<0)return c;
				return a;
			}
			if(compareIndices(A,b,c)+1)return b;
			if(compareIndices(A,a,c)<1)return a;
			return c;
		}
		function medianOf9(A,s,e){
			let l=e-s,h=l/2|0,q=h/2|0,t=q/2|0;
			return medianOf3(A,medianOf3(A,s,s+t,s+q),medianOf3(A,s+q+t,s+h,s+h+t),medianOf3(A,s+h+q,s+h+q+t,e-1));
		}
		function mOMHelper(A,s,l){
			if(l==1)return s;
			let t=l/3|0;
			return medianOf3(A,mOMHelper(A,s,t),mOMHelper(A,s+t,t),mOMHelper(A,s+2*t,t));
		}
		function medianOfMedians(A,s,l){
			if(l==1)return s;
			let nP=pow(3,round(log(l)/log(3))-1);
			if(nP==l)return mOMHelper(A,s,l);
			if(2*nP>=l)nP=nP/3|0;
			return medianOf3(A,mOMHelper(A,s,nP),mOMHelper(A,s+l-nP,nP),medianOfMedians(A,s+nP,l-2*nP));
		}
		function equ(a,b){
			return(a-b>>31)+(b-a>>31)+1;
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.5,true);
			else await reversal(A,start,end,.5,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(i<e&&!compareIndices(A,i,i+1))i++;
				r=i;
				if(l-r)
					if(r-l<3)await swap(A,l,r,.5,true);
					else await reversal(A,l,r,.5,true);
				i++;
			}
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.1,true);
			if(a-b)await write(A,b,t,.1,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let p0=a,p1=m-1,p2=m,p3=b-1,t;
			while(p0<p1&&p2<p3){
				t=A[p1];
				await write(A,p1--,A[p0],.25,true);
				await write(A,p0++,A[p2],.25,true);
				await write(A,p2++,A[p3],.25,true);
				await write(A,p3--,t,.5,true);
			}
			while(p0<p1){
				t=A[p1];
				await write(A,p1--,A[p0],.25,true);
				await write(A,p0++,A[p3],.25,true);
				await write(A,p3--,t,.5,true);
			}
			while(p2<p3){
				t=A[p2];
				await write(A,p2++,A[p3],.25,true);
				await write(A,p3--,A[p0],.25,true);
				await write(A,p0++,t,.5,true);
			}
			if(p0<p3)
				if(p3-p0>2)await reversal(A,p0,p3,.5,true);
				else await swap(A,p0,p3,.5,true);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,.1,true);
					else await reversal(A,a,i-1,.1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function insertSort(A,a,b){
			for(let i=await findRun(A,a,b);i<b;i++)
				await insertTo(A,i,rightExpSearch(A,a,i,A[i]));
		}
		async function inPlaceMergeBW(A,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a)
				if(compareIndices(A,i,j)>0){
					k=rightExpSearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=i+1-k;
					i=k-1;
				}else j--;
		}
		async function laziestStable(A,a,b){
			if(b-a<17)return await insertSort(A,a,b);
			let s=sqrt(b-a-1)+1|0;
			for(let i=a;i<b;i+=s){
				let j=minVal(i+s,b);
				await insertSort(A,i,j);
				await inPlaceMergeBW(A,a,i,j);
			}
		}
		async function partitionEasy(A,a,b,pv){
			let pa=a,pb=a;
			for(let i=a;i<b;i++){
				let c=compareIndexValue(A,i,pv);
				if(c<0){
					await insertTo(A,i,pa++,.25);
					pb++;
				}else if(!c)await insertTo(A,i,pb++,.25);
			}
			return[pa,pb];
		}
		async function partition(A,a,b,pv){
			let s=sqrt(b-a-1)+1|0,pa=a,pb=a;
			for(let i=a;i<b;i+=s){
				let j=minVal(i+s,b),[p0,p1]=await partitionEasy(A,i,j,pv);
				if(i>a){
					await rotate(A,pb,i,p1);
					await rotate(A,pa,pb,pb+p0-i);
				}
				pa+=p0-i;
				pb+=p1-i;
			}
			return[pa,pb];
		}
		async function sortHelper(A,a,b,bA){
			while(b-a>16){
				let pI;
				if(bA){
					let n=b-a;n-=~n&1;pI=medianOfMedians(A,a,n);bA=false;
				}else pI=medianOf9(A,a,b);
				let[p0,p1]=await partition(A,a,b,A[pI]),lL=p0-a,rL=b-p1,qL=p1-p0;
				if(qL==b-a)return;
				if(!rL){
					bA=qL<(lL/8|0);b=p0;
					continue;
				}
				if(!lL){
					bA=qL<(rL/8|0);a=p1;
					continue;
				}
				if(rL<lL){
					bA=rL<(lL/8|0);
					await sortHelper(A,p1,b,bA);
					b=p0;
				}else{
					bA=lL<(rL/8|0);
					await sortHelper(A,a,p0,bA);
					a=p1;
				}
			}
			await insertSort(A,a,b);
		}
		async function quickSort(A,a,b){
			let l=b-a;
			if(l<17)return await insertSort(A,a,b);
			let bl=0,eq=0,sk=0,ds,qd,lp,ct=l,p=a;
			while(ct>16){
				for(qd=ds=0,lp=0;lp<16;lp++){
					let c=compareIndices(A,p,p+1);
					ds+=c>0;qd+=!c;p++;
				}
				sk+=equ(ds,0)|equ(ds+qd,16);bl+=ds;eq+=qd;ct-=16;
			}
			while(--ct>0){
				let c=compareIndices(A,p,p+1);
				bl+=c>0;eq+=!c;p++;
			}
			if(!bl)return;
			if(bl+eq==l-1){
				if(eq>0)await stableSegmentReversal(A,a,b-1);
				else if(b-a<4)await swap(A,a,b-1,.75,true);
				else await reversal(A,a,b-1,.75,true);
				return;
			}
			let x=l/6|0;
			if(sk>(l/20|0)||bl<=x||bl+eq>=l-x)await laziestStable(A,a,b);
			else await sortHelper(A,a,b,false);
		}
		await quickSort(arr,0,len);
	}
	async logNPivotQuickSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)
					await write(A,i,A[i+d],.5,true);
				await write(A,b,t,.5,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function sift(A,s,r,l,t){
			let j=r;
			while(2*j+1<l){
				j=2*j+1;
				if(j+1<l&&compareIndices(A,s+j,s+j+1)<0)j++;
			}
			while(compareValueIndex(A,t,s+j)>0)j=(j-1)/2|0;
			for(let t2;j>r;j=(j-1)/2|0){
				t2=A[s+j];
				await write(A,s+j,t,.5,true);
				t=t2;
			}
			await write(A,s+r,t,.5,true);
		}
		async function heapSort(A,s,e){
			let p=e-s;
			for(let j=(p-1)/2|0;j>=0;j--)await sift(A,s,j,p,A[s+j]);
			for(let j=p-1;j>0;j--){
				let t=A[s+j];
				await write(A,s+j,A[s],1,true);
				await sift(A,s,0,j,t);
			}
		}
		async function sort(A,s,o,d){
			let l=o-s;
			if(l>16){
				if(!d)return await heapSort(A,s,o);
				let r=log2(l),nS=s+r;
				await sort(A,s,nS,--d);
				let ps=new Array(r);
				for(let i=0;i<r;i++)write(ps,i,i+s,0,false,true);
				for(let i=nS;i<o;i++){
					let a=0,b=r;
					while(a<b){
						let m=(b-a)/2+a|0;
						if(compareIndices(A,ps[m],i)>0)b=m;
						else a=m+1;
					}
					let p=i;
					for(let j=r-1;j>=a;j--){
						await swap(A,ps[j]+1,p,1,true);
						await swap(A,p=ps[j],ps[j]+1,1,true);
						write(ps,j,ps[j]+1,0,false,true);
					}
				}
				await sort(A,s,ps[0],d);
				for(let i=1;i<r;i++)
					await sort(A,ps[i-1]+1,ps[i],d);
				await sort(A,ps[r-1]+1,o,d);
			}else await insertSort(A,s,o);
		}
		await sort(arr,0,len,2*log2(len));
	}
	async improvedLogNPivotQuickSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
				await write(A,b,t,.5,true);
			}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,false);
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function siftDown(A,v,i,p,n){
			while(4*i+1<n){
				let m=v,nx=i,c=4*i+1;
				for(let j=c;j<minVal(c+4,n);j++)if(compareValues(A[p+j],m)>0)m=A[p+(nx=j)];
				if(nx==i)break;
				await write(A,p+i,m,1,true);
				i=nx;
			}
			await write(A,p+i,v,1,true);
		}
		async function heapSort(A,a,b){
			let n=b-a;
			for(let i=(n-1)/4|0;i>=0;i--)await siftDown(A,A[a+i],i,a,n);
			for(let i=n-1;i>0;i--){
				let t=A[a+i];
				await write(A,a+i,A[a],1,false);
				await siftDown(A,t,0,a,i);
			}
		}
		async function sortHelper(A,T,a,b,d){
			if(b-a<32)return await insertSort(A,a,b);
			if(!d--)return await heapSort(A,a,b);
			let r=new Random(),n=b-a,z=log2(n),s=(n-1)/z+1|0,c=0;
			for(let i=a+r.nextInt(s-1);i<b;i+=s,c++){
				let o=binSearch(T,0,c,A[i],false);
				for(let j=c;j>o;j--)
					write(T,j,T[j-1],0,false,true);
				write(T,o,A[i],0,false,true);
			}
			if(!compareIndices(T,0,c-1)){
				let i=a,j=b,pv=T[0];
				for(let k=i;k<j;k++)
					if(compareValues(A[k],pv)<0)await swap(A,k,i++,1,true);
					else if(compareValues(A[k],pv)>0){
						do j--;while(j>k&&compareValues(A[j],pv)>0);
						await swap(A,k,j,1,true);
						if(compareValues(A[k],pv)<0)await swap(A,k,i++,1,true);
					}
				await sortHelper(A,T,a,i,d);
				await sortHelper(A,T,j,b,d);
				return;
			}
			let bC=c+1,pa=new Array(bC).fill(0),pb=new Array(bC).fill(0);
			write(pa,0,a,0,false,true);
			write(pb,0,a,0,false,true);
			for(let i=a;i<b;i++){
				let o=binSearch(T,0,c,A[i],true);
				write(pb,o,pb[o]+1,0,false,true);
			}
			for(let i=1;i<bC;i++)
				write(pb,i,pb[i]+pb[i-1],0,false,true);
			arraycopy(pb,0,pa,1,bC-1,0,false,true);
			for(let i=0;i<bC-1;i++)
				while(pa[i]<pb[i]){
					let t=A[pa[i]],t0=-1,aW=false,nx=binSearch(T,0,c,t,true),n0;
					while(nx-i){
						n0=binSearch(T,0,c,A[pa[nx]],true);
						if(pa[nx]-pb[nx]+1)
							while(n0==nx){
								write(pa,nx,pa[nx]+1,0,false,true);
								n0=binSearch(T,0,c,A[pa[nx]],true);
							}
						aW=true;t0=A[pa[nx]];
						await write(A,pa[nx],t,.5,true);
						write(pa,nx,pa[nx]+1,0,false,true);
						t=t0;nx=n0;
					}
					if(aW)await write(A,pa[i],t,.5,true);
					write(pa,i,pa[i]+1,0,false,true);
				}
			await sortHelper(A,T,a,pb[0],d);
			for(let i=1;i<bC;i++)await sortHelper(A,T,pb[i-1],pb[i],d);
		}
		async function quickSort(A,a,b){
			if(b-a<32)return await insertSort(A,a,b);
			await sortHelper(A,new Array(log2(b-a)),a,b,2*log2(b-a));
		}
		await quickSort(arr,0,len);
	}
	async KWayQuickSort(len){
		let base=askForNum(4,"Base",1);
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binsert(A,s,e){
			for(let i=s;i<e;i++)
				if(compareIndices(A,i-1,i)>0){
					let n=A[i];
					let l=binarySearch(A,s-1,i-1,n);
					for(let r=i;r>l;r--)await write(A,r,A[r-1],.25,true);
					await write(A,l,n,.01,true);
				}
		}
		async function sort(A,s,o,b){
			let n=o-s;
			while(n<=b)b--;
			if(n>16){
				let t=b,nS=s+t,ps=new Array(t);
				await sort(A,s,nS,b);
				for(let i=0;i<t;i++)write(ps,i,i+s,0,false,true);
				for(let i=nS;i<o;i++){
					let l=0,r=t;
					while(l<r){
						let m=(r-l)/2+l|0;
						if(compareIndices(A,ps[m],i)>0)r=m;
						else l=m+1;
					}
					let p=i;
					for(let j=t-1;j>=l;j--){
						if(ps[j]+1-p)await swap(A,ps[j]+1,p,.25,true);
						await swap(A,p=ps[j],ps[j]+1,.25,true);
						write(ps,j,ps[j]+1,0,false,true);
					}
				}
				await sort(A,s,ps[0],b);
				for(let i=1;i<t;i++)await sort(A,ps[i-1]+1,ps[i],b);
				await sort(A,ps[t-1]+1,o,b);
			}else await binsert(A,s+1,o);
		}
		await sort(arr,0,len,maxVal(1,base));
	}
	async smartSemiMedianQuickSort(len){
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function insertTo(A,a,b){
			if(a==b)return;
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)
				await write(A,i,A[i+d],.5,true);
			await write(A,b,t,.5,true);
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function sift(A,s,r,l,t){
			let j=r;
			while(2*j+1<l){
				j=2*j+1;
				if(j+1<l&&compareIndices(A,s+j,s+j+1)<0)j++;
			}
			while(compareValueIndex(A,t,s+j)>0)j=(j-1)/2|0;
			for(let t2;j>r;j=(j-1)/2|0){
				t2=A[s+j];
				await write(A,s+j,t,.5,true);
				t=t2;
			}
			await write(A,s+r,t,.5,true);
		}
		async function heapSort(A,s,e){
			let p=e-s;
			for(let j=(p-1)/2|0;j>=0;j--)await sift(A,s,j,p,A[s+j]);
			for(let j=p-1;j>0;j--){
				let t=A[s+j];
				await write(A,s+j,A[s],1,true);
				await sift(A,s,0,j,t);
			}
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function semiMedian(A,a,b){
			let l=b-a,v=-1;
			for(let i=1;i<l;i*=2,v=-v)
				for(let j=a;j<b-i;j+=i*2)
					if(compareIndices(A,j,j+i)-v)
						await swap(A,j,j+i,1,true);
		}
		async function partition(A,a,b,p){
			let i=a,j=b;
			if(a-p)await swap(A,a,p,1,true);
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)>0);
				if(i>=j){
					if(a-j)await swap(A,a,j,1,true);
					return j;
				}
				await swap(A,i,j,1,true);
			}
		}
		async function getSortedRuns(A,a,b){
			let rS=true,s=true,c;
			for(let i=a;i<b-1;i++){
				c=compareIndices(A,i,i+1);
				if(c>0)s=false;
				else rS=false;
				if(!rS&&!s)return false;
			}
			if(rS&&!s){
				await reversal(A,a,b-1,1,true);
				s=true;
			}
			return s;
		}
		async function sortHelper(A,a,b,bA){
			while(b-a>16){
				if(await getSortedRuns(A,a,b))return;
				await medianOfThree(A,a,b);
				let m=await partition(A,a,b,a);
				let lL=m-a,rL=b-m-1;
				if(lL<((b-a)/16|0)||rL<((b-a)/16|0)){
					if(--bA<1)return await heapSort(A,a,b);
					await semiMedian(A,a,b);
					m=await partition(A,a,b,a);
					console.log(shuffleType.value);
					lL=m-a;
					rL=b-m-1;
				}
				if(rL<lL){
					await sortHelper(A,m+1,b,bA);
					b=m;
				}else{
					await sortHelper(A,a,m,bA);
					a=m+1;
				}
			}
			await insertSort(A,a,b);
		}
		await sortHelper(arr,0,len,floorLog(len));
	}
	async unstableTernarySingularityQuickSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function insertTo(A,a,b){
			let t=A[a];
			for(let i=a;i>b;i--)await write(A,i,A[i-1],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function findReverseRun(A,s,e){
			let r=s,d=false,c=compareIndices(A,r,r+1);
			while(c+1&&r+1<e){
				if(c>0)d=true;
				if(++r+1<e)c=compareIndices(A,r,r+1);
			}
			if(r>s&&d){
				if(r<s+3)await swap(A,s,r,.75,true);
				else await reversal(A,s,r,.75,true);
			}
			return r;
		}
		async function sift(A,s,r,l,t){
			let j=r;
			while(2*j+1<l){
				j=2*j+1;
				if(j+1<l&&compareIndices(A,s+j,s+j+1)<0)j++;
			}
			while(compareValueIndex(A,t,s+j)>0)j=(j-1)/2|0;
			for(let t2;j>r;j=(j-1)/2|0){
				t2=A[s+j];
				await write(A,s+j,t,.5,true);
				t=t2;
			}
			await write(A,s+r,t,.5,true);
		}
		async function heap(A,s,e){
			let p=e-s;
			for(let j=(p-1)/2|0;j>=0;j--)await sift(A,s,j,p,A[s+j]);
			for(let j=p-1;j>0;j--){
				let t=A[s+j];
				await write(A,s+j,A[s],1,true);
				await sift(A,s,0,j,t);
			}
		}
		async function partition(A,a,b,p){
			let i1=a,i=a-1,j=b,j1=b;
			while(1){
				while(++i<j){
					let c=compareIndexValue(A,i,p);
					if(!c)await swap(A,i1++,i,1,true);
					else if(c>0)break;
				}
				while(--j>i){
					let c=compareIndexValue(A,j,p);
					if(!c)await swap(A,--j1,j,1,true);
					else if(c<0)break;
				}
				if(i<j)await swap(A,i,j,1,true);
				else{
					if(i1==b)return[a,b];
					else if(j<i)j++;
					while(i1>a)await swap(A,--i,--i1,1,true);
					while(j1<b)await swap(A,j++,j1++,1,true);
					break;
				}
			}
			return[i,j];
		}
		async function sortHelper(A,a,b,d,r){
			while(b-a>iL){
				if(++d>dL||r>3)return await heap(A,a,b);
				let pI=a+1;
				while(pI<b&&compareIndices(A,pI-1,pI)<1)pI++;
				if(pI>=b)return;
				let[p0,p1]=await partition(A,a,b,A[pI-1]);
				if(p1-p0==b-a)return;
				r=minVal(b-p1,p0-a)<=rL?r+1:0;
				if(b-p1<p0-a){
					await sortHelper(A,p1,b,d,r);
					b=p0;
				}else{
					await sortHelper(A,a,p0,d,r);
					a=p1;
				}
			}
			await insertSort(A,a,b);
		}
		let dL,iL,rL;
		async function quickSort(A,a,b){
			dL=minVal(sqrt(b-a)|0,2*log2(b-a));
			iL=maxVal(dL/2|0,16);
			rL=maxVal(dL/4|0,2);
			if(await findReverseRun(A,a,b)+1<b)
				await sortHelper(A,a,b,0,0);
		}
		await quickSort(arr,0,len);
	}
	async adaptiveBinfaClurgeSort(len){
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function method(A,s,e){
			let sb=s,b=false;
			for(let r=s+e/2|0;r<s+e&&!b;r++){
				if(compareIndices(A,r-1,r)>0){
					let c=compareIndices(A,sb,r);
					for(let h=0;h<(cbrt(e)|0)&&c<1;h++)c=compareIndices(A,++sb,r);
					if(c<1)sb=binarySearch(A,sb,r-1,A[r]);
					for(let l=sb,i=0;l<r;l++){
						swap(A,l,r);
						if(++i>sqrt(e))await markSwap(l,r,i=0);
					}
					sb++;
				}else b=true;
			}
		}
		async function nonpow2(A,s,e,m){
			let sb=s;
			for(let r=m;r<s+e;r++){
				if(compareIndices(A,r-1,r)>0){
					let t=sb-s?sb-1:s;
					if(compareIndices(A,t,r)>0)sb=s;
					let c=compareIndices(A,sb,r);
					for(let h=0;h<(cbrt(e)|0)&&c<1;h++)c=compareIndices(A,++sb,r);
					if(c<1)sb=binarySearch(A,sb,r-1,A[r]);
					for(let l=sb,i=0;l<r;l++){
						swap(A,l,r);
						if(++i>sqrt(e))await markSwap(l,r,i=0);
					}
					sb++;
				}
			}
		}
		let l=2;
		for(;l<len;l*=2)for(let i=0;i+l-1<len;i+=l)await method(arr,i,l);
		if(l==len)await method(arr,0,len);
		else await nonpow2(arr,0,len,l/2|0);
	}
	async nilSort(len){
		const GS=new GrailSorting();
		GS.setRotation((A,p,a,b)=>{
			return IndexedRotations.neon(A,p,p+a,p+a+b,1,true);
		});
		async function multiSwap(A,a,b,l){
			while(l-->0)await swap(A,a++,b++,1,true);
		}
		async function insert1(A,a,l){
			let t=A[l--],k=0;
			while(l>=a&&compareValues(A[l],t)>0){
				write(A,l+1,A[l--],0);
				if(++k>sqrt(len))await mark(l+2,k=0);
			}
			await write(A,l+1,t,1,true,false);
		}
		async function insert2(A,a,l,r){
			let tL=A[l--],tR=A[r],k=0;
			while(l>=a&&compareValues(A[l],tR)>0){
				write(A,l+2,A[l--],0);
				if(++k>sqrt(len))await mark(l+3,k=0);
			}
			await write(A,l+2,tR,1,true);
			while(l>=a&&compareValues(A[l],tL)>0){
				write(A,l+1,A[l--],0);
				if(++k>sqrt(len))await mark(l+2,k=0);
			}
			await write(A,l+1,tL,1,true);
		}
		async function findRun(A,a,b){
			let i=a+1;
			if(i==b)return i;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,.1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			return i;
		}
		async function blockInsertion(A,a,b){
			let i,j,l;
			i=await findRun(A,a,b);
			while(i<b){
				j=await findRun(A,i,b);l=j-i;
				if(l<3)
					if(l>1)await insert2(A,a,i,i+1);
					else await insert1(A,a,i);
				else await GS.grailMergeWithoutBuffer(A,a,i-a,l);
				i=j;
			}
		}
		async function zeromerge(A,s,m,e){
			if(compareIndices(A,m-1,m)<1)return;
			if(compareIndices(A,s,e-1)>0)return await IndexedRotations.neon(A,s,m,e,1,true);
			await IndexedRotations.neon(A,B,B+bZ,s,1,true);
			B=s-bZ;
			let l=s,r=m,lB=B,rB=m,lZ=bZ,rZ=0;
			while(l<m||r<e){
				while(l<m&&r<e&&lZ>0){
					if(compareIndices(A,l,r)<1)await swap(A,lB++,l++,.1,true);
					else{
						await swap(A,lB++,r++,.1,true);
						lZ--;rZ++;
					}
				}
				if(lZ>0){
					while(l<m)await swap(A,lB++,l++,.1,true);
					while(r<e&&lZ>0){
						await swap(A,lB++,r++,1.25,true);
						lZ--;rZ++;
					}
				}
				while(l<m&&r<e&&rZ>0)
					if(compareIndices(A,l,r)<1){
						await swap(A,rB++,l++,.1,true);
						rZ--;lZ++;
					}else await swap(A,rB++,r++,.1,true);
				if(rZ>0){
					while(l<m&&rZ>0){
						await swap(A,rB++,l++,.1,true);
						rZ--;lZ++;
					}
					while(r<e)await swap(A,rB++,r++,.1,true);
				}
				await IndexedRotations.neon(A,lB,m,rB+rZ,2.5,true);
				l+=rB-m+rZ;lB+=rB-m+rZ;m=r=rB+rZ;rZ=0;
			}
			B=e-bZ;
		}
		async function pingpong(A,s,e){
			if(e-s<9)return await blockInsertion(A,s,e);
			for(let i=s;i<e;i+=8)await blockInsertion(A,i,minVal(i+8,e));
			for(let j=8;j<e-s;j*=2)
				for(let i=s;i<e;i+=2*j){
					if(i+j>=e)break;
					let k=minVal(i+2*j,e);
					if(j<bZ){
						await multiSwap(A,i,B,j);
						let l=B,r=i+j,t=i;
						while(l<B+j&&r<k)
							if(compareIndices(A,l,r)<1)await swap(A,l++,t++,1,true);
							else await swap(A,r++,t++,1,true);
						while(l<B+j)await swap(A,l++,t++,1,true);
					}else await GS.grailMergeWithoutBuffer(A,i,j,k-i-j);
				}
		}
		async function ppmergeruns(A,s,e){
			let m=maxVal(8,bZ);
			for(let i=s;i<e;i+=m)await pingpong(A,i,minVal(i+m,e));
		}
		async function runZero(A,s,e){
			B=s;bZ=await GS.grailFindKeys(A,s,e-s,sqrt(e-s)|0);
			if(bZ<4){
				//blockBack is from Lazicci, was not called during testing
				if(e-s<17)await blockInsertion(A,s,e);
				else await blockBack(A,s,await mergeRuns(A,s,e),e);
				return;
			}
			await ppmergeruns(A,B+bZ,e);
			for(let j=maxVal(bZ,8);j<e-s;j*=2){
				for(let i=B+bZ;i<e;i+=2*j){
					if(i+j>=e)break;
					if(i+2*j>e)await zeromerge(A,i,i+j,e);
					else await zeromerge(A,i,i+j,i+2*j);
				}
				await IndexedRotations.neon(A,s,B,B+bZ,1,true);
				B=s;
			}
			await blockInsertion(A,B,B+bZ);
			await GS.grailMergeWithoutBuffer(A,B,bZ,e-B-bZ);
		}
		let B,bZ;
		await runZero(arr,0,len);
	}
	async optimizedPushSort(len){
		let as=true,f=1,k=0;
		while(as){
			as=false;
			let g=1;
			for(let i=f>1?f-1:1;i+g<=len;)
				if(compareIndices(arr,i-1,i-1+g)>0){
					for(let j=1;j<=g;j++){
						swap(arr,i-1,i-1+j);
						if(++k>sqrt(len-f))await markSwap(i-1,i-1+j,k=0);
					}
					if(!as)f=i;
					as=true;
					g++;
				}else i++;
		}
	}
	async baseNOddEvenSort(len){
		let base=askForNum(4,"Base",1);
		let o=0,as=false,r=true;
		while(r){
			for(let i=o;i+1<len;i+=base)if(compareIndices(arr,i,i+1)>0)await swap(arr,i,i+1,.1,as=true);
			if(++o>base-1){
				o=0;
				if(!as)r=false;as=false;
			}
		}
	}
	async californiumSortStable(len){
		async function bubbleReversal(A,s,l){
			if(l-s<1)return;
			else if(l-s==1){
				if(compareIndices(A,s,l))swap(A,s,l);
			}else{
				counts.rev++;
				for(let i=l,k=0;i>s;i--){
					for(let j=s;j<i;j++)if(compareIndices(A,j,j+1))swap(A,j,j+1);
					if(++k>sqrt(l-s))await mark(i,k=0);
				}
			}
		}
		function sqrtrnd(v){
			let p=0;
			while(++p*p<v);
			return p;
		}
		async function californium(A,a,b,d,d2){
			if(b-a==2)if(compareIndices(A,a,a+1)>0)await swap(A,a,a+1,1,true);
			if(--d2<1){
				for(let i=a;++i<b;)
					if(compareIndices(A,i-1,i)>0){
						await swap(A,i-1,i,1,true);
						i=a;
					}
				return;
			}
			if(a>=b-2)return;
			let R=new Array(),M=new Array();
			let i=b,j,k,m,me=0,b0=b;
			let sh=false;
			bc:while(i>a+1){
				R.unshift(i=b0);M=[];
				for(k=sqrtrnd(i-a);k-->0;){
					sh=M.length&&compareIndexValue(A,a,M[0])+1;
					me=0;
					for(j=(m=a)+1;j<i;j++){
						let p=compareIndices(A,m,j);
						if(!p)me++;
						if(p<0||sh)
							if(!M.length||compareIndexValue(A,j,M[0])<0){
								m=j;sh=false;me=0;
							}
					}
					if(sh)break bc;
					M.unshift(A[m]);
					k-=me;
				}
				cnt:for(j=b0=a;j<i;j++){
					for(let v of M)
						if(!compareIndexValue(A,j,v)){
							await bubbleReversal(A,b0,j-1);
							continue cnt;
						}
					await bubbleReversal(A,b0,j-1);
					await bubbleReversal(A,a,b0-1);
					await multiSwap(A,j,b0++,.001,true);
				}
			}
			if(me==b-a-1)return;j=a;
			for(k=0;k<R.length;k++)await californium(A,j,j=R[k],d,d2);
		}
		await californium(arr,0,len,0,(32-clz32(len-1))/2|0);
	}
	async raikoSort(len){
		function keyLessThan(s,pa,a,b){
			let c=compareIndices(s,pa[a],pa[b]);
			return c<0||!c&&compareValues(a,b)<0;
		}
		async function siftDown(A,h,pa,t,r,z){
			while(2*r+2<z){
				let n=2*r+1,m=n+(keyLessThan(A,pa,h[n],h[n+1])?0:1);
				if(keyLessThan(A,pa,h[m],t))await write(h,r,h[r=m],0,true,true);
				else break;
			}
			let m=2*r+1;
			if(m<z&&keyLessThan(A,pa,h[m],t))await write(h,r,h[r=m],0,true,true);
			write(h,r,t,0,false,true);
		}
		async function kWayMerge(A,d,h,pa,pb,z,x){
			for(let i=0;i<z;i++)write(h,i,i,0,false,true);
			for(let i=(z-1)/2|0;i>=0;i--)await siftDown(A,h,pa,h[i],i,z);
			for(let i=0;z>0;i++){
				let m=h[0];
				write(d,i,A[pa[m]],0,!x,x);
				write(pa,m,pa[m]+1,0,false,true);
				if(pa[m]==pb[m])await siftDown(A,h,pa,h[--z],0,z);
				else await siftDown(A,h,pa,h[0],0,z);
			}
		}
		async function findRun(A,a,b){
			let i=a+1,d=i<b?compareIndices(A,i-1,i++)<1:!0;
			while(i<b){
				if(d^compareIndices(A,i-1,i)<1)break;
				i++;
			}
			if(!d)
				if(i-a<4)await swap(A,a,i-1,.1,true);
				else await reversal(A,a,i-1,.1,true);
			return i;
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			if(l<2)return;
			let rs=new Array((l-1)/2+2|0),r=a,rf=0;
			while(r<b){
				write(rs,rf++,r,0,false,true);
				r=await findRun(A,r,b);
			}
			let B=new Array(l);
			if(rf>1){
				let pa=new Array(rf);
				let pb=new Array(rf);
				let h=new Array(rf);
				arraycopy(rs,0,pa,0,rf,0,false,true);
				arraycopy(pa,1,pb,0,rf-1,0,false,true);
				write(pb,rf-1,b,0,false,true);
				await kWayMerge(A,B,h,pa,pb,rf,true);
				await arraycopy(B,0,A,a,l,1,true);
			}
		}
		await mergeSort(arr,0,len);
	}
	async kleeSort(len){
		async function multiSwap(A,a,b,l){
			while(l-->0)await swap(A,a++,b++,1,true);
		}
		async function siftDown(A,v,i,p,n){
			while(4*i+1<n){
				let m=v,x=i,c=4*i+1;
				for(let j=c;j<minVal(c+4,n);j++)if(compareValues(A[p+j],m)>0)m=A[p+(x=j)];
				if(x==i)break;
				await write(A,p+i,m,1,true);
				i=x;
			}
			await write(A,p+i,v,1,true);
		}
		async function heapSort(A,a,b){
			let n=b-a;
			for(let i=(n-1)/4|0;i>=0;i--)await siftDown(A,A[a+i],i,a,n);
			for(let i=n-1;i>0;i--){
				let t=A[a+i];
				await write(A,a+i,A[a]);
				await siftDown(A,t,0,a,i);
			}
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)
					await write(A,i,A[i+d],.5,true);
				await write(A,b,t,.5,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)
				await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		function medOf3(A,a,b,c){
			let t;
			if(compareIndices(A,a,b)>0){
				t=b;
				b=a;
			}else t=a;
			if(compareIndices(A,b,c)>0){
				if(compareIndices(A,t,c)>0)return t;
				return c;
			}
			return b;
		}
		function medP3(A,a,b,d){
			if(b-a==3||(b-a>3&&!d))return medOf3(A,a,a+(b-a)/2|0,b-1);
			if(b-a<3)return a+(b-a)/2|0;
			let t=(b-a)/3|0;
			return medOf3(A,medP3(A,a,a+t,--d),medP3(A,a+t,b-t,d),medP3(A,b-t,b,d));
		}
		function medOfMed(A,a,b){
			if(b-a<7)return a+(b-a)/2|0;
			let p=1;
			while(6*p<b-a)p*=3;
			return medOf3(A,medP3(A,a,a+p,-1),medOfMed(A,a+p,b-p),medP3(A,b-p,b,-1));
		}
		async function partition(A,a,b,pI){
			let i=a,j=b;
			await swap(A,a,pI,1,true);
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)>0);
				if(i>=j){
					await swap(A,a,j,1,true);
					return j;
				}
				await swap(A,i,j,1,true);
			}
		}
		async function partTernary(A,a,b,pv){
			for(;a<b;a++)if(compareValues(A[a],pv)+1)break;
			for(;b>a;b--)if(compareValues(A[b-1],pv)<1)break;
			let i1=a,i=a-1,j=b,j1=b;
			while(1){
				while(++i<j){
					let c=compareIndexValue(A,i,pv);
					if(!c)await swap(A,i1++,i,1,true);
					else if(c>0)break;
				}
				while(--j>i){
					let c=compareIndexValue(A,j,pv);
					if(!c)await swap(A,--j1,j,1,true);
					else if(c<0)break;
				}
				if(i>=j){
					if(i1==b)return[a,b];
					if(j<i)j++;
					if(i1-a>i-i1){
						let i2=i;i=a;
						while(i1<i2)await swap(A,i++,i1++,1,true);
					}else while(i1>a)await swap(A,--i,--i1,1,true);
					if(b-j1>j1-j){
						let j2=j;j=b;
						while(j1>j2)await swap(A,--j,--j1,1,true);
					}else while(j1<b)await swap(A,j++,j1++,1,true);
					return[i,j];
				}
				await swap(A,i,j,1,true);
			}
		}
		async function fancySplitBucket(A,a,b,p){
			let n=b-a,m=a+n/2|0;
			await heapSort(A,m,b);
			let i=m-1,j=b-1;
			let c=n/2|0;
			while(c-->0)
				if(compareIndices(A,i,j)>0)await swap(A,--p,i--,1,true);
				else await swap(A,--p,j--,1,true);
			let m1=m;
			while(i>=a&&j>=m)
				if(compareIndices(A,i,j)>0)await swap(A,--m1,i--,1,true);
				else await swap(A,--m1,j--,1,true);
			while(j>=m)await swap(A,--m1,j--,1,true,false);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		function gridSearch(A,i,l,r,k,g,o){
			while(l<r){
				let m=r+(r-l)/2|0;
				if(compareIndices(A,o+i[m]*g,k)<1)l=m;
				else r=m-1;
			}
			return l;
		}
		async function gridSort(A,zs,ds,a,b,p,bL){
			let b2=2*bL;
			if(b-a<=b2)return await heapSort(A,a,b);
			await heapSort(A,a,a+b2);
			await multiSwap(A,a,p,bL);
			await multiSwap(A,a+bL,p+b2,bL);
			zs[0]=zs[1]=bL;ds[1]=1;
			let kZ=2;
			for(let i=a+b2;i<b;i++){
				let o=gridSearch(A,ds,0,kZ-1,i,b2,p),idx=ds[o],bP=p+idx*b2;
				await swap(A,bP+zs[idx],i,1,true);
				if(++zs[idx]==b2){
					let bN=p+kZ*b2+bL;
					await fancySplitBucket(A,bP,bP+b2,bN);
					zs[idx]=zs[kZ]=bL;
					for(let j=kZ-1;j>o;j--)write(ds,j+1,ds[j],0,false,true);
					write(ds,o+1,kZ++,0,false,true);
				}
			}
			for(let i=0,dst=a;i<kZ;i++){
				let idx=ds[i],bP=p+idx*b2;
				if(zs[idx]>bL){
					await heapSort(A,bP+bL,bP+zs[idx]);
					await mergeTo(A,bP,bP+bL,bP+zs[idx],dst);
				}else await multiSwap(A,bP,dst,zs[idx]);
				dst+=zs[idx];
			}
		}
		async function quickGridHelper(A,zs,ds,a,b,p,bL,pL){
			let bd=false;
			while(b-a>(pL/2|0)){
				let pI;
				if(bd)pI=medOfMed(A,a,b);
				else pI=medP3(A,a,b,1);
				let m=await partition(A,a,b,pI),l=m-a,r=b-m-1;
				bd=minVal(l,r)<(maxVal(l,r)/16|0);
				if(r<l){
					await gridSort(A,zs,ds,m+1,b,p,bL);
					b=m;
				}else{
					await gridSort(A,zs,ds,a,m,p,bL);
					a=m+1;
				}
			}
			await gridSort(A,zs,ds,a,b,p,bL);
		}
		async function quickGridSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;
				e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.5,true);
				else await reversal(A,a,b-1,.5,true);
				return;
			}
			let l=b-a;
			if(l<33)return await insertSort(A,a,b);
			let bL=1<<((33-clz32(l-1))/2|0);
			let zs=new Array(bL).fill(0);
			let ds=new Array(bL).fill(0);
			let a1=a,b1=b;
			let bd=false;
			while(b1-a1>8*bL){
				let pI;
				if(bd)pI=medOfMed(A,a1,b1);
				else pI=medP3(A,a1,b1,1);
				let[p0,p1]=await partTernary(A,a1,b1,A[pI]);
				if(p1-p0==b1-a1){
					a1=b1;
					break;
				}
				let m1=p0,m2=p1;
				let lL=m1-a1,rL=b1-m2;
				bd=minVal(lL,rL)<(maxVal(lL,rL)/16|0);
				if(rL<lL){
					await quickGridHelper(A,zs,ds,m2,b1,a1,bL,lL);
					b1=m1;
				}else{
					await quickGridHelper(A,zs,ds,a1,m1,m2,bL,rL);
					a1=m2;
				}
			}
			if(b1-a1>1)await heapSort(A,a1,b1);
		}
		await quickGridSort(arr,0,len);
	}
	async parCiuraShellSort(len){
		function ciura(n){
			if(n<12)return[1,4,10,23,57,132,301,701,1750,3938,8861][n-1];
			return 2.25**n|0;
		}
		function par(A,l){
			let m=new Array(l).fill(!1),mx=A[0];
			for(let i=1;i<l;i++)
				if(A[i]>mx){
					mx=A[i];
					m[i]=true;
				}
			let p=1;
			for(let i=l-1,j=l-1;j>=0&&i>=p;j--){
				while(!m[j]&&j>0)j--;
				mx=A[j];
				while(mx<=A[i]&&i>=p)i--;
				if(A[j]>A[i]&&p<i-j)p=i-j;
			}
			return p;
		}
		async function shellPass(A,l,g){
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		async function sort(A,l){
			let s=0,k;
			for(k=1;s<par(A,l);k++)s=ciura(k);
			while(s>1){
				let p=par(A,l);s=ciura(--k);
				while(s>=p){
					if(--k>0)s=ciura(k);
					else{
						s=1;
						break;
					}
				}
				await shellPass(A,l,s);
				if(s==1)break;
			}
		}
		await sort(arr,len);
	}
	async parFurtherRandomShellSort(len){
		async function shellPass(A,l,p,b){
			for(let h=randInt(1,b+1),i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				while(j>=h&&compareValues(A[j-h],v)>0)
					await write(A,j,A[j-=h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
				h=randInt(1,i<b?i+1:b+1);
			}
		}
		function nextBound(A,l){
			let m=new Array(l).fill(!1),mx=A[0];
			for(let i=1;i<l;i++){
				if(A[i]>mx){
					mx=A[i];
					m[i]=true;
				}
			}
			let i=l-1,p=1,j=l-1;
			while(j>=0&&i>=p){
				while(!m[j]&&j>0)j--;
				mx=A[j];
				while(mx<=A[i]&&i>=p)i--;
				if(A[j]>A[i]&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		let b=len-1;
		while(b>(cbrt(len)|0)){
			await shellPass(arr,len,b,b%2+b/2|0);
			b=nextBound(arr,len);
		}
		await shellPass(arr,len,b,1);
	}
	async simplifiedHanoiSort(len){
		class Rod{
			constructor(i,x){
				if(x)this.A=new Array(i);
				else this.A=i;
				this.X=x;
				this.z=-1;
			}
			empty(){
				return this.z<0;
			}
			size(){
				return this.z+1;
			}
			dispose(){
				this.z=-2;
			}
			peekTop(i){
				if(this.empty()||i>this.z)return-1/0;
				return this.A[this.z-i];
			}
			async drop(v){
				await write(this.A,++this.z,v,1,true,this.X);
			}
			lift(){
				if(this.empty())return-1/0;
				return this.A[this.z--];
			}
		}
		async function towerHanoi(f,x,t,n){
			if(n==1){
				if(f.size()>0)
					await t.drop(f.lift());
			}else if(n>1){
				await towerHanoi(f,t,x,n-1);
				if(f.size()>0)
					await t.drop(f.lift());
				await towerHanoi(x,f,t,n-1);
			}
		}
		async function pushAll(n){
			let i=0;
			if(!s2.size())return;
			while(i<s2.size()&&compareValues(s2.peekTop(i),n)<1)i++;
			await towerHanoi(s2,mn,s1,i);
		}
		async function runHanoi(A,e){
			for(let i=0;i<e;i++){
				let t=A[i];
				await pushAll(t);
				await s2.drop(t);
				await towerHanoi(s1,mn,s2,s1.size());
			}
			await towerHanoi(s2,s1,mn,s2.size());
			s1.dispose();
			s2.dispose();
			await reversal(A,0,e-1,25,true);
		}
		let mn=new Rod(arr,false);
		let s1=new Rod(len,true);
		let s2=new Rod(len,true);
		await runHanoi(arr,len);
	}
	async cityscapeSortNS(len){
		async function csdep(A,i,j){
			if(i==j)return;
			let a=minVal(i,j),b=maxVal(i,j);
			if(compareIndices(A,a,b)>0)await swap(A,a,b,.1,true);
		}
		async function shellPass(A,s,e,g){
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&j-h>=s&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		async function shell(A,s,e){
			for(let g=(e-s)/2.25|0;g>1;g=g/2.25|0)await shellPass(A,s,e,g);
			await shellPass(A,s,e,1);
		}
		function maxsorted(A,s,e){
			let a=e-1,b=e-1,sg=true;
			while(sg){
				if(b-1<s)return s;
				if(compareIndices(A,b-1,b)>0)sg=false;
				else b--;
			}
			let sl=b-1;
			for(let i=b-2;i>=s;i--)if(compareIndices(A,sl,i)<0)sl=i;
			while(compareIndices(A,sl,a)<1)if(--a<s)break;
			return a+1;
		}
		async function sort(A,l){
			let i=l;
			while(i>0){
				let h=i,j=0;
				for(;j<i;j++){
					await csdep(A,j,j+1);
					for(h=i-1;h>i-j-2;h--){
						await csdep(A,j,h);
						if(h<=j)break;
					}
					if(h<=j)break;
				}
				await shell(A,j,i);
				i=maxsorted(A,0,i);
			}
		}
		await sort(arr,len);
	}
	async basicDigSort(len){
		function par(A,a,b){
			let m=new Array(b-a).fill(!1),mx=A[a];
			for(let i=1;i<b-a;i++)
				if(A[a+i]>mx){
					mx=A[a+i];
					m[i]=true;
				}
			let p=1;
			for(let i=b-a-1,j=b-a-1;j>=0&&i>=p;j--){
				while(!m[j]&&j>0)j--;
				mx=A[a+j];
				while(mx<=A[a+i]&&i>=p)i--;
				if(A[a+j]>A[a+i]&&p<i-j)p=i-j;
			}
			return p;
		}
		async function sort(A,n){
			let ls=0,l=n,ms=n-2,s=true,td=0;
			for(let i=0;i<n&&s;i=ls,td++){
				l=par(A,0,n);
				let msd=s=false;
				for(let j=ms;j>=i;j--)
					if(compareIndices(A,j,j+1)>0){
						await swap(A,ls=j,j+1,.1,s=true);
						if(!msd){
							msd=true;
							ms=j+1<n-1?j+1:n-2;
						}
					}
				if(s)
					for(let a=ls+1;a<=ms;a++)
						if(compareIndices(A,a,a+1)>0){
							let bl=a+l<n-1?a+l:n-2;
							for(let b=a+1;b<=bl;b++)
								if(compareIndices(A,a,b)>0){
									await swap(A,a++,b,.1,true);
									if(b>ms)ms=b;
								}
						}
			}
		}
		await sort(arr,len);
	}
	async adaptiveRandomClamberSort(len){
		function randomSearch(A,a,b,v){
			while(a<b){
				let m=randInt(a,b);
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		for(let r=1,i=0;r<len;r++)
			if(compareIndices(arr,r-1,r)>0){
				let l=randomSearch(arr,0,r-1,arr[r]);
				while(l<r){
					swap(arr,l++,r);
					if(++i>sqrt(len))await markSwap(l-1,r,i=0);
				}
			}
	}
	async optimizedZubbleSort(len){
		for(let i=len-1,c=1,f=1;i>=f;i-=c){
			let fs=false;
			for(let j=maxVal(f-1,0);j<i;j++){
				let k=j,s=false;
				while(j<i&&compareIndices(arr,k,j+1)>0){
					j++;
					s=true;
				}
				if(s){
					await swap(arr,k,j,1,true);
					c=1;
					if(!fs)f=k;
					fs=true;
				}else c++;
			}
		}
	}
	async lootSort(len){
		let c=0,i=0;
		for(;i+c+1<len;i++){
			if(i>0)
				if(compareIndices(arr,i-1,i)<0){
					i--;
					c++;
				}
			if(compareIndices(arr,i+c,i+c+1)<1){
				i--;
				c++;
			}else await Wr.insert(arr,i+c+1,i,.1,true);
		}
		await IndexedRotations.adaptable(arr,0,i,len,.1,true);
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,1,true);
			else await reversal(A,s,e,1,true);
			let i=s,l,r;
			while(i<e){
				l=i;
				while(!compareIndices(A,i,i+1)&&i<e)i++;
				r=i;
				if(l-r){
					if(r-l<3)await swap(A,l,r,1,true);
					else await reversal(A,l,r,1,true);
				}
				i++;
			}
		}
		async function pd(A,s,e){
			let f=s,c=compareIndices(A,f,f+1),u=false;
			while(c<1&&f+1<e){
				if(!c)u=true;
				if(++f+1<e)c=compareIndices(A,f,f+1);
			}
			let r=s;
			if(f==s){
				let d=false;
				c=compareIndices(A,r,r+1);
				while(c+1&&r+1<e){
					if(!c)u=true;
					else d=true;
					if(++r+1<e)c=compareIndices(A,r,r+1);
				}
				if(r>s&&d){
					if(u)await stableSegmentReversal(A,s,r);
					else if(r<s+3)await swap(A,s,r,1,true);
					else await reversal(A,s,r,1,true);
				}
			}
			return maxVal(f,r);
		}
		function binarySearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function pdbinsert(A,s,e){
			let p=await pd(A,s,e),j=0;
			for(let i=p+1;i<e;i++){
				let t=A[i];
				let l=binarySearch(A,s,i,t);
				let w=false;
				for(let r=i;r>l;r--){
					write(A,r,A[r-1],0);
					w=true;
					if(++j>=len)await mark(r,j=0);
				}
				if(w)await write(A,l,t,1,true);
			}
		}
		await pdbinsert(arr,0,len);
	}
	async adaptiveFibonacciClamberSort(len){
		function fibonacciSearch(A,s,e,v){
			let f2=0,f1=1,f=1;
			while(f<=e-s){
				f2=f1;f1=f;f=f2+f1;
			}
			let o=s-1;
			while(f>1){
				let i=minVal(o+f2,e);
				if(compareValues(A[i],v)<1){
					f=f1;f1=f2;f2=f-f1;o=i;
				}else{
					f=f2;f1-=f2;f2=f-f1;
				}
			}
			let p=o+1;
			if(compareValues(A[p],v)<1)p++;
			return p;
		}
		for(let r=1,i=0;r<len;r++)
			if(compareIndices(arr,r-1,r)>0){
				let l=fibonacciSearch(arr,0,r-1,arr[r]);
				while(l<r){
					swap(arr,l++,r);
					if(++i>sqrt(len))await markSwap(l-1,r,i=0);
				}
			}
	}
	async forwardRunShoveSort(len){
		for(let l=1;l-len;l++){
			let r=len;
			while(l<r)
				if(compareIndices(arr,l-1,r-1)>0)await multiSwap(arr,l-1,r-1,.02,true);
				else r--;
		}
	}
	async binaryInvaSort(len){
		let s=0;
		while(s<len&&compareIndices(arr,s,s+1)<1)s++;
		for(let i=1;i<len;i++){
			let r=randInt(i,len),n=arr[r],a=0,b=i;
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(n,arr[m])<0)b=m;
				else a=m+1;
			}
			let j=i,k=0;
			await multiSwap(arr,r,i,.05,true);
			while(j>=0&&j>a){
				swap(arr,j,--j);
				if(++k>sqrt(len))await mark(j+1,k=0);
			}
		}
	}
	async fateSort(len){
		let l=1,b=len,fs=0,hs=len,i=0;
		while(b>1){
			let hl=0;
			for(let r=l+1;r<=b;r++)
				if(compareIndices(arr,l-1,r-1)>0)
					if(!hl)hl=r;
					else if(compareIndices(arr,hl-1,r-1)<0)hl=r;
			if(hl>hs)hs=hl;
			if(hl){
				if(!fs)fs=l;
				swap(arr,l-1,hl-1);
				if(++i>sqrt(len))await markSwap(l-1,hl-1,i=0);
			}
			if(++l>b){
				l=fs;
				b=hs-1;
				fs=hs=0;
			}
		}
	}
	async circleSortJaune(len){
		async function circle(A,a,b,as){
			if(a>=b)return as;
			let l=a,r=b,sh=false;
			while(l<r){
				if(compareIndices(A,l,r)>0)await swap(A,l,r,.25,sh=true);
				else l++;
				r--;
			}
			return await circlex(A,a,l,as||sh)|await circlex(A,l,b,as||sh);
		}
		async function circlex(A,a,b,as){
			if(a>=b)return as;
			let l=a,r=b,sh=false;
			while(l<r){
				if(compareIndices(A,l,r)>0)await swap(A,l,r,.25,sh=true);
				else break;
				l++;r--;
			}
			return await circle(A,l,b-1,as||sh)|await circlex(A,a+1,r,as||sh);
		}
		let o=0,g=len,as=true;
		while(as)
			for(as=false,g=len;g>0;g--){
				as=await circle(arr,o=0,len-1,as);
				while(o<len){
					as=await circlex(arr,o,minVal(o+(g-1),len-1),as);
					o+=g;
				}
			}
	}
	async circleSortRouge(len){
		async function circle(A,a,b,as){
			let sh=false;
			for(;a<b;a++,b--)if(compareIndices(A,a,b)>0)await swap(A,a,b,.5,sh=true);
			return as||sh;
		}
		let as=true;
		while(as){
			as=false;
			for(let g=len;g>0;g--)
				for(let o=0;o+g-1<len;o+=g)
					as=await circle(arr,o,o+g-1,as);
		}
	}
	async goalkeeperSort(len){
		function score(A,b){
			let n=b,f=false;
			while(n>0&&!f){
				for(let i=0;i<n&&!f;i++)if(compareIndices(A,i,n)>0)f=true;
				if(!f)n--;
			}
			return n;
		}
		async function sort(A,l){
			let b=score(A,l-1);
			while(b>0)
				if(compareIndices(A,0,1)>0){
					let f=false,g;
					for(g=2;g<=b&&!f;g++)if(compareIndices(A,0,g)<0)f=true;
					if(!f){
						await Wr.insert(A,0,b--,.01,true);
						b=score(A,b);
					}else await Wr.insert(A,0,g-2,.01,true);
				}else await Wr.insert(A,0,b,.01,true);
		}
		await sort(arr,len);
	}
	async meanPartitionSort(len){
		async function partition(A,s,e){
			let n=1/0,x=-1/0;
			for(let i=s;i<e;i++){
				if(A[i]<n)n=A[i];
				if(A[i]>x)x=A[i];
			}
			let md=n+(x-n)/2+1|0,il=0;
			for(let i=s;i<e;i++)if(compareValues(A[i],md)<0)if(s+il++-i)await swap(A,i,s+il-1,.25,true);
			return il;
		}
		async function presumepartitions(A,s,e){
			if(e-s>1){
				let m=await partition(A,s,e);
				await presumepartitions(A,s,s+m);
				await presumepartitions(A,s+m,e);
			}
		}
		await presumepartitions(arr,0,len,0);
	}
	async swaplessClamberSort(len){
		async function clamber(A,a,b){
			for(let i=a+1,k=0;i<b;i++){
				let t=A[i],c=false;
				for(let j=a;j<i;j++)
					if(compareValueIndex(A,t,j)<0){
						let t2=A[j];c=true;
						write(A,j,t);
						if(++k>sqrt(len))await mark(j,k=0);
						t=t2;
					}
				if(c)await write(A,i,t,.25,true);
			}
		}
		await clamber(arr,0,len);
	}
	async paintSort(len){
		for(let i=0,k=0;i<len;i++)
			for(let j=i;j<len;j++){
				if(compareIndices(arr,j,j+1)>0){
					await multiSwap(arr,j,len-1,.005,true);
					j=i;
				}else if(j<len-1){
					swap(arr,j,j+1);
					if(++k>sqrt(len))await markSwap(j,j+1,k=0);
				}
				if(compareIndices(arr,j,i)>0)await swap(arr,j,i,1,true);
			}
		await reversal(arr,0,len-1,1,true);
	}
	async circleSortInverseIterative(len){
		async function circle(A,a,b,as){
			let sh=false;
			for(;a<b;a++,b--)if(compareIndices(A,a,b)>0)await swap(A,a,b,1,sh=true);
			return as||sh;
		}
		let g=2,as=true;
		while(as){
			as=false;g=2;
			while(g<=len){
				for(let o=0;o+g-1<len;o+=g)as=await circle(arr,o,o+g-1,as);
				g*=2;
			}
			if(g/2-len&&!as)await new QuadSorting().quadSort(arr,0,len);
		}
	}
	async optimizedShoveSort(len){
		let l=1,r=0;
		while(l<len)
			if(compareIndices(arr,l-1,l)>0){
				await multiSwap(arr,l-1,len-1,.0125,true);
				if(l>1)l--;
				if(++r>=len-l){
					await reversal(arr,l,len-1,1.25,true);
					r=0;
				}
			}else l++;
	}
	async NReboundSort(len){
		let base=askForNum(0,"Base",0);
		async function sort(A,l,t){
			if(!t)t=(l/16|0)>1?(l/16|0):(l/2|0);
			let su=false,s=false;
			for(let d=1;!s;d*=-1){
				let i=d>0||!su?0:l-2,b=0;
				su=s=true;
				for(;i>=0&&i<l-1;i+=d)
					if(compareIndices(A,i,i+1)>0){
						await swap(A,i,i+1,.01,true,s=false);
						if(++b==t){
							d=-d;
							b=0;
						}
					}
			}
		}
		await sort(arr,len,base);
	}
	async badGnomeSort(len){
		let s=0;
		while(s<len&&compareIndices(arr,s,s+1)<1)s++;
		for(let i=s;i<len;i++){
			await multiSwap(arr,len-1,i,.05,true);
			let j=i-1,k=0;
			while(j+1&&compareIndices(arr,j,j+1)>0){
				swap(arr,j,j--+1);
				if(++k>sqrt(len))await markSwap(j+1,j+2,k=0);
			}
		}
	}
	async binaryVacuumSort(len){
		async function pull(A,a,b){
			let t=a;--b;
			while(a<b){
				let m=a+(b-a+1)/2|0,c=compareIndices(A,m,t);
				if(c>0)return await multiSwap(A,t,m,2/b,true);
				else a=m+1;
			}
			await multiSwap(A,t,b,1/b,true);
		}
		while(len>0){
			while(!isMaxSorted(arr,0,len))
				await pull(arr,0,len);
			len--;
		}
	}
	async pingPongSort(len){
		let i=len/2|0,sC=0,f=true,j=0;
		while(1){
			if(compareIndices(arr,i-1,i)>0){
				swap(arr,i-1,i);
				if(++j>sqrt(len))await markSwap(i-1,i,j=0);
				if(i==1)f=true;
				else if(i==len-1)f=false;
				else f=!f;
				sC=0;
				continue;
			}else{
				if(f)i++;
				else i--;
				sC++;
			}
			if(sC>=len-1)break;
			else{
				if(!i){
					f=true;
					sC=0;
					i++;
				}else if(i==len){
					f=false;
					sC=0;
					i--;
				}
			}
		}
	}
	async poptimalSort(len){
		async function greversal(A,s,e,g){
			let l=e-s,k=s+l-g-l%g;
			for(let i=s,j=k;i<j;i+=g,j-=g)
				await swap(A,i,j,.1,true);
		}
		async function defeatPatterns(A,s,e,g,dr){
			let c=compareIndices(A,s,s+g)*dr,n=c,t=s;
			if(!c)c=-dr;
			while(s<e-g&&(n==c||!n)){
				s+=g;
				n=compareIndices(A,s,s+g);
			}
			if(c==dr)await greversal(A,t,s+1,g);
			return s>=e-g;
		}
		async function zubble(A,s,e,dr,g){
			if(await defeatPatterns(A,s,e,g,dr))return;
			let fb=s+g,cs=1;
			for(let j=e-g;j>=fb;j-=g*cs){
				let fs=false;
				for(let i=maxVal(s,fb-g);i<j;i+=g){
					let k=i;
					while(i<j&&compareIndices(A,k,i+g)==dr)i+=g;
					if(k-i){
						await swap(A,k,i,1,true);
						if(!fs){
							fb=k;
							fs=true;
						}
						cs=1;
					}else cs++;
				}
			}
		}
		async function circleRoutine(A,s,e,b,dr,g){
			for(let i=s,j=e;i<j;i+=g,j-=g)if(j<b)if(compareIndices(A,i,j)==dr)await swap(A,i,j,1,true);
			let m=s+((e-s)/(2*g)|0)*g;
			if(m==s)return;
			await circleRoutine(A,s,m,b,dr,g);
			await circleRoutine(A,m+g,e,b,dr,g);
		}
		async function gpedCircle(A,s,e,d,g){
			let ug=(e-s)/g|0,cp=1;
			while(cp<ug)cp<<=1;
			await circleRoutine(A,s,s+(cp-1)*g,e,d,g);
		}
		async function wipdiPop(A,s,e,dr,gq,o){
			if(e-s<=gq)return;
			if(o<1)await zubble(A,s,e,dr,gq);
			else{
				let g=1,d=dr;
				while(g<=((e-s)/(2*gq)|0))g*=2;
				g=g/2|0;
				let li=s,tC=sqrt(g)|0;
				while(g>1){
					let gr=g*gq;d=dr;
					for(let i=s;i<s+(e-s)%gr+gr;i+=gq){
						if(o==1&&g<tC)await gpedCircle(A,i,e,d,gr);
						else await wipdiPop(A,i,e,d,gr,o-1);
						li=i;d=-d;
					}
					g=g/2|0;
				}
				if(d==dr)await greversal(A,li,e+gq,2*gq);
				else await greversal(A,s,e+gq,2*gq);
				await wipdiPop(A,s,e,dr,gq,o-1);
			}
		}
		await wipdiPop(arr,0,len,1,1,1);
	}
	async strangeSort(len){
		let base=askForNum(2,"Base");
		let as=true;
		while(as){
			as=false;
			for(let o=1;o-len;o++){
				let m=1,b=1;
				while(o+m<=len)
					if(compareIndices(arr,o+m/base-1|0,o+m-1)>0){
						await swap(arr,o+m/base-1|0,o+m-1,.1,as=true);
						if(!m){
							b*=base;
							m=b;
						}else m=m/base|0;
					}else{
						b*=base;
						m=b;
					}
			}
		}
	}
	async rubbleSort(len){
		function sig(a,b,d){
			return(a+b+d*abs(a-b))/2|0;
		}
		async function run(A,s,e){
			if(s>=e-1)return s+1;
			let c=-compareIndices(A,s++,s)|1,k=s-1,d;
			do d=compareIndices(A,s++,s);while(s<e&&d-c);
			let m=(s-k)/2|0,q=sig(k,s-1,-c);
			for(let i=0;i<m;i++)await swap(A,k+i,q+c*i,1,true);
			return s;
		}
		async function sort(A,l){
			let rs=new Array(l/2|0),rf=0,r=0;
			while(r<l)write(rs,rf++,(r=await run(A,r,l))-1,0,false,true);
			while(rf>1){
				for(let i=1;i<rf;i++)
					if(compareIndices(A,rs[i-1],rs[i])>0){
						let t=A[rs[i-1]],tm=rs[i-1]-1;
						while(tm>=(i-2<0?0:rs[i-2]+1)){
							if(compareIndices(A,tm,rs[i])<1)break;
							await write(A,tm+1,A[tm--],.1,true);
						}
						await write(A,tm+1,A[rs[i]],.1,true);
						await write(A,rs[i],t,.1,true);
					}
				if(rs[rf-1]==rs[rf-2])write(rs,--rf,0,0,false,true);
				else write(rs,rf-1,rs[rf-1]-1,0,false,true);
			}
		}
		await sort(arr,len);
	}
	async weirdBubblePopSort(len){
		async function weirdBubble(A,a,b,d){
			let c=d?1:-1,s=false,k=0;
			while(!s){
				s=true;
				for(let i=a+1;i<b;i++){
					let j=i;
					while(j>a&&compareIndices(A,j-1,j)*c>0){
						swap(A,i,--j);
						if(++k>sqrt(b-a))await markSwap(i,j+1,k=0);
						s=false;
					}
				}
			}
		}
		async function popSort(A,a,b){
			let q=(b-a)/4|0,h=(b-a)/2|0;
			await weirdBubble(A,a,a+q,0);
			await weirdBubble(A,a+q,a+h,1);
			await weirdBubble(A,a+h,b-q,0);
			await weirdBubble(A,b-q,b,1);
			await weirdBubble(A,a,a+h,0);
			await weirdBubble(A,a+h,b,1);
			await weirdBubble(A,a,b,1);
		}
		await popSort(arr,0,len);
	}
	async shobeSort(len){
		let d=false;
		let s=0;
		while(!d){
			d=true;
			let sf=false;
			for(let i=s-1>0?s-1:0;i+1<len;i++)
				while(compareIndices(arr,i,i+1)>0){
					await multiSwap(arr,i,len-1,.01,true,d=false);
					if(!sf){
						s=i;
						sf=true;
					}
				}
		}
	}
	async quasimiddleSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,.05,true);
				return true;
			}
			return false;
		}
		async function middle(A,s,e){
			let m=s+(e-s)/2|0,sw=false,t=false;
			for(let i=1;m-i>=s&&m+i<=e;i++){
				t=await cs(A,m-i,m);
				if(!sw&&t)sw=true;
				t=await cs(A,m,m+i);
				if(!sw&&t)sw=true;
			}
			return sw;
		}
		let sw=true;
		while(sw){
			let t=sw=false;
			for(let i=1;i<len;i++){
				t=await middle(arr,0,i);
				if(!sw&&t)sw=true;
				t=await middle(arr,i,len-1);
				if(!sw&&t)sw=true;
			}
		}
	}
	async segmentedSort(len){
		async function sortSegments(A,s,e){
			let as=false;
			for(let i=s;i<e;i++){
				let a=i;
				while(compareIndices(A,i,i+1)<1&&i+1<e)i++;
				let b1=i,b2=i+1;
				if(i+1<e){
					if(compareIndices(A,a,b2)>0){
						i++;
						while(compareIndices(A,i,i+1)<1&&i+1<e)i++;
						let c1=i,c2=i+1;
						if((b2-a)%(c1-b1)<1||(c1-b1)%(b2-a)<1)await IndexedRotations.holyGriesMills(A,a,b2,c2,.1,as=true);
						else await IndexedRotations.cycleReverse(A,a,b2,c2,.1,as=true);
						i=a-1;
					}else i=b1;
				}
			}
			return as;
		}
		while(await sortSegments(arr,0,len));
		for(let i=1;i<len;i++)await sortSegments(arr,i,len);
	}
	async squeegeeSort(len){
		async function stoogeSort(A,i,j,d){
			if(compareIndices(A,i,j)>0)await reversal(A,i,j,.05,true);
			if(j-i>1){
				let t=(j-i+1)/3|0;
				await stoogeSort(A,i,j-t,d);
				await stoogeSort(A,i+2*t,j,d);
				await stoogeSort(A,i,j-t,d);
				if(j-i>2){
					await stoogeSort(A,j-2*t,j,d);
					await stoogeSort(A,i,j-t,d);
				}
			}
			if(compareIndices(A,i,j)>0)await reversal(A,i,j,.005,true);
		}
		await stoogeSort(arr,0,len-1,0);
	}
	async rougeSpacePopSort(len){
		async function bubble(A,s,e,d){
			let c=1,n,f=1;
			for(let j=e-1,k=0;j>0;j-=c){
				n=maxVal(f-1,s);
				let a=false;c=1;
				for(let i=n;i<j;i++)
					if(compareIndices(A,i,i+1)==d){
						swap(A,i,i+1);a=true;
						if(++k>sqrt(e-s))await markSwap(i,i+1,k=0);
						if(!a)f=i;c=1;
					}else c++;
			}
		}
		for(let l=2,i=0,d=-1;l<=len;l++)
			for(i=0,d=-1;i+l<=len;d=-d)
				await bubble(arr,i,i+=l,d);
		await bubble(arr,0,len,1);
	}
	async gnoomeSort(len){
		async function stoogeSort(A,i,j,d){
			if(compareIndices(A,i,j)>0)await swap(A,i,j,.005,true);
			if(j-i>1){
				let t=(j-i+1)/3|0;
				await stoogeSort(A,i,j-t);
				await stoogeSort(A,i,i+t);
				await stoogeSort(A,i+t,j);
				await stoogeSort(A,i+t,j-t);
				await stoogeSort(A,i,i+t);
			}
		}
		for(let i=1;i<len;i++)await stoogeSort(arr,0,i);
	}
	async adaptiveBPMSort(len){
		function getMinLevel(n){
			while(n>31)n=(n+1)/2|0;
			return n;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2|0;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		function medOf3(A,a,b,c){
			let t;
			if(compareIndices(A,a,b)>0)[t,b]=[b,a];
			else t=a;
			if(compareIndices(A,b,c)>0){
				if(compareIndices(A,t,c)>0)return t;
				return c;
			}
			return b;
		}
		async function medianOfMedians(A,a,b){
			while(b-a>2){
				let m=a,i=a;
				for(;i+2<b;i+=3)await swap(A,m++,medOf3(A,i,i+1,i+2),1,true);
				while(i<b)await swap(A,m++,i++,1,true);
				b=m;
			}
		}
		async function multiSwap(A,a,b,l){
			if(a-b)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0)
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
		}
		async function partition(A,a,b){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function quickSelect(A,a,b,m){
			let bP=false,md=false,m1=m+(b-m+1)/2|0;
			while(1){
				if(bP)await medianOfMedians(A,a,b,md=true);
				else await medianOfThree(A,a,b);
				let p=await partition(A,a,b);
				await swap(A,a,p,1,true,false);
				let l=p-a,r=b-p-1;
				bP=!md&&(minVal(l,r)<maxVal(l,r)/16|0);
				if(p>=m&&p<m1)return p;
				else if(p<m)a=p+1;
				else b=p;
			}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			return binSearch(A,a+i/2|0,minVal(b,a-1+i),v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			return binSearch(A,maxVal(a,b-i+1),b-i/2|0,v,l);
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a;
			await multiSwap(A,a,p,pL);
			let i=0,j=m,k=a;
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m;
			await multiSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+i--,1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(b-m<m-a)await mergeBW(A,a,m,b,p);
			else await mergeFW(A,a,m,b,p);
		}
		async function lazyBufferedMergeFW(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			let pL=m-a;
			await multiSwap(A,a,p,pL);
			let i=0,j=m,k=a;
			while(i<pL&&j<b){
				if(compareIndices(A,j,p+i)<0){
					let q=leftExpSearch(A,j,b,A[p+i],true);
					while(j<q)await swap(A,k++,j++,1,true);
				}
				await swap(A,k++,p+i++,1,true);
			}
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,.1,true);
					else await reversal(A,j,i-1,.1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function inPlaceMerge(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,j=getMinLevel(l);
			if(await buildRuns(A,a,b,j))return;
			while(j<l){
				for(i=a;i+2*j<=b;i+=2*j)await merge(A,i,i+j,i+2*j,p);
				if(i+j<b)await merge(A,i,i+j,b,p);
				j*=2;
			}
		}
		async function sort(A,a,b){
			if(b-a<33)return await buildRuns(A,a,b,b-a);
			let mL=sqrt(b-a)|0,m=b-(b-a)/2|0;
			await mergeSort(A,m,b,a);
			while(m-a>mL){
				let m1=m-(m-a)/2|0;
				m1=await quickSelect(A,a,m,m1);
				await mergeSort(A,m1,m,a);
				await lazyBufferedMergeFW(A,m1,m,b,a);
				m=m1;
			}
			await buildRuns(A,a,m,m-a);
			await inPlaceMerge(A,a,m,b);
		}
		await sort(arr,0,len);
	}
	async originalPCBoysParShellSort(len){
		let base=askForNum(2,"Division constant",1);
		function par(A,l){
			let m=new Array(l).fill(!1),mx=A[0];
			for(let i=1;i<l;i++)
				if(A[i]>mx){
					mx=A[i];
					m[i]=true;
				}
			let p=1;
			for(let i=l-1,j=l-1;j>=0&&i>=p;j--){
				while(!m[j]&&j>0)j--;
				mx=A[j];
				while(mx<=A[i]&&i>=p)i--;
				if(A[j]>A[i]&&p<i-j)p=i-j;
			}
			return p;
		}
		async function shellPass(A,l,g){
			if(g>=lg)return;lg=g;
			for(let h=g,i=h;i<l;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&compareValues(A[j-h],v)>0;j-=h)
					await write(A,j,A[j-h],.25,w=true);
				if(w)await write(A,j,v,.25,true);
			}
		}
		let lg;
		async function sort(A,l){
			let lp=l;lg=l;
			while(1){
				let p=par(A,l);
				if(p>=lp)p=lp-base;lp=p;
				if((p/base|0)<2){
					await shellPass(A,l,1,p);
					break;
				}
				await shellPass(A,l,p/base+p%base|0);
			}
		}
		await sort(arr,len);
	}
	async fibonacciHeapSort(len){
		let FIB=new Array(44).fill(0);
		function genFib(){
			FIB[0]=FIB[1]=1;
			for(let i=2;i<FIB.length;i++)
				FIB[i]=FIB[i-2]+FIB[i-1];
		}
		async function fastsift(A,a,b){
			let o=toByte(clz32(b&~a));
			if(o<2)return;
			while(o>2){
				let f=FIB[o-2],j=b-f;
				if(j>=a&&compareIndices(A,b,j)>0){
					await swap(A,b,j,1,true);
					o-=2;
				}else o--;
			}
		}
		async function sift(A,a,b){
			let o=2,n=b-1;
			if(o<2)return;
			while(o>1){
				let f=FIB[o-1],j=b-f;
				if(j<a)return;
				else{
					let l=j,m=b-FIB[o-2]-f;
					if(m<a)m=a;
					for(let i=0;i<FIB[o-2]&&m+i<j;i++)if(compareIndices(A,l,m+i)>0)l=m+i;
					await swap(A,l,n,1,true);
					n=l;o=toByte(o+1);
				}
			}
		}
		async function fibHeapify(A,s,e){
			genFib();
			let j=1;
			while(FIB[j]<=e-s)j++;
			for(let i=s;i<e;i++)await fastsift(A,s,i);
		}
		await fibHeapify(arr,0,len);
		for(let i=0;i<len;i++){
			await swap(arr,i,len-1,1,true);
			await sift(arr,i+1,len);
		}
		await insertSort(arr,0,len,.1);
	}
	async adaptiveVelvetSort(len){
		async function pair(A,a,m){
			if(a+1<m&&compareIndices(A,a,a+1)>0)await swap(A,a,a+1,1,true);
		}
		async function heap(A,a,b,d){
			let m=a+(b-a)/2|0;
			if(a<m){
				await heap(A,a,m,d+1);
				await heap(A,m,b,d+1);
				if(compareIndices(A,a,m)>0){
					await swap(A,a,m,1,true,false);
					await heap(A,m,b,d+1);
				}
			}
		}
		async function sift(A,a,a1,b,d){
			let p=(b-a+1)/2|0,B=b,lp=0;
			while(p-lp){
				while(b-p>a1&&p-lp){
					b-=p;lp=p++;p=p/2|0;
					if(compareIndices(A,a1,b)>0){
						await swap(A,a1,b,1,true);
						await pair(A,b,B);
						await sift(A,b,b,b+lp,d+1);
					}
				}
				lp=p++;p=p/2|0;
			}
		}
		await heap(arr,0,len,0);
		for(let i=1;i<len-1;i++)await sift(arr,0,i,len,0);
	}
	async binomialVelvetSort(len){
		async function heap(A,a,b){
			let m=a+(b-a)/2|0;
			if(a<m){
				await heap(A,a,m);
				await heap(A,m,b);
				if(compareIndices(A,a,m)>0){
					let z=A[a];
					await write(A,a,A[m],1,true);
					await sift(A,m,m,b,z,1);
				}
			}
		}
		async function sift(A,a,a1,b,t,s){
			let p=b-a,lp,m,mp;
			do{
				lp=p++;
				mp=p=p/2|0;
				m=b-p;
			}while(p-lp&&b-p<=a1);
			while(p-lp){
				while(b-p>a1){
					b-=p;
					if(m-b&&compareIndices(A,m,b)+1)[m,mp]=[b,p];
					p=(p+1)/2|0;
				}
				lp=p++;
				p=p/2|0;
			}
			if(m>a1&&compareValueIndex(A,t,m)>0){
				await write(A,a1,A[m],1,true);
				await sift(A,m,m,m+mp,t,++s);
			}else if(s)await write(A,a1,t,1,true);
		}
		await heap(arr,0,len);
		for(let i=1;i<len-1;i++)await sift(arr,0,i,len,arr[i],0);
	}
	async rectangleSelectionSort(len){
		let w=sqrt(len)|0;
		while(len%w)w++;
		for(let i=0;i<len;i++){
			for(let x=i%w,j=i-x;j<len;j+=w){
				let s=j,sl=j<i?j+x:j;
				for(let k=sl+1;k<j+w;k++)if(compareIndices(arr,sl,k)>0)sl=k;
				if(sl%w-x)await swap(arr,sl,s+x,.1,true);
			}
			let sl=i;
			for(let j=i+w;j<len;j+=w)if(compareIndices(arr,sl,j)>0)sl=j;
			if(sl-i)await swap(arr,sl,i,.1,true);
		}
	}
	async newBingoSort(len){
		for(let j=len,k=1;;){
			for(let i=k;i<j;i++)if(compareIndices(arr,i,k-1)+1)await swap(arr,k++,i,.02,true);
			if(k==j)break;
			if(!compareIndices(arr,0,k-1))while(k>0)await swap(arr,--j,--k,.02,true);
			else{
				await swap(arr,--j,--k,1,true);
				while(!compareIndices(arr,--k,j))await swap(arr,--j,k,.02,true);
			}
			if(!k)k=1;
		}
	}
	async rollSort(len){
		for(let i=0,k=0;i<len;i++){
			let m=i;
			for(let j=i+1;j<len;j++)if(compareIndices(arr,j,m)<0)m=j;
			let d=m-i;
			for(let r=0;r<d;r++)for(let j=i;j<len-1;j++){
				swap(arr,j,j+1);
				if(++k>len)await markSwap(j,j+1,k=0);
			}
		}
	}
	async binarySiftHeapSort(len){
		function binSearch(A,i,b,v){
			let a=0;
			while(a<b){
				let m=(a+b)/2|0;
				if(compareValues(A[i[m]],v)<1)b=m;
				else a=m+1;
			}
			return a;
		}
		async function siftDown(A,T,r,t,b){
			let j=r,c=0;
			r=2*r+1;
			while(r+1<b){
				if(compareIndices(A,r,r+1)<0)r++;
				write(T,c++,r,0,false,true);
				r=2*r+1;
			}
			if(r<b)write(T,c++,r,0,false,true);
			let k=binSearch(A,T,c,t);
			for(let i=0;i<k;j=T[i++])await write(A,j,A[T[i]],.25,true);
			await write(A,j,t,.25,true);
		}
		async function sort(A,l){
			let r=0;
			while((1<<r)<l)r++;
			let T=new Array(r+1);
			for(let i=(l-1)/2|0;i>=0;i--)await siftDown(A,T,i,A[i],l);
			for(let i=l-1;i>0;i--){
				let t=A[i];
				await write(A,i,A[0],.5,true);
				await siftDown(A,T,0,t,i);
			}
		}
		await sort(arr,len);
	}
	async cocktailSandpaperSort(len){
		for(let i=0;i<len-1;i++){
			for(let j=i+1;j<len;j++)if(compareIndices(arr,i,j)>0)await swap(arr,i,j,1,true);
			i++;
			for(let j=len-1;j>i;j--)if(compareIndices(arr,i,j)>0)await swap(arr,i,j,1,true);
		}
	}
	async disparityShellMergeSortIterative(len){
		function getBit(B,i){
			let b=(B[i>>3])>>(i&7)&1;
			return b==1;
		}
		function flag(b,i){
			write(b,i>>3,b[i>>3]|(1<<(i&7)),0,false,true);
		}
		function findDisparity(A,a,b){
			let n=b-a,m=new Array(((n-1)>>3)+1).fill(0),mI=0;
			for(let i=1;i<n;i++)if(compareIndices(A,a+i,a+mI)>0)flag(m,mI=i);
			let i=n-1,p=1,j=n-1;
			while(j>=0&&i>=p){
				while(!getBit(m,j)&&j>0)j--;
				mI=j;
				while(compareIndices(A,a+i,a+mI)>0&&i>=p)i--;
				if(compareIndices(A,a+i,a+j)<1&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		async function shellPass(A,a,b,g,lg){
			if(g>=lg)return lg;
			if(g==lg-1&&g-1)return lg;
			lg=g;
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],1,true);
					j-=g;
				}
				if(j+g<i)await write(A,j+g,k,1,true);
			}
			return g;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++){
				let t=A[i],j=i-1;
				while(j>=a&&compareValues(A[j],t)>0)await write(A,j+1,A[j--],.5,true);
				if(j+1<i)await write(A,j+1,t,.5,true);
			}
		}
		async function shellSort(A,a,b){
			let d=3,lp=b-a,lg=b-a;
			while(1){
				let p=findDisparity(A,a,b);
				if(p>=lp)p=lp-d|0;
				if((p/(d|0)|0)<2){
					await shellPass(A,a,b,1,lg);
					break;
				}
				lg=await shellPass(A,a,b,(p/(d|0)|0)+p%(d|0),lg);
				if(lp-p<=(sqrt(lp)|0))d*=1.5;
				lp=p;
			}
		}
		async function mergeSort(A,a,b){
			let mR=b-a,i;
			for(;mR>31;mR=++mR/2|0);
			for(i=a;i+mR<b;i+=mR)await insertSort(A,i,i+mR);
			await insertSort(A,i,b);
			for(let j=mR;j<b-a;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await shellSort(A,i,i+2*j);
				if(i+j<b)await shellSort(A,i,b);
			}
		}
		await mergeSort(arr,0,len);
	}
	async disparityShellMergeSortRecursive(len){
		function getBit(B,i){
			let b=(B[i>>3])>>(i&7)&1;
			return b==1;
		}
		function flag(b,i){
			write(b,i>>3,b[i>>3]|(1<<(i&7)),0,false,true);
		}
		function findDisparity(A,a,b){
			let n=b-a,m=new Array(((n-1)>>3)+1).fill(0),mI=0;
			for(let i=1;i<n;i++)if(compareIndices(A,a+i,a+mI)>0)flag(m,mI=i);
			let i=n-1,p=1,j=n-1;
			while(j>=0&&i>=p){
				while(!getBit(m,j)&&j>0)j--;
				mI=j;
				while(compareIndices(A,a+i,a+mI)>0&&i>=p)i--;
				if(compareIndices(A,a+i,a+j)<1&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		async function shellPass(A,a,b,g,lg){
			if(g>=lg)return lg;
			if(g==lg-1&&g-1)return lg;
			lg=g;
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],1,true);
					j-=g;
				}
				if(j+g<i)await write(A,j+g,k,1,true);
			}
			return g;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++){
				let t=A[i],j=i-1;
				while(j>=a&&compareValues(A[j],t)>0)await write(A,j+1,A[j--],.5,true);
				if(j+1<i)await write(A,j+1,t,.5,true);
			}
		}
		async function shellSort(A,a,b){
			let d=3,lp=b-a,lg=b-a;
			while(1){
				let p=findDisparity(A,a,b);
				if(p>=lp)p=lp-d|0;
				if((p/(d|0)|0)<2){
					await shellPass(A,a,b,1,p,lg);
					break;
				}
				lg=await shellPass(A,a,b,(p/(d|0)|0)+p%(d|0),lg);
				if(lp-p<=(sqrt(lp)|0))d*=1.5;
				lp=p;
			}
		}
		async function mergeSort(A,a,b){
			if(b-a<32)return await insertSort(A,a,b);
			let m=a+(b-a)/2|0;
			await mergeSort(A,a,m);
			await mergeSort(A,m,b);
			await shellSort(A,a,b);
		}
		await mergeSort(arr,0,len);
	}
	async rewritten_nlognStoogeSort(len){
		async function leftMerge(A,T,s,m,e){
			if(s==m)return;
			arraycopy(A,s,T,0,m-s,0,false,true);
			let l=0,h=m,n=s;
			while(l<m-s&&h<e)
				if(compareValues(T[l],A[h])<1)await write(A,n++,T[l++],1,true);
				else await write(A,n++,A[h++],1,true);
			while(l<m-s)await write(A,n++,T[l++],1,true);
		}
		function binsearch(A,s,e,v){
			while(s<e){
				let m=s+(e-s)/2|0;
				if(compareValues(A[m],v)<0)s=m+1;
				else e=m;
			}
			return s;
		}
		async function sort3(A,a,b,c){
			if(compareIndices(A,a,b)>0)await swap(A,a,b,.1,true);
			if(compareIndices(A,b,c)>0){
				await swap(A,b,c,.1,true);
				if(compareIndices(A,a,b)>0)await swap(A,a,b,.1,true);
			}
		}
		async function NLNStooge(A,T,s,e){
			if(s==e)return;
			let th=(e-s+1)/3|0;
			if(!th){
				if(e-s-2)await insertSort(A,s,e,.5);
				return;
			}else if(e-s==2)return await sort3(A,s,s+1,s+2);
			let mA=s+th,mB=e-th;
			await NLNStooge(A,T,s,mA);
			await NLNStooge(A,T,mA,mB);
			await NLNStooge(A,T,mB,e);
			await leftMerge(A,T,s,mA,mB);
			await leftMerge(A,T,mA,mB,e);
			let b=s;
			if(e-s>190)b=binsearch(A,s,mA,A[mA]);
			await leftMerge(A,T,b,mA,e);
		}
		await NLNStooge(arr,new Array((len+1)/3|0),0,len);
	}
	async NDShellMergeSort(len){
		function findDisparity(A,a,b){
			let n=b-a,m=new Array(n).fill(!1),mI=0;
			for(let i=1;i<n;i++)if(compareIndices(A,a+i,a+mI)>0)m[mI=i]=true;
			let i=n-1,p=1,j=n-1;
			while(j>=0&&i>=p){
				while(!m[j]&&j>0)j--;
				mI=j;
				while(compareIndices(A,a+i,a+mI)>0&&i>=p)i--;
				if(compareIndices(A,a+i,a+j)<1&&p<i-j)p=i-j;
				j--;
			}
			return p;
		}
		async function shellPass(A,a,b,g,lg){
			if(g>=lg)return lg;
			if(g==lg-1&&g-1)return lg;
			lg=g;
			for(let i=a+g;i<b;i++){
				let k=A[i],j=i-g;
				while(j>=a&&compareValues(k,A[j])<0){
					await write(A,j+g,A[j],1,true);
					j-=g;
				}
				if(j+g-i)await write(A,j+g,k,1,true);
			}
			return g;
		}
		async function shellSort(A,a,b){
			let d=3,lp=b-a,lg=b-a;
			while(1){
				let p=findDisparity(A,a,b);
				if(p>=lp)p=lp-d|0;
				if((p/(d|0)|0)<2){
					await shellPass(A,a,b,1,lg);
					break;
				}
				lg=await shellPass(A,a,b,(p/(d|0)|0)+p%(d|0),lg);
				if(lp-p<=(sqrt(lp)|0))d*=1.5;
				lp=p;
			}
		}
		async function findRun(A,a,b){
			let i=a+1,d=i<b?compareIndices(A,i-1,i++)<1:!0;
			while(i<b){
				if(d^compareIndices(A,i-1,i)<1)break;
				i++;
			}
			if(!d)
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			return i;
		}
		async function mergeSort(A,a,b){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b))>=b)break;
				await shellSort(A,a,j=await findRun(A,i,b));
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b))>=b)break;
					await shellSort(A,k,j=await findRun(A,i,b));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async medianMergeSort2(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,.5,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,.5,true);
				if(compareIndices(A,a,m)>0)return;
			}
		}
		async function medianOfFive(A,a){
			await medianOfThree(A,a,a+5);
			await medianOfThree(A,a+1,a+4);
		}
		async function medianOfMedians(A,a,b){
			let e=b,s=a,i,j,d=true;
			while(e-s>1){
				j=s;
				for(i=s;i+9<e;i+=5){
					await medianOfFive(A,i);
					await swap(A,j++,i+2,1,true);
				}
				if(i<e){
					await binaryInsertion(A,i,e,.2);
					await swap(A,j++,i+(e-(d?1:0)-i)/2,1,true);
					if((e-i)%2<1)d=!d;
				}
				e=j;
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return j;
			}
		}
		async function merge(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		function getMinLevel(n){
			while(n>31)n=(n+3)/4|0;
			return n;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,o,j=getMinLevel(l);
			for(i=a;i+j<=b;i+=j)await binaryInsertion(A,i,i+j,.2);
			await binaryInsertion(A,i,b,.2);
			while(j<l){
				o=p;
				for(i=a;i+2*j<=b;i+=2*j,o+=2*j)await merge(A,i,i+j,i+2*j,o);
				if(i+j<b)await merge(A,i,i+j,b,o);
				else while(i<b)await swap(A,i++,o++,1,true);
				j*=2;o=a;
				for(i=p;i+2*j<=p+l;i+=2*j,o+=2*j)await merge(A,i,i+j,i+2*j,o);
				if(i+j<p+l)await merge(A,i,i+j,p+l,o);
				else while(i<p+l)await swap(A,i++,o++,1,true);
				j*=2;
			}
		}
		async function mergeSortHalf(A,a,b,p){
			let m=a+(b-a)/2|0,m1=a+(m-a)/2|0;
			await mergeSort(A,a,m1,p);
			await mergeSort(A,m1,m,p);
			await mergeSort(A,m,b,p);
			await merge(A,a,m1,m,p);
			let i=p,j=m,k=a;
			while(i<p+m-a&&j<b)
				if(compareIndices(A,i,j)<1)await swap(A,k++,i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<p+m-a)await swap(A,k++,i++,1,true);
		}
		async function medianMergeSort(A,a,b){
			let s=a,e=b,bP=false,md=false;
			while(e-s>16){
				if(bP)await medianOfMedians(A,s,e,md=true);
				else{
					await medianOfThree(A,s,e);
					await swap(A,s,s+(e-s-1)/2,1,true);
				}
				let p=await partition(A,s+1,e,s);
				await swap(A,s,p,1,true);
				let l=p-s,r=e-p-1;
				bP=!md&&((!l||!r)||((l/r|0)>15||(r/l|0)>15));
				if(l<=r)
					if(2*l>=r){
						await mergeSortHalf(A,p+1,e,s);
						e=p;
					}else await mergeSort(A,s,p,s=p+1);
				else
					if(2*r>=l)await mergeSortHalf(A,s,p,s=p+1);
					else{
						await mergeSort(A,p+1,e,s);
						e=p;
					}
			}
			await binaryInsertion(A,s,e,.2);
		}
		await medianMergeSort(arr,0,len);
	}
	async miepurgeSort(len){
		let base=askForNum(16,"Base");
		function tabComp(A,t,a,b){
			return compareIndices(A,t[a],t[b]);
		}
		async function sift(A,r,t){
			while(r<=(t.length/2|0)){
				let l=r*2;
				if(l<t.length&&tabComp(A,t,l-1,l)>0)l++;
				if(tabComp(A,t,r-1,l-1)>0){
					await swap(t,r-1,l-1,0,true,true);
					r=l;
				}else break;
			}
		}
		async function heapifyTable(A,t){
			for(let i=t.length/2|0;i>0;i--)await sift(A,i,t);
		}
		function remove(A,d){
			let nw=new Array(A.length-1);
			for(let i=0,j=0;i<A.length;i++){
				if(i==d)continue;
				write(nw,j++,A[i],0,false,true);
			}
			return nw;
		}
		function heapIndex(A,p,t,d){
			let i=0;
			while(i<p.length&p[i]<=t[d])i++;
			return i;
		}
		async function kWayMerge(A,P){
			let X=new Array(P[P.length-1]-P[0]),T=new Array(P.length-1),k=0;
			arraycopy(P,0,T,0,T.length,0,false,true);
			await heapifyTable(A,T);
			while(T.length>1){
				let n=heapIndex(A,P,T,0),sM=T.length>2?(tabComp(A,T,1,2)>0?2:1):1;
				do if(T[0]<P[n])write(X,k++,A[T[0]++],0,false,true);while(T[0]<P[n]&&tabComp(A,T,0,sM)<1);
				if(T[0]>=P[n]){
					swap(T,0,T.length-1,0,false,true);
					T=remove(T,T.length-1);
				}
				await sift(A,1,T);
			}
			let lK=heapIndex(A,P,T,0);
			while(T[0]<P[lK])write(X,k++,A[T[0]++],0,false,true);
			await arraycopy(X,0,A,P[0],X.length,1,true);
		}
		async function miepurge(A,s,e,b){
			let X=new Array(b+1).fill(0),st=(e-s+1)/b|0;
			if(e-s<b)return await new HeapSorting(true).sort(A,s,e,.1);
			if(!st||e-s==b)return await binaryDoubleInsertion(A,s,e,.2);
			for(let i=0;i<b;i++)X[i]=s+st*i;
			X[b]=e;
			for(let i=0;i<b;i++)
				if(b<24&&st>th)await miepurge(A,X[i],X[i+1],b);
				else await binaryDoubleInsertion(A,X[i],X[i+1],.25);
			await kWayMerge(A,X);
		}
		let th=pow(len,21/28)|0;
		await miepurge(arr,0,len,base);
	}
	async MOMIntroSort(len){
		function floorLogBaseTwo(a){
			return log(a)/log(2)|0;
		}
		function hyperfloor(n){
			return pow(2,floorLogBaseTwo(n));
		}
		async function insertion(A,f,l){
			for(let c=f+1;c-l;++c){
				let s0=c,s1=c-1;
				if(compareIndices(A,s0,s1)<0){
					let t=A[s0];
					do await write(A,s0,A[s1],.25,true);while(--s0-f&&compareValues(t,A[--s1])<0);
					await write(A,s0,t,.1,true);
				}
			}
		}
		async function insSort(A,f,l){
			if(f-l)await insertion(A,f,l);
		}
		async function sift(A,f,z){
			if(z<2)return;
			let r=f+z-1,c1=r-1,c2=f+z/2-1|0;
			while(1){
				let mr=r;
				if(compareIndices(A,mr,c1)<0)mr=c1;
				if(compareIndices(A,mr,c2)<0)mr=c2;
				if(mr==r)return;
				await swap(A,r,mr,.1,true);
				z=z/2|0;
				if(z<2)return;
				r=mr;c1=r-1;c2=mr-z+z/2|0;
			}
		}
		async function popHeap(A,f,l,z){
			let pz=hyperfloor(z+1)-1,l_r=l-1,bg=l_r,bgz=pz,it=f;
			while(1){
				let r=it+pz-1;
				if(r==l_r)break;
				if(compareIndices(A,bg,r)<0){
					bg=r;bgz=pz;
				}
				it=r+1;
				z-=pz;
				pz=hyperfloor(z+1)-1;
			}
			if(bg-l_r){
				await swap(A,bg,l_r,.1,true);
				await sift(A,bg-bgz+1,bgz);
			}
		}
		async function heapify(A,f,l){
			let z=l-f;
			if(z<2)return;
			let smP=15;
			if(z<16)return await insertion(A,f,l);
			let pl=1,it=f,nx=it+smP;
			while(1){
				await insertion(A,it,nx);
				let pz=smP;
				for(let i=(pl&(-pl))>>1;i;i>>=1){
					it-=pz;
					pz=2*pz+1;
					await sift(A,it,pz);
					++nx;
				}
				if(l-nx<=smP)return await insSort(A,nx,l);
				it=nx;
				nx+=smP;
				++pl;
			}
		}
		async function sort(A,f,l){
			let z=l-f;
			if(z<2)return;
			do await popHeap(A,f,l--,z--);while(z>1);
		}
		async function medianof3(A,l,m,r){
			if(compareIndices(A,r,l)<0)await swap(A,l,r,1,true);
			if(compareIndices(A,m,l)<0)await swap(A,m,l,1,true);
			if(compareIndices(A,r,m)<0)await swap(A,r,m,1,true);
			return A[m];
		}
		async function medianOfMedians(A,a,b,c){
			let e=b,s=a,i,j,d=true;
			while(e-s>1){
				j=s;
				for(i=s;i+2*c<=e;i+=c){
					await insertSort(A,i,i+c,.2);
					await swap(A,j++,i+c/2,1,true);
				}
				if(i<e){
					await insertSort(A,i,e,.2);
					await swap(A,j++,i+(e-(d?1:0)-i)/2,1,true);
					if((e-i)%2<1)d=!a;
				}
				e=j;
			}
			return A[a];
		}
		async function partition(a,lo,hi,x){
			let i=lo,j=hi;
			while(1){
				while(compareValues(a[i],x)<0)i++;
				do j--;while(compareValues(x,a[j])<0);
				if(i>=j)return i;
				await swap(a,i++,j,1,true);
			}
		}
		async function introsortLoop(a,lo,hi,d){
			while(hi-lo>16){
				if(!d){
					await heapify(a,lo,hi);
					await sort(a,lo,hi);
					return;
				}
				let pv=await medianof3(a,lo,lo+(hi-lo)/2|0,hi-1);
				let p=await partition(a,lo,hi,pv);
				let l=p-lo,r=hi-p;
				if((!l||!r)||((l/r|0)>15||(r/l|0)>15)){
					pv=await medianOfMedians(a,lo,hi,5);
					p=await partition(a,lo,hi,pv);
				}
				await introsortLoop(a,lo,lo=p,--d);
			}
		}
		await introsortLoop(arr,0,len,2*floorLogBaseTwo(len));
		await insertSort(arr,0,len,.5);
	}
	async advancedLogMergeSort(len){
		let base=askForNum(1,"Block size");
		class BitArray{
			constructor(A,a,b,z,w){
				this.A=A;this.a=a;this.b=b;this.z=z;this.w=w;
			}
			async flipBit(a,b){
				await swap(this.A,a,b,.5,true);
			}
			getBit(a,b){
				return compareIndices(this.A,a,b)>0;
			}
			async setXor(d,v){
				if(d<0||d>=this.z)return;
				let s=d*this.w,i1=this.a+s+this.w;
				for(let i=this.a+s,j=this.b+s;i<i1;i++,j++,v>>=1)if(v&1)await this.flipBit(i,j);
			}
			get(d){
				if(d<0||d>=this.z)return;
				let r=0,s=d*this.w;
				for(let k=0,i=this.a+s,j=this.b+s;k<this.w;k++,i++,j++)r|=(this.getBit(i,j)?1:0)<<k;
				return r;
			}
		}
		function log2(n){
			return 31-clz32(n);
		}
		function calcBLen(n){
			let h=n/2|0,r=minVal(64,h/2|0),c=h/r|0;
			while(c*(log2(c-1)+1)+c<=(h/2|0))c=h/--r|0;
			return r+1;
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+b>>>1;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+b>>>1;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function pivCmp(v,p,c){
			return compareValues(v,p)<c;
		}
		async function pivBufXor(A,a,b,v,w){
			for(;w-->0;v>>=1)if(v&1)await swap(A,a+w,b+w,1,true);
		}
		function pivBufGet(A,a,p,c,w,b){
			let r=0;
			while(w-->0){
				r<<=1;
				r|=(pivCmp(A[a++],p,c)?0:1)^b;
			}
			return r;
		}
		async function blockCycle(A,p,n,p1,bL,wL,pv,pC,b){
			for(let i=0;i<n;i++){
				let d=pivBufGet(A,p+i*bL,pv,pC,wL,b);
				while(d-i){
					await blockSwap(A,p+i*bL,p+d*bL,bL);
					d=pivBufGet(A,p+i*bL,pv,pC,wL,b);
				}
				await pivBufXor(A,p+i*bL,p1+i*bL,i,wL);
			}
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.cycleReverse(A,a,m,b,1,true);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function blockMergeHelper(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(m-a<=bL)return await mergeFWExt(A,sw,a,m,b);
			arraycopy(A,m-bL,sw,0,bL,0,false,true);
			let bC=0,wL=log2((b-a)/bL-2|0)+1,i=a,j=m,k=0,pc=p;
			while(i<m-bL&&j+bL-1<b){
				if(compareIndices(A,i+bL-1,j+bL-1)<1){
					await pivBufXor(A,i,pc,k++,wL);
					i+=bL;
				}else{
					await pivBufXor(A,j,pc,(k++<<1)|1,wL+1);
					j+=bL;
				}
				pc+=bL;bC++;
			}
			while(i<m-bL){
				await pivBufXor(A,i,pc,k++,wL);
				i+=bL;pc+=bL;bC++;
			}
			await arraycopy(A,a,A,m-bL,bL,1,true);
			let a1=a+bL;
			await blockCycle(A,a1,bC,p,bL,wL,pv,pC,bt);
			let f=a1,l=pivCmp(A[a1+wL],pv,pC)^(bt!=0);
			if(!l)await swap(A,a1+wL,p+wL,1,true);
			for(k=1,j=a;k<bC;k++){
				let n=a1+k*bL,fr=pivCmp(A[n+wL],pv,pC)^(bt!=0);
				if(!fr)await swap(A,n+wL,p+n+wL-a1,1,true);
				if(l^fr){
					i=f;f=n;
					while(i<n){
						let c=compareIndices(A,i,f);
						if(c<0||l&&!c)await write(A,j++,A[i++],1,true);
						else await write(A,j++,A[f++],1,true);
					}
					l=!l;
				}
			}
			if(l){
				k=a1+bC*bL;i=f;f=k;
				while(i<k&&f<b)
					if(compareIndices(A,i,f)<1)await write(A,j++,A[i++],1,true);
					else await write(A,j++,A[f++],1,true);
				if(f==b){
					while(i<k)await write(A,j++,A[i++],1,true);
					return await arraycopy(sw,0,A,b-bL,bL,1,true);
				}
			}
			for(i=0;i<bL&&f<b;)
				if(compareValues(sw[i],A[f])<1)await write(A,j++,sw[i++],1,true);
				else await write(A,j++,A[f++],1,true);
			while(i<bL)await write(A,j++,sw[i++],1,true);
		}
		async function blockMergeEasy(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(b-m<=bL)return await mergeBWExt(A,sw,a,m,b);
			if(m-a<=bL)return await mergeFWExt(A,sw,a,m,b);
			let a1=a+(m-a)%bL;
			await blockMergeHelper(A,sw,a1,m,b,p,bL,pv,pC,bt);
			await mergeFWExt(A,sw,a,a1,b);
		}
		async function blockMerge(A,sw,a,m,b,bL){
			let l=m-a,r=b-m,lC=(l+r+1)/2|0,md;
			if(r<l){
				if(r<=bL){
					await mergeBWExt(A,sw,a,m,b);
					return false;
				}
				let la=0,lb=r;
				while(la<lb){
					let lm=la+lb>>>1;
					if(compareIndices(A,m+lm,a+lC-lm-1)<1)la=lm+1;
					else lb=lm;
				}
				md=!la?A[a+lC-1]:compareIndices(A,m+la-1,a+lC-la-1)>0?A[m+la-1]:A[a+lC-la-1];
			}else{
				if(l<=bL){
					await mergeFWExt(A,sw,a,m,b);
					return false;
				}
				let la=0,lb=l;
				while(la<lb){
					let lm=la+lb>>>1;
					if(compareIndices(A,a+lm,m+lC-lm-1)<0)la=lm+1;
					else lb=lm;
				}
				md=l==r&&la==l?A[m-1]:!la?A[m+lC-1]:compareIndices(A,a+la-1,m+lC-la-1)+1?A[a+la-1]:A[m+lC-la-1];
			}
			let m1=leftBinSearch(A,a,m,md),m2=rightBinSearch(A,m,b,md),ms2=m-rightBinSearch(A,m1,m,md),ms1=leftBinSearch(A,m,m2,md)-m;
			await rotate(A,m-ms2,m,m2);
			await rotate(A,m1,m-ms2,m+ms1-ms2);
			await blockMergeEasy(A,sw,a,m1,m1+ms1,a+lC,bL,md,0,0);
			await blockMergeEasy(A,sw,m2-ms2,m2,b,a,bL,md,1,1);
			return m2-m1-ms2-ms1<=lC;
		}
		async function blockMergeWithBufHelper(A,sw,a,m,b,pa,pb,bL){
			if(m-a<=bL)return await mergeFWExt(A,sw,a,m,b);
			arraycopy(A,m-bL,sw,0,bL,0,false,true);
			let bC=0,mC=(b-a)/bL-1|0,wL=log2(mC)+1,P=new BitArray(A,pa,pb,mC,wL),B=new BitArray(A,pb-mC,pb+pb-pa-mC,mC,1),a1=a+bL,i=a,j=m,k;
			while(i<m-bL&&j+bL-1<b){
				let pV;
				if(compareIndices(A,i+bL-1,j+bL-1)<1){
					pV=(i==a?(m-a1)/bL-1:(i-a1)/bL)|0;
					await B.setXor(bC,1);
					i+=bL;
				}else{
					pV=(j-a1)/bL|0;j+=bL;
				}
				if(bC++-pV)await P.setXor(bC-1,pV+1);
			}
			while(i<m-bL){
				let pV=(i==a?(m-a1)/bL-1:(i-a1)/bL)|0;
				if(bC-pV)await P.setXor(bC,pV+1);
				await B.setXor(bC,1);
				i+=bL;bC++;
			}
			await arraycopy(A,a,A,m-bL,bL,1,true);
			for(i=0;i<bC;i++){
				k=P.get(i);
				if(k>0){
					await arraycopy(A,a1+i*bL,A,a,bL,1,true);
					j=i;
					do{
						await arraycopy(A,a1+(k-1)*bL,A,a1+j*bL,bL,1,true);
						await P.setXor(j,k);
						j=k-1;k=P.get(j);
					}while(k-i-1);
					await arraycopy(A,a,A,a1+j*bL,bL,1,true);
					await P.setXor(j,k);
				}
			}
			let f=a1,l=B.get(0)!=0;
			if(l)await B.setXor(0,1);
			for(k=1,j=a;k<bC;k++){
				let n=a1+k*bL,fr=B.get(k)!=0;
				if(fr)await B.setXor(k,1);
				if(l^fr){
					i=f;f=n;
					while(i<n){
						let c=compareIndices(A,i,f);
						if(c<0||l&&!c)await write(A,j++,A[i++],1,true);
						else await write(A,j++,A[f++],1,true);
					}
					l=!l;
				}
			}
			if(l){
				k=a1+bC*bL;i=f;f=k;
				while(i<k&&f<b)
					if(compareIndices(A,i,f)<1)await write(A,j++,A[i++],1,true);
					else await write(A,j++,A[f++],1,true);
				if(f==b){
					while(i<k)await write(A,j++,A[i++],1,true);
					await arraycopy(sw,0,A,b-bL,bL,1,true);
					return;
				}
			}
			for(i=0;i<bL&&f<b;)
				if(compareValues(sw[i],A[f])<1)await write(A,j++,sw[i++],1,true);
				else await write(A,j++,A[f++],1,true);
			while(i<bL)await write(A,j++,sw[i++],1,true);
		}
		async function blockMergeWithBuf(A,sw,a,m,b,pa,pb,bL){
			if(b-m<=bL)return await mergeBWExt(A,sw,a,m,b);
			if(m-a<=bL)return await mergeFWExt(A,sw,a,m,b);
			let a1=a+(m-a)%bL;
			await blockMergeWithBufHelper(A,sw,a1,m,b,pa,pb,bL);
			await mergeFWExt(A,sw,a,a1,b);
		}
		async function pureLogMergeSort(A,sw,a,b,bL){
			let j;
			for(j=b-a;((j+1)/2|0)>15;j=++j/2|0);
			for(let i=a;i<b;i+=j)await binaryInsertion(A,i,minVal(b,i+j),.2);
			for(let k;j<b-a;j*=2){
				for(k=a;k+j<b&&!await blockMerge(A,sw,k,k+j,minVal(b,k+2*j),bL);k+=2*j);
				for(let i=k+2*j;i+j<b;i+=2*j)await blockMergeWithBuf(A,sw,i,i+j,minVal(b,i+2*j),k,k+j,bL);
			}
		}
		async function sort(A,l){
			if(l<17)return await binaryInsertion(A,0,l,.2);
			let bL=maxVal(calcBLen(l),minVal(base,l));
			await pureLogMergeSort(A,new Array(bL),0,l,bL);
		}
		await sort(arr,len);
	}
	async logMergeSort(len){
		let base=askForNum(1,"Block size",1);
		function log2(n){
			return 31-clz32(n);
		}
		function productLog(n){
			let r=1;
			while(r*(1<<r)+r-1<n)r++;
			return r;
		}
		function medianOf3(A,i){
			if(!i.length)return-1;
			let[a,b,c]=i;
			if(i.length<3)return a;
			if(compareIndices(A,a,b)<1){
				if(compareIndices(A,b,c)<1)return b;
				if(compareIndices(A,a,c)<0)return c;
				return a;
			}
			if(compareIndices(A,b,c)+1)return b;
			if(compareIndices(A,a,c)<1)return a;
			return c;
		}
		function medianOf9(A,s,e){
			let l=e-s,h=l/2|0,q=h/2|0,g=q/2|0;
			return medianOf3(A,[medianOf3(A,[s,s+g,s+q]),medianOf3(A,[s+q+g,s+h,s+h+g]),medianOf3(A,[s+h+q,s+h+q+g,e-1])]);
		}
		function mOMHelper(A,s,l){
			if(l==1)return s;
			let t=l/3|0;
			return medianOf3(A,[mOMHelper(A,s,t),mOMHelper(A,s+t,t),mOMHelper(A,s+2*t,t)]);
		}
		function medianOfMedians(A,s,l){
			if(l==1)return s;
			let nP=pow(3,round(log(l)/log(3)));
			if(nP==l)return mOMHelper(A,s,l);
			nP/=3;if(2*nP>=l)nP=nP/3|0;
			return medianOf3(A,[mOMHelper(A,s,nP),mOMHelper(A,s+l-nP,nP),medianOfMedians(A,s+nP,l-2*nP)]);
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function pivCmp(v,p,c){
			return compareValues(v,p)<c;
		}
		async function pivBufSet(A,a,b,v,w){
			for(;w-->0;v>>=1)if(v&1)await swap(A,a+w,b+w,1,true);
		}
		function pivBufGet(A,a,p,c,w,b){
			let r=0;
			while(w-->0){
				r<<=1;r|=(pivCmp(A[a++],p,c)?b:b^1);
			}
			return r;
		}
		async function partitionEasy(A,X,a,b,p,pC){
			let j=0;
			for(let i=a;i<b;i++)
				if(pivCmp(A[i],p,pC))await write(A,a++,A[i],.2,true);
				else write(X,j++,A[i],0,false,true);
			await arraycopy(X,0,A,a,j,.5,true);
			return a;
		}
		async function blockCycle(A,p,n,p1,bL,wL,pv,pC,b){
			for(let i=0;i<n;i++){
				let d=pivBufGet(A,p+i*bL,pv,pC,wL,b);
				while(d-i){
					await blockSwap(A,p+i*bL,p+d*bL,bL);
					d=pivBufGet(A,p+i*bL,pv,pC,wL,b);
				}
				await pivBufSet(A,p+i*bL,p1+i*bL,i,wL);
			}
		}
		async function blockPartition(A,sw,a,b,bL,pv,pC){
			for(;a<b;a++)if(!pivCmp(A[a],pv,pC))break;
			for(;b>a;b--)if(pivCmp(A[b-1],pv,pC))break;
			if(b-a<=2*bL)return await partitionEasy(A,sw,a,b,pv,pC);
			let p=a,l=0,r=0,lb=0,rb=0;
			for(let i=a;i<b;i++)
				if(pivCmp(A[i],pv,pC)){
					write(sw,l++,A[i],0,false,true);
					if(l==bL){
						await arraycopy(sw,0,A,p,bL,.5,true);
						l=0;lb++;p+=bL;
					}
				}else{
					write(sw,bL+r++,A[i],0,false,true);
					if(r==bL){
						await arraycopy(sw,bL,A,p,bL,.5,true);
						r=0;rb++;p+=bL;
					}
				}
			let mn=minVal(lb,rb),m=a+lb*bL;
			if(mn>0){
				let bC=lb+rb,wL=log2(mn-1)+1;
				for(let i=0,j=0,k=0;i<mn;i++){
					while(!pivCmp(A[a+j*bL+wL],pv,pC))j++;
					while(pivCmp(A[a+k*bL+wL],pv,pC))k++;
					await pivBufSet(A,a+j++*bL,a+k++*bL,i,wL);
				}
				if(lb<rb){
					for(let i=bC-1,j=0;j<rb;i--)if(!pivCmp(A[a+i*bL+wL],pv,pC))await blockSwap(A,a+i*bL,a+(bC-++j)*bL,bL);
					await blockCycle(A,a,lb,m,bL,wL,pv,pC,0);
				}else{
					for(let i=0,j=0;j<lb;i++)if(pivCmp(A[a+i*bL+wL],pv,pC))await blockSwap(A,a+i*bL,a+(j++)*bL,bL);
					await blockCycle(A,m,rb,a,bL,wL,pv,pC,1);
				}
			}
			await arraycopy(sw,bL,A,b-r,r,1,true);
			if(l>0){
				await arraycopy(A,a+lb*bL,A,a+lb*bL+l,rb*bL,1,true);
				await arraycopy(sw,0,A,a+lb*bL,l,1,true);
			}
			return a+lb*bL+l;
		}
		async function selectMedian(A,X,a,b,bL){
			let md=(a+b)/2|0,bP=false;
			while(b-a>32){
				let p;
				if(bP){
					let n=b-a;n-=~n&1;
					p=medianOfMedians(A,a,n);
					bP=false;
				}else p=medianOf9(A,a,b);
				let m=await blockPartition(A,X,a,b,bL,A[p],0);
				if(m==a){
					m=await blockPartition(A,X,a,b,bL,A[p],1);
					if(md>=a&&md<m)return;
				}
				let l=m-a,r=b-m;
				bP=8*l<r||8*r<l;
				if(m<=md)a=m;else b=m;
			}
			await binaryInsertion(A,a,b,.2);
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function mergeTo(f,t,a,m,b,p,x){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(f,i,j)<1)await write(t,p++,f[i++],1,true,x);
				else await write(t,p++,f[j++],1,true,x);
			while(i<m)await write(t,p++,f[i++],1,true,x);
			while(j<b)await write(t,p++,f[j++],1,true,x);
		}
		async function smartMerge(A,B,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=rightBinSearch(A,a,m,A[m]);
			b=leftBinSearch(A,m,b,A[m-1]);
			if(m-a<=b-m)await mergeFWExt(A,B,a,m,b);
			else await mergeBWExt(A,B,a,m,b);
		}
		async function pingPongMerge(A,B,a,m1,m2,m3,b){
			let p=0,p1=p+m2-a,pE=p+b-a;
			if(compareIndices(A,m1-1,m1)>0||compareIndices(A,m3-1,m3)>0){
				await mergeTo(A,B,a,m1,m2,p,true);
				await mergeTo(A,B,m2,m3,b,p1,true);
				await mergeTo(B,A,p,p1,pE,a,false);
			}else await smartMerge(A,B,a,m2,b);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true,false);
		}
		async function blockMerge(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(compareIndices(A,m-1,m)<1)return;
			b=leftBinSearch(A,m,b,A[m-1]);
			if(b-m<=2*bL)return await mergeBWExt(A,sw,a,m,b);
			let a1=rightBinSearch(A,a,m,A[m]);
			if(m-a1<=2*bL)return await mergeFWExt(A,sw,a1,m,b);
			a=a1-(a1-a)%bL;
			let bC=(b-a)/bL-2|0,wL=log2(bC-1)+1,i=a,j=m,k=0,l=0,r=0,c=0;
			while(c++<2*bL)
				if(compareIndices(A,i,j)<1){
					write(sw,k++,A[i++],0,false,true);
					l++;
				}else{
					write(sw,k++,A[j++],0,false,true);
					r++;
				}
			let t=0,pc=p,lf=l>=r;k=lf?i-l:j-r;c=0;
			do{
				if(j==b||compareIndices(A,i,j)<1){
					await write(A,k++,A[i++],1,true);
					l++;
				}else{
					await write(A,k++,A[j++],1,true);
					r++;
				}
				if(++c==bL){
					await pivBufSet(A,k-bL,pc,t++,wL);
					pc+=bL;
					if(lf)l-=bL;else r-=bL;
					lf=l>=r;k=lf?i-l:j-r;c=0;
				}
			}while(i<m);
			let b1=b-c;
			await arraycopy(A,k-c,A,b1,c,1,true);
			r-=c;l=minVal(l,m-a-l);
			await arraycopy(A,a,A,m-l,l,1,true);
			await arraycopy(A,a+l,A,b1-r,r,1,true);
			await arraycopy(sw,0,A,a,2*bL,1,true);
			await blockCycle(A,a+2*bL,bC,p,bL,wL,pv,pC,bt);
		}
		async function logMerge(A,X,a,b,p,bL,pv,pC,bt){
			let j=16;
			for(let i=a;i<b;i+=j)await binaryInsertion(A,i,minVal(i+j,b),.2);
			for(let i;2*j<=bL;j*=4){
				for(i=a;i+2*j<b;i+=4*j)await pingPongMerge(A,X,i,i+j,i+2*j,minVal(i+3*j,b),minVal(i+4*j,b));
				if(i+j<b)await smartMerge(A,X,i,i+j,b);
			}
			for(;j<=2*bL;j*=2)for(let i=a;i+j<b;i+=2*j)await smartMerge(A,X,i,i+j,minVal(i+2*j,b));
			for(;j<b-a;j*=2)for(let i=a;i+j<b;i+=2*j)await blockMerge(A,X,i,i+j,minVal(i+2*j,b),p,bL,pv,pC,bt);
		}
		async function sort(A,l){
			let bL=maxVal(productLog(l),minVal(base,l/2|0));
			bL=1<<(log2(bL-1)+1);
			let X=new Array(2*bL),a=0,b=l,m1=a+l/2|0,m2=m1+(l&1);
			await selectMedian(A,X,a,b,bL);
			if(!compareIndices(A,a,b-1))return;
			let p=A[m1];
			for(;!compareIndices(A,m1-1,m2);m1--);
			let pC=!compareIndexValue(A,m1-1,p)?1:0;
			await logMerge(A,X,a,m1,m2,bL,p,pC,0);
			await logMerge(A,X,m2,b,a,bL,p,pC,1);
		}
		await sort(arr,len);
	}
	async logKitaSortImplicit(len){
		function log(v){
			return 32-clz32(v-1);
		}
		function productLog(n){
			let r=1,q=0;
			while((r<<r)+r-1<n)r++;
			while(1<<q<r)q++;
			return[r,1<<q];
		}
		async function multiSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		function medOf3(A,a,b,c){
			let d;
			if(compareIndices(A,a,b)>0){
				d=b;b=a;
			}else d=a;
			if(compareIndices(A,b,c)>0){
				if(compareIndices(A,d,c)>0)return d;
				return c;
			}
			return b;
		}
		function ninther(A,a,b){
			if(b-a<10)return A[a+(b-a)/2|0];
			let l=b-a,h=l/2|0,q=l/4|0,g=l/8|0;
			return medOf3(A,medOf3(A,a,a+g,a+q),medOf3(A,a+q+g,a+h,a+h+g),medOf3(A,b-q,b-g,b-1));
		}
		function pseudomo27(A,a,b){
				if(b-a<64)	return ninther(A,a,b);
				else{
					let d=(b-a+1)/8|0;
					return medOf3(A,ninther(A,a,a+2*d),ninther(A,a+3*d,a+5*d),ninther(A,a+6*d,b));
				}
		}
		function pseudomo81(A,a,b){
				if(b-a<256)return pseudomo27(A,a,b);
				else{
					let d=(b-a+1)/24|0;
					return medOf3(A,medOf3(A,ninther(A,a,a+2*d),ninther(A,a+3*d,a+5*d),ninther(A,a+6*d,a+8*d)),medOf3(A,ninther(A,a+9*d,a+11*d),ninther(A,a+12*d,a+14*d),ninther(A,a+15*d,a+17*d)),medOf3(A,ninther(A,a+18*d,a+20*d),ninther(A,a+19*d,a+21*d),ninther(A,a+22*d,b)));
				}
		}
		function pseudomo243(A,a,b){
				if(b-a<16384)return pseudomo81(A,a,b);
				else{
					let d=(b-a+1)/24|0;
					return medOf3(A,medOf3(A,pseudomo27(A,a,a+2*d),pseudomo27(A,a+3*d,a+5*d),pseudomo27(A,a+6*d,a+8*d)),medOf3(A,pseudomo27(A,a+9*d,a+11*d),pseudomo27(A,a+12*d,a+14*d),pseudomo27(A,a+15*d,a+17*d)),medOf3(A,pseudomo27(A,a+18*d,a+20*d),pseudomo27(A,a+19*d,a+21*d),pseudomo27(A,a+22*d,b)));
				}
		}
		function gaprank(A,a,b,g,r){
			let re=0;
			while(a<b){
				if(a-r)if(compareIndices(A,a,r)<0)re++;
				a+=g;
			}
			return re;
		}
		function rankof243s(A,a,b){
			let s=1;
			while(s*s<b-a)s*=2;
			if((s=s/2|0)<2)return ninther(A,a,b);
			let m=(b-a-1)/(2*s)+1|0,e=(b-a)/8|0,cm=a+(b-a)/2|0,cr=0;
			for(let i=0;i<e;i+=s){
				let p=pseudomo243(A,a+i,b-e+i),r=gaprank(A,a,b,s,p);
				if(abs(cr-m)>abs(r-m)){
					cm=p;
					cr=r;
				}
			}
			return cm;
		}
		async function encode(A,a,b,v){
			while(v>0){
				if(v%2)await swap(A,a,b,1,true);
				v=v/2|0;a++;b++;
			}
		}
		async function recode(A,a,x,w,fr,f,to,t){
			let F=x+fr*w,T=x+to*w,tm,i=0;
			while(minVal(f,t)>0){
				if((f&t)%2){
					tm=A[F+i];
					await write(A,F+i,A[a+i],.3,true);
					await write(A,a+i,A[T+i],.3,true);
					await write(A,T+i,tm,.3,true);
				}else if(f%2)await swap(A,a+i,F+i,1,true);
				else if(t%2)await swap(A,a+i,T+i,1,true);
				f=f/2|0;t=t/2|0;i++;
			}
			while(f>0){
				if(f%2)await swap(A,a+i,F+i,1,true);
				f=f/2|0;i++;
			}
			while(t>0){
				if(t%2)await swap(A,a+i,T+i,1,true);
				t=t/2|0;i++;
			}
		}
		function get(A,a,p,l,c,b){
			let v=0,i=0;
			while(l-->0){
				v|=(compareIndexValue(A,a+i,p)<c^b?1<<i:0);
				i++;
			}
			return v;
		}
		async function getAndFree(A,a,x,p,l,w,c,b){
			let v=get(A,a,p,w,c,b);
			await encode(A,a,x+v*l,v);
			return v;
		}
		async function partitionEasy(A,t,a,b,p,c){
			let j=0;
			for(let i=a;i<b;i++)
				if(compareIndexValue(A,i,p)<c)await write(A,a++,A[i],.2,true);
				else write(t,j++,A[i],0,false,true);
			await arraycopy(t,0,A,a,j,.5,true);
			return a;
		}
		async function blockcycle(A,a,m,b,l,w,p,c,i){
			for(let k=0;k<b-1;k++){
				let z=get(A,a+k*l,p,w,c,i);
				while(z-k){
					await multiSwap(A,a+k*l,a+z*l,l);
					z=get(A,a+k*l,p,w,c,i);
				}
				await encode(A,a+k*l,m+k*l,k);
			}
			await encode(A,a+(b-1)*l,m+(b-1)*l,b-1);
		}
		async function partition(A,T,a,b,p,c){
			let B=T.length+1;
			if(b-a<B)return await partitionEasy(A,T,a,b,p,c);
			let l=0,r=0,t=a,lb=0,rb=0;
			for(let i=a;i<b;i++){
				if(compareIndexValue(A,i,p)<c){
					await write(A,t+l++,A[i],.25,true);
					if(l==B){
						l=0;t+=B;lb++;
					}
				}else if(r==B-1){
					let t2=A[i];
					await arraycopy(A,t,A,t+B,l,.25,true);
					await arraycopy(T,0,A,t,r,.25,true);
					await write(A,t+r,t2,.25,true);
					t+=B;r=0;rb++;
				}else write(T,r++,A[i],0,false,true);
			}
			let m=minVal(lb,rb);
			if(m>0){
				let M=log(m);
				for(let i=0,j=0,k=0;i<m;i++){
					while(compareIndexValue(A,a+j*B+M,p)>=c)j++;
					while(compareIndexValue(A,a+k*B+M,p)<c)k++;
					await encode(A,a+j++*B,a+k++*B,i);
				}
				if(lb<rb){
					for(let i=lb+rb-1,j=0;i>=0;i--)
						if(compareIndexValue(A,a+i*B+M,p)>=c)await multiSwap(A,a+i*B,a+(i+j)*B,B);
						else j++;
					await blockcycle(A,a,a+lb*B,lb,B,M,p,c,lb<rb);
				}else{
					for(let i=0,j=0;i<lb+rb;i++)if(compareIndexValue(A,a+i*B+M,p)<c)await multiSwap(A,a+i*B,a+j++*B,B);
					await blockcycle(A,a+lb*B,a,rb,B,M,p,c,lb<rb);
				}
			}
			await arraycopy(T,0,A,b-r,r,1,true);
			if(l>0){
				arraycopy(A,t,T,0,l,0,false,true);
				await arraycopy(A,a+lb*B,A,a+lb*B+l,rb*B,.5,true);
				await arraycopy(T,0,A,a+lb*B,l,.5,true);
			}
			return a+l+lb*B;
		}
		async function quickselect(A,T,a,b,r){
			let bd=false;
			while(b-a>20){
				let m=A[bd?rankof243s(A,a,b):pseudomo243(A,a,b)],p=await partition(A,T,a,b,m,0);
				if(p==a)p=await partition(A,T,a,b,m,1);
				if(p==b)return[a,b];
				bd=6*(p-a)<b-a||6*(b-p)<b-a;
				if(p<=r)a=p;else b=p;
			}
			await binaryInsertion(A,a,b,.5);
			let m1=r,m2=r;
			do m1--;while(!compareIndices(A,m1,r));m1++;
			do m2++;while(!compareIndices(A,m2,r));
			return[m1,m2];
		}
		async function merge(A,T,a,m,b,t,X){
			let l=a,r=m;
			while(l<m&&r<b)
				if(compareIndices(A,l,r)<1)await write(T,t++,A[l++],.5,true,X);
				else await write(T,t++,A[r++],.5,true,X);
			while(l<m)await write(T,t++,A[l++],.5,true,X);
			while(r<b)await write(T,t++,A[r++],.5,true,X);
		}
		async function tailmerge(A,T,a,m,b){
			arraycopy(A,m,T,0,b-m,0,false,true);
			let l=m-1,r=b-m-1;
			while(l>=a&&r>=0)
				if(compareIndexValue(A,l,T[r])>0)await write(A,--b,A[l--],.5,true);
				else await write(A,--b,T[r--],.5,true);
			while(r>=0)await write(A,--b,T[r--],.5,true);
		}
		async function indexll(A,a,b,x,w,w1,p,c,y){
			for(let i=a,j=0;j<((b-a)/w|0);j++){
				let k=get(A,i,p,w1,c,y);
				await recode(A,i,x,w,k,k,(i-a)/w|0,j);
				i=a+k*w;
			}
			let i=a+w,i1=1;
			for(;i<b-w;i+=w,i1++){
				let j=get(A,i,p,w1,c,y);
				if(!j)continue;
				let m=i-a;
				while(j-i1){
					let k=get(A,a+j*w,p,w1,c,y);
					await encode(A,i,x+m,j);
					await multiSwap(A,i,a+(m=j*w),w);
					j=k;
				}
				await encode(A,i,x+m,i1);
			}
			for(let j=i,k=w1;k-->0;j++)
				if(compareIndexValue(A,j,p)<0^y){
					await encode(A,i,x+i-a,i1);
					break;
				}
		}
		async function kitamerge(A,tmp,x,i,ib,j,jb,p,c,w,w1,y){
			let lt=new Array(3).fill(0),rt=[ib,0,0];
			let l=i,ln=await getAndFree(A,l,x,p,w,w1,c,y),ltc=1,lc=0,ld=0,r=j,mb=ib,rn=await getAndFree(A,r,x+j-i,p,w,w1,c,y),rtc=1,rc=0,rd=0,cc=0,bb,bt=0,ls=-1,fbt=-1,tc=0,ft=-1,sb;
			for(;cc<2*w;cc++){
				if(!jb||(ib>0&&compareIndices(A,l,r)<1)){
					write(tmp,cc,A[l++],0,false,true);lc++;
					if(++ld==w){
						if(!--ib)continue;
						ld=0;lt[ltc++]=ln;l=i+ln*w;ln=await getAndFree(A,l,x,p,w,w1,c,y);
					}
				}else{
					write(tmp,cc,A[r++],0,false,true);rc++;
					if(++rd==w){
						if(!--jb)continue;
						rd=0;rt[rtc++]=rn+mb;r=j+rn*w;rn=await getAndFree(A,r,x+j-i,p,w,w1,c,y);
					}
				}
			}
			do{
				while(lc>=rc&&(ib>0||jb>0)){
					bt=lt[0];lt[0]=lt[1];lt[1]=lt[2];ltc--;bb=i+bt*w;
					for(cc=0;cc<w;cc++)
						if(!jb||(ib>0&&compareIndices(A,l,r)<1)){
							await write(A,bb+cc,A[l++],.5,true);lc++;
							if(++ld==w){
								if(!--ib)continue;
								ld=0;lt[ltc++]=ln;l=i+ln*w;ln=await getAndFree(A,l,x,p,w,w1,c,y);
							}
						}else{
							write(A,bb+cc,A[r++],0,false,true);rc++;
							if(++rd==w){
								if(!--jb)continue;
								rd=0;rt[rtc++]=rn+mb;r=j+rn*w;rn=await getAndFree(A,r,x+j-i,p,w,w1,c,y);
							}
						}
					lc-=w;
					if(tc++>0)
						if(!bt)ft=ls;
						else await encode(A,ls,x+bt*w,bt);
					else fbt=bt;
					ls=bb;
				}
				while(lc<=rc&&(ib>0||jb>0)){
					bt=rt[0];rt[0]=rt[1];rt[1]=rt[2];rtc--;bb=i+bt*w;
					for(cc=0;cc<w;cc++){
						if(!jb||(ib>0&&compareIndices(A,l,r)<1)){
							await write(A,bb+cc,A[l++],.5,true);lc++;
							if(++ld==w){
								if(!--ib)continue;
								ld=0;lt[ltc++]=ln;l=i+ln*w;ln=await getAndFree(A,l,x,p,w,w1,c,y);
							}
						}else{
							await write(A,bb+cc,A[r++],.5,true);rc++;
							if(++rd==w){
								if(!--jb)continue;
								rd=0;rt[rtc++]=rn+mb;r=j+rn*w;rn=await getAndFree(A,r,x+j-i,p,w,w1,c,y);
							}
						}
					}
					rc-=w;
					if(tc++>0)await encode(A,ls,x+bt*w,bt);
					else fbt=bt;
					ls=bb;
				}
			}while(ib>0||jb>0);
			if(ltc>0){
				if(!fbt)fbt=lt[0];
				if(ft>=0)await encode(A,ft,x+lt[0]*w,lt[0]);
				await arraycopy(A,i,A,i+lt[0]*w,w,1,true);
				sb=rtc>0?rt[0]:lt[1];
			}else{
				if(!fbt)fbt=rt[0];
				if(ft>=0)await encode(A,ft,x+rt[0]*w,rt[0]);
				await arraycopy(A,i,A,i+rt[0]*w,w,1,true);
				sb=rt[1];
			}
			await arraycopy(tmp,0,A,i,w,.5,true);
			await arraycopy(tmp,w,A,i+sb*w,w,.5,true);
			await encode(A,i,x+sb*w,sb);
			await encode(A,i+sb*w,x+fbt*w,fbt);
		}
		async function kita(A,T,a,b,x,w,p,c,iv){
			let B=b,s=T.length/2|0;
			b-=(b-a)%s;
			for(let i=a;i<b;i+=16)await binaryInsertion(A,i,minVal(i+16,b),.5);
			let j=16;
			for(;j<=(T.length/4|0);j*=4){
				for(let i=a;i+j<b;i+=4*j){
					await merge(A,T,i,i+j,minVal(i+2*j,b),0,true);
					await merge(A,T,minVal(i+2*j,b),minVal(i+3*j,b),minVal(i+4*j,b),2*j,true);
					await merge(T,A,0,minVal(2*j,b-i),minVal(4*j,b-i),i,false);
				}
			}
			for(;j<=T.length;j*=2)for(let i=a;i+j<b;i+=2*j)await tailmerge(A,T,i,i+j,minVal(i+2*j,b));
			for(let i=a;i<b;i+=j){
				if(i+s<b)await encode(A,i,x+s+i-a,1);
				if(i+2*s<b)await encode(A,i+s,x+2*s+i-a,2);
				if(i+3*s<b)await encode(A,i+2*s,x+3*s+i-a,3);
			}
			for(;j<b-a;j*=2)for(let i=a;i+j<b;i+=2*j)await kitamerge(A,T,x+i-a,i,j/s|0,i+j,minVal(j,b-i-j)/s|0,p,c,s,w,iv);
			await indexll(A,a,b,x,s,w,p,c,iv);
			if(b<B){
				await binaryInsertion(A,b,B,.5);
				await tailmerge(A,T,a,b,B);
			}
		}
		async function logkita(A,a,b){
			let[lg,lg2]=productLog(b-a);
			let X=new Array(2*lg2);
			let m=a+(b-a)/2|0;
			let bd=await quickselect(A,X,a,b,m);
			await kita(A,X,a,bd[0],bd[0],lg-1,A[m],0,true);
			await kita(A,X,bd[1],b,a,lg-1,A[m],1,false);
		}
		await logkita(arr,0,len);
	}
	async sumSeededPDQSort(len){
		async function quickSort(a,p,r){
			if(r-p>16){
				let pv=(r^p+a[p]^a[r]+a[p]+a[r]+p+r)*(r^p+a[p]^a[r]+a[p]+a[r]+p+r)%(r-p)+p;
				let x=a[abs((pv+a[p]^a[r]+a[p]+a[r]+p+r)*(pv+a[p]^a[r]+a[p]+a[r]+p+r)%(r-p)+p)%(r-p-1)+p],i=p,j=r;
				while(i<=j){
					while(compareValues(a[i],x)<0)i++;
					while(compareValues(a[j],x)>0)j--;
					if(i<=j)await swap(a,i++,j--,1,true);
				}
				if(p<j)await quickSort(a,p,j);
				if(i<r)await quickSort(a,i,r);
			}else await binaryInsertion(a,p,r+1,.1);
		}
		await quickSort(arr,0,len-1);
	}
	async OOPLaziestSort(len){
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binaryInsertion(A,a,b){
			for(let i=a+1;i<b;i++)await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function merge(A,t,l,r,e){
			for(let i=0;i<r-l;i++)write(t,i,A[i+l],0,false,true);
			let bP=0;
			while(l<r&&r<e)
				if(compareValues(t[bP],A[r])<1)await write(A,l++,t[bP++],1,true);
				else await write(A,l++,A[r++],1,true);
			while(l<r)await write(A,l++,t[bP++],.5,true);
		}
		async function laziestStableSort(A,s,e){
			let l=e-s;
			if(l<17)return await binaryInsertion(A,s,e);
			let i,bL=maxVal(16,sqrt(l)|0);
			for(i=s;i+2*bL<e;i+=bL)await binaryInsertion(A,i,i+bL);
			await binaryInsertion(A,i,e);
			let t=new Array(bL);
			while(i-bL>=s)await merge(A,t,i-=bL,i+bL,e);
		}
		await laziestStableSort(arr,0,len);
	}
	async onlineLaziestSort(len){
		async function insertTo(A,a,b){
			let t=A[a];
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0)
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binaryInsertion(A,a,b){
			for(let i=a+1;i<b;i++)await insertTo(A,i,rightBinSearch(A,a,i,A[i]));
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a)
				if(compareIndices(A,i,j)>0){
					k=rightBinSearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=i+1-k;i=k-1;
				}else j--;
		}
		async function laziestStableSort(A,a,b){
			let s=16,j=512;
			for(let i=a;i<b;i+=s){
				if(i-a==j){
					j*=4;s*=2;
				}
				let e=minVal(i+s,b);
				await binaryInsertion(A,i,e);
				await inPlaceMergeBW(A,a,i,e);
			}
		}
		await laziestStableSort(arr,0,len);
	}
	async proportionExtendSort(len){
		let base=askForNum(16,"Block size");
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function binaryInsert(A,a,m,b){
			for(let i=m;i<b;i++){
				let t=A[i],j=rightBinSearch(A,a,i,t);
				await arraycopy(A,j,A,j+1,i-j,.2,true);
				await write(A,j,t,.5,true);
			}
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return i;
			}
		}
		async function peSort(A,a,b,pZ){
			let n=b-a,m=a+maxVal(1,n/pZ|0);
			if(n<33)return await binaryInsert(A,a,a+1,b);
			await peSort(A,a,m,pZ);
			await peRec(A,a,m,b,pZ);
		}
		async function peRec(A,a,m,b,pZ){
			if(b-a<33)return await binaryInsert(A,a,maxVal(a+1,m),b);
			if(m-a<1)return await peSort(A,a,b,maxVal(2,pZ/2|0));
			if(b-m<1)return;
			let m1=(a+m)/2|0,m2=await partition(A,m,b,m1),m3=m2;
			while(m-->m1)await swap(A,m,--m2,1,true);
			await peRec(A,a,m,m2,pZ);
			await peRec(A,m2+1,m3,b,pZ);
		}
		await peSort(arr,0,len,base);
	}
	async proportionExtendMergeSort(len){
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		async function partition(A,a,b,p){
			let i=a-1,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else return i;
			}
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a;
			await blockSwap(A,a,p,pL);
			let i=0,j=m,k=a;
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m;
			await blockSwap(A,m,p,pL);
			let i=pL-1,j=m-1,k=b-1;
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+(i--),1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+(i--),1,true);
		}
		async function smartMerge(A,a,m,b,p){
			if(m-a<b-m)await mergeFW(A,a,m,b,p);
			else await mergeBW(A,a,m,b,p);
		}
		async function mergeTo(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)await swap(A,p++,i++,1,true);
				else await swap(A,p++,j++,1,true);
			while(i<m)await swap(A,p++,i++,1,true);
			while(j<b)await swap(A,p++,j++,1,true);
		}
		async function pingPongMerge(A,a,m1,m,m2,b,p){
			let p1=p+m-a,pE=p+b-a;
			await mergeTo(A,a,m1,m,p);
			await mergeTo(A,m,m2,b,p1);
			await mergeTo(A,p,p1,pE,a);
		}
		async function mergeSort(A,a,b,p){
			let n=b-a,j=n;
			for(;((j+3)/4|0)>7;j=(j+3)/4|0);
			for(let i=a;i<b;i+=j)await binaryInsertion(A,i,minVal(b,i+j),.2);
			for(let i;j<n;j*=4){
				for(i=a;i+2*j<b;i+=4*j)await pingPongMerge(A,i,i+j,i+2*j,minVal(i+3*j,b),minVal(i+4*j,b),p);
				if(i+j<b)await mergeBW(A,i,i+j,b,p);
			}
		}
		async function smartMergeSort(A,a,b,p,pb){
			if(b-a<=pb-p)return await mergeSort(A,a,b,p);
			let m=a+b>>>1;
			await mergeSort(A,a,m,p);
			await mergeSort(A,m,b,p);
			await mergeFW(A,a,m,b,p);
		}
		async function peSort(A,a,m,b){
			let n=b-a;
			if(n<32)return await binaryInsertion(A,a,b,.25);
			if(m-a<=(n/3|0)){
				let t=(n+2)/3|0;
				await smartMergeSort(A,m,b-t,b-t,b);
				await smartMerge(A,a,m,b-t,b-t);
				m=b-t;
			}
			let m1=a+m>>>1,m2=await partition(A,m,b,m1),i=m,j=m2;
			while(i>m1)await swap(A,--i,--j,1,true);
			m=m2-(m-m1);
			if(m-m1<b-m2){
				await mergeSort(A,m1,m,m2);
				await smartMerge(A,a,m1,m,m2);
				await peSort(A,m+1,m2,b);
			}else{
				await mergeSort(A,m2,b,m1);
				await smartMerge(A,m+1,m2,b,m1);
				await peSort(A,a,m1,m);
			}
		}
		await peSort(arr,0,0,len);
	}
	async ternaryMedianMergeSort(len){
		function medianOfThree(A,i0,i1,i2){
			let tmp;
			if(compareIndices(A,i0,i1)>0){
				tmp=i1;
				i1=i0;
			}else tmp=i0;
			if(compareIndices(A,i1,i2)>0){
				if(compareIndices(A,tmp,i2)>0)return tmp;
				return i2;
			}
			return i1;
		}
		async function medianOfMedians(A,a,b){
			while(b-a>2){
				let m=a,i=a;
				for(;i+2<b;i+=3)
					await swap(A,m++,medianOfThree(A,i,i+1,i+2),1,true,false);
				while(i<b)
					await swap(A,m++,i++,1,true,false);
				b=m;
			}
		}
		async function partition(A,a,b,p){
			let i1=a,i=a-1,j=b,j1=b;
			for(;;){
				while(++i<j){
					let c=compareIndexValue(A,i,p);
					if(!c)await swap(A,i1++,i,1,true);
					else if(c>0)break;
				}
				while(--j>i){
					let c=compareIndexValue(A,j,p);
					if(!c)await swap(A,--j1,j,1,true);
					else if(c<0)break;
				}
				if(i<j)await swap(A,i,j,1,true);
				else{
					if(i1==b)return[a,b];
					else if(j<i)j++;
					if(i1-a>i-i1){
						let i2=i;i=a;
						while(i1<i2)await swap(A,i++,i1++,1,true);
					}else while(i1>a)await swap(A,--i,--i1,1,true);
					if(b-j1>j1-j){
						let j2=j;j=b;
						while(j1>j2)await swap(A,--j,--j1,1,true);
					}else while(j1<b)await swap(A,j++,j1++,1,true);
					break;
				}
			}
			return[i,j];
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function multiSwap(A,a,b,l){
			if(a-b)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a,i=0,j=m,k=a;
			await multiSwap(A,a,p,pL);
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m,i=pL-1,j=m-1,k=b-1;
			await multiSwap(A,m,p,pL);
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+i--,1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function smartMerge(A,a,m,b,p){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(b-m<m-a)await mergeBW(A,a,m,b,p);
			else await mergeFW(A,a,m,b,p);
		}
		function getMinLevel(n){
			while(n>31)n=++n/2|0;
			return n;
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,1,true);
					else await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function mergeSort(A,a,b,p){
			let l=b-a;
			if(l<2)return;
			let i,j=getMinLevel(l);
			if(await buildRuns(A,a,b,j))return;
			while(j<l){
				for(i=a;i+2*j<=b;i+=2*j)await smartMerge(A,i,i+j,i+2*j,p);
				if(i+j<b)await smartMerge(A,i,i+j,b,p);
				j*=2;
			}
		}
		async function medianMergeSort(A,a,b){
			let s=a,e=b,bP=false;
			while(e-s>32){
				let pI;
				if(bP)await medianOfMedians(A,pI=s,e);
				else pI=medianOfThree(A,s,s+(e-1-s)/2|0,e-1);
				let[p0,p1]=await partition(A,s,e,A[pI]),lL=p0-s,rL=e-p1,qL=p1-p0;
				if(qL==b-a)return;
				if(!rL){
					bP=qL<(lL/16|0);e=p0;
					continue;
				}
				if(!lL){
					bP=qL<(rL/16|0);s=p1;
					continue;
				}
				bP=minVal(lL,rL)<(maxVal(lL,rL)/16|0);
				if(lL<=rL)await mergeSort(A,s,p0,s=p1);
				else await mergeSort(A,p1,e,s,e=p0);
			}
			await buildRuns(A,s,e,e-s);
		}
		await medianMergeSort(arr,0,len);
	}
	async quadPivotQuickSort(len){
		async function compSwap(A,a,b){
			if(compareIndices(A,a,b)>0)await swap(A,a,b,.5,true);
		}
		async function quadPivotQuick(A,a,b){
			let n=b-a;
			if(n<33)return await binaryInsertion(A,a,b,.2);
			let s=n/5|0;
			await swap(A,a,a+s,1,true);
			await swap(A,a+1,a+2*s,1,true);
			await swap(A,a+2,a+3*s,1,true);
			await swap(A,a+3,a+4*s,1,true);
			await compSwap(A,a,a+1);
			await compSwap(A,a+2,a+3);
			await compSwap(A,a,a+2);
			await compSwap(A,a+1,a+3);
			await compSwap(A,a+1,a+2);
			let p1=A[a],p2=A[a+1],p3=A[a+2],p4=A[a+3];
			let i1=a,i=a,j=b,j1=b;
			for(let k=i;k<j;k++)
				if(compareIndexValue(A,k,p2)<1){
					let t=A[k];
					await write(A,k,A[i],.25,true);
					if(compareValues(t,p1)<0){
						await write(A,i,A[i1],.25,true);
						await write(A,i1++,t,.25,true);
					}else await write(A,i,t,.25,true);
					i++;
				}else if(compareIndexValue(A,k,p3)+1){
					while(--j>k){
						if(compareIndexValue(A,j,p3)<1)break;
						if(compareIndexValue(A,j,p4)>0)await swap(A,--j1,j,.5,true);
					}
					let t=A[k];
					await write(A,k,A[j],.25,true);
					if(compareValues(t,p4)>0){
						await write(A,j,A[--j1],.25,true);
						await write(A,j1,t,.25,true);
					}else await write(A,j,t,.25,true);
					if(compareIndexValue(A,k,p2)<1){
						t=A[k];
						await write(A,k,A[i],.25,true);
						if(compareValues(t,p1)<0){
							await write(A,i,A[i1],.25,true);
							await write(A,i1++,t,.25,true);
						}else await write(A,i,t,.25,true);
						i++;
					}
				}
			await quadPivotQuick(A,a,i1);
			if(compareValues(p1,p2)<0)await quadPivotQuick(A,i1,i);
			if(compareValues(p2,p3)<0)await quadPivotQuick(A,i,j);
			if(compareValues(p3,p4)<0)await quadPivotQuick(A,j,j1);
			await quadPivotQuick(A,j1,b);
		}
		await quadPivotQuick(arr,0,len);
	}
	async quickHeapSort(len){
		async function insertTo(A,a,b,t){
			while(a>b)await write(A,a,A[--a],.5,true);
			await write(A,b,t,.5,true);
		}
		function binSearch(A,a,b,v){
			while(a<b){
				let m=(a+b)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function sqrtMedian(A,a,b){
			let n=b-a,c=sqrt(n)|0;c-=1-c%2;
			let p=a,s=n/c|0,rn=new Random(),r=rn.nextInt(s);
			for(let i=a+r;c>0;c--,p++,i+=s){
				let t=A[i];
				await write(A,i,A[p],.5,true);
				await insertTo(A,p,binSearch(A,a,p,t),t);
			}
			return p;
		}
		async function partition(A,a,b){
			let m=await sqrtMedian(A,a,b),p=(a+m)/2|0,i=m-1,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)>0);
				do j--;while(j>=i&&compareIndices(A,j,p)<0);
				if(i<j)await swap(A,i,j,1,true);
				else{
					while(a<=p)await swap(A,--i,a++,1,true);
					return i;
				}
			}
		}
		async function siftDown(A,x,p,n,r){
			let t=A[p+r],c=x?1:-1;
			while(2*r+2<n){
				let nx=p+2*r+1;nx=(compareIndices(A,nx+1,nx)==c)?nx+1:nx;
				if(compareValues(A[nx],t)==c){
					await write(A,p+r,A[nx],.5,true);r=nx-p;
				}else return await write(A,p+r,t,.5,true);
			}
			let nx=p+2*r+1;
			if(nx-p<n&&compareValues(A[nx],t)==c){
				await write(A,p+r,A[nx],.5,true);r=nx-p;
			}
			await write(A,p+r,t,.5,true);
		}
		async function siftDownEasy(A,x,p,n,m,t){
			let r=0,c=x?1:-1;
			while(2*r+1<m){
				let nx=p+2*r+1;nx=(compareIndices(A,nx+1,nx)==c)?nx+1:nx;
				await write(A,p+r,A[nx],.5,true);r=nx-p;
			}
			let nx=p+2*r+1;
			if(nx-p<n){
				await write(A,p+r,A[nx],.5,true);r=nx-p;
				if(r+1<n)await write(A,p+r++,A[p+r],.5,true);
			}
			await write(A,p+r,t,.5,true);
		}
		async function heapSort(A,x,a,b,p){
			let n=b-a,m=(n/4|0)*2+1,c=x?1:-1;
			for(let i=(n-1)/2|0;i>=0;i--)await siftDown(A,x,a,n,i);
			for(let i=a+m+1;i<b;i+=2)if(compareIndices(A,i,i-1)==c)await swap(A,i-1,i,1,true);
			if(x)for(let i=0;i<n;i++){
				let t=A[--p];
				await write(A,p,A[a],1,true);
				await siftDownEasy(A,x,a,n,m,t);
			}else for(let i=0;i<n;i++){
				let t=A[p];
				await write(A,p++,A[a],1,true);
				await siftDownEasy(A,x,a,n,m,t);
			}
		}
		async function quickHeapSort(A,a,b){
			let s=a,e=b;
			while(e-s>32){
				let p=await partition(A,s,e),l=p-s,r=e-p-1;
				if(l<=r){
					await heapSort(A,true,s,p,e);e-=l;
					await swap(A,--e,p,1,true);
				}else{
					await heapSort(A,false,p+1,e,s);s+=r;
					await swap(A,s++,p,1,true);
				}
			}
			await binaryInsertion(A,s,e,.25);
		}
		await quickHeapSort(arr,0,len);
	}
	async byproductSort(len){
		const GS=new GrailSorting();
		async function shellPass(A,s,e,g){
			if(par<g)return;
			for(let h=g,i=h+s;i<e;i++){
				let v=A[i],j=i,w=false;
				for(;j>=h&&j-h>=s&&compareValues(A[j-h],v)>0;j-=h)await write(A,j,A[j-h],.5,w=true);
				if(w)await write(A,j,v,.5,checks=true);
			}
		}
		async function grailMultiSwap(A,a,b,l){
			while(l--)await swap(A,a++,b++,1,true);
		}
		async function mergeFindRun(A,a,b){
			let i=await MHT.findRun(A,a,b,.5,true);
			let j;
			for(;i<a+16&&i<b;i=j){
				j=await MHT.findRun(A,i,b,.5,checks=true);
				if(i<b)await GS.grailMergeWithoutBuffer(A,a,i-a,j-i);
			}
			return i;
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=MHT.minExponentialSearch(A,m,b,A[a],true);
				await MHT.rotateIndexed(A,a,m,i,1,true);
				let t=i-m;m=i;a+=t+1;
				if(a>=m)break;
				a=MHT.minExponentialSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=MHT.maxExponentialSearch(A,a,m,A[b-1],false);
				await MHT.rotateIndexed(A,i,m,b,1,true);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=MHT.maxExponentialSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,a,m,b,d){
			let lA=m-a,lB=b-m;
			if(lA<9||lB<9){
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
				return;
			}
			let c=lA+(lB-lA)/2|0;
			if(lB<lA){
				let r1=0,r2=lB;
				while(r1<r2){
					let ml=r1+(r2-r1)/2|0;
					if(compareIndices(A,m-c+ml,b-ml-1)>0)r2=ml;
					else r1=ml+1;
				}
				await MHT.rotateIndexed(A,m-c+r1,m,b-r1,1,true);
				let m1=b-c;
				await merge(A,m1,b-r1,b,d+1);
				await merge(A,a,m1-lB+r1,m1,d+1);
			}else{
				let r1=0,r2=lA;
				while(r1<r2){
					let ml=r1+(r2-r1)/2|0;
					if(compareIndices(A,a+ml,m+c-ml-1)>0)r2=ml;
					else r1=ml+1;
				}
				await MHT.rotateIndexed(A,a+r1,m,m+c-r1,1,true);
				let m1=a+c;
				await merge(A,a,a+r1,m1,d+1);
				await merge(A,m1,m1+lA-r1,b,d+1);
			}
		}
		async function block(A,a,b){
			let i,j,k;
			while(1){
				let l=a,s=0;
				i=await mergeFindRun(A,a,b);s++;
				if(i>=b)break;
				else checks=true;
				j=await mergeFindRun(A,i,b);s++;
				await merge(A,a,i,j,0);
				if(j>=b)break;k=j;
				while(1){
					i=await mergeFindRun(A,k,b);s++;
					if(i>=b){
						await merge(A,l,k,i,0);
						break;
					}
					j=await mergeFindRun(A,i,b);s++;
					await merge(A,k,i,j,0);
					if(j>=b)break;
					l=k;k=j;
				}
				if(s==3)break;
			}
		}
		let par,checks;
		async function sort(A,l){
			let[ln,ht]=MHT.getRectangleDimensions(l);
			while(1){
				checks=false;
				if(ht%ln||ln==ht)for(let i=0;i<l;i+=ln)await block(A,i,i+ln);
				par=MHT.parX(A,0,l,.1,true);
				if(ln-1&&ht-1){
					let m=ln;
					if(ln%2+ht%2<1){
						for(;m*3<l;m*=3);
						for(;m>=ln;m=m/3|0)await shellPass(A,0,l,m);
					}else{
						for(;m*2<l;m*=2);
						for(;m>=ln;m=m/2|0)await shellPass(A,0,l,m);
					}
				}
				if(checks&&ln-ht)[ht,ln]=[ln,ht];
				else break;
			}
			if(ln-1&&ht-1)await block(A,0,l);
		}
		await sort(arr,len);
	}
	async recursiveTimSort(len){
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		function leftBoundSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+1)i*=2;
			return rightBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return leftBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			if(a>b){
				let t=A[a];
				do await write(A,a,A[--a],.25,true);while(a>b);
				await write(A,b,t,.25,true);
			}
		}
		async function insertion(A,a,b){
			let i=a+1;
			if(i>=b)return;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)await insertTo(A,i,rightExpSearch(A,a,i,A[i]));
		}
		async function mergeFW(A,T,a,m,b){
			let l1=m-a,t=a;
			arraycopy(A,a,T,0,l1,0,false,true);
			let i=0,mG=7,l=0,r=0;
			while(1){
				do{
					if(compareValues(T[i],A[m])<1){
						await write(A,a++,T[i++],1,true);
						l++;r=0;
						if(i==l1)return;
					}else{
						await write(A,a++,A[m++],1,true);
						r++;l=0;
						if(m==b){
							while(i<l1)await write(A,a++,T[i++],1,true);
							return;
						}
					}
				}while((l|r)<mG);
				do{
					l=leftExpSearch(A,m,b,T[i])-m;
					for(let j=0;j<l;j++)await write(A,a++,A[m++],1,true);
					await write(A,a++,T[i++],1,true);
					if(i==l1)return;
					else if(m==b){
						while(i<l1)await write(A,a++,T[i++],1,true);
						return;
					}
					r=leftBoundSearch(T,i,l1,A[m])-i;
					for(let j=0;j<r;j++)
						await write(A,a++,T[i++],1,true);
					await write(A,a++,A[m++],1,true);
					if(i==l1)return;
					else if(m==b){
						while(i<l1)await write(A,a++,T[i++],1,true);
						return;
					}
					mG--;
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function mergeBW(A,T,a,m,b){
			let l2=b-m,t=a;
			arraycopy(A,m--,T,0,l2,0,false,true);
			let i=l2-1,mG=7,l=0,r=0;
			while(1){
				do{
					if(compareValues(T[i],A[m])+1){
						await write(A,--b,T[i--],1,true);
						l++;r=0;
						if(i<0)return;
					}else{
						await write(A,--b,A[m--],1,true);
						r++;l=0;
						if(m<a){
							while(i>=0)await write(A,--b,T[i--],1,true);
							return;
						}
					}
				}while((l|r)<mG);
				do{
					l=m+1-rightExpSearch(A,a,m+1,T[i]);
					for(let j=0;j<l;j++)await write(A,--b,A[m--],1,true);
					await write(A,--b,T[i--],1,true);
					if(i<0)return;
					else if(m<a){
						while(i>=0)await write(A,--b,T[i--],1,true);
						return;
					}
					r=i+1-rightBoundSearch(T,0,i+1,A[m]);
					for(let j=0;j<r;j++)await write(A,--b,T[i--],1,true);
					await write(A,--b,A[m--],1,true);
					if(i<0)return;
					else if(m<a){
						while(i>=0)await write(A,--b,T[i--],1,true);
						return;
					}
				}while((l|r)>6);
				if(mG<0)mG=0;
				mG+=2;
			}
		}
		async function smartMerge(A,T,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftBoundSearch(A,a,m,A[m]);
			b=rightBoundSearch(A,m,b,A[m-1]);
			if(b-m<m-a)await mergeBW(A,T,a,m,b);
			else await mergeFW(A,T,a,m,b);
		}
		async function sort(A,t,a,b){
			if(b-a<32)return await insertion(A,a,b);
			let m=a+(b-a)/2|0;
			await sort(A,t,a,m);
			await sort(A,t,m,b);
			await smartMerge(A,t,a,m,b);
		}
		await sort(arr,new Array(len/2|0),0,len);
	}
	async blockTimSort(len){
		function getMinLevel(n){
			while(n>31)n=++n/2|0;
			return n;
		}
		async function insertTo(A,a,b){
			let t=A[a];
			for(let i=a;i>b;i--)await write(A,i,A[i-1],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		function insertToBW(A,a,b){
			let t=A[a];
			for(let i=a;i<b;i++)write(A,i,A[i+1],0,false,true);
			if(a-b)write(A,b,t,0,false,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function shiftFWExt(A,a,m,b){
			while(m<b)await write(A,a++,A[m++],1,true);
		}
		async function rotate(A,a,m,b){
			let lA=m-a,lB=b-m,p=a,e=p+lA+lB;
			while(lA>0&&lB>0)
				if(lA<lB){
					for(let i=0;i<lA;i++){
						let t=A[p+i],j=p+i+lA;
						for(;j<e;j+=lA)await write(A,j-lA,A[j],1,true);
						await write(A,j-lA,t,1,true);
					}
					p+=lB;lB%=lA;lA-=lB;
				}else{
					for(let i=0;i<lB;i++){
						let t=A[p+i+lA],j=p+i+lA-lB;
						for(;j>=p;j-=lB)await write(A,j+lB,A[j],1,true);
						await write(A,j+lB,t,1,true);
					}
					e=p+lB;lA%=lB;lB-=lA;
				}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			let nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)
						await swap(A,j,i-1,1,true,false);
					else
						await reversal(A,j,i-1,1,true,false);
				}else
					while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;
					j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function checkReverseBounds(A,a,m,b){
			if(compareIndices(A,a,b-1)>0)return!await rotate(A,a,m,b);
			return false;
		}
		async function boundCheck(A,a,m,b){
			return compareIndices(A,m-1,m)<1||await checkReverseBounds(A,a,m,b);
		}
		async function mergeFromBuf(A,B,a,m,b,bL){
			let i=0;
			while(i<bL&&m<b)
				if(compareValues(B[i],A[m])<1)await write(A,a++,B[i++],1,true);
				else await write(A,a++,A[m++],1,true);
			while(i<bL)await write(A,a++,B[i++],1,true);
		}
		async function mergeTo(f,t,a,m,b,p,X){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(f,i,j)<1)await write(t,p++,f[i++],1,true,X);
				else await write(t,p++,f[j++],1,true,X);
			while(i<m)await write(t,p++,f[i++],1,true,X);
			while(j<b)await write(t,p++,f[j++],1,true,X);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,B,a,m,b){
			if(minVal(m-a,b-m)<9)
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			else if(m-a>b-m)await mergeBWExt(A,B,a,m,b);
			else await mergeFWExt(A,B,a,m,b);
		}
		function getSubarray(T,t,k){
			return compareIndices(T,t,k)<0;
		}
		async function blockSelect(A,T,p,r,d,lC,bC,bL){
			let mK=lC;
			for(let j=0,k=lC+1;j<k-1;j++){
				let m=j;
				for(let i=maxVal(lC-r,j+1);i<k;i++){
					let c=compareIndices(A,p+d+i*bL,p+d+m*bL);
					if(c<0||!c&&compareIndices(T,i,m)<0)m=i;
				}
				if(m-j){
					await multiSwap(A,p+j*bL,p+m*bL,bL);
					swap(T,j,m,0,false,true);
					if(k<bC&&m==k-1)k++;
				}
				if(m==mK)mK=j;
			}
			return mK;
		}
		async function mergeBlocks(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<1)await write(A,p++,A[i++],1,true);
				else await write(A,p++,A[j++],1,true);
			if(i>p)await shiftFWExt(A,p,i,m);
			return j;
		}
		async function mergeBlocksRev(A,a,m,b,p){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(A,i,j)<0)await write(A,p++,A[i++],1,true);
				else await write(A,p++,A[j++],1,true);
			if(i>p)await shiftFWExt(A,p,i,m);
			return j;
		}
		async function blockMerge(A,B,T,a,m,b,bL){
			let b1=b-(b-m-1)%bL-1,i=a+bL,j=a,ke=-1,lC=(m-i)/bL|0,bC=(b1-i)/bL|0,l=-1,r=lC-1;
			for(let k=0;k<bL;k++){
				write(B,k,A[m-bL+k],0,false,true);
				await write(A,m-bL+k,A[a+k],.5,true);
			}
			for(let k=0;k<bC;k++)write(T,k,k,0,false,true);
			insertToBW(T,0,lC-1);
			let mK=await blockSelect(A,T,i,1,bL-1,lC,bC,bL),f=true;
			while(l<lC&&r<bC){
				if(f){
					do{
						j+=bL;l++;ke++;
					}while(l<lC&&getSubarray(T,ke,mK));
					if(l==lC){
						i=await mergeBlocks(A,i,j,b,i-bL);
						await mergeFromBuf(A,B,i-bL,i,b,bL);
					}else i=await mergeBlocks(A,i,j,j+bL-1,i-bL);
				}else{
					do{
						j+=bL;r++;ke++;
					}while(r<bC&&!getSubarray(T,ke,mK));
					if(r==bC){
						await shiftFWExt(A,i-bL,i,b);
						await arraycopy(B,0,A,b-bL,bL,1,true);
					}else i=await mergeBlocksRev(A,i,j,j+bL-1,i-bL);
				}
				f=!f;
			}
		}
		async function smartMerge(A,B,a,m,b){
			if(await boundCheck(A,a,m,b))return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(await checkReverseBounds(A,a,m,b))return;
			await merge(A,B,a,m,b);
		}
		async function pingPongMerge(A,B,a,m1,m2,m3,b){
			let p=0,p1=p+m2-a,pE=p+b-a;
			if(compareIndices(A,m1-1,m1)>0||(m3<b&&compareIndices(A,m3-1,m3)>0)){
				await mergeTo(A,B,a,m1,m2,p,true);
				await mergeTo(A,B,m2,m3,b,p1,true);
				await mergeTo(B,A,p,p1,pE,a,false);
			}else await smartMerge(A,B,a,m2,b);
		}
		async function smartBlockMerge(A,B,T,a,m,b,bL){
			if(await boundCheck(A,a,m,b))return;
			let s=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(await checkReverseBounds(A,s,m,b))return;
			if(minVal(m-s,b-m)<=bL)await merge(A,B,s,m,b);
			else await blockMerge(A,B,T,s-=(s-a)%bL,m,b,bL);
		}
		async function blockMergeSort(A,a,b){
			let l=b-a;
			if(l<128){
				let j=getMinLevel(l);
				if(await buildRuns(A,a,b,j))return;
				let T=new Array(l/2|0),i;
				for(;j<l;j*=2){
					for(i=a;i+2*j<=b;i+=2*j)await smartMerge(A,T,i,i+j,i+2*j);
					if(i+j<b)await smartMerge(A,T,i,i+j,b);
				}
				return;
			}
			let j=getMinLevel(l),bL;
			for(bL=j;bL*bL<l;bL*=2);
			let tL=l/bL|0;
			if(await buildRuns(A,a,b,j))return;
			let B=new Array(bL),i;
			for(;4*j<=bL;j*=4){
				for(i=a;i+2*j<b;i+=4*j)await pingPongMerge(A,B,i,i+j,i+2*j,minVal(i+3*j,b),minVal(i+4*j,b));
				if(i+j<b)await smartMerge(A,B,i,i+j,b);
			}
			for(;j<=bL;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await smartMerge(A,B,i,i+j,i+2*j);
				if(i+j<b)await smartMerge(A,B,i,i+j,b);
			}
			let T=new Array(tL);
			for(;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await smartBlockMerge(A,B,T,i,i+j,i+2*j,bL);
				if(i+j<b)await smartBlockMerge(A,B,T,i,i+j,b,bL);
			}
		}
		await blockMergeSort(arr,0,len);
	}
	async bicycleSort(len){
		function getRank(A,s,e,d,b,l){
			let bt=new BigInteger(),x=0;
			for(let i=s;i<e;i++)
				if(bt.testBit(A[i])){
					if(((A[i]>b)^l)&&i-d&&compareIndices(A,i,d)<0)x++;
				}else bt=bt.setBit(A[i]);
			for(let i=!l?b:A[d];i<(!l?A[d]:b);i++)if(bt.testBit(i))x++;
			return x;
		}
		function getRank_stuck(A,s,e,i,b,l){
			let r=0;
			for(let j=s;j<e;j++)if((l^(A[j]>=b))&&j-i&&compareIndices(A,j,i)<0)r++;
			return r;
		}
		async function tailCycle(A,s,e,t,p){
			let sH=e>t,l=e-s;
			for(let i=s;i<e;i++){
				let r,a=0;
				do{
					r=a++>=l?getRank_stuck(A,i,e,i,p,sH)+(sH?getRank_stuck(A,t,t+l,i,p,true):getRank_stuck(A,t-l,t,i,p,false)):!sH?getRank(A,s,e,i,p,false)+getRank(A,t-l,t,i,p,false):getRank(A,s,e,i,p,true)+getRank(A,t,t+l,i,p,true);
					if(!r)break;
					let n=sH?t+l-r-2:t-l+r+1;
					while(A[n]==A[i])n++;
					await swap(A,i,n,1,true);
				}while(r>0);
			}
		}
		async function cycleSort(A,s,e){
			for(let c=s;c<e-1;c++){
				let v=A[c],p=c;
				for(let i=c+1;i<e;i++)if(compareValues(A[i],v)<0)p++;
				if(p==c)continue;
				while(v==A[p])p++;
				let t=A[p];
				await write(A,p,v,0,true);v=t;
				while(p-c){
					p=c;
					for(let i=c+1;i<e;i++)if(compareValues(A[i],v)<0)p++;
					while(v==A[p])p++;t=A[p];
					await write(A,p,v,0,true);v=t;
				}
			}
		}
		async function cycle(A,s,e,d){
			if(!d--)return await cycleSort(A,s,e+1,0);
			if(e==s)return;
			let p=s+(e-s+1)/2|0,x=A[p],i=s,j=e;
			while(i<=j){
				while(compareValues(A[i],x)>0)i++;
				while(compareValues(A[j],x)<0)j--;
				if(i<=j)await swap(A,i++,j--,1,true);
			}
			if(i>p){
				await tailCycle(A,j,e+1,s,x);
				let w=s+e-j-1;
				if(w>s)await cycle(A,w,e,d);
				else await cycleSort(A,s,e+1,0);
			}else{
				await tailCycle(A,s,i,e,x);
				let w=e-i+s+1;
				if(w<e)await cycle(A,s,w,d);
				else await cycleSort(A,s,e+1,0);
			}
		}
		let l=0;
		for(let p=1;p<=(len/2|0);p*=2)l++;
		await cycle(arr,0,len-1,l+(l>>1));
		await insertSort(arr,0,len,1);
	}
	async shnexSort(len){
		function noDupes(A,l){
			let n=1/0,x=-n;
			for(let i=0;i<l;i++){
				if(A[i]<n)n=A[i];
				if(A[i]>x)x=A[i];
			}
			if(n||x-l+1)return false;
			let z=x-n+1,h=new Array(z).fill(0);
			for(let i=0;i<l;i++)
				if(holes[A[i]-n]==1)return false;
				else holes[A[i]-n]=1;
			return true;
		}
		if(noDupes(arr,len))for(let i=0;i<len;i++)while(compareValues(arr[i],i))await multiSwap(arr,i,arr[i],.05,true);
		else for(let i=0;i+1<len;i++)
			if(compareIndices(arr,i,i+1)>0){
				await multiSwap(arr,i+1,0,.05,true);
				i=-1;
			}
	}
	async peelBingoSort(len){
		async function collect(A,e){
			let n=0;
			for(let l=e;l>=0;l--){
				let c=compareIndices(A,l,e-n+1<e?e-n+1:e);
				if(c>0){
					await Wr.insert(A,l,e,.1,true);
					n=1;
				}else if(!c){
					if(l-e+n)await Wr.insert(A,l,e-n,.1,true);
					n++;
				}
			}
			return n;
		}
		for(let i=len;i>0;i-=await collect(arr,i-1));
	}
	async tableSelectionSort(len){
		function stableComp(A,T,a,b){
			let c=compareIndices(A,T[a],T[b]);
			return c<0||!c&&compareIndices(T,a,b)<0;
		}
		async function sort(A,l){
			let T=new Array(l);
			for(let i=0;i<l;i++)await write(T,i,i,.5,true,true);
			for(let i=0;i<l-1;i++){
				let mI=i;
				for(let j=i+1;j<l;j++)if(stableComp(A,T,j,mI))mI=j;
				if(mI-i)await swap(T,i,mI,.25,true,true);
			}
			for(let i=0;i<l;i++)
				if(compareValues(i,T[i])){
					let t=A[i],j=i,n=T[i];
					do{
						await write(A,j,A[n],1,true);
						await write(T,j,j,1,true,true);
						n=T[j=n];
					}while(compareValues(n,i));
					await write(A,j,t,1,true);
					await write(T,j,j,1,true,true);
				}
		}
		await sort(arr,len);
	}
	async selectionClamberSort(len){
		async function selectionClamber(A,s,e){
			for(let i=s;i<e-1;i++){
				let l=i;
				for(let j=i+1;j<e;j++)if(compareIndices(A,j,l)<0)l=j;
				if(l==e-1)await swap(A,l,i,1,true);
				else await selectionClamber(A,i,l+1);
			}
		}
		await selectionClamber(arr,0,len);
	}
	async yukariSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function rotateNoBuf(A,a,m,b){
			let p0=a,p1=m-1,p2=m,p3=b-1,t;
			while(p0<p1&&p2<p3){
				t=A[p1];
				await write(A,p1--,A[p0],.5,true);
				await write(A,p0++,A[p2],.5,true);
				await write(A,p2++,A[p3],.5,true);
				await write(A,p3--,t,.5,true);
			}
			while(p0<p1){
				t=A[p1];
				await write(A,p1--,A[p0],.5,true);
				await write(A,p0++,A[p3],.5,true);
				await write(A,p3--,t,.5,true);
			}
			while(p2<p3){
				t=A[p2];
				await write(A,p2++,A[p3],.5,true);
				await write(A,p3--,A[p0],.5,true);
				await write(A,p0++,t,.5,true);
			}
			if(p0<p3)
				if(p3-p0>2)await reversal(A,p0,p3,1,true);
				else await swap(A,p0,p3,1,true);
		}
		async function rotate(A,B,a,m,b){
			if(a>=m||m>=b)return;
			if(B==null)return await rotateNoBuf(A,a,m,b);
			let p=a,l=m-a,r=b-m,pa=p,pb=p+l,pc=p+r,pd=pb+r;
			if(l<r){
				let br=r-l;
				if(br<l){
					let o=l;
					if(br>B.length)return await rotateNoBuf(A,a,m,b);
					arraycopy(A,pb,B,0,br,0,false,true);
					while(o-->0){
						await write(A,--pc,A[--pd],.5,true);
						await write(A,pd,A[--pb],.5,true);
					}
					await arraycopy(B,0,A,pa,br,1,true);
				}else{
					if(l>B.length)return await rotateNoBuf(A,a,m,b);
					arraycopy(A,pa,B,0,l,0,false,true);
					await arraycopy(A,pb,A,pa,r,1,true);
					await arraycopy(B,0,A,pc,l,1,true);
				}
			}else if(r<l){
				let br=l-r;
				if(br<r){
					if(br>B.length)return await rotateNoBuf(A,a,m,b);
					let o=r;
					arraycopy(A,pc,B,0,br,0,false,true);
					while(o-->0){
						await write(A,pc++,A[pa],.5,true);
						await write(A,pa++,A[pb++],.5,true);
					}
					await arraycopy(B,0,A,pd-br,br,1,true);
				}else{
					if(r>B.length)return await rotateNoBuf(A,a,m,b);
					arraycopy(A,pb,B,0,r,0,false,true);
					while(l-->0)await write(A,--pd,A[--pb],1,true);
					await arraycopy(B,0,A,pa,r,1,true);
				}
			}else while(l-->0)await swap(A,pa++,pb++,1,true);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function merge(A,B,a,m,b,bn){
			if(bn){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,B,a,m,b);
			}
			if(m-a>b-m)await mergeBWExt(A,B,a,m,b);
			else await mergeFWExt(A,B,a,m,b);
		}
		async function rotateMerge(A,B,a,m,b){
			while(minVal(m-a,b-m)>B.length){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,B,a,m,b);
				if(minVal(m-a,b-m)<=B.length)return await merge(A,B,a,m,b,false);
				let m1,m2,m3;
				if(m-a>=b-m){
					m2=binSearch(A,m,b,A[m1=a+(m-a)/2|0],true);
					m3=m1+m2-m;
				}else{
					m1=binSearch(A,a,m,A[m2=m+(b-m)/2|0],false);
					m3=m2++-m+m1;
				}
				await rotate(A,B,m1,m,m2);
				if(b-m3-1<m3-a){
					await rotateMerge(A,B,m3+1,m2,b);
					m=m1;b=m3;
				}else{
					await rotateMerge(A,B,a,m1,m3);
					m=m2;a=m3+1;
				}
			}
			await merge(A,B,a,m,b,true);
		}
		async function findRun(A,a,b,mR){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++],false));
			return i;
		}
		async function mergeSort(A,a,b){
			let l=b-a;
			if(l<33)return await findRun(A,a,b,b-a);
			let mR=16,bL=1;
			while(bL*bL<l)bL*=2;
			let B=new Array(bL),i,j,k;
			while(1){
				if((i=await findRun(A,a,b,mR))>=b)break;
				await rotateMerge(A,B,a,i,j=await findRun(A,i,b,mR));
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b,mR))>=b)break;
					await rotateMerge(A,B,k,i,j=await findRun(A,i,b,mR));
					if((k=j)>=b)break;
				}
			}
		}
		await mergeSort(arr,0,len);
	}
	async synchronousEctaSort(len){
		const BMS=new BlockMergeSorting();
		async function writeTo(A,t,f){
			await write(A,t,A[f],1,true);
		}
		async function mergeWithBufFWHead(A,T,m,b){
			let lB=b-m,pb=T.length,pa=pb-lB,p=pa-lB;
			while(pa<pb&&m<b)
				if(compareValues(T[pa],A[m])<1)await write(T,p++,T[pa++],1,true,true);
				else await write(T,p++,A[m++],1,true,true);
			if(p<pa)while(pa<pb)await write(T,p++,T[pa++],1,true,true);
			while(m<b)await write(T,p++,A[m++],1,true,true);
		}
		async function mergeWithBufBWHead(A,T,m,b){
			let lB=b-m,pb=T.length,pa=pb-lB,p=b+lB;pb--;b--;
			while(pb>=pa&&b>=m)
				if(compareValues(T[pb],A[b])>0)await write(A,--p,T[pb--],1,true);
				else await write(A,--p,A[b--],1,true);
			if(p>b+1)while(b>=m)await write(A,--p,A[b--],1,true);
			while(pb>=pa)await write(A,--p,T[pb--],1,true);
		}
		async function blockMergeEasy(A,I,i,j,a,m,b,bL,bC,p){
			let c=j-p[1]>i-p[0]?1:0,k=0;
			while(i<m||j<b){
				if(i<m&&j<b)
					if(compareIndices(A,i,j)<1)await writeTo(A,p[c]++,i++);
					else await writeTo(A,p[c]++,j++);
				else if(i<m)await writeTo(A,p[c]++,i++);
				else await writeTo(A,p[c]++,j++);
				if(++k==bL){
					write(I,bC++,p[c]/bL-1,0,false,true);
					c=j-p[1]>i-p[0]?1:0;k=0;
				}
			}
			while(k-->0)await writeTo(A,--b,--p[c]);
			return bC;
		}
		async function blockMergeHead(A,T,I,a,m,b,bL,bC,p){
			p[0]=a;p[1]=m;
			let i=a,j=m,fL=2*bL;
			for(let k=0;k<fL;k++)
				if(i<m&&j<b)
					if(compareIndices(A,i,j)<1)await write(T,k,A[i++],1,true,true);
					else await write(T,k,A[j++],1,true,true);
				else if(i<m)await write(T,k,A[i++],1,true,true);
				else await write(T,k,A[j++],1,true,true);
			return await blockMergeEasy(A,I,i,j,a,m,b,bL,bC,p);
		}
		async function blockMerge(A,I,a,m,b,bL,bC,p){
			let i=a,j=m;
			for(let pC=2-(a-p[1])/bL|0;pC>0;pC--){
				write(I,bC++,p[0]/bL,0,false,true);
				for(let k=0;k<bL;k++)
					if(i<m&&j<b)
						if(compareIndices(A,i,j)<1)await writeTo(A,p[0]++,i++);
						else await writeTo(A,p[0]++,j++);
					else if(i<m)await writeTo(A,p[0]++,i++);
					else await writeTo(A,p[0]++,j++);
			}
			p[0]=p[1];p[1]=m;
			return await blockMergeEasy(A,I,i,j,a,m,b,bL,bC,p);
		}
		async function blockCycle(A,B,K,a,bL,bC){
			for(let i=0;i<bC;i++)
				if(compareValues(i,K[i])){
					arraycopy(A,a+i*bL,B,0,bL,0,false,true);
					let j=i,n=K[i];
					do{
						await arraycopy(A,a+n*bL,A,a+j*bL,bL,1,true);
						write(K,j,j,0,false,true);
						n=K[j=n];
					}while(compareValues(n,i));
					await arraycopy(B,0,A,a+j*bL,bL,1,true);
					write(K,j,j,0,false,true);
				}
		}
		async function sort(A,l){
			if(l<17)return await BMS.binaryInsertion(A,0,l);
			let bL=1;
			while(bL*bL<(l/2|0))bL*=2;
			let fL=2*bL,tL=l/bL|0,T=new Array(fL),I=new Array(tL),a=0,b=l,n=b-a,i=a+1,j=1,j2=2*j,c=compareIndices(A,i-1,i)>0;
			write(T,fL-2,A[i-(c?0:1)],0,false,true);
			write(T,fL-1,A[i-(c?1:0)],0,false,true);
			for(i+=2;i<b;i+=2){
				c=compareIndices(A,i-1,i)>0;
				await write(A,i-3,A[i-(c?0:1)],1,true);
				await write(A,i-2,A[i-(c?1:0)],1,true);
			}
			if(i==b)await write(A,i-3,A[i-1],1,true);
			for(b-=j2,j=j2,j2*=2;j<fL;b-=j,j=j2,j2*=2){
				await mergeWithBufFWHead(A,T,a,a+j);
				for(i=a+j;i+j<b;i+=j2)await BMS.mergeWithBufFWExt(A,i,i+j,minVal(i+j2,b),i-j);
				await BMS.shiftFWExt(A,i-j,i,b);
			}
			let a1=a+j;
			for(i=a1;i+j<b;i+=j2);
			await BMS.shiftBWExt(A,i,b,b+j);
			for(i-=j2;i>=a1;i-=j2){
				let k=minVal(i+j2,b);
				await BMS.mergeWithBufBWExt(A,i,i+j,k,k+j);
			}
			await mergeWithBufBWHead(A,T,a,a1);
			let p=[0,0];
			for(b=a+n,j=j2,j2*=2;j<n;j=j2,j2*=2){
				let bC=2;
				bC=await blockMergeHead(A,T,I,a,a+j,minVal(a+j2,b),bL,bC,p);
				for(i=a+j2;i+j<b;i+=j2)bC=await blockMerge(A,I,i,i+j,minVal(i+j2,b),bL,bC,p);
				let c=0,e=(i-=j2)+j;
				while(p[0]<e){
					await arraycopy(T,c*bL,A,p[0],bL,1,true);
					await write(I,c++,p[0]/bL,0,false,true);
					p[0]+=bL;
				}
				e=minVal(i+j2,b);
				while(e-p[1]>=bL){
					await arraycopy(T,c*bL,A,p[1],bL,1,true);
					await write(I,c++,p[1]/bL,0,false,true);
					p[1]+=bL;
				}
				await blockCycle(A,T,I,0,bL,bC);
			}
		}
		await sort(arr,len);
	}
	async smoothBingoSort(len){
		for(let i=len-1;i>0;){
			let sI=0,qZ=0;
			for(let j=1;j<=i;j++){
				let c=compareIndices(arr,sI,j);
				if(c<0){
					await swap(arr,j,++sI,.2,true);
					qZ=0;
				}else if(!c){
					await swap(arr,j,++sI,.2,true);
					qZ++;
				}
			}
			if(sI==i)break;
			for(let k=qZ+1;k>0;k--)await swap(arr,i--,sI--,1,true);
		}
	}
	async shoveSandpaperSort(len){
		for(let i=0;i<len;i++)for(let c=i+1;c<len;c++)await multiSwap(arr,i+(compareIndices(arr,i,i+1)<1),len-1,1/(len*.9-i),true);
	}
	async optimizedSmoothBingoSort(len){
		let s=0,q=0;
		for(let i=len-1;i>s;){
			for(let j=s;j>0&&!compareIndices(arr,j-1,j);j--,q++);
			for(let j=s+1;j<=i;j++){
				let c=compareIndices(arr,j,s);
				if(c+1){
					if(j-++s)await swap(arr,j,s,.5,true);
					if(!c)q++;
					else q=0;
				}
			}
			if(s>=i)return;
			do await swap(arr,s--,i--,1,true,false);while(q-->0);
			if(q<0)q=0;
			if(s<0)s=0;
		}
	}
	async evenMoreOptimizedSmoothBingoSort(len){
		let s=0,qs=[];
		for(let i=len-1;i>s;){
			let q;
			if(qs.length)q=qs.pop();
			else q=0;
			for(let j=s+1;j<=i;j++){
				let c=compareIndices(arr,j,s);
				if(c+1){
					if(j-++s)await swap(arr,j,s,.5,true);
					if(!c)q++;
					else{
						qs.push(q);
						q=0;
					}
				}
			}
			if(s>=i)return;
			do await swap(arr,s--,i--,1,true);while(q-->0);
			if(s<0)s=0;
		}
	}
	async boseNelsonSortIterative2(len){
		async function compSwap(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		function weight(x){
			let r=0;
			while(x>0){
				r+=x&1;
				x=x/2|0;
			}
			return r;
		}
		async function boseNelsonPass(A,a,m,v,w){
			let n=0;
			for(let j=0;j<(1<<w)-1;j++){
				await compSwap(A,a+n+v,m+n);
				for(let i=0;;i++){
					while((v>>i)&1)i++;
					if(!((n>>i)&1)){
						n|=1<<i;
						break;
					}
					n&=~(1<<i);
				}
			}
			await compSwap(A,a+n+v,m+n);
		}
		let e;
		async function sort(A,n){
			e=n;n=1<<ceil(log(n)/log(2));
			for(let j=0,k=1;k<e;j++,k*=2)
				for(let m=0;m<k;m++)
					for(let i=0,w=j-weight(m);i+k<e;i+=2*k)
						await boseNelsonPass(A,i,i+k,m,w);
		}
		await sort(arr,len);
	}
	async dupeSort(len){
		async function compSwap(A,a,b){
			if(a<b&&compareIndices(A,a,b)>0)await swap(A,a,b,1,true);
		}
		function bitreverse(n,l){
			let v=0;
			while(l>0){
				v|=(n&1)<<--l;
				n>>=1;
			}
			return v;
		}
		async function sort(A,l){
			for(let i=1,p=0,q=0;;i++){
				if(2<<p==i){
					q=++p;
					if(1<<p>=2*l)break;
				}
				if(i==((1<<p)|(1<<(p-q))))if(-p+q--)continue;
				let k=bitreverse(i,p);
				for(let j=0;j<l;j++)if((j^k)<l&&(j^k)-j==1<<q)await compSwap(A,j,j^k);
			}
		}
		await sort(arr,len);
	}
	async interweaveSort(len){
		async function avgList(L,T,l){
			let i=a1=0;
			for(let k=0;k<ceil(l/2);k++)a1+=L[O+i++];
			a1=a1/ceil(l/2)|0;a2=0;
			for(let k=0;k<(l/2|0);k++)a2+=L[O+i++];
			a2=a2/(l/2|0)|0;
			if(compareValues(a1,a2)>0){
				T=[];
				i=0;
				for(let k=0;k<(l/2|0);k++){
					T.push(L[O+i]);
					await write(L,O+i,L[O+l/2+i++|0],1,true);
				}
				for(let k=0;k<(l/2|0);k++)await write(L,O+i,T[i++-l/2|0],1,true);
			}
		}
		async function avgLeft(L,T,l){
			let i=0;a1=0;
			for(let k=0;k<ceil(l/4);k++)a1+=L[O+i++];
			a1=a1/ceil(l/4)|0;a2=0;
			for(let k=0;k<(l/4|0);k++)a2+=L[O+i++];
			a2=a2/(l/4|0)|0;
			if(compareValues(a1,a2)>0){
				T=[];i=0;
				for(let k=0;k<(l/4|0);k++){
					T.push(L[O+i]);
					await write(L,O+i,L[O+l/4+i++|0],1,true);
				}
				for(let k=0;k<(l/4|0);k++)await write(L,O+i,T[i++-l/4|0],1,true);
			}
		}
		async function avgRight(L,T,l){
			let i=l/2|0;a1=0;
			for(let k=0;k<ceil(l/4);k++)a1+=L[O+i++];
			a1=a1/ceil(l/4)|0;a2=0;
			for(let k=0;k<(l/4|0);k++)a2+=L[O+i++];
			a2=a2/(l/4|0)|0;
			if(compareValues(a1,a2)>0){
				T=[];i=l/2|0;
				for(let k=0;k<(l/4|0);k++){
					T.push(L[O+i]);
					await write(L,O+i,L[O+l/4+i++|0],1,true);
				}
				for(let k=0;k<(len/4|0);k++)await write(L,O+i,T[i++-3*(l/4|0)],1,true);
			}
		}
		async function weave(L,T,T2,l){
			let i=0;T=[];T2=[];
			for(let k=0;k<ceil(l/2);k++)T.push(L[O+i++]);
			for(let k=0;k<(l/2|0);k++)T2.push(L[O+i++]);
			i=1;
			while(i<=l){
				await write(L,O+i-1,T[ceil(i/2)-1],1,true);
				if(i<l)await write(L,O+i,T2[ceil(i/2)-1],1,true);
				i+=2;
			}
		}
		async function getMedianPivot(L,T,T2,l){
			let i=0,j=0;T=[];P=(L[O]+L[O+l-1])/2|0;
			for(let k=0;k<l;k++){
				if(compareValues(L[O+i],P)>0)await write(L,O+j++,L[O+i],1,true);
				else T.push(L[O+i]);
				i++;
			}
			i=0;
			for(let k=0;k<T.length;k++)await write(L,O+j++,T[i++],1,true);
		}
		async function circleSort(A,a,b){
			let t=0,n=1,i=0;
			for(;n<b;n*=2,t++);t=t/2|0;
			do if(++i>=t){
				await binaryInsertion(A,a,b);
				break;
			}while(await iterativeCircleSortRoutine(A,n,1));
		}
		async function sort(A,a,b){
			let l=b-a,T=[],T2=[];O=a;
			for(let i=0;i<2;i++){
				await avgList(A,T,l);
				await avgLeft(A,T,l);
				await avgRight(A,T,l);
				await weave(A,T,T2,l);
				await weave(A,T,T2,l);
				await getMedianPivot(A,T,T2,l);
			}
			await circleSort(A,a,b);
		}
		let a1,a2,P,O;
		await sort(arr,0,len);
	}
	async baseNWeaveSort(len){
		let base=askForNum(16,"Base",1);
		async function innerSort(A,s,e,r){
			if(s==e)return;
			if(s+r>=e)return await insertionSort(A,s,e);
			let m=(e-s>>1)+s;
			await innerSort(A,s,m,r);
			await innerSort(A,m,e,r);
		}
		async function insertionSort(A,s,e){
			for(let i=s+1;i<=e;i++){
				let m=i-1;
				while(m>=s&&compareIndices(A,m,i)>0)m--;
				await multiSwap(A,i,m+1,0,true);
			}
		}
		async function sort(A,e,p){
			let T=new Array(e),n=ceil(e/p),l=0,r=n;
			while(r<e){
				await binaryInsertion(A,l,r+1,.025);
				if(r==e-1)break;
				l=r;r+=n;
				if(r>=e)r=e-1;
			}
			let rI=0,wI=0,t=n;
			while(t>0){
				while(rI<e){
					write(T,wI++,A[rI],0,false,true);
					rI+=n;
				}
				rI=n-(--t);
			}
			await arraycopy(T,0,A,0,e,.1,true);
			await binaryInsertion(A,0,e,.1);
		}
		await sort(arr,len,base);
	}
	async optimizedPDMergeSort(len){
		async function mU(A,s,m,e){
			for(let i=0;i<m-s;i++)write(c,i,A[i+s],true);
			let P=0,l=s,r=m;
			while(l<r&&r<e)
				if(compareValues(c[P],A[r])<1)await write(A,l++,c[P++],0,true);
				else await write(A,l++,A[r++],0,true);
			while(l<r)await write(A,l++,c[P++],0,true);
		}
		async function mD(A,s,m,e){
			for(let i=0;i<e-m;i++)write(c,i,A[i+m],true);
			let P=e-m-1,l=m-1,r=e-1;
			while(r>l&&l>=s)
				if(compareValues(A[l],c[P])<1)await write(A,r--,c[P--],0,true);
				else await write(A,r--,A[l--],0,true);
			while(r>l)await write(A,r--,c[P--],0,true);
		}
		function mr(A,l,r,e){
			return e-r<r-l?mD(A,l,r,e):mU(A,l,r,e);
		}
		function compare(a,b){
			return compareValues(a,b)<1;
		}
		async function insertSort(A,s,m,e){
			let p,c;
			for(let i=m;i<e;i++){
				c=A[i];p=i-1;
				while(p>=s&&compareValues(A[p],c)>0)await write(A,p+1,A[p--],.5,true);
				await write(A,p+1,c,.5,true);
			}
		}
		async function identifyRun(A,i,mI){
			let sI=i;
			if(i>=mI)return-1;
			let c=compare(A[i],A[++i]);
			while(i<mI){
				let cC=compare(A[i],A[i+1]);
				if(cC-c)break;
				i++;
			}
			if(!c)await reversal(A,sI,i,1,true);
			let l=i-sI+1;
			if(l<16){
				let e=minVal(sI+16,mI+1);
				await insertSort(A,sI,i+1,e);
				return e>mI?-1:e;
			}
			if(i>=mI)return-1;
			return i+1;
		}
		async function findRuns(A,e){
			let r=new Array(e/16+2|0),lR=0;C=0;
			while(lR+1){
				write(r,C++,lR,0,false,true);
				let nR=await identifyRun(A,lR,e);
				lR=nR;
			}
			return r;
		}
		let C,c=new Array(len/2|0),r=await findRuns(arr,len-1);
		while(C>1){
			for(let i=0;i<C-1;i+=2)await mr(arr,r[i],r[i+1],i+3>C?len:r[i+2]);
			for(let i=1,j=2;i<C;i++,j+=2,C--)write(r,i,r[j],0,false,true);
		}
	}
	async plasmaSort(len){
		async function rotate(A,p,a,b){
			await Rotations.holyGriesMills(A,p,a,b,1,true);
		}
		function leftBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])>0)i*=2;
			return leftBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function rotate2(A,a,m,b){
			let l=m-a,r=b-m;
			while(l>0&&r>0)
				if(r<l){
					await multiSwap(A,m-r,m,r);
					b-=r;m-=r;l-=r;
				}else{
					await multiSwap(A,a,m,l);
					a+=l;m+=l;r-=l;
				}
		}
		async function inPlaceMerge(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b){
				if(compareIndices(A,i,j)>0){
					k=leftExpSearch(A,j+1,b,A[i]);
					await rotate2(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
			}
		}
		async function collectKeys(A,s,kC,e){
			let mb=s,cI=s+1,lG=cI,bC=0,c;
			for(c=1;c<kC-s;c++){
				let n=A[cI],l=mb,h=lG,lB=bC;
				while(l<h){
					let m=l+(h-l)/2|0,p=compareValues(n,A[m]);
					if(p<0)h=m;
					else if(!p){
						bC++;
						break;
					}else l=m+1;
				}
				if(bC>0){
					if(bC>lB){
						c--;
						if(++cI>=e)break;
						continue;
					}
					await rotate(A,mb,lG-mb,bC);
					mb+=bC;lG=cI;l+=bC;bC=0;
				}
				let j=cI-1;
				while(j>=l)await write(A,j+1,A[j--],1,true);
				await write(A,l,n,1,true);
				lG++;
				if(++cI>=e)break;
			}
			if(mb-s)await rotate(A,s,mb-s,c);
			return c;
		}
		function getBufferSize(l){
			let z;
			for(z=1;z*z<l;z*=2);
			return z;
		}
		function getKeySize(b,l){
			return l/b|0;
		}
		async function mergeUnderBuffer(A,bZ,s,m,e,rP){
			if(rP)await rotate(A,s,m-s,e-m);
			for(let i=0;i<m-s;i++)await swap(A,i,s+i,.5,true);
			let bP=0,l=s,r=m;
			while(l<r&&r<e)
				if(compareIndices(A,bP,r)<1)await swap(A,bP++,l++,.25,true);
				else await swap(A,l++,r++,.25,true);
			while(l<r)await swap(A,bP++,l++,.25,true);
		}
		async function blockSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function mergeOverBuffer(A,bZ,s,m,e,kZ){
			resetKeys(kZ);
			let mK=K[kZ/2|0],blZ=bZ,i;
			for(i=s;i<e-blZ;i+=blZ){
				let iK=(i-s)/blZ|0,li=i,lk=iK;
				for(let j=i+blZ;j<e;j+=blZ){
					let jk=(j-s)/blZ|0,c=compareIndices(A,j,li);
					if(c<0||!c&&compareIndices(K,jk,lk)<0){
						li=j;lk=jk;
					}
				}
				if(li>i){
					await blockSwap(A,i,li,blZ);
					swap(K,(i-s)/blZ,lk,0,false,true);
				}
				if(iK>0)
					if(compareIndices(A,i-1,i)>0){
						let kI=(i-s)/blZ|0;
						await mergeUnderBuffer(A,bZ,i-blZ,i,i+blZ,K[kI-1]>mK&&K[kI-1]>K[kI]);
					}
			}
			let kI=kZ-1;
			await mergeUnderBuffer(A,bZ,i-blZ,i,i+blZ,K[kI-1]>mK&&K[kI-1]>K[kI]);
		}
		function resetKeys(c){
			for(let i=0;i<c;i++)write(K,i,i,0,false,true);
		}
		let K;
		async function sort(A,l){
			if(l<24)return await insertSort(A,0,l,.3);
			let bZ=getBufferSize(l);
			await collectKeys(A,0,bZ,l);
			let i,g;
			for(i=bZ+1;i<l;i+=2)if(compareIndices(A,i-1,i)>0)await swap(A,i-1,i,.5,true);
			for(g=2;g<bZ*2;g*=2){
				for(i=bZ;i+2*g<=l;i+=2*g)await mergeUnderBuffer(A,bZ,i,i+g,i+2*g,false);
				if(i+g<l)await mergeUnderBuffer(A,bZ,i,i+g,l,false);
			}
			K=new Array(getKeySize(bZ,l));
			for(;g<=l-bZ;g*=2){
				let kZ=2*g/bZ|0;
				for(i=bZ;i+2*g<=l;i+=2*g)await mergeOverBuffer(A,bZ,i,i+g,i+2*g,kZ);
				if(i+g<l)await mergeOverBuffer(A,bZ,i,i+g,l,kZ);
			}
			await sort(A,bZ);
			await inPlaceMerge(A,0,bZ,l);
		}
		await sort(arr,len);
	}
	async extraAdaptiveRemoteMergeSort(len){
		const GS=new GrailSorting();
		async function firstPhase(A,s,e){
			let p=e-1,t=A[e];
			while(p>=s&&compareValues(A[p],t)>0)await write(A,p+1,A[p--],1,true);
			await write(A,p+1,t,1,true);
		}
		async function lastPhase(A,s,e){
			let p=s+1,t=A[p-1];
			while(p<e&&compareValues(A[p],t)<0)await write(A,p-1,A[p++],1,true);
			await write(A,p-1,t,1,true);
		}
		async function lrMerge(A,T,s,m,e){
			if(s==m||m==e)return;
			if(m-s<e-m){
				arraycopy(A,s,T,0,m-s,0,false,true);
				let l=0,h=m,n=s;
				while(l<m-s&&h<e)
					if(compareValues(T[l],A[h])<1)await write(A,n++,T[l++],1,true);
					else await write(A,n++,A[h++],1,true);
				while(l<m-s)await write(A,n++,T[l++],1,true);
				return;
			}
			arraycopy(A,m,T,0,e-m,0,false,true);
			let l=m-1,h=e-m-1,n=e-1;
			while(l>=s&&h>=0)
				if(compareValues(A[l],T[h])>0)await write(A,n--,A[l--],1,true);
				else await write(A,n--,T[h--],1,true);
			while(h>=0)await write(A,n--,T[h--],1,true);
		}
		async function sort(A,ln){
			let t=(ln+1)/2|0,m=32;
			if(t<=m)return await binaryInsertion(A,0,ln,.2);
			let T=new Array(maxVal(m,sqrt(t)|0));
			for(let l=m;l<=t;l++){
				let p=0;
				if(l==m)for(let i=0;i<ln;i+=l)await binaryInsertion(A,i,minVal(i+l,ln),.25);
				else
					for(let i=0;i<ln;i+=l){
						let n=minVal(i+l,ln);
						if(i+l<=ln){
							if(!p)await firstPhase(A,i,n-1);
							else if(p==l-2)await lastPhase(A,i,n);
							else await lrMerge(A,T,i,i+l-p-1,i+l);
						}else if(i+l-p<=ln)await lrMerge(A,T,i,i+l-p-1,n);
						p=++p%(l-1);
					}
			}
			await GS.grailMergeWithoutBuffer(A,0,t,ln-t);
		}
		await sort(arr,len);
	}
	async potassiumSort(len){
		async function cycleReverse(A,a,m,b){
			let p0=a,p1=m-1,p2=m,p3=b-1,t;
			while(p0<p1&&p2<p3){
				t=A[p1];
				await write(A,p1--,A[p0],.5,true);
				await write(A,p0++,A[p2],.5,true);
				await write(A,p2++,A[p3],.5,true);
				await write(A,p3--,t,.5,true);
			}
			while(p0<p1){
				t=A[p1];
				await write(A,p1--,A[p0],.5,true);
				await write(A,p0++,A[p3],.5,true);
				await write(A,p3--,t,.5,true);
			}
			while(p2<p3){
				t=A[p2];
				await write(A,p2++,A[p3],.5,true);
				await write(A,p3--,A[p0],.5,true);
				await write(A,p0++,t,.5,true);
			}
			if(p0<p3)
				if(p3-p0>2)await reversal(A,p0,p3,1,true);
				else await swap(A,p0,p3,1,true);
		}
		async function multiSwap(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function multiSwapBW(A,a,b,l){
			for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else await cycleReverse(A,a,m,b);
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function expSearch(A,a,b,v,d,l){
			let i=1,a1,b1;
			if(d){
				while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
				a1=a+i/2|0;b1=minVal(b,a-1+i);
			}else{
				while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
				a1=maxVal(a,b-i+1);b1=b-i/2|0;
			}
			return binSearch(A,a1,b1,v,l);
		}
		async function insertSort(A,a,b){
			let i=a+1;
			if(i>=b)return;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				if(i-a<4)await swap(A,a,i-1,1,true);
				else await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)await insertTo(A,i,expSearch(A,a,i,A[i],false,false));
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=expSearch(A,m,b,A[a],true,true);
				await rotate(A,a,m,i);
				let t=i-m;m=i;a+=t+1;
				if(a>=m)break;
				a=expSearch(A,a,m,A[m],true,false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=expSearch(A,a,m,A[b-1],false,false);
				await rotate(A,i,m,b);
				let t=m-i;m=i;b-=t+1;
				if(m<=a)break;
				b=expSearch(A,m,b,A[m-1],false,true);
			}
		}
		async function merge(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return false;
			a=expSearch(A,a,m,A[m],true,false);
			b=expSearch(A,m,b,A[m-1],false,true);
			if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
			return true;
		}
		async function diamondMerge(A,a,m,b,l){
			if(a>=m||m>=b)return true;
			if(minVal(m-a,b-m)<=l)return await merge(A,a,m,b);
			let q=(minVal(m-a,b-m)-1)/2+1|0;
			if(await diamondMerge(A,m-q,m,m+q,l)){
				await diamondMerge(A,a,m-q,m,l);
				await diamondMerge(A,m,m+q,b,l);
				await diamondMerge(A,a+q,m,b-q,l);
				return true;
			}
			return false;
		}
		async function stoogeSort(A,a,b,l){
			if(b-a<=l)return await insertSort(A,a,b);
			let m=a+(b-a)/2|0;
			await stoogeSort(A,a,m,l);
			await stoogeSort(A,m,b,l);
			await diamondMerge(A,a,m,b,l);
		}
		async function partition(A,a,b,p){
			let i=a,j=b;
			await swap(A,a,p,1,true);
			while(1){
				do i++;while(i<j&&compareIndices(A,i,a)<0);
				do j--;while(j>=i&&compareIndices(A,j,a)>0);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,a,j,1,true);
					return j;
				}
			}
		}
		function medOf3(A,l0,l1,l2){
			if(compareIndices(A,l0,l1)>0)[l0,l1]=[l1,l0];
			if(compareIndices(A,l1,l2)>0){
				[l1,l2]=[l2,l1];
				if(compareIndices(A,l0,l1)>0)return l0;
			}
			return l1;
		}
		function medOfMed(A,s,e,d){
			if(e-s<9||d<1)return medOf3(A,s,s+(e-s)/2|0,e);
			let v=(e-s)/8|0;
			return medOf3(A,medOfMed(A,s,s+2*v,--d),medOfMed(A,s+3*v,s+5*v,d),medOfMed(A,s+6*v,e,d));
		}
		async function getSortedRuns(A,a,b){
			let rS=true,s=true;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				if(c>0)s=false;
				else rS=false;
				if(!rS&&!s)return false;
			}
			if(rS&&!s)await reversal(A,a,b-1,1,s=true);
			return s;
		}
		async function sort(A,a,b,t){
			while(b-a>t){
				if(await getSortedRuns(A,a,b))return;
				let pI=medOfMed(A,a,b-1,log(b-a)/log(6)|0),p=await partition(A,a,b,pI);
				if(b-p-1<p-a){
					await sort(A,p+1,b,t);
					b=p;
				}else{
					await sort(A,a,p,t);
					a=p+1;
				}
			}
			await stoogeSort(A,a,b,sqrt(b-a-1)+1|0);
		}
		await sort(arr,0,len,pow(len,.67)|0);
	}
	async pureLogMergeSort(len){
		let base=askForNum(1,"Block size",1);
		function productLog(n){
			let r=1;
			while((r<<r)+r-1<n)r++;
			return r;
		}
		function log2(n){
			return 31-clz32(n);
		}
		function leftBinSearch(A,a,b,val){
			while(a<b){
				let m=(a+b)>>>1;
				if(compareValues(val,A[m])<1)
					b=m;
				else
					a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,val){
			while(a<b){
				let m=(a+b)>>>1;
				if(compareValues(val,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function pivCmp(v,p,c){
			return compareValues(v,p)<c;
		}
		async function pivBufXor(A,a,b,v,w){
			while(w-->0){
				if(v&1)await swap(A,a+w,b+w,1,true);
				v>>=1;
			}
		}
		function pivBufGet(A,a,p,c,w,b){
			let r=0;
			while(w-->0){
				r<<=1;r|=(pivCmp(A[a++],p,c)?0:1)^b;
			}
			return r;
		}
		async function blockCycle(A,p,n,p1,bL,w,v,c,b){
			for(let i=0;i<n;i++){
				let d=pivBufGet(A,p+i*bL,v,c,w,b);
				while(d-i){
					await blockSwap(A,p+i*bL,p+d*bL,bL);
					d=pivBufGet(A,p+i*bL,v,c,w,b);
				}
				await pivBufXor(A,p+i*bL,p1+i*bL,i,w);
			}
		}
		async function blockSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		async function rotate(A,a,m,b){
			await IndexedRotations.cycleReverse(A,a,m,b,1,true);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function blockMergeHelper(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(m-a<=2*bL)return await mergeFWExt(A,sw,a,m,b);
			let bC=0,wL=log2((b-a)/bL-3|0)+1,i=a,j=m,k=0,l=0,r=0,c=0;
			while(c++<2*bL)
				if(compareIndices(A,i,j)<1){
					write(sw,k++,A[i++],0,false,true);
					l++;
				}else{
					write(sw,k++,A[j++],0,false,true);
					r++;
				}
			let t=0,pc=p,lf=l>=r;k=lf?i-l:j-r;c=0;
			do{
				if(j==b||compareIndices(A,i,j)<1){
					await write(A,k++,A[i++],1,true);
					l++;
				}else{
					await write(A,k++,A[j++],1,true);
					r++;
				}
				if(++c==bL){
					await pivBufXor(A,k-bL,pc,t++,wL);
					if(lf)l-=bL;
					else r-=bL;
					lf=l>=r;k=lf?i-l:j-r;c=0;bC++;pc+=bL;
				}
			}while(i<m);
			let b1=j-c;
			await arraycopy(A,k-c,A,b1,c,1,true);
			r-=c;l=minVal(l,m-a-l);
			await arraycopy(A,a,A,m-l,l,1,true);
			await arraycopy(A,a+l,A,b1-r,r,1,true);
			await arraycopy(sw,0,A,a,2*bL,1,true);
			await blockCycle(A,a+2*bL,bC,p,bL,wL,pv,pC,bt);
		}
		async function blockMergeEasy(A,sw,a,m,b,p,bL,pv,pC,bt){
			if(b-m<=2*bL)return await mergeBWExt(A,sw,a,m,b);
			if(m-a<=2*bL)return await mergeFWExt(A,sw,a,m,b);
			let a1=a+(m-a)%bL;
			await blockMergeHelper(A,sw,a1,m,b,p,bL,pv,pC,bt);
			await mergeFWExt(A,sw,a,a1,b);
		}
		async function blockMerge(A,sw,a,m,b,bL){
			let l=m-a,r=b-m,lC=(l+r+1)/2|0,md;
			if(r<l){
				if(r<=bL)return await mergeBWExt(A,sw,a,m,b);
				let la=0,lb=r;
				while(la<lb){
					let lm=la+lb>>>1;
					if(compareIndices(A,m+lm,a+lC-lm-1)<1)la=lm+1;
					else lb=lm;
				}
				md=!la?A[a+lC-1]:compareIndices(A,m+la-1,a+lC-la-1)>0?A[m+la-1]:A[a+lC-la-1];
			}else{
				if(l<=bL)return await mergeFWExt(A,sw,a,m,b);
				let la=0,lb=l;
				while(la<lb){
					let lm=la+lb>>>1;
					if(compareIndices(A,a+lm,m+lC-lm-1)<0)la=lm+1;
					else lb=lm;
				}
				md=l==r&&la==l?A[m-1]:!la?A[m+lC-1]:compareIndices(A,a+la-1,m+lC-la-1)+1?A[a+la-1]:A[m+lC-la-1];
			}
			let m1=leftBinSearch(A,a,m,md),m2=rightBinSearch(A,m,b,md),ms2=m-rightBinSearch(A,m1,m,md),ms1=leftBinSearch(A,m,m2,md)-m;
			await rotate(A,m-ms2,m,m2);
			await rotate(A,m1,m-ms2,m+ms1-ms2);
			await blockMergeEasy(A,sw,a,m1,m1+ms1,a+lC,bL,md,0,0);
			await blockMergeEasy(A,sw,m2-ms2,m2,b,a,bL,md,1,1);
		}
		async function pureLogMergeSort(A,sw,a,b,bL){
			let j=16;
			for(let i=a;i<b;i+=j)await binaryInsertion(A,i,minVal(b,i+j),.25);
			for(;j<b-a;j*=2)for(let i=a;i+j<b;i+=2*j)await blockMerge(A,sw,i,i+j,minVal(b,i+2*j),bL);
		}
		let bL=maxVal(productLog(len),minVal(base,len));
		await pureLogMergeSort(arr,new Array(2*bL),0,len,bL);
	}
	async miniKitaSort(len){
		let BL;
		function inc(v,t,l,o,b,i){
			if((v[i]-o[i])%BL>(++v[i]-o[i])%BL)
				if(++l[i]>=b)v[i]=-1;
				else v[i]=o[i]+t[l[i]]*BL;
		}
		async function merge(A,B,s,m,e){
			arraycopy(A,m,B,0,e-m,0,false,true);
			let l=m-1,r=e-m-1,t=e;
			while(l>=s&&r>=0)
				if(compareValues(A[l],B[r])>0)await write(A,--t,A[l--],1,true);
				else await write(A,--t,B[r--],1,true);
			while(r>=0)await write(A,--t,B[r--],1,true);
		}
		async function blockmerge(A,B,T,T2,s,a,m,b){
			let md=s+(m-a)*BL,c=0,l=0,g=0,o=[s,md],ps=[s+T[a]*BL,md+T[m]*BL],bs=[...ps],cs=[0,0],tp=[a,m],tb=[a,m];
			for(let i=0;i<2*BL;i++)
				if(tp[0]<m&&(tp[1]==b||compareIndices(A,...ps)<1)){
					write(B,i,A[ps[0]],0,false,true);
					inc(ps,T,tp,o,m,0);cs[0]++;
				}else{
					write(B,i,A[ps[1]],0,false,true);
					inc(ps,T,tp,o,b,1);cs[1]++;
				}
			while(tp[0]<m||tp[1]<b){
				l=cs[0]<cs[1]?1:0;
				for(c=0;c++<BL;){
					if(tp[0]<m&&(tp[1]==b||compareIndices(A,...ps)<1)){
						await write(A,bs[l],A[ps[0]],.5,true);
						inc(ps,T,tp,o,m,0);cs[0]++;
					}else{
						await write(A,bs[l],A[ps[1]],.5,true);
						inc(ps,T,tp,o,b,1);cs[1]++;
					}
					inc(bs,T,tb,o,l>0?b:m,l);
				}
				cs[l]-=BL;
				write(T2,g++,T[tb[l]-1]+(m-a)*l,0,false,true);
			}
			let w=0,t=a;
			while(cs[0]>0){
				await arraycopy(B,w,A,s+T[tb[0]]*BL,BL,1,true);
				write(T,a++,T[tb[0]++],0,false,true);
				w+=BL;cs[0]-=BL;
			}
			while(cs[1]>0){
				await arraycopy(B,w,A,md+T[tb[1]]*BL,BL,1,true);
				write(T,a++,T[tb[1]++]+m-t,0,false,true);
				w+=BL;cs[1]-=BL;
			}
			arraycopy(T2,0,T,a,g,0,false,true);
		}
		async function index(A,T,X,a,b){
			for(let i=a,j=0;i<b;i+=BL,j++){
				if(!compareValues(j,X[j]))continue;
				arraycopy(A,i,T,0,BL,0,false,true);
				let k=j,n=X[j];
				do{
					await arraycopy(A,a+n*BL,A,a+k*BL,BL,1,true);
					write(X,k,k,0,false,true);
					n=X[k=n];
				}while(compareValues(j,n));
				await arraycopy(T,0,A,a+k*BL,BL,1,true);
				write(X,k,k,1,true);
			}
		}
		async function kita(A,a,c){
			if(c-a<33)return await binaryInsertion(A,a,c,.5);
			let sl=(31-clz32(c-a))/2|0,s=BL=1<<sl,b=c-(c-a)%s,k=(c-a)/s|0,B=new Array(2*s),t0=new Array(k),t1=new Array(k);
			for(let i=a;i<b;i+=16)await binaryInsertion(A,i,minVal(i+16,b),.5);
			for(let i=0;i<k;i++)write(t0,i,i%4,0,false,true);
			for(let j=16;j<b-a;j*=2)
				for(let i=a;i+j<b;i+=2*j){
					let p=minVal(i+2*j,b);
					if(j>2*s)await blockmerge(A,B,t0,t1,i,(i-a)/s|0,(i+j-a)/s|0,(p-a)/s|0);
					else await merge(A,B,i,i+j,p);
				}
			await index(A,B,t0,a,b);
			if(b<c){
				await kita(A,b,c);
				await merge(A,B,a,b,c);
			}
		}
		await kita(arr,0,len);
	}
	async strongHeapSort(len){
		function sibling(i){
			if(!i)return 0;
			return i+i%2-(i+1)%2;
		}
		function isLeaf(i,n){
			if(i%2)return sibling(i)>=n;
			return 2*i+1>=n;
		}
		async function strengtheningSiftDown(A,i,n){
			let x=A[i];
			while(!isLeaf(i,n)){
				let j=sibling(i);
				if(i%2<1)j=2*i+1;
				else if(j<n&&2*i+1<n&&compareIndices(A,2*i+1,j)<1)j=2*i+1;
				if(compareValues(x,A[j])<1)break;
				await write(A,i,A[j],.25,true);
				i=j;
			}
			await write(A,i,x,.25,true);
		}
		async function sort(A,l){
			for(let i=l;i>0;i--)await strengtheningSiftDown(A,i,l);
			for(let i=l;i>0;i--){
				let t=A[0];
				await write(A,0,A[i],.25,true);
				await strengtheningSiftDown(A,0,i);
				await write(A,i,t,.25,true);
			}
			await reversal(A,0,l-1,1,true);
		}
		await sort(arr,len);
	}
	async linkedIterativeQuickSort(len){
		async function quickSort(a,p,r){
			let ts=[{p,r}];
			while(ts.length){
				let t=ts.shift(),i=t.p,j=t.r,pv=t.p+(t.r-t.p)/2|0,x=a[pv];
				while(i<=j){
					while(compareValues(a[i],x)<0)i++;
					while(compareValues(a[j],x)>0)j--;
					if(i<=j)await swap(a,i++,j--,.1,true);
				}
				if(t.p<j)ts.push({p:t.p,r:j});
				if(i<t.r)ts.push({p:i,r:t.r});
			}
		}
		await quickSort(arr,0,len-1);
	}
	async countingSort(len){
		let m=analyzeMax(arr,len),o=[...arr],c=new Array(m+1).fill(0);
		for(let i=0;i<len;i++){
			await write(c,arr[i],c[arr[i]]+1,1,false,true);
			draw();mark(i);
		}
		for(let i=1;i<c.length;i++)await write(c,i,c[i]+c[i-1],1,true,true);
		for(let i=len-1;i>=0;i--){
			o[c[arr[i]]-1]=arr[i];c[arr[i]]--;
		}
		for(let i=len-1;i>=0;i--)await write(arr,i,o[i],1,true);
	}
	async twentyWayPopSort(len){
		let base=askForNum(1,"Order",1,32);
		async function bubbleSort(A,s,e,r){
			let sw=e,c=r?1:-1,j=0;
			while(sw>s){
				let ls=s;
				for(let i=s;i<sw-1;i++)if(compareIndices(A,i,i+1)==c){
					swap(A,i,ls=i+1);
					if(++j>(e-s)/2)await markSwap(i,ls,j=0);
				}
				sw=ls;
			}
		}
		async function bubblePop(A,s,e,r){
			let sw=e,c=r?1:-1,j=0;
			while(sw>s){
				let ls=s;
				for(let i=s;i<sw-1;i++)
					if(compareIndices(A,i,i+1)==c){
						swap(A,i,ls=i+1);
						if(++j>(e-s)/2)await markSwap(i,ls,j=0);
					}else if(ls>s)break;
				sw=ls;
			}
		}
		async function pop(A,s,e,o,i){
			if(s>=e)return;
			if(e-s<21)return await bubbleSort(A,s,e,!i);
			let w=(e-s+1)/20|0,t=(e-s+1)/10|0,f=(e-s+1)/5|0;
			if(o<1)await bubbleSort(A,s,e,!i);
			else if(o<2){
				await bubbleSort(A,s,s+w,i);
				await bubbleSort(A,s+w,s+t,!i);
				await bubbleSort(A,s+t,s+t+w,i);
				await bubbleSort(A,s+t+w,s+f,!i);
				await bubbleSort(A,s+f,s+f+w,i);
				await bubbleSort(A,s+f+w,s+f+t,!i);
				await bubbleSort(A,s+f+t,s+f+t+w,i);
				await bubbleSort(A,s+f+t+w,s+2*f,!i);
				await bubbleSort(A,s+2*f,s+2*f+w,i);
				await bubbleSort(A,s+2*f+w,s+2*f+t,!i);
				await bubbleSort(A,s+2*f+t,s+2*f+t+w,i);
				await bubbleSort(A,s+2*f+t+w,e-2*f,!i);
				await bubbleSort(A,e-2*f,e-2*f+w,i);
				await bubbleSort(A,e-2*f+w,e-2*f+t,!i);
				await bubbleSort(A,e-2*f+t,e-2*f+t+w,i);
				await bubbleSort(A,e-2*f+t+w,e-f,!i);
				await bubbleSort(A,e-f,e-f+w,i);
				await bubbleSort(A,e-f+w,e-f+t,!i);
				await bubbleSort(A,e-f+t,e-f+t+w,i);
				await bubbleSort(A,e-f+t+w,e,!i);
				await bubblePop(A,s,s+t,i);
				await bubblePop(A,s+t,s+f,!i);
				await bubblePop(A,s+f,s+f+t,i);
				await bubblePop(A,s+f+t,s+2*f,!i);
				await bubblePop(A,s+2*f,s+2*f+t,i);
				await bubblePop(A,s+2*f+t,e-2*f,!i);
				await bubblePop(A,e-2*f,e-2*f+t,i);
				await bubblePop(A,e-2*f+t,e-f,!i);
				await bubblePop(A,e-f,e-f+t,i);
				await bubblePop(A,e-f+t,e,!i);
				await bubblePop(A,s,s+f,!i);
				await bubblePop(A,s+f,s+2*f,!i);
				await bubblePop(A,s+2*f,e-2*f,i);
				await bubblePop(A,e-2*f,e-f,!i);
				await bubblePop(A,e-f,e,i);
				await bubblePop(A,e-2*f,e,i);
				await bubblePop(A,s+f,e-2*f,!i);
				await bubblePop(A,s+f,e,i);
				await bubblePop(A,s,e,!i);
			}else{
				await pop(A,s,s+w,o-1,!i);
				await pop(A,s+w,s+t,o-1,i);
				await pop(A,s+t,s+t+w,o-1,!i);
				await pop(A,s+t+w,s+f,o-1,i);
				await pop(A,s+f,s+f+w,o-1,!i);
				await pop(A,s+f+w,s+f+t,o-1,i);
				await pop(A,s+f+t,s+f+t+w,o-1,!i);
				await pop(A,s+f+t+w,s+2*f,o-1,i);
				await pop(A,s+2*f,s+2*f+w,o-1,!i);
				await pop(A,s+2*f+w,s+2*f+t,o-1,i);
				await pop(A,s+2*f+t,s+2*f+t+w,o-1,!i);
				await pop(A,s+2*f+t+w,e-2*f,o-1,i);
				await pop(A,e-2*f,e-2*f+w,o-1,!i);
				await pop(A,e-2*f+w,e-2*f+t,o-1,i);
				await pop(A,e-2*f+t,e-2*f+t+w,o-1,!i);
				await pop(A,e-2*f+t+w,e-f,o-1,i);
				await pop(A,e-f,e-f+w,o-1,!i);
				await pop(A,e-f+w,e-f+t,o-1,i);
				await pop(A,e-f+t,e-f+t+w,o-1,!i);
				await pop(A,e-f+t+w,e,o-1,i);
				await pop(A,s,s+t,o-1,!i);
				await pop(A,s+t,s+f,o-1,i);
				await pop(A,s+f,s+f+t,o-1,!i);
				await pop(A,s+f+t,s+2*f,o-1,i);
				await pop(A,s+2*f,s+2*f+t,o-1,!i);
				await pop(A,s+2*f+t,e-2*f,o-1,i);
				await pop(A,e-2*f,e-2*f+t,o-1,!i);
				await pop(A,e-2*f+t,e-f,o-1,i);
				await pop(A,e-f,e-f+t,o-1,!i);
				await pop(A,e-f+t,e,o-1,i);
				await pop(A,s,s+f,o-1,i);
				await pop(A,s+f,s+2*f,o-1,i);
				await pop(A,s+2*f,e-2*f,o-1,!i);
				await pop(A,e-2*f,e-f,o-1,i);
				await pop(A,e-f,e,o-1,!i);
				await pop(A,e-2*f,e,o-1,!i);
				await pop(A,s+f,e-2*f,o-1,i);
				await pop(A,s+f,e,o-1,!i);
				await pop(A,s,e,o-1,i);
			}
		}
		await pop(arr,0,len,base,false);
	}
	async badThirtySort(len){
		let s=true;
		for(let d=1;s;d=-d)for(let i=0,e=s=false;i<len&&!e;i++)for(let j=d>0?i+1:len-1;(d>0&&j<len||d<0&&j>i)&&!e;j+=d)if(compareIndices(arr,i,j)>0)await swap(arr,i,j,.001,s=e=true);
	}
	async gnomePopSort(len){
		async function gnome(A,s,e,v){
			let c=v?-1:1,k=0;
			for(let i=s+1;i<e;i++){
				let j=i-1;
				while(j>=s&&compareIndices(A,j,j+1)==c){
					swap(A,j,j--+1);
					if(++k>(e-s)/2)await markSwap(j+1,j+2,k=0);
				}
			}
		}
		async function pop(A,s,e,o,v){
			if(s>=e)return;
			if(e-s<5||o<1)return await gnome(A,s,e,!v);
			let q=(e-s+1)/4|0;
			if(o<2){
				await gnome(A,s,s+q,v);
				await gnome(A,s+q,e-2*q,!v);
				await gnome(A,s,e-2*q,!v);
				await gnome(A,e-2*q,e-q,!v);
				await gnome(A,e-q,e,v);
				await gnome(A,e-2*q,e,v);
				await gnome(A,s,e,v);
			}else{
				await pop(A,s,s+q,o-1,v);
				await pop(A,s+q,e-2*q,o-1,!v);
				await pop(A,s,e-2*q,o-1,!v);
				await pop(A,e-2*q,e-q,o-1,!v);
				await pop(A,e-q,e,o-1,v);
				await pop(A,e-2*q,e,o-1,v);
				await pop(A,s,e,o-1,v);
			}
		}
		await pop(arr,0,len,1+log2(len)/2|0,false);
	}
	async unoptimizedReverseBubbleSort(len){
		let s=1;
		while(s){
			s=0;
			for(let i=len-1;i>0;i--)if(compareIndices(arr,i-1,i)>0)await swap(arr,i-1,i,.075,s=true);
		}
	}
	async altQuasimiddleSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0){
				await swap(A,a,b,.05,true);
				return true;
			}
			return false;
		}
		async function middle(A,s,e){
			let m=s+(e-s)/2|0,w=false,t=false;
			for(let i=1;m-i>=s&&m+i<=e;i++){
				if(t=await cs(A,m-i,m))w=true;
				if(t=await cs(A,m,m+i))w=true;
				if(t=await cs(A,m-i,m))w=true;
			}
			return w;
		}
		async function sort(A,l){
			let s=true;
			while(s){
				let t=s=false;
				for(let i=1;i<l;i++){
					if(t=await middle(A,0,i))s=true;
					if(t=await middle(A,i,l-1))s=true;
				}
			}
		}
		await sort(arr,len);
	}
	async firingSquadSortIterative(len){
		async function firingSquad(A,s,e,d){
			if(d){
				let l=s,r=s+1,lc=1,rc=true;
				while(l<r){
					if(compareIndices(A,l,r)>0)await swap(A,l,r,1,sw=true);
					if(++lc>2){
						l++;lc=0;
					}
					if(rc){
						if(++r>e-1){
							r--;rc=false;
						}
					}else r--;
				}
			}else{
				let r=e-1,l=e-2,rc=1,lc=true;
				while(l<r){
					if(compareIndices(A,l,r)>0)await swap(A,l,r,1,sw=true);
					if(++rc>2){
						r--;rc=0;
					}
					if(lc){
						if(--l<s){
							l++;lc=false;
						}
					}else l++;
				}
			}
		}
		async function init(A,s,e,f){
			await firingSquad(A,s,e,f);
			let d=true;
			for(let l=(e-s)/2|0;l>1;l=l/2|0)for(let i=s;i+l<=e;i+=l)await firingSquad(A,i,i+l,d=!d);
		}
		let d=false,sw=true,l=2;
		for(;l<=len;l*=2);l=l/2|0;
		while(sw){
			sw=false;
			if(l==len)await init(arr,0,len,d=!d);
			else{
				await init(arr,0,l,true);
				if(len-l>=(l/2|0))await init(arr,(len-l)/2|0,(len+l)/2|0,true);
				await init(arr,len-l,len,false);
			}
		}
	}
	async firingSquadSortRecursive(len){
		async function firingSquad(A,s,e,d){
			if(d){
				let l=s,r=s+1,lc=1,rc=true;
				while(l<r){
					if(compareIndices(A,l,r)>0)await swap(A,l,r,.1,sw=true);
					if(++lc>2){
						l++;lc=0;
					}
					if(rc){
						if(++r>e-1){
							r--;rc=false;
						}
					}else r--;
				}
			}else{
				let r=e-1,l=e-2,rc=1,lc=true;
				while(l<r){
					if(compareIndices(A,l,r)>0)await swap(A,l,r,.1,sw=true);
					if(++rc>2){
						r--;rc=0;
					}
					if(lc){
						if(--l<s){
							l++;lc=false;
						}
					}else l++;
				}
			}
			if(e-s>2){
				await firingSquad(A,s,e-(e-s)/2|0,false);
				await firingSquad(A,e-(e-s)/2|0,e,true);
			}
		}
		let d=false,sw=true,l=2;
		for(;l<=len;l*=2);l=l/2|0;
		while(sw){
			sw=false;
			if(l==len)await firingSquad(arr,0,len,d=!d);
			else{
				await firingSquad(arr,0,l,true);
				if(len-l>=(l/2|0))await firingSquad(arr,(len-l)/2|0,(len+l)/2|0,true);
				await firingSquad(arr,len-l,len,false);
			}
		}
	}
	async feruSort(len){
		function ceilLogEven(v){
			let l=0;
			for(;v>0;v=v/2|0)l++;
			return l%2<1;
		}
		let bS,bE;
		async function multiSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		async function merge(A,B,s,m,e,rv){
			let t=s,l=s,r=m,a=rv?B:A,b=rv?A:B;
			if(compareIndices(a,m-1,m)<1){
				await arraycopy(a,s,b,s,e-s,.1,true,!rv);
				return false;
			}
			if(compareIndices(a,s,e-1)+1){
				await arraycopy(a,s,b,s+e-m,m-s,.1,true,!rv);
				await arraycopy(a,m,b,s,e-m,.1,true,!rv);
				return false;
			}
			while(l<m&&r<e)
				if(compareIndices(a,l,r)<1)await write(b,t++,a[l++],1,true,!rv);
				else await write(b,t++,a[r++],1,true,!rv);
			while(l<m)await write(b,t++,a[l++],1,true,!rv);
			while(r<e)await write(b,t++,a[r++],1,true,!rv);
			return true;
		}
		async function mergeSort(A,t,s,e,x){
			let m=s+(e-s)/2|0;
			if(e-s<32&&!x){
				await insertSort(A,s,e,.1);
				return false;
			}
			await mergeSort(A,t,s,m,!x);
			await mergeSort(A,t,m,e,!x);
			return await merge(A,t,s,m,e,!x);
		}
		async function quMerge(A,s,m,e){
			await arraycopy(A,s,A,bS,m-s,1,true);
			let l=bS,r=m,t=s;
			while(l<bS+m-s&&r<e)
				if(compareIndices(A,l,r)<1)await write(A,t++,A[l++],1,true);
				else await write(A,t++,A[r++],1,true);
			let q=t;
			while(l<bS+m-s)await write(A,t++,A[l++],1,true);
			return q;
		}
		async function oopRotate(A,s,m,e){
			if(e-m>m-s){
				await arraycopy(A,s,A,bS,m-s,1,true);
				await arraycopy(A,m,A,s,e-m,1,true);
				await arraycopy(A,bS,A,s+e-m,m-s,1,true);
			}else{
				await arraycopy(A,m,A,bS,e-m,1,true);
				await arraycopy(A,s,A,s+e-m,m-s,1,true);
				await arraycopy(A,bS,A,s,e-m,1,true);
			}
		}
		function binSearch(A,s,e,k,l){
			while(s<e){
				let m=s+(e-s)/2|0,c=compareValues(A[m],k);
				if(c>0||l&&!c)e=m;
				else s=m+1;
			}
			return s;
		}
		async function feruMerge(A,s,m,e){
			let bZ=bE-bS;
			if(e-s<=bZ){
				let l=s,r=m,t=bS;
				while(l<m&&r<e)
					if(compareIndices(A,l,r)<1)await write(A,t++,A[l++],1,true);
					else await write(A,t++,A[r++],1,true);
				while(l<m)await write(A,t++,A[l++],1,true);
				while(r<e)await write(A,t++,A[r++],1,true);
				await arraycopy(A,bS,A,s,e-s,1,true);
			}else if(m-s<=bZ){
				await arraycopy(A,s,A,bS,m-s,1,true);
				let l=bS,r=m,t=s;
				while(l<bS+m-s&&r<e)
					if(compareIndices(A,l,r)<1)await write(A,t++,A[l++],1,true);
					else await write(A,t++,A[r++],1,true);
				while(l<bS+m-s)await write(A,t++,A[l++],1,true);
			}else if(e-m<=bE-bS){
				await arraycopy(A,m,A,bS,e-m,1,true);
				let l=m-1,r=bS+e-m-1,t=e-1;
				while(l>=s&&r>=bS)
					if(compareIndices(A,l,r)>0)await write(A,t--,A[l--],1,true);
					else await write(A,t--,A[r--],1,true);
				while(r>=bS)await write(A,t--,A[r--],1,true);
			}else{
				let lL=(m-s)%bZ,lR=(e-m)%bZ;
				if(lL)await oopRotate(A,m-lL,m,e-lR);
				m-=lL;e-=lR+lL;
				if(e-s<=2*bZ)await feruMerge(A,s,m,e);
				else{
					let bl=(e-s)/bZ|0;
					for(let i=0;i<bl-1;i++){
						let n=i;
						for(let j=i+1;j<bl;j++)if(compareIndices(A,s+n*bZ,s+j*bZ)>0)n=j;
						let w=s+i*bZ;
						if(n-i)await multiSwap(A,w,s+n*bZ,bZ);
					}
					for(let i=1,d=s;i<bl;i++){
						let w=s+i*bZ;
						d=await quMerge(A,d,w,w+bZ);
					}
				}
				if(lR||lL){
					await feruMerge(A,e,e+lL,e+lL+lR);
					await feruMerge(A,binSearch(A,s,e,A[e],true),e,binSearch(A,e,e+lL+lR,A[e-1],false));
				}
			}
		}
		async function feruHalfMerge(A,T,a,b,t,c,d){
			while(c<d&&a<b)
				if(compareValues(T[a],A[c])<1)await write(A,t++,T[a++],1,true);
				else await write(A,t++,A[c++],1,true);
			while(a<b)await write(A,t++,T[a++],1,true);
		}
		async function feruMergeSort(A,s,e){
			let m=s+(e-s)/2|0;
			if(s==m)return;
			await feruMergeSort(A,s,m);
			await feruMergeSort(A,m,e);
			await feruMerge(A,s,m,e);
		}
		async function feru(A,s,e){
			if(e-s<16)return await insertSort(A,s,e,.2);
			let z=(e-s)/16|0,T=new Array(z),cl=ceilLogEven(e-s);
			await mergeSort(A,T,s,s+z,cl);
			if(!cl)arraycopy(A,s,T,0,z,0,false,true);
			bS=s;bE=s+z;
			await feruMergeSort(A,s+z,e);
			await feruHalfMerge(A,T,0,z,s,s+z,e);
		}
		await feru(arr,0,len);
	}
	async bottomDownMergeSort(len){
		class AC{
			constructor(s,e,b){
				this.s=s;this.e=e;this.b=b;
			}
			async run(){
				await arraycopy(X,this.s,M,this.s,this.e-this.s,1,true);
			}
		}
		async function merge(q,s,m,e){
			let l=s,r=m,t=s,b=0;
			if(e-s>0){
				if(compareIndices(M,m-1,m)<0)return;
				if(compareIndices(M,s,e-1)>0)return await IndexedRotations.cycleReverse(M,s,m,e,.2,true);
			}else return;
			while(l<m&&r<e){
				if(compareIndices(M,l,r)<1){
					write(X,t++,M[l++],0,false,true);
					b=(b<<1)+1;
				}else{
					write(X,t++,M[r++],0,false,true);
					b=(b>>>1)-1;
				}
			}
			if(l==r)return;
			let z=t;
			while(l<m){
				await write(M,z++,M[l++],1,true);
				b=(b>>>1)+b+1;
			}
			while(r++<e)b=(b>>>1)-1;
			q.add(new AC(s,t,b));
		}
		let M,X;
		async function sort(A,l){
			let q=new PriorityQueue((a,b)=>a.b-b.b),i=2;M=A;X=new Array(l);
			for(;i<=l;i*=2){
				for(let j=0;j<l;j+=i)
					if(j+i<l)await merge(q,j,j+i/2|0,j+i);
					else await merge(q,j,j+i/2|0,l);
				while(q.size())await q.poll().run();
			}
			if(i/2-l|0){
				await merge(q,0,i/2|0,l);
				await q.poll().run();
			}
		}
		await sort(arr,len);
	}
	async MOMPriorityQuickSort(len){
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function medianOfMedians(A,a,b,s){
			let e=b,st=a,i,j,d=true;
			while(e-st>1){
				j=st;
				for(i=st;i+2*s<=e;i+=s){
					await insertSort(A,i,i+s,.1);
					await swap(A,j++,i+s/2,1,true);
				}
				if(i<e){
					await insertSort(A,i,e,.1);
					await swap(A,j++,i+(e-(d?1:0)-i)/2,1,true);
					if((e-i)%2<1)d=!d;
				}
				e=j;
			}
		}
		async function partition(A,a,b,p){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,p,j,1,true);
					return j;
				}
			}
		}
		async function quickSort(A,s,e){
			if(e-s<32)return await insertSort(A,s,e,.5);
			let q=new PriorityQueue((a,b)=>a.n<b.n?1:-1);
			q.add({a:s,b:e,n:e-s});
			while(q.size()){
				let p=q.poll(),{a,b,n}=p;
				await medianOfThree(A,a,b);
				let m=await partition(A,a,b,a),l=m-a,r=b-m-1;
				if(l/n<.0625||r/n<.0625){
					await medianOfMedians(A,a,b,5);
					m=await partition(A,a,b,a);
				}
				if(m-a>31)q.add({a,b:m,n:m-a});
				else await insertSort(A,a,m,.5);
				if(b-m>32)q.add({a:m+1,b,n:b-m-1});
				else await insertSort(A,m+1,b,.5);
			}
		}
		await quickSort(arr,0,len);
	}
	async dualPivotLLLPriorityQuickSort(len){
		function part(a,b,d){
			return{a,b,d,n:b-a};
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)await write(A,i,A[i+d],0,true);
				await write(A,b,t,.5,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		function pC(A,i,a,b,d){
			let v=A[i],c=compareValues(v,a);
			if(c<0||d&&!c)return-1;c=compareValues(v,b);
			if(c>0||d&&!c)return 1;
			return 0;
		}
		async function partition(A,a,b,p1,p2,bs){
			let i=a,j=a;
			for(let k=a;k<b;k++){
				let c=pC(A,k,p1,p2,bs);
				if(c<1){
					let t=A[k];
					await write(A,k,A[j],.25,true);
					if(c<0){
						await write(A,j,A[i],.25,true);
						await write(A,i++,t,.25,true);
					}else await write(A,j,t,.25,true);
					j++;
				}
			}
			return[i,j];
		}
		async function consumePartition(A,q,a,b,d){
			if(b-a>32)q.add(part(a,b,d));
			else await insertSort(A,a,b);
		}
		async function innerSort(A,l,r){
			if(r-l<33)return await insertSort(A,l,r);
			let q=new PriorityQueue((a,b)=>b.n-a.n);
			q.add(part(l,r,3));
			while(q.size()){
				let p=q.poll(),{a,b,d,n}=p,p1,p2,s=n/d|0,pC=compareIndices(A,a+s,b-1-s);
				if(pC>0){
					p1=A[b-1-s];
					p2=A[a+s];
				}else{
					p1=A[a+s];
					p2=A[b-1-s];
				}
				let[m1,m2]=await partition(A,a,b,p1,p2,pC);
				if(!pC&&m2-m1==b-a)continue;
				if(minVal(m1-a,minVal(m2-m1,b-m2))<33)d++;
				await consumePartition(A,q,a,m1,d);
				if(pC)await consumePartition(A,q,m1,m2,d);
				await consumePartition(A,q,m2,b,d);
			}
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.1,true);
				else await reversal(A,a,b-1,.1,true);
				return;
			}
			await innerSort(A,a,b);
		}
		await quickSort(arr,0,len);
	}
	async shufflePriorityQuickSort(len){
		function part(a,b,bA){
			return{a,b,bA,n:b-a};
		}
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function medianOfThree(A,a,b){
			let m=a+(b-1-a)/2;
			if(compareIndices(A,a,m)>0)await swap(A,a,m,1,true);
			if(compareIndices(A,m,b-1)>0){
				await swap(A,m,b-1,1,true);
				if(compareIndices(A,a,m)>0)return;
			}
			await swap(A,a,m,1,true);
		}
		async function shuffle(A,a,b){
			let r=new Random();
			for(let i=a;i<b;i++)await swap(A,i,i+r.nextInt(b-i),.75,true);
		}
		async function partition(A,a,b,p){
			let i=a,j=b;
			while(1){
				do i++;while(i<j&&compareIndices(A,i,p)<0);
				do j--;while(j>=i&&compareIndices(A,j,p)>0);
				if(i<j)await swap(A,i,j,1,true);
				else{
					await swap(A,p,j,1,true);
					return j;
				}
			}
		}
		async function insertTo(A,a,b){
			let t=A[a],c=false;
			while(a>b)await write(A,a,A[--a],.25,c=true);
			if(c)await write(A,b,t,.25,true);
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function siftDown(A,v,i,p,n){
			while(4*i+1<n){
				let m=v,nx=i,c=4*i+1;
				for(let j=c;j<minVal(c+4,n);j++)if(compareValues(A[p+j],m)>0)max=A[p+(nx=j)];
				if(nx==i)break;
				await write(A,p+i,m,1,true);
				i=nx;
			}
			await write(A,p+i,v,1,true);
		}
		async function heapSort(A,a,b){
			let n=b-a;
			for(let i=(n-1)/4|0;i>=0;i--)await siftDown(A,A[a+i],i,a,n);
			for(let i=n-1;i>0;i--){
				let t=A[a+i];
				await write(A,a+i,A[a],1);
				await siftDown(A,t,0,a,i);
			}
		}
		async function innerSort(A,s,e){
			if(e-s<33)return await insertSort(A,s,e);
			let q=new PriorityQueue((a,b)=>a.n<b.n?1:-1);
			q.add(part(s,e,log2(e-s)));
			sL:while(q.size()){
				let p=q.poll(),{a,b,bA,n}=p;
				await medianOfThree(A,a,b);
				let m=await partition(A,a,b,a),l=m-a,r=b-m-1;
				while(l<(n/16|0)||r<(n/16|0)){
					if(--bA<1){
						await heapSort(A,a,b);
						continue sL;
					}
					await shuffle(A,a,b);
					await medianOfThree(A,a,b);
					m=await partition(A,a,b,a);
					l=m-a;r=b-m-1;
				}
				if(l>31)q.add(part(a,m,bA));
				else await insertSort(A,a,m);
				if(r>31)q.add(part(m+1,b,bA));
				else await insertSort(A,m+1,b);
			}
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.5,true);
				else await reversal(A,a,b-1,.5,true);
				return;
			}
			await innerSort(A,a,b);
		}
		await quickSort(arr,0,len);
	}
	async dualPivotPriorityQuickSort(len){
		function part(a,b,d){
			return{a,b,d,n:b-a};
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
				await write(A,b,t,.5,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function partitionTernary(A,a,b,p){
			let i=a,j=b;
			for(let k=i;k<j;k++)
				if(compareIndexValue(A,k,p)<0)await swap(A,k,i++,.5,true);
				else if(compareIndexValue(A,k,p)>0){
					do j--;while(k<j&&compareIndexValue(A,j,p)>0);
					await swap(A,k,j,.5,true,false);
					if(compareIndexValue(A,k,p)<0)await swap(A,k,i++,.5,true);
				}
			return[i,j];
		}
		async function partition(A,a,b,p1,p2){
			let i=a,j=b;
			for(let k=i;k<j;k++)
				if(compareIndexValue(A,k,p1)<1)await swap(A,k,i++,.5,true);
				else if(compareIndexValue(A,k,p2)+1){
					do j--;while(k<j&&compareIndexValue(A,j,p2)+1);
					await swap(A,k,j,.5,true);
					if(compareIndexValue(A,k,p1)<1)await swap(A,k,i++,.5,true);
				}
			return[i,j];
		}
		async function consumePartition(A,q,a,b,d){
			if(b-a>16)q.add(part(a,b,d));
			else await insertSort(A,a,b);
		}
		async function innerSort(A,l,r){
			if(r-l<17)return await insertSort(A,l,r);
			let q=new PriorityQueue((a,b)=>b.n-a.n);
			q.offer(part(l,r,3));
			while(q.size()){
				let p=q.poll(),{a,b,d,n}=p,p1,p2,s=n/d|0,pC=compareIndices(A,a+s,b-1-s);
				if(pC>0){
					p1=A[b-1-s];
					p2=A[a+s];
				}else{
					p1=A[a+s];
					p2=A[b-1-s];
				}
				let[m1,m2]=!pC?await partitionTernary(A,a,b,p1):await partition(A,a,b,p1,p2);
				if(!pC&&m2-m1==b-a)continue;
				if(minVal(m1-a,minVal(m2-m1,b-m2))<17)d++;
				await consumePartition(A,q,a,m1,d);
				if(pC)await consumePartition(A,q,m1,m2,d);
				await consumePartition(A,q,m2,b,d);
			}
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.5,true);
				else await reversal(A,a,b-1,.5,true);
			}else await innerSort(A,a,b);
		}
		await quickSort(arr,0,len);
	}
	async unstableLogPartitionSort(len){
		const GS=new GrailSorting();
		async function log(v){
			return 32-clz32(v-1);
		}
		class BitArray{
			constructor(A,a,b,z,w){
				this.A=A;this.a=a;this.b=b;this.z=z;this.w=w;
			}
			async flipBit(a,b){
				await swap(this.A,a,b,.1,true);
			}
			getBit(a,b){
				return compareIndices(this.A,a,b)>0;
			}
			async xor(d,u){
				if(d<0||d>=this.z)return;
				let s=d*this.w,i1=this.a+s+this.w;
				for(let i=this.a+s,j=this.b+s;i<i1;i++,j++,u>>=1)if(u&1)await this.flipBit(i,j);
			}
			get(d){
				if(d<0||d>=this.z)return;
				let r=0,s=d*this.w;
				for(let k=0,i=this.a+s,j=this.b+s;k<this.w;k++,i++,j++)r|=(this.getBit(i,j)?1:0)<<k;
				return r;
			}
			async incr(d){
				if(d<0||d>=this.z)return;
				let s=d*this.w,i1=this.a+s+this.w;
				for(let i=this.a+s,j=this.b+s;i<i1;i++,j++){
					await this.flipBit(i,j);
					if(this.getBit(i,j))return;
				}
			}
		}
		function medOf3(A,a,b,c){
			let d;
			if(compareIndices(A,a,b)>0)[d,b]=[b,a];
			else d=a;
			if(compareIndices(A,b,c)>0){
				if(compareIndices(A,d,c)>0)return d;
				return c;
			}
			return b;
		}
		function ninther(A,a,b){
			if(b-a<10)return A[a+(b-a)/2|0];
			let l=b-a,h=l/2|0,q=l/4|0,e=l/8|0;
			return medOf3(A,medOf3(A,a,a+e,a+q),medOf3(A,a+q+e,a+h,a+h+e),medOf3(A,b-q,b-e,b-1));
		}
		async function partition(A,a,b,p){
			let c=a,d=--b,c1=0,d1=0,C=0;
			for(;;){
				while(a<=b&&(C=compareIndexValue(A,a,p))<1){
					if(!C){
						await swap(A,c++,a,.25,true);
						c1++;
					}
					a++;
				}
				while(a<=b&&(C=compareIndexValue(A,b,p))+1){
					if(!C){
						await swap(A,d--,b,.25,true);
						d1++;
					}
					b--;
				}
				if(a==b)b--;
				if(a<b)await swap(A,a++,b--,1,true);
				else{
					for(let i=c;c1-->0;)await swap(A,b--,--i,.1,true);
					for(let i=d;d1-->0;)await swap(A,a++,++i,.1,true);
					return[b+1,a-1];
				}
			}
		}
		async function quickselect(A,a,b,r){
			let j=0;
			while(b-a>24){
				let p=ninther(A,a,b),[m0,m1]=await partition(A,a,b,A[p]);
				if(m0<=r&&r<=m1)return j;
				else if(r<m0)b=m0;
				else a=m1+1;j++;
			}
			await insertSort(A,a,b,.1);
			return j;
		}
		async function merge(A,a,b,p){
			let m=16,q=false;
			for(let i=a;i<b;i+=m)await insertSort(A,i,minVal(i+m,b),.1);
			for(;m<b-a;m*=2){
				let t=q?p:a,f=q?a:p;
				for(let i=t;i<t+b-a;i+=2*m){
					let l=i,le=minVal(i+m,t+b-a),r=le,e=minVal(r+m,t+b-a);
					while(l<le&&r<e)
						if(compareIndices(A,l,r)<1)await swap(A,l++,f++,1,true);
						else await swap(A,r++,f++,1,true);
					while(l<le)await swap(A,l++,f++,1,true);
					while(r<e)await swap(A,r++,f++,1,true);
				}
				q=!q;
			}
			if(q)for(let i=a;i<b;i++)await swap(A,i,p+i-a,1,true);
		}
		function bin(A,a,b,v,r){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareIndices(A,v,m)<(r?1:0))b=m;
				else a=m+1;
			}
			return a;
		}
		function idx(A,v,p,a1,z,iv){
			return v<a1+2*(z+1)*z&&(compareIndices(A,v,p+v-a1)>0^iv)?p+v-a1:v;
		}
		async function why(A,a,b,p,iv){
			let z=await log(b-a),a1=a+z;
			if(z+2*(z+1)*z>=b-a||z<2)return await insertSort(A,a,b,.1);
			let c=new BitArray(A,iv?p:a1,iv?a1:p,z+1,z);
			let ps=new BitArray(A,(iv?p:a1)+(z+1)*z,(iv?a1:p)+(z+1)*z,z+1,z);
			for(let i=a1,j=a;i<b;i+=(b-a)/z-1|0)await swap(A,j++,i,1,true);
			await merge(A,a,a1,a1);
			for(let i=a1;i<b;i++){
				let j=bin(A,a,a1,idx(A,i,p,a1,z,iv),false)-a;
				await c.incr(j);
			}
			for(let i=0,s=0;i<=z;i++){
				let v=i==z?0:c.get(i);
				await ps.xor(i,s);s+=v;
			}
			for(let i=0;i<=z;i++){
				let v1=ps.get(i),v=v1+a1,w=c.get(i),w1=w;
				while(w>0){
					let v2=idx(A,v,p,a1,z,iv),x=bin(A,a,a1,v2,false)-a;
					while(x!=i){
						let y=ps.get(x),w2=c.get(x),w3=w2,t=y,t1,b2;
						while((b2=bin(A,a,a1,t1=idx(A,t+a1,p,a1,z,iv),false)-a)==x){
							t++;if(--w3<1)break;
						}
						if(w3<1){
							t1=idx(A,t+a1,p,a1,z,iv);w3=0;
						}else w3--;
						await swap(A,v2,t1,1,true);
						await ps.xor(x,y^++t);
						await c.xor(x,w2^w3);
						if(((v-a1)/z|0)%(z+1)==x)v2=idx(A,v,p,a1,z,iv);
						x=b2;
					}
					v++;w--;
				}
				await c.xor(i,w1);
				await ps.xor(i,v1);
			}
			let i=a1;
			for(let j=a;j<a1;j++){
				let i1=bin(A,a1,b,j,true);
				await run(A,i,i=i1);
			}
			await run(A,i,b);
			await GS.grailMergeWithoutBuffer(A,a,z,b-a-z);
		}
		async function run(A,a,b){
			let m1=a+(b-a)/2|0,m2=m1,z=await quickselect(A,a,b,m1);
			if(!z&&!compareIndices(A,a,b-1))return;
			let p=A[m1];
			do m1--;while(!compareIndexValue(A,m1,p));m1++;
			do m2++;while(!compareIndexValue(A,m2,p));m2--;
			let l=m1-a,r=b-m2;
			if(l>r){
				await merge(A,m2,b,a);
				await why(A,a,m1,m1,false);
			}else{
				await merge(A,a,m1,m2);
				await why(A,m2,b,a,true);
			}
		}
		await run(arr,0,len);
	}
	async lazyStableTernaryQuickSort(len){
		function floorLog(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		function medianOf3(A,v0,v1,v2){
			let t0=0,t1=0,v;
			v=(compareIndices(A,v0,v1)>0)?1:0;t0=v;t1=v^1;
			v=(compareIndices(A,v0,v2)>0)?1:0;t0+=v;
			if(t0==1)return v0;
			v=(compareIndices(A,v1,v2)>0)?1:0;t1+=v;
			return t1==1?v1:v2;
		}
		function medianOf9(A,a,b){
			let v0,v1,v2,d=(b-a)/9|0;
			return medianOf3(A,medianOf3(A,a,a+d*1,a+d*2),medianOf3(A,a+d*3,a+d*4,a+d*5),medianOf3(A,a+d*6,a+d*7,a+d*8));
		}
		function leftBinSearch(A,a,b,val){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(val,A[m])<1)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightBinSearch(A,a,b,v){
			while(a<b){
				let m=a+(b-a)/2|0;
				if(compareValues(v,A[m])<0)b=m;
				else a=m+1;
			}
			return a;
		}
		function rightExpSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			return rightBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		function leftBoundSearch(A,a,b,val){
			let i=1;
			while(a-1+i<b&&compareValues(v,A[a-1+i])+1)i*=2;
			return rightBinSearch(A,a+i/2|0,minVal(b,a-1+i),v);
		}
		function rightBoundSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<1)i*=2;
			return leftBinSearch(A,maxVal(a,b-i+1),b-i/2|0,v);
		}
		async function insertTo(A,a,b){
			let t=A[a],c=false;
			while(a>b)await write(A,a,A[--a],.5,c=true);
			if(c)await write(A,b,t,.5,true);
		}
		function rotate(A,a,m,b){
			return IndexedRotations.holyGriesMills(A,a,m,b,.1,true);
		}
		async function insertSort(A,a,b){
			let i=a+1;
			if(compareIndices(A,i-1,i++)>0){
				while(i<b&&compareIndices(A,i-1,i)>0)i++;
				await reversal(A,a,i-1,1,true);
			}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			for(;i<b;i++)await insertTo(A,i,rightExpSearch(A,a,i,A[i]));
		}
		async function partialInsert(A,a,b){
			if(a==b)return true;
			let c=0;
			for(let i=a+1;i<b;i++){
				if(c>8)return false;
				if(compareIndices(A,i-1,i)>0){
					let t=A[i],j=i;
					do await write(A,j,A[--j],.1,true);while(j>a&&compareValues(A[j-1],t)>0);
					await write(A,j,t,.1,true);
					c+=i-j;
				}
			}
			return true;
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightBinSearch(A,j,i,A[i++]));
				j=i++;
			}
			return nS;
		}
		async function inPlaceMergeFW(A,a,m,b){
			let i=a,j=m,k;
			while(i<j&&j<b)
				if(compareIndices(A,i,j)>0){
					k=leftBinSearch(A,j+1,b,A[i]);
					await rotate(A,i,j,k);
					i+=k-j;j=k;
				}else i++;
		}
		async function inPlaceMergeBW(A,a,m,b){
			let i=m-1,j=b-1,k;
			while(j>i&&i>=a)
				if(compareIndices(A,i,j)>0){
					k=rightBinSearch(A,a,i,A[j]);
					await rotate(A,k,i+1,j+1);
					j-=i+1-k;i=k-1;
				}else j--;
		}
		async function smartInPlaceMerge(A,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftBoundSearch(A,a,m,A[m]);
			b=rightBoundSearch(A,m,b,A[m-1]);
			if(compareIndices(A,a,b-1)>0)await rotate(A,a,m,b);
			else if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function lazyStableSort(A,a,b){
			let mR=b-a;
			for(;mR>31;mR=++mR/2|0);
			if(await buildRuns(A,a,b,mR))return;
			for(let i,j=mR;j<(b-a);j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await smartInPlaceMerge(A,i,i+j,i+2*j);
				if(i+j<b)await smartInPlaceMerge(A,i,i+j,b);
			}
		}
		async function partition(A,a,b,pI){
			let p=A[pI],pa=a,pb=a,c=compareIndexValue(A,a,p);
			for(let i=a;i<b;){
				let j=i;
				if(c<0){
					do c=compareIndexValue(A,++j,p);while(j<b&&c<0);
					await rotate(A,pa,i,j);pa+=j-i;pb+=j-i;i=j;
				}else if(!c){
					do c=compareIndexValue(A,++j,p);while(j<b&&!c);
					await rotate(A,pb,i,j);pb+=j-i;i=j;
				}else do c=compareIndexValue(A,++i,p);while(i<b&&c>0);
			}
			return[pa,pb];
		}
		async function quickSort(A,a,b,d){
			while(b-a>16){
				if(!d)return await lazyStableSort(A,a,b);
				let p=medianOf3(A,a,a+(b-a)/2,b-1),[pa,pb]=await partition(A,a,b,p),l=pa-a,r=b-pb,qL=pb-pa;
				if(qL==b-a)return;
				if(!l||!r||((l/r|0)>15||(r/l|0)>15)){
					p=medianOf9(A,a,b);[pa,pb]=await partition(A,a,b,p);l=pa-a;r=b-pb;qL=pb-pa;
					if(qL==b-a)return;
				}
				if(await partialInsert(A,a,pa)&&await partialInsert(A,pb,b))return;
				if(l>r)await quickSort(A,pb,b,--d,b=pa);
				else await quickSort(A,a,pa,--d,a=pb);
			}
			await insertSort(A,a,b);
		}
		await quickSort(arr,0,len,2*floorLog(len));
	}
	async headQuicksort(len){
		function head(s,e,d){
			return{s,e,d,n:e-s};
		}
		function tabComp(A,t,a,b){
			return compareIndices(A,t[a],t[b]);
		}
		async function sift(A,r,t){
			while(r<=(t.length/2|0)){
				let l=r*2;
				if(l<t.length&&tabComp(A,t,l-1,l)>0)l++;
				if(tabComp(A,t,r-1,l-1)>0){
					await swap(t,r-1,l-1,0,true,true);
					r=l;
				}else break;
			}
		}
		async function heapifyTable(A,t){
			for(let i=t.length/2|0;i>0;i--)await sift(A,i,t);
		}
		function remove(A,d){
			let nw=new Array(A.length-1);
			for(let i=0,j=0;i<A.length;i++){
				if(i==d)continue;
				write(nw,j++,A[i],0,false,true);
			}
			return nw;
		}
		function heapIndex(A,p,t,d){
			let i=0;
			while(i<p.length&p[i]<=t[d])i++;
			return i;
		}
		async function kWayMerge(A,P){
			let X=new Array(P[P.length-1]-P[0]),T=new Array(P.length-1),k=0;
			arraycopy(P,0,T,0,T.length,0,false,true);
			await heapifyTable(A,T);
			while(T.length>1){
				let n=heapIndex(A,P,T,0),sM=T.length>2?(tabComp(A,T,1,2)>0?2:1):1;
				do if(T[0]<P[n])write(X,k++,A[T[0]++],0,false,true);while(T[0]<P[n]&&tabComp(A,T,0,sM)<1);
				if(T[0]>=P[n]){
					swap(T,0,T.length-1,0,false,true);
					T=remove(T,T.length-1);
				}
				await sift(A,1,T);
			}
			let lK=heapIndex(A,P,T,0);
			while(T[0]<P[lK])write(X,k++,A[T[0]++],0,false,true);
			await arraycopy(X,0,A,P[0],X.length,1,true);
		}
		async function miepurge(A,s,e,b){
			let X=new Array(b+1).fill(0),st=(e-s+1)/b|0;
			if(e-s<b)return await new HeapSorting(true).sort(A,s,e,.1);
			if(!st||e-s==b)return await binaryDoubleInsertion(A,s,e,.2);
			for(let i=0;i<b;i++)X[i]=s+st*i;
			X[b]=e;
			for(let i=0;i<b;i++)
				if(b<24&&st>th)await miepurge(A,X[i],X[i+1],b);
				else await binaryDoubleInsertion(A,X[i],X[i+1],.25);
			await kWayMerge(A,X);
		}
		async function merge(A,T,s,m,e){
			if(s>=m)return;
			await merge(A,T,s,(m+s)/2|0,m);
			await merge(A,T,m,(m+e)/2|0,e);
			if(compareIndices(A,m-1,m)<1)return;
			arraycopy(A,s,T,0,m-s,0,false,true);
			let l=0,h=m,n=s;
			while(l<m-s&&h<e)
				if(compareValues(T[l],A[h])<1)await write(A,n++,T[l++],1,true);
				else await write(A,n++,A[h++],1,true);
			while(l<m-s)await write(A,n++,T[l++],1,true);
		}
		let med15Swaps=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,1,3,5,7,9,11,13,15,2,4,6,8,10,12,1,5,9,13,2,6,10,14,3,7,11,15,4,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15,6,11,7,10,4,13,14,15,8,12,2,3,5,9,2,5,8,14,3,9,12,15,6,7,10,11,3,5,12,14,4,9,8,13,7,9,11,13,4,6,8,10,4,5,6,7,8,9,10,11,12,13,7,8,9,10];
		async function fifteen(A,c){
			for(let i=0;i<med15Swaps.length;i+=2){
				let a=c-16+med15Swaps[i],b=c-16+med15Swaps[i+1];
				if(compareIndices(A,a,b)>0)await swap(A,a,b,10,true);
			}
		}
		async function quickSort(a,q,p,r,d){
			let x;
			if(r-p>128&&d<(log1p(r-p)/log(6)|0)){
				let e=p+(r-p+15)/2|0;
				await fifteen(a,e);
				x=a[e-7];
			}else if(r-p<16)return await insertSort(a,p,r+1,.2);
			else{
				let m=a[p];
				for(let i=p+1;i<=r;i++)m+=a[i];
				x=m/(r-p+1)|0;
			}
			let i=p,j=r;
			while(i<=j){
				while(i<=j&&compareValues(a[i],x)<0)i++;
				while(i<=j&&compareValues(a[j],x)>0)j--;
				if(i<=j)await swap(a,i++,j--,1,true);
			}
			q.offer(head(p,j,d));
			q.offer(head(i,r,d));
		}
		let th;
		async function sort(A,l){
			let q=new PriorityQueue((a,b)=>((a.n-b.n)>>31)|-((b.n-a.n)>>31)),sq=sqrt(l)|0,cb=cbrt(l)|0,lg=log(l)/log(6)|0,T=new Array(sq);th=cb;
			await quickSort(A,q,0,l-1,0);
			while(q.size()){
				let p=q.poll();
				if(!p.n)continue;
				if(p.n<2*sq)await merge(A,T,p.s,p.s+(p.e-p.s+1)/2|0,p.e+1);
				else if(p.d>=cb){
					mp.miepurge(A,p.s,p.e+1,lg);
					T=new Array(sq);
				}else await quickSort(A,q,p.s,p.e,p.d+1);
			}
		}
		await sort(arr,len);
	}
	async aeosQSort(len){
		function clearArr(A){
			for(let i=0;i<A.length;i++)A[i]=0;
		}
		function medianOfFewUnique(A,s){
			let i=s,r=0;
			while(!r)r=compareIndices(A,s,++i);
			if(r<0)return i;
			return s;
		}
		function medianOf3(A,i){
			if(!i.length)return-1;
			if(!i.length<3)return i[0];
			let[a,b,c]=i;
			if(compareIndices(A,a,b)<1){
				if(compareIndices(A,b,c)<1)return b;
				if(compareIndices(A,a,c)<0)return c;
				return a;
			}
			if(compareIndices(A,b,c)+1)return b;
			if(compareIndices(A,a,c)<1)return a;
			return c;
		}
		function medianOf9(A,a,b){
			let l=b-a,h=l/2|0,q=h/2|0,e=q/2|0;
			return medianOf3(A,[medianOf3(A,[a,a+e,a+q]),medianOf3(A,[a+q+e,a+h,a+h+e]),medianOf3(A,[a+h+q,a+h+q+e,b-1])]);
		}
		function mOMHelper(A,s,l){
			if(l==1)return s;
			let t=l/3|0;
			return medianOf3(A,[mOMHelper(A,s,t),mOMHelper(A,s+t,t),mOMHelper(A,s+2*t,t)]);
		}
		function medianOfMedians(A,s,l){
			if(l==1)return s;
			let nP=pow(3,round(log(l)/log(3)));
			if(nP==l)return mOMHelper(A,s,l);nP=nP/3|0;
			if(2*nP>=l)nP=nP/3|0;
			return medianOf3(A,[mOMHelper(A,s,nP),mOMHelper(A,s+l-nP,nP),medianOfMedians(A,s+nP,l-2*nP)]);
		}
		async function rotate(A,s,l,r){
			let j=s+l,k=0;
			while(k<r)await write(eX,k++,A[j++],.1,true,true);k=s+l;
			while(k>s)await write(A,--j,A[--k],.1,true);j=0;
			while(j<r)await write(A,k++,eX[j++],.1,true);
			clearArr(eX);
		}
		async function partition(A,s,e,sq,pE){
			let ss=0,ls=0,sB=0,bC=0;
			for(let i=s;i<e;i++){
				if(compareValues(A[i],pE)<0){
					if(ls)await write(A,s+bC*sq+ss,A[i],.1,true);
					if(++ss==sq){
						ss=0;iX[bC++]=sB++*sq;
					}
				}else{
					write(eX,ls,A[i],0,false,true);
					if(++ls==sq){
						let j=i;
						for(let k=i-sq;k>=s+bC*sq;)await write(A,j--,A[k--],.1,true);
						for(let k=sq;k>0;)await write(A,j--,eX[--k],.1,true);
						clearArr(eX);
						ls=0;iX[bC++]=-1;
					}
				}
			}
			for(let j=e,k=ls;k>0;)await write(A,--j,eX[--k],.1,true);
			clearArr(eX);
			if(sB==bC)return sB*sq+ss;
			if(!sB){
				if(ss)await rotate(A,s,bC*sq,ss);
				return ss;
			}
			let fP=sB;
			for(let i=0;i<bC;i++)if(iX[i]==-1)iX[i]=fP++*sq;
			let i=0;
			while(i<bC&&(iX[i]/sq|0)==i)i++;
			while(i<bC){
				for(let j=s+i*sq,k=0;k<sq;j++,k++)write(eX,k,A[j],0,false,true);
				let t=iX[i]/sq|0,c=i,n=i;
				while(iX[n]/sq-c|0)n++;
				while(n-t){
					for(let j=s+n*sq,k=s+c*sq;j<s+(n+1)*sq;j++,k++)await write(A,k,A[j],.1,true);
					iX[c]=c*sq;c=n;n=i;
					while(iX[n]/sq-c|0)n++;
				}
				for(let j=s+n*sq,k=s+c*sq;j<s+(n+1)*sq;j++,k++)await write(A,k,A[j],.1,true);
				iX[c]=c*sq;
				for(let j=0,k=s+t*sq;j<sq;j++,k++)await write(A,k,eX[j],.1,true);
				clearArr(eX);
				iX[t]=t*sq;
				do i++;while(i<bC&&(iX[i]/sq|0)==i);
			}
			clearArr(iX);
			if(ss)await rotate(A,s+sB*sq,(bC-sB)*sq,ss);
			return sB*sq+ss;
		}
		async function sortHelper(A,s,e,sq,bP){
			while(e-s>15){
				let pP;
				if(!bP)pP=medianOf9(A,s,e);
				else if(bP>0){
					let l=e-s;
					if(!(l&1))l-=1;
					pP=medianOfMedians(A,s,l);
				}else{
					pP=medianOfFewUnique(A,s);
					bP=~bP;
				}
				let pE=A[pP];
				pP=await partition(A,s,e,sq,pE);
				let nE=s+pP,nS=nE;
				while(nS<e&&!compareValues(A[nS],pE))nS++;
				let l1=nE-s,l2=e-nS;
				if(l1>l2){
					bP+=l1>8*l2?1:0;
					await sortHelper(A,nS,e,sq,bP);
					e=nE;
				}else if(l2>8*l1)
					if(!l1)bP=~bP;
					else{
						await sortHelper(A,s,nE,sq,++bP);
						s=nS;
					}
				else{
					await sortHelper(A,s,nE,sq,bP);
					s=nS;
				}
			}
			await insertSort(A,s,e,.1);
		}
		let eX,iX;
		async function sort(A,l){
			if(l<16)await insertSort(A,0,l,1);
			let lg=1;
			while(1<<(++lg<<1)<l);
			let sq=1<<lg;eX=new Array(sq).fill(0);iX=new Array(l/sq|0).fill(0);
			await sortHelper(A,0,l,sq,0);
		}
		await sort(arr,len);
	}
	async cynoSort(len){
		function part(a,b,d){
			return{a,b,d,n:b-a};
		}
		async function insertTo(A,a,b){
			if(a-b){
				let t=A[a],d=a>b?-1:1;
				for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
				await write(A,b,t,.5,true);
			}
		}
		function expSearch(A,a,b,v){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<0)i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			while(a1<b1){
				let m=a1+(b1-a1)/2|0;
				if(compareValues(v,A[m])<0)b1=m;
				else a1=m+1;
			}
			return a1;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)await insertTo(A,i,expSearch(A,a,i,A[i]));
		}
		async function consumePartition(A,q,a,b,d){
			if(b-a>32)q.add(part(a,b,d));
			else await insertSort(A,a,b);
		}
		async function innerSort(A,l,r){
			if(r-l<33)return await insertSort(A,l,r);
			let q=new PriorityQueue((a,b)=>b.n-a.n);
			q.add(part(l,r,3));
			while(q.size()){
				let p=q.poll(),{a,b,d,n}=p,p1,p2,s=n/d|0;
				if(compareIndices(A,a+s,b-1-s)>0){
					p1=A[b-1-s];
					p2=A[a+s];
				}else{
					p1=A[a+s];
					p2=A[b-1-s];
				}
				let i1=a,i=a,j=b,j1=b;
				for(let k=i;k<j;k++){
					let c1=compareIndexValue(A,k,p1);
					if(c1<1){
						let t=A[k];
						await write(A,k,A[i],.2,true);
						if(!c1){
							await write(A,i,A[i1],.2,true);
							await write(A,i1++,t,.2,true);
						}else await write(A,i,t,.2,true);
						i++;
					}else{
						let c2=compareIndexValue(A,k,p2);
						if(c2+1){
							while(--j>k){
								let c=compareIndexValue(A,j,p2);
								if(!c)await swap(A,--j1,j,.5,true);
								else if(c<0)break;
							}
							let t=A[k];
							await write(A,k,A[j],.2,true);
							if(!c2){
								await write(A,j,A[--j1],.2,true);
								await write(A,j1,t,.2,true);
							}else await write(A,j,t,.2,true);
							c1=compareIndexValue(A,k,p1);
							if(c1<1){
								t=A[k];
								await write(A,k,A[i],.2,true);
								if(!c1){
									await write(A,i,A[i1],.2,true);
									await write(A,i1++,t,.2,true);
								}else await write(A,i,t,.2,true);
								i++;
							}
						}
					}
				}
				if(i1==b)continue;
				if(minVal(i-a,minVal(j-i,b-j))<33)d++;
				await consumePartition(A,q,i,j,d);
				if(i1-a>i-i1){
					let i2=i;i=a;
					while(i1<i2)await swap(A,i++,i1++,1,true);
				}else while(i1>a)await swap(A,--i,--i1,1,true);
				await consumePartition(A,q,a,i,d);
				if(b-j1>j1-j){
					let j2=j;j=b;
					while(j1>j2)await swap(A,--j,--j1,1,true);
				}else while(j1<b)await swap(A,j++,j1++,1,true);
				await consumePartition(A,q,j,b,d);
			}
		}
		async function quickSort(A,a,b){
			let z=0,e=0;
			for(let i=a;i<b-1;i++){
				let c=compareIndices(A,i,i+1);
				z+=c>0;e+=!c;
			}
			if(!z)return;
			if(z+e==b-a-1){
				if(b-a<4)await swap(A,a,b-1,.75,true);
				else await reversal(A,a,b-1,.75,true);
				return;
			}
			await innerSort(A,a,b);
		}
		await quickSort(arr,0,len);
	}
	async sussyBakaSort(len){
		let mode=askForNum(1,"0 or 1",0,1);
		function cmp(A,a,b){
			return-(compareIndices(A,b,a)>>31);
		}
		function medof3a(A,l){
			let a=cmp(A,l,l+1),b=cmp(A,l+(a^1),l+2);b+=(a^1)|b;
			let c=cmp(A,l+b,l+a);
			return l+((c-1&a)|(-c&b));
		}
		function medof3b(A,l,l1,l2){
			let s=[l,l1,l2],a=cmp(A,l,l1),b=cmp(A,s[a^1],l2);b+=(a^1)|b;
			let c=cmp(A,s[b],s[a]);
			return s[(c-1&a)|(-c&b)];
		}
		function ninther(A,a,b){
			if(b-a<4)return a+(b-a)/2|0;
			if(b-a<8)return medof3a(A,a+(b-a-1)/2|0);
			let d=(b-a+1)/8|0;
			return medof3b(A,medof3b(A,a,a+d,a+2*d),medof3b(A,a+3*d,a+4*d,a+5*d),medof3b(A,a+6*d,a+7*d,b));
		}
		function pseudomo27(A,a,b){
			if(b-a<81)return ninther(A,a,b);
			let d=(b-a+1)/8|0;
			return medof3b(A,ninther(A,a,a+2*d),ninther(A,a+3*d,a+5*d),ninther(A,a+6*d,b));
		}
		function pseudomo81(A,a,b){
			if(b-a<324)return pseudomo27(A,a,b);
			let d=(b-a+1)/24|0;
			return medof3b(A,medof3b(A,ninther(A,a,a+2*d),ninther(A,a+3*d,a+5*d),ninther(A,a+6*d,a+8*d)),medof3b(A,ninther(A,a+9*d,a+11*d),ninther(A,a+12*d,a+14*d),ninther(A,a+15*d,a+17*d)),medof3b(A,ninther(A,a+18*d,a+20*d),ninther(A,a+19*d,a+21*d),ninther(A,a+22*d,b)));
		}
		async function ternarysplitOOP(A,T,s,e){
			if(s>=e)return;
			let p,pi;
			if(mode)p=pseudomo81(A,s,e);
			else{
				let z=A[s]^A[e];
				if(z<(s^e))p=(z^(A[s]&(s^e)))%(e-s)+s;
				else p=(z^(A[e]&~(s-e)))%(e-s)+s;
			}
			let a=s,b=e,j=0,i=s,n=A[a],aE=true;pi=A[p];
			while(a<=b){
				let c=compareValues(n,pi);A[a]=-1;
				if(c<0)await write(A,i++,n,0,true,aE=false);
				else if(!c){
					while(a<b&&!compareIndexValue(A,b,pi))b--;
					let v=A[b];
					await write(A,b--,n,0,true);n=v;
					continue;
				}else write(T,j++,n,0,aE=false,true);
				n=A[++a];
			}
			if(aE)return;b=i+j-1;
			await arraycopy(T,0,A,i,j,1,true);
			await ternarysplitOOP(A,T,i,b);
			await IndexedRotations.cycleReverse(A,i,b+1,e+1,1,true);
			await ternarysplitOOP(A,T,s,i-1);
		}
		await ternarysplitOOP(arr,new Array(len),0,len-1);
	}
	async logNaryHeapSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		async function siftDown(A,v,i,p,n,b){
			while(b*i+1<n){
				let m=v,nx=i,c=b*i+1;
				for(let j=c;j<minVal(c+b,n);j++)if(compareValues(A[p+j],m)>0)m=A[p+(nx=j)];
				if(nx==i)break;
				await write(A,p+i,m,1,true);
				i=nx;
			}
			await write(A,p+i,v,1,true);
		}
		async function heapSort(A,a,b){
			let n=b-a,bs=maxVal(log2(n),2);
			for(let i=(n-1)/bs|0;i>=0;i--)await siftDown(A,A[a+i],i,a,n,bs);
			for(let i=n-1;i>0;i--){
				let t=A[a+i];
				await write(A,a+i,A[a],1,true);
				await siftDown(A,t,0,a,i,bs);
			}
		}
		await heapSort(arr,0,len);
	}
	async inverseSelectionSort(len){
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1,j=0;
			for(let i=a;i-b;i+=d){
				write(A,i,A[i+d]);
				if(++j>sqrt((b-a)*d))await mark(i,j=0);
			}
			if(a-b)await write(A,b,t,.05,true);
		}
		async function selectionSort(A,a,b){
			for(let i=a;i<b;i++){
				let mI=i;
				for(let j=i+1;j<b;j++)if(compareIndices(A,mI,j)<1)mI=j;
				await insertTo(A,mI,a);
			}
		}
		await selectionSort(arr,0,len);
	}
	async heapHunterSort(len){
		const HS=new HeapSorting(false);
		for(let j=0;j<len;j++){
			let k=len-1;
			while(compareIndices(arr,j,k)<1&&k>j)k--;
			if(k-j)await HS.heapify(arr,j,k+1,.5);
		}
	}
	async inverseSmoothSelectionSort(len){
		async function multiSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		async function sort(A,l){
			for(let i=0;i<l-1;i++){
				let sI=i,qZ=0;
				for(let j=i+1;j<l;j++){
					let c=compareIndices(A,j,sI);
					if(c<1){
						if(j-++sI)await swap(A,j,sI,1,true);
						if(!c)qZ++;
						else qZ=0;
					}
				}
				if(sI==l-1){
					await reversal(A,i,l-1,1,true);
					break;
				}
				await multiSwap(A,i,sI-qZ,qZ+1);i+=qZ;
			}
		}
		await sort(arr,len);
	}
	async instinctSandpaperSort(len){
		for(let i=0,k=0;i<len-1;i++)
			for(let j=i+1;j<len;j++){
				swap(arr,i,j);
				if(compareIndices(arr,i,j)>0)swap(arr,i,j);
				if(++k>sqrt(len))await markSwap(i,j,k=0);
			}
	}
	async scrollHeapHunterSort(len){
		const HS=new HeapSorting(false);
		for(let j=0;j<len;j++){
			let k=len-1;
			while(compareIndices(arr,j,k)<1&&k>j)k--;
			if(k-j)for(let i=k;i>=j;i--)await HS.heapify(arr,i,k+1,.2);
		}
	}
	async doubleSandpaperSort(len){
		let l=0,r=len-1,i=1;
		while(l<=r){
			i=l;
			while(i<r){
				if(compareIndices(arr,l,i)>0)await swap(arr,l,i,.05,true);
				if(compareIndices(arr,i,r)>0)await swap(arr,i,r,.05,true);
				i++;
			}
			l++;r--;
		}
	}
	async instinctReverseSandpaperSort(len){
		for(let i=0,k=0;i<len-1;i++)
			for(let j=len-1;j>i;j--){
				swap(arr,i,j);
				if(compareIndices(arr,i,j)>0)swap(arr,i,j);
				if(++k>sqrt(len))await markSwap(i,j,k=0);
			}
	}
	async swaplessRollSort(len){
		for(let i=0;i<len;i++){
			let m=i;
			for(let j=i+1;j<len;j++)if(compareIndices(arr,j,m)<0)m=j;
			let d=m-i;
			for(let r=0;r<d;r++)await Wr.insert(arr,i,len-1,.005,true);
		}
	}
	async sandpaperBingoSort(len){
		async function collect(A,e){
			let c=0;
			for(let l=e;l>=0;l--){
				let m=compareIndices(A,l,e-c+1<e?e-c+1:e);
				if(m>0){
					await swap(A,l,e,.1,true);
					c=1;
				}else if(!m){
					if(l-e+c)await swap(A,l,e-c,.1,true);
					c++;
				}
			}
			return c;
		}
		for(let i=len;i>0;i-=await collect(arr,i-1));
	}
	async geapSort(len){
		async function makeGeap(A,s,e){
			for(let i=e-1;i>s;i--){
				let j=i;
				while(j>=s){
					let n=(j+s-2)/2|0,c=(j+s)/2|0;
					if(c>=s&&n>=s&&compareIndices(A,c,n)>0)await swap(A,c,n,.1,true);
					if(n>=s&&compareIndices(A,n,j)<0)await swap(A,j,c,.1,true);
					j=n;
				}
			}
		}
		await makeGeap(arr,0,len);
		for(let i=len-1;i>=0;i--){
			await swap(arr,0,--len,1,true);
			await makeGeap(arr,0,len);
		}
	}
	async swapfulCycleSort(len){
		function countLesser(A,a,b,d){
			let r=a;
			for(let i=a+1;i<b;i++)r+=compareIndices(A,i,d)<0;
			return r;
		}
		async function sort(A,a,b){
			for(let i=a;i<b-1;i++){
				let r=countLesser(A,i,b,i);
				if(r-i)
					do{
						while(!compareIndices(A,r,i))r++;
						await swap(A,i,r,.02,true);
						r=countLesser(A,i,b,i);
					}while(r!=i);
			}
		}
		await sort(arr,0,len);
	}
	async stableDemoDerbySort(len){
		for(let i=0;i<len-1;i++){
			let l,s;
			do{
				l=s=0;
				for(let j=i+1;j<len;j++){
					let c=compareIndices(arr,j,i);
					if(c<0)l++;
					else if(!c){
						await multiSwap(arr,j,s+i++,.005,true);
						l--;
					}
				}
				if(l<1&&s>0){
					i+=s;
					break;
				}
				await Rotations.holyGriesMills(arr,i,s+1,l,.01,true);
			}while(l>0);
		}
	}
	async instinctCocktailSandpaperSort(len){
		for(let i=0,k=0;i<len-1;i++){
			for(let j=i+1;j<len;j++){
				swap(arr,i,j);
				if(compareIndices(arr,i,j)>0)swap(arr,i,j);
				if(++k>sqrt(len))await markSwap(i,j,k=0);
			}
			i++;
			for(let j=len-1;j>i;j--){
				swap(arr,i,j);
				if(compareIndices(arr,i,j)>0)swap(arr,i,j);
				if(++k>sqrt(len))await markSwap(i,j,k=0);
			}
		}
	}
	async casinoSort(len){
		async function multiSwap(A,a,b,s){
			while(s-->0)await swap(A,a++,b++,1,true);
		}
		async function sort(A,l){
			let bZ=[];
			for(let i=0;i<l;){
				let s=1;
				for(let j=i+1;j<l;j++)if(!compareIndices(A,j,i))await multiSwap(A,j,i+s++,.01,true);
				if(bZ.length>=(l/2|0)){
					bZ=[];
					await Sorts.prototype.lazyHeapSort(l);
					return;
				}
				bZ.push(s);
				i+=s;
			}
			let bN=0;
			while(bZ.length){
				let zN=bZ.shift(),m=-1,mI=bN,tI=bN+zN;
				for(let i=0;i<bZ.size();i++){
					if(compareIndices(A,mI,tI)>0){
						mI=tI;
						m=i;
					}
					tI+=bZ[i];
				}
				if(m<0)bN+=zN;
				else if(zN==bZ[m]){
					await multiSwap(A,mI,bN,zN);
					bN+=zN;
				}else{
					await IndexedRotations.griesMills(A,bN,mI,mI+bZ[m],.025,true);
					bN+=bZ.remove(m);
					bZ.unshift(zN);
				}
			}
		}
		await sort(arr,len);
	}
	async tableHeapSort(len){
		async function siftDown(A,K,i,p,n,kV){
			while(2*i+1<n){
				let kM=kV,nx=i,h=2*i+1;
				for(let j=h;j<minVal(h+2,n);j++){
					let c=compareIndices(A,K[p+j],kM);
					if(c>0||!c&&compareValues(K[j],kM)>0)kM=K[nx=j];
				}
				if(nx==i)break;
				await write(K,i,kM,0,false,true);
				i=nx;
			}
			await write(K,i,kV,0,false,true);
		}
		async function sort(A,a,b){
			let l=b-a;
			let K=new Array(l).fill(0);
			for(let i=0;i<l;i++)write(K,i,i,0,false,true);
			for(let i=(l-1)/2|0;i>=0;i--)await siftDown(A,K,i,a,l,K[i]);
			for(let i=l-1;i>0;i--){
				let t=K[i];
				await write(K,i,K[0],0,false,true);
				await siftDown(A,K,0,a,i,t);
			}
			for(let i=0;i<l;i++)
				if(compareValues(i,K[i])){
					let t=A[a+i],j=i,n=K[i];
					do{
						await write(A,a+j,A[a+n],1,true);
						await write(K,j,j,0,false,true);
						n=K[j=n];
					}while(compareValues(n,i));
					await write(A,a+j,t,1,true);
					await write(K,j,j,0,false,true);
				}
		}
		await sort(arr,0,len);
	}
	async optimizedOpiumSort(len){
		function isLeast(A,t,d,x,l){
			for(let i=d+1;i<l;i++)if(compareIndices(A,d,i)>0)return false;
			for(let i=0;i<x;i++)if(compareIndexValue(A,d,t[i])>0)return false;
			return true;
		}
		async function sort(A,l){
			let c=new Array(l);
			for(let j=0;j<l;j++)c[j]=-1;
			for(let j=0,h=0,i=j,cd=0;i<l;j++){
				if(j>l-1){
					j=i;
					for(let k=i;k<=h;k++){
						await write(A,k,c[k-i],.1,true);
						c[k-i]=-1;
					}
					for(let k=0;k<l;k++)c[k]=-1;
					cd=h=0;
				}
				if(isLeast(A,c,j,cd,l)){
					if(i-j)await write(A,i,A[j],.1,true);
					i++;h=j;
				}else write(c,cd++,A[j],0,false,true);
			}
		}
		await sort(arr,len);
	}
	async simplifiedBlockTimSort(len){
		function getMinLevel(n){
			while(n>31)n=++n/2|0;
			return n;
		}
		async function insertTo(A,a,b){
			let t=A[a];
			for(let i=a;i>b;i--)await write(A,i,A[i-1],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function multiSwap(A,a,b,l){
			if(a-b)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
		}
		async function rotate(A,a,m,b){
			let lA=m-a,lB=b-m,p=a,e=p+lA+lB;
			while(lA>0&&lB>0)if(lA<lB){
				for(let i=0;i<lA;i++){
					let t=A[p+i],j=p+i+lA;
					for(;j<e;j+=lA)await write(A,j-lA,A[j],1,true);
					await write(A,j-lA,t,1,true);
				}
				p+=lB;lB%=lA;lA-=lB;
			}else{
				for(let i=0;i<lB;i++){
					let t=A[p+i+lA],j=p+i+lA-lB;
					for(;j>=p;j-=lB)await write(A,j+lB,A[j],1,true);
					await write(A,j+lB,t,1,true);
				}
				e=p+lB;lA%=lB;lB-=lA;
			}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,1,true);
					else await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function mergeTo(f,t,a,m,b,p,x){
			let i=a,j=m;
			while(i<m&&j<b)
				if(compareIndices(f,i,j)<1)await write(t,p++,f[i++],1,true,x);
				else await write(t,p++,f[j++],1,true,x);
			while(i<m)await write(t,p++,f[i++],1,true,x);
			while(j<b)await write(t,p++,f[j++],1,true,x);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a,i=0,j=m;
			arraycopy(A,a,T,0,s,0,false,true);
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m,i=s-1,j=m-1;
			arraycopy(A,m,T,0,s,0,false,true);
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true),t=i-m;
				await rotate(A,a,m,i);m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false),t=m-i;
				await rotate(A,i,m,b);m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function merge(A,B,a,m,b){
			if(minVal(m-a,b-m)<9)
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			else if(m-a>b-m)await mergeBWExt(A,B,a,m,b);
			else await mergeFWExt(A,B,a,m,b);
		}
		async function mergeBlocks(A,B,a,m,b,l){
			let s=b-m,i=s-1,j=m-1;
			arraycopy(A,m,B,0,s,0,false,true);
			while(i>=0&&j>=a){
				let c=compareValues(B[i],A[j]);
				if(c>0||l&&!c)await write(A,--b,B[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			}
			while(i>=0)await write(A,--b,B[i--],1,true);
		}
		async function blockSelect(A,T,a,tm,tb,bL){
			let i1=0,j1=tm,k=0;
			while(k<j1&&j1<tb)
				if(compareIndices(A,a+i1*bL+bL-1,a+j1*bL+bL-1)<1){
					if(i1>k)await multiSwap(A,a+k*bL,a+i1*bL,bL);
					swap(T,k++,i1,0,false,true);i1=k;
					for(let i=maxVal(k+1,tm);i<j1;i++)if(compareIndices(T,i,i1)<0)i1=i;
				}else{
					await multiSwap(A,a+k*bL,a+j1*bL,bL);
					swap(T,k,j1++,0,false,true);
					if(i1==k++)i1=j1-1;
				}
			while(k<j1-1){
				if(i1>k)await multiSwap(A,a+k*bL,a+i1*bL,bL);
				swap(T,k++,i1,0,false,true);i1=k;
				for(let i=k+1;i<j1;i++)if(compareIndices(T,i,i1)<0)i1=i;
			}
		}
		async function blockMerge(A,B,T,a,m,b,bL){
			let tL1=(m-a)/bL|0,bC=(b-a)/bL|0,tm=tL1,tb=bC,b1=b-(b-m)%bL;
			for(let k=0;k<bC;k++)write(T,k,k,0,false,true);
			let mK=T[tm],f=a;
			await blockSelect(A,T,a,tm,tb,bL);
			let l=compareValues(T[0],mK)<0;
			for(let i=1;i<bC;i++)
				if(l^(compareValues(T[i],mK))<0){
					let nx=a+i*bL,nE=binSearch(A,nx,nx+bL,A[nx-1],l);
					await mergeBlocks(A,B,f,nx,nE,l);
					f=nE;l=!l;
				}
			if(l)await mergeBlocks(A,B,f,b1,b,l);
		}
		async function smartMerge(A,B,a,m,b){
			if(a>=m||m>=b)return;
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			await merge(A,B,a,m,b);
		}
		async function pingPongMerge(A,B,a,m1,m2,m3,b){
			let p=0,p1=p+m2-a,pE=p+b-a;
			if(compareIndices(A,m1-1,m1)>0||(m3<b&&compareIndices(A,m3-1,m3)>0)){
				await mergeTo(A,B,a,m1,m2,p,true);
				await mergeTo(A,B,m2,m3,b,p1,true);
				await mergeTo(B,A,p,p1,pE,a,false);
			}else await smartMerge(A,B,a,m2,b);
		}
		async function smartBlockMerge(A,B,T,a,m,b,bL){
			if(a>=m||m>=b)return;
			if(compareIndices(A,m-1,m)<1)return;
			let s=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(minVal(m-s,b-m)<=bL)await merge(A,B,s,m,b);
			else await blockMerge(A,B,T,s-=(s-a)%bL,m,b,bL);
		}
		async function blockMergeSort(A,a,b){
			let l=b-a;
			if(l<128){
				let j=getMinLevel(l);
				if(await buildRuns(A,a,b,j))return;
				let T=new Array(l/2|0),i;
				for(;j<l;j*=2){
					for(i=a;i+2*j<=b;i+=2*j)await smartMerge(A,T,i,i+j,i+2*j);
					if(i+j<b)await smartMerge(A,T,i,i+j,b);
				}
				return;
			}
			let j=getMinLevel(l),bL;
			for(bL=j;bL*bL<l;bL*=2);
			let tL=l/bL+2|0;
			if(await buildRuns(A,a,b,j))return;
			let B=new Array(bL),i;
			for(;4*j<=bL;j*=4){
				for(i=a;i+2*j<b;i+=4*j)await pingPongMerge(A,B,i,i+j,i+2*j,minVal(i+3*j,b),minVal(i+4*j,b));
				if(i+j<b)await smartMerge(A,B,i,i+j,b);
			}
			for(;j<=bL;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await smartMerge(A,B,i,i+j,i+2*j);
				if(i+j<b)await smartMerge(A,B,i,i+j,b);
			}
			let T=new Array(tL);
			for(;j<l;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await smartBlockMerge(A,B,T,i,i+j,i+2*j,bL);
				if(i+j<b)await smartBlockMerge(A,B,T,i,i+j,b,bL);
			}
		}
		await blockMergeSort(arr,0,len);
	}
	async ayakaSort(len){
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function reverse(A,a,b){
			if(b-a<3)await swap(A,a,b,1,true);
			else await reversal(A,a,b,1,true);
		}
		async function multiSwap(A,a,b,l,d){
			if(a==b)return;
			if(d)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3)await reverse(A,p0,p3);
			}
		}
		async function buildUniqueRun(A,a,n){
			let nK=1,i=a+1;
			if(compareIndices(A,i-1,i)<0){
				i++;nK++;
				while(nK<n&&compareIndices(A,i-1,i)<0){
					i++;nK++;
				}
			}else if(compareIndices(A,i-1,i)>0){
				i++;nK++;
				while(nK<n&&compareIndices(A,i-1,i)>0){
					i++;nK++;
				}
				await reverse(A,a,i-1);
			}
			return nK;
		}
		async function buildUniqueRunBW(A,b,n){
			let nK=1,i=b-1;
			if(compareIndices(A,i-1,i)<0){
				i--;nK++;
				while(nK<n&&compareIndices(A,i-1,i)<0){
					i--;nK++;
				}
			}else if(compareIndices(A,i-1,i)>0){
				i--;nK++;
				while(nK<n&&compareIndices(A,i-1,i)>0){
					i--;nK++;
				}
				await reverse(A,i,b-1);
			}
			return nK;
		}
		async function findKeys(A,a,b,nK,n){
			let p=a,pE=a+nK;
			for(let i=pE;i<b&&nK<n;i++){
				let o=binSearch(A,p,pE,A[i],true);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,p,pE,i);
					let n=i-pE;o+=n;p+=n;pE+=n;nK++;
					await insertTo(A,pE++,o);
				}
			}
			await rotate(A,a,p,pE);
			return nK;
		}
		async function findKeysBW(A,a,b,nK,n){
			let p=b-nK,pE=b;
			for(let i=p-1;i>=a&&nK<n;i--){
				let o=binSearch(A,p,pE,A[i],true);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,i+1,p,pE);
					let n=p-i-1;o-=n;pE-=n;p-=n+1;nK++;
					await insertTo(A,i,o-1);
				}
			}
			await rotate(A,p,pE,b);
			return nK;
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reverse(A,j,i-1);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		function insertSort(A,a,b){
			return buildRuns(A,a,b,b-a);
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a,i=0,j=m,k=a;
			await multiSwap(A,a,p,pL,true);
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m,i=pL-1,j=m-1,k=b-1;
			await multiSwap(A,m,p,pL,true);
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+i--,1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true),t=i-m;;
				await rotate(A,a,m,i);m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false),t=m-i;
				await rotate(A,i,m,b);m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function inPlaceMerge(A,a,m,b,d){
			if(d){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			}
			if(b-m<m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function redistBufferFW(A,a,m,b){
			let rP=leftExpSearch(A,m,b,A[a],true);
			await rotate(A,a,m,rP);
			let d=rP-m;a+=d;m+=d;
			let a1=a+(m-a)/2|0;
			rP=leftExpSearch(A,m,b,A[a1],true);
			await rotate(A,a1,m,rP);d=rP-m;a1+=d;m+=d;
			await inPlaceMerge(A,a,a1-d,a1,false);
			await inPlaceMerge(A,a1,m,b,false);
		}
		async function redistBufferBW(A,a,m,b){
			let rP=rightExpSearch(A,a,m,A[b-1],false);
			await rotate(A,rP,m,b);
			let d=m-rP;b-=d;m-=d;
			let b1=m+(b-m)/2|0;
			rP=rightExpSearch(A,a,m,A[b1-1],false);
			await rotate(A,rP,m,b1);d=m-rP;b1-=d;m-=d;
			await inPlaceMerge(A,b1,b1+d,b,false);
			await inPlaceMerge(A,a,m,b1,false);
		}
		async function merge(A,a,m,b,p,d){
			if(d){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			}
			if(minVal(m-a,b-m)<9)
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			else if(b-m<m-a)await mergeBW(A,a,m,b,p);
			else await mergeFW(A,a,m,b,p);
		}
		async function rotateMerge(A,a,m,b,p,pL){
			while(minVal(m-a,b-m)>pL){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
				if(minVal(m-a,b-m)<=pL)return await merge(A,a,m,b,p,false);
				let m1,m2,m3;
				if(m-a>=b-m){
					m2=binSearch(A,m,b,A[m1=a+(m-a)/2|0],true);
					m3=m1+m2-m;
				}else{
					m1=binSearch(A,a,m,A[m2=m+(b-m)/2|0],false);
					m3=m2++-m+m1;
				}
				await rotate(A,m1,m,m2);
				if(b-m3-1<m3-a){
					await rotateMerge(A,m3+1,m2,b,p,pL);
					m=m1;b=m3;
				}else{
					await rotateMerge(A,a,m1,m3,p,pL);
					m=m2;a=m3+1;
				}
			}
			await merge(A,a,m,b,p,true);
		}
		async function lazyStableSort(A,a,b){
			let j=b-a;
			for(;j>31;j=++j/2|0);
			if(await buildRuns(A,a,b,j))return;
			for(let i;j<b-a;j*=2){
				for(i=a;i+2*j<=b;i+=2*j)await inPlaceMerge(A,i,i+j,i+2*j,true);
				if(i+j<b)await inPlaceMerge(A,i,i+j,b,true);
			}
		}
		async function mergeSort(A,a,b){
			let l=b-a,j=l;
			if(l<64)return await lazyStableSort(A,a,b);
			for(;j>31;j=++j/2|0);
			let bL=j;
			for(bL=j;bL*bL<l;bL*=2);
			let d=bL,bB,rR=await buildUniqueRunBW(A,b,d),lR=0;
			if(rR==d)bB=true;
			else{
				lR=await buildUniqueRun(A,a,d);
				if(lR==d)bB=false;
				else bB=(rR<16&&lR<16)||rR>=lR;
			}
			let k=bB?await findKeysBW(A,a,b,rR,d):await findKeys(A,a,b,lR,d);
			if(k==1)return;
			if(k<5)return await lazyStableSort(A,a,b);
			if(k<d){
				while(bL>k)bL=bL/2|0;
				k=bL;
			}
			let a1,b1,p;
			if(bB){
				a1=a;b1=b-k;p=b1;
			}else{
				a1=a+k;b1=b;p=a;
			}
			l=b1-a1;
			if(!await buildRuns(A,a1,b1,j)){
				let i;
				for(;j<=bL;j*=2)for(i=a1;i+j<b1;i+=2*j)await merge(A,i,i+j,minVal(i+2*j,b1),p,true);
				for(;j<l;j*=2)for(i=a1;i+j<b1;i+=2*j)await rotateMerge(A,i,i+j,minVal(i+2*j,b1),p,bL);
			}
			await insertSort(A,p,p+bL);
			if(bB){
				a=leftExpSearch(A,a,b1,A[b1],false);
				if(k>=(d/2|0))await redistBufferBW(A,a,b1,b);
				else await inPlaceMerge(A,a,b1,b,false);
			}else{
				b=rightExpSearch(A,a1,b,A[a1-1],true);
				if(k>=(d/2|0))await redistBufferFW(A,a,a1,b);
				else await inPlaceMerge(A,a,a1,b,false);
			}
		}
		await mergeSort(arr,0,len);
	}
	async ayatoSort(len){
		async function multiSwap(A,a,b,l,d){
			if(a==b)return;
			if(d)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function reverse(A,a,b){
			if(b-a<3)await swap(A,a,b,1,true);
			else await reversal(A,a,b,1,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3)await reverse(A,p0,p3);
			}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function buildUniqueRun(A,a,n){
			let nK=1,i=a+1;
			if(compareIndices(A,i-1,i)<0){
				i++;nK++;
				while(nK<n&&compareIndices(A,i-1,i)<0){
					i++;nK++;
				}
			}else if(compareIndices(A,i-1,i)>0){
				i++;nK++;
				while(nK<n&&compareIndices(A,i-1,i)>0){
					i++;nK++;
				}
				await reverse(A,a,i-1);
			}
			return nK;
		}
		async function buildUniqueRunBW(A,b,n){
			let nK=1,i=b-1;
			if(compareIndices(A,i-1,i)<0){
				i--;nK++;
				while(nK<n&&compareIndices(A,i-1,i)<0){
					i--;nK++;
				}
			}else if(compareIndices(A,i-1,i)>0){
				i--;nK++;
				while(nK<n&&compareIndices(A,i-1,i)>0){
					i--;nK++;
				}
				await reverse(A,i,b-1);
			}
			return nK;
		}
		async function findRun(A,a,b,mR){
			let i=a+1;
			if(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reverse(A,a,i-1);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			}
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++],false));
			return i;
		}
		function insertSort(A,a,b){
			return findRun(A,a,b,b-a);
		}
		async function findKeys(A,a,b,nK,n){
			let p=a,pE=a+nK;
			for(let i=pE;i<b&&nK<n;i++){
				let o=binSearch(A,p,pE,A[i],true);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,p,pE,i);
					let n=i-pE;o+=n;p+=n;pE+=n;nK++;
					await insertTo(A,pE++,o);
				}
			}
			await rotate(A,a,p,pE);
			return nK;
		}
		async function findKeysBW(A,a,b,nK,n){
			let p=b-nK,pE=b;
			for(let i=p-1;i>=a&&nK<n;i--){
				let o=binSearch(A,p,pE,A[i],true);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,i+1,p,pE);
					let n=p-i-1;o-=n;pE-=n;p-=n+1;nK++;
					await insertTo(A,i,o-1);
				}
			}
			await rotate(A,p,pE,b);
			return nK;
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true),t=i-m;
				await rotate(A,a,m,i);m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false),t=m-i;
				await rotate(A,i,m,b);m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function inPlaceMerge(A,a,m,b,bnd){
			if(bnd){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			}
			if(b-m<=m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a,i=0,j=m,k=a;
			await multiSwap(A,a,p,pL,true);
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m,i=pL-1,j=m-1,k=b-1;
			await multiSwap(A,m,p,pL,true);
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+i--,1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function merge(A,a,m,b,p,d){
			if(d){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			}
			if(minVal(m-a,b-m)<9)
				if(m-a>b-m)await inPlaceMergeBW(A,a,m,b);
				else await inPlaceMergeFW(A,a,m,b);
			else if(b-m<m-a)await mergeBW(A,a,m,b,p);
			else await mergeFW(A,a,m,b,p);
		}
		async function redistBufferFW(A,a,m,b){
			let rP=leftExpSearch(A,m,b,A[a],true);
			await rotate(A,a,m,rP);
			let d=rP-m;a+=d;m+=d;
			let a1=a+(m-a)/2|0;
			rP=leftExpSearch(A,m,b,A[a1],true);
			await rotate(A,a1,m,rP);d=rP-m;a1+=d;m+=d;
			await inPlaceMerge(A,a,a1-d,a1,false);
			await inPlaceMerge(A,a1,m,b,false);
		}
		async function redistBufferBW(A,a,m,b){
			let rP=rightExpSearch(A,a,m,A[b-1],false);
			await rotate(A,rP,m,b);
			let d=m-rP;b-=d;m-=d;
			let b1=m+(b-m)/2|0;
			rP=rightExpSearch(A,a,m,A[b1-1],false);
			await rotate(A,rP,m,b1);d=m-rP;b1-=d;m-=d;
			await inPlaceMerge(A,b1,b1+d,b,false);
			await inPlaceMerge(A,a,m,b1,false);
		}
		async function rotateMerge(A,a,m,b,p,pL){
			while(minVal(m-a,b-m)>pL){
				if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
				if(minVal(m-a,b-m)<=pL)return await merge(A,a,m,b,p,false);
				let m1,m2,m3;
				if(m-a>=b-m){
					m2=binSearch(A,m,b,A[m1=a+(m-a)/2|0],true);
					m3=m1+m2-m;
				}else{
					m1=binSearch(A,a,m,A[m2=m+(b-m)/2|0],false);
					m3=m2++-m+m1;
				}
				await rotate(A,m1,m,m2);
				if(b-m3-1<m3-a){
					await rotateMerge(A,m3+1,m2,b,p,pL);
					m=m1;b=m3;
				}else{
					await rotateMerge(A,a,m1,m3,p,pL);
					m=m2;a=m3+1;
				}
			}
			await merge(A,a,m,b,p,true);
		}
		async function lazyStableSort(A,a,b){
			let mR=b-a,i,j,k;
			while(mR>31)mR=++mR/2|0;
			while(1){
				if((i=await findRun(A,a,b,mR))>=b)break;
				await inPlaceMerge(A,a,i,j=await findRun(A,i,b,mR),true);
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b,mR))>=b)break;
					await inPlaceMerge(A,k,i,j=await findRun(A,i,b,mR),true);
					if((k=j)>=b)break;
				}
			}
		}
		async function innerSort(A,a,b,p,pL,mR){
			let i,j,k;
			while(1){
				if((i=await findRun(A,a,b,mR))>=b)break;
				await rotateMerge(A,a,i,j=await findRun(A,i,b,mR),p,pL);
				if((k=j)>=b)break;
				while(1){
					if((i=await findRun(A,k,b,mR))>=b)break;
					await rotateMerge(A,k,i,j=await findRun(A,i,b,mR),p,pL);
					if((k=j)>=b)break;
				}
			}
		}
		async function mergeSort(A,a,b){
			let l=b-a,mR=l;
			if(l<64)return await lazyStableSort(A,a,b);
			while(mR>31)mR=++mR/2|0;
			let bL=mR;
			for(bL=mR;bL*bL<l;bL*=2);
			let d=bL,bB,rR=await buildUniqueRunBW(A,b,d),lR=0;
			if(rR==d)bB=true;
			else{
				lR=await buildUniqueRun(A,a,d);
				if(lR==d)bB=false;
				else bB=(rR<16&&lR<16)||rR>=lR;
			}
			let k=bB?await findKeysBW(A,a,b,rR,d):await findKeys(A,a,b,lR,d);
			if(k==1)return;
			if(k<5)return await lazyStableSort(A,a,b);
			if(k<d){
				while(bL>k)bL=bL/2|0;
				k=bL;
			}
			let a1,b1,p;
			if(bB){
				a1=a;b1=b-k;p=b1;
			}else{
				a1=a+k;b1=b;p=a;
			}
			await innerSort(A,a1,b1,p,bL,mR);
			await insertSort(A,p,p+bL);
			if(bB){
				a=leftExpSearch(A,a,b1,A[b1],false);
				if(k>=(d/2|0))await redistBufferBW(A,a,b1,b);
				else await inPlaceMerge(A,a,b1,b,false);
			}else{
				b=rightExpSearch(A,a1,b,A[a1-1],true);
				if(k>=(d/2|0))await redistBufferFW(A,a,a1,b);
				else await inPlaceMerge(A,a,a1,b,false);
			}
		}
		await mergeSort(arr,0,len);
	}
	async sanaeSort(len){
		function ceilCbrt(n){
			let r=0;
			while(r*r*r<n)r++;
			return r;
		}
		async function multiSwap(A,a,b,l,d){
			if(a==b)return;
			if(d)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function reverse(A,a,b){
			if(b-a<3)await swap(A,a,b,1,true);
			else await reversal(A,a,b,1,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3)await reverse(A,p0,p3);
			}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function buildUniqueRun(A,a,n){
			let nK=1,i=a+1;
			if(compareIndices(A,i-1,i)<0){
				i++;nK++;
				while(nK<n&&compareIndices(A,i-1,i)<0){
					i++;nK++;
				}
			}else if(compareIndices(A,i-1,i)>0){
				i++;nK++;
				while(nK<n&&compareIndices(A,i-1,i)>0){
					i++;nK++;
				}
				await reverse(A,a,i-1);
			}
			return nK;
		}
		async function buildUniqueRunBW(A,b,n){
			let nK=1,i=b-1;
			if(compareIndices(A,i-1,i)<0){
				i--;nK++;
				while(nK<n&&compareIndices(A,i-1,i)<0){
					i--;nK++;
				}
			}else if(compareIndices(A,i-1,i)>0){
				i--;nK++;
				while(nK<n&&compareIndices(A,i-1,i)>0){
					i--;nK++;
				}
				await reverse(A,i,b-1);
			}
			return nK;
		}
		async function findKeys(A,a,b,nK,n){
			let p=a,pE=a+nK;
			for(let i=pE;i<b&&nK<n;i++){
				let o=binSearch(A,p,pE,A[i],true);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,p,pE,i);
					let n=i-pE;o+=n;p+=n;pE+=n;nK++;
					await insertTo(A,pE++,o);
				}
			}
			await rotate(A,a,p,pE);
			return nK;
		}
		async function findKeysBW(A,a,b,nK,n){
			let p=b-nK,pE=b;
			for(let i=p-1;i>=a&&nK<n;i--){
				let o=binSearch(A,p,pE,A[i],true);
				if(pE==o||compareIndices(A,i,o)){
					await rotate(A,i+1,p,pE);
					let n=p-i-1;o-=n;pE-=n;p-=n+1;nK++;
					await insertTo(A,i,o-1);
				}
			}
			await rotate(A,p,pE,b);
			return nK;
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a;
			let nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					await reverse(A,j,i-1);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true),t=i-m;
				await rotate(A,a,m,i);m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false),t=m-i;
				await rotate(A,i,m,b);m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function inPlaceMerge(A,a,m,b){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(b-m<=m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function mergeFW(A,a,m,b,p){
			let pL=m-a,i=0,j=m,k=a;
			await multiSwap(A,a,p,pL,true);
			while(i<pL&&j<b)
				if(compareIndices(A,p+i,j)<1)await swap(A,k++,p+i++,1,true);
				else await swap(A,k++,j++,1,true);
			while(i<pL)await swap(A,k++,p+i++,1,true);
		}
		async function mergeBW(A,a,m,b,p){
			let pL=b-m,i=pL-1,j=m-1,k=b-1;
			await multiSwap(A,m,p,pL,true);
			while(i>=0&&j>=a)
				if(compareIndices(A,p+i,j)+1)await swap(A,k--,p+i--,1,true);
				else await swap(A,k--,j--,1,true);
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function merge(A,a,m,b,p){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			if(b-m<m-a)await mergeBW(A,a,m,b,p);
			else await mergeFW(A,a,m,b,p);
		}
		async function fragmentedMergeFW(A,a,m,b,s){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			while(m-a>s&&m<b){
				let rP,d,a1=a+s;
				rP=binSearch(A,m,b,A[a1],true);
				await rotate(A,a1,m,rP);d=rP-m;a1+=d;m+=d;
				await inPlaceMerge(A,a,a1-d,a=a1);
			}
			await inPlaceMerge(A,a,m,b);
		}
		async function fragmentedMergeBW(A,a,m,b,s){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			while(b-m>s&&m>a){
				let rP,d,b1=b-s;
				rP=binSearch(A,a,m,A[b1-1],false);
				await rotate(A,rP,m,b1);d=m-rP;b1-=d;m-=d;
				await inPlaceMerge(A,b1,b1+d,b);b=b1;
			}
			await inPlaceMerge(A,a,m,b);
		}
		async function lazyBufferedMergeBW(A,a,m,b,p){
			if(a>=m||m>=b||compareIndices(A,m-1,m)<1)return;
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(compareIndices(A,a,b-1)>0)return await rotate(A,a,m,b);
			let pL=b-m,i=pL-1,j=m-1,k=b-1;
			await multiSwap(A,m,p,pL,true);
			while(i>=0&&j>=a){
				if(compareIndices(A,j,p+i)>0){
					let q=rightExpSearch(A,a,j+1,A[p+i],false);
					while(j>=q)await swap(A,k--,j--,1,true);
				}
				await swap(A,k--,p+i--,1,true);
			}
			while(i>=0)await swap(A,k--,p+i--,1,true);
		}
		async function lazyStableSort(A,a,b){
			let j=b-a;
			for(;j>31;j=++j/2|0);
			if(await buildRuns(A,a,b,j))return;
			for(let i;j<b-a;j*=2)for(i=a;i+j<b;i+=2*j)await inPlaceMerge(A,i,i+j,minVal(i+2*j,b));
		}
		async function lazierestSort(A,a,b){
			let l=b-a;
			if(l<32)return await lazyStableSort(A,a,b);
			let s=ceilCbrt(l),s1=s*s;
			if(await buildRuns(A,a,b,s))return;
			for(let i=a+s,j=a;i<b;i+=s){
				if(i-j==s1){
					j+=s1;i+=s;
				}
				await inPlaceMerge(A,j,i,minVal(i+s,b));
			}
			for(let i=a+s1;i<b;i+=s1)await fragmentedMergeBW(A,a,i,minVal(i+s1,b),s);
		}
		async function mergeSort(A,a,b){
			let l=b-a,bL,mR;
			if(l<65)return await lazyStableSort(A,a,b);
			for(bL=1;(bL*bL*bL/l|0)<l;bL*=2);
			for(mR=1;(mR*mR*mR/l|0)<l;mR++);
			mR=(16*mR)/bL|0;bL=(bL*mR)/16|0;
			let bB,rR=await buildUniqueRunBW(A,b,bL),lR=0;
			if(rR==bL)bB=true;
			else{
				lR=await buildUniqueRun(A,a,bL);
				if(lR==bL)bB=false;
				else bB=(rR<16&&lR<16)||rR>=lR;
			}
			let k=bB?await findKeysBW(A,a,b,rR,bL):await findKeys(A,a,b,lR,bL);
			if(k<bL){
				if(keys==1)return;
				else if(k<=ceilCbrt(l))await lazyStableSort(A,a,b);
				else await lazierestSort(A,a,b);
				return;
			}
			let a1,b1,p;
			if(bB){
				a1=a;b1=b-k;p=b1;
			}else{
				a1=a+k;b1=b;p=a;
			}
			l=b1-a1;
			if(!await buildRuns(A,a1,b1,mR)){
				let i,j=mR;
				for(;j<bL;j*=2)for(i=a1;i+j<b1;i+=2*j)await merge(A,i,i+j,minVal(i+2*j,b1),p);
				for(i=a1+bL;i<b1;i+=bL)await lazyBufferedMergeBW(A,a1,i,minVal(i+bL,b1),p);
			}
			await lazierestSort(A,p,p+bL);
			let s=maxVal(16,ceilCbrt(b-a));
			if(bB)await fragmentedMergeBW(A,a=leftExpSearch(A,a,b1,A[b1],false),b1,b,s);
			else await fragmentedMergeFW(A,a,a1,b=rightExpSearch(A,a1,b,A[a1-1],true),s);
		}
		await mergeSort(arr,0,len);
	}
	async pureFibHeapSort(len){
		function genFib(){
			FIB[0]=FIB[1]=1;
			for(let i=2;i<FIB.length;i++)FIB[i]=FIB[i-2]+FIB[i-1];
		}
		async function sift(A,a,b){
			let o=2,n=b-1;
			while(1){
				let f=FIB[o-2],j=b-f;
				if(j<a)return;
				else{
					let l=j,m=b-FIB[o-1];
					if(m<a)m=a;
					for(let i=m;i<j;i++)if(i>=a&&compareIndices(A,l,i)>0)l=i;
					await swap(A,l,n,1,true);
					n=l;o=toByte(o+1);
				}
			}
		}
		async function fibHeapify(A,s,e){
			genFib();
			let j=1;
			while(FIB[j]<=e-s)j++;
			for(let i=s+1;i<=e;i++)await sift(A,s,i);
		}
		let FIB=new Array(46).fill(0);
		async function sort(A,l){
			await fibHeapify(A,0,l);
			for(let i=0;i<l;i++){
				await swap(A,i,l-1,1,true);
				await sift(A,i+1,l);
			}
			await insertSort(A,0,l,1);
		}
		await sort(arr,len);
	}
	async quickMergeSort(len){
		function log2(n){
			let l=0;
			while(n>>=1)++l;
			return l;
		}
		let threshold=32;
		function equ(a,b){
			return((a-b)>>31)+((b-a)>>31)+1;
		}
		async function stableSegmentReversal(A,s,e){
			if(e-s<3)await swap(A,s,e,.5,true);
			else await reversal(A,s,e,.5,true);
			let i=s,l,r;
			while(i<e){
				l=i;while(i<e&&!compareIndices(A,i,i+1))i++;r=i;
				if(l-r)
					if(r-l<3)await swap(A,l,r,.5,true);
					else await reversal(A,l,r,.5,true);
				i++;
			}
		}
		function medOf3(A,i0,i1,i2){
			let t;
			if(compareIndices(A,i0,i1)>0){
				t=i1;i1=i0;
			}else t=i0;
			if(compareIndices(A,i1,i2)>0){
				if(compareIndices(A,t,i2)>0)return t;
				return i2;
			}
			return i1;
		}
		function medP3(A,a,b,d){
			if(b-a==3||(b-a>3&&!d))return medOf3(A,a,a+(b-a)/2|0,b-1);
			if(b-a<3)return a+(b-a)/2|0;
			let t=(b-a)/3|0;
			return medOf3(A,medP3(A,a,a+t,--d),medP3(A,a+t,b-t,d),medP3(A,b-t,b,d));
		}
		function medOfMed(A,a,b){
			if(b-a<7)return a+(b-a)/2|0;
			let p=1;
			while(6*p<b-a)p*=3;
			return medOf3(A,medP3(A,a,a+p,-1),medOfMed(A,a+p,b-p),medP3(A,b-p,b,-1));
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			return binSearch(A,a+i/2|0,minVal(b,a-1+i),v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			return binSearch(A,maxVal(a,b-i+1),b-i/2|0,v,l);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function mergeFWExt(A,T,a,m,b){
			let s=m-a;
			arraycopy(A,a,T,0,s,0,false,true);
			let i=0,j=m;
			while(i<s&&j<b)
				if(compareValues(T[i],A[j])<1)await write(A,a++,T[i++],1,true);
				else await write(A,a++,A[j++],1,true);
			while(i<s)await write(A,a++,T[i++],1,true);
		}
		async function mergeBWExt(A,T,a,m,b){
			let s=b-m;
			arraycopy(A,m,T,0,s,0,false,true);
			let i=s-1,j=m-1;
			while(i>=0&&j>=a)
				if(compareValues(T[i],A[j])+1)await write(A,--b,T[i--],1,true);
				else await write(A,--b,A[j--],1,true);
			while(i>=0)await write(A,--b,T[i--],1,true);
		}
		async function merge(A,buf,a,m,b){
			if(compareIndices(A,m-1,m)<1)return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(m-a>b-m)await mergeBWExt(A,buf,a,m,b);
			else await mergeFWExt(A,buf,a,m,b);
		}
		async function findRun(A,a,b,mR){
			let i=a+1;
			if(i<b)
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-a<4)await swap(A,a,i-1,1,true);
					else await reversal(A,a,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
			while(i-a<mR&&i<b)await insertTo(A,i,rightExpSearch(A,a,i,A[i++],false));
			return i;
		}
		function insertSort(A,a,b){
			return findRun(A,a,b,b-a);
		}
		async function mergeSort(A,B,a,b){
			let l=b-a,mR=16,rs=new Array((l-1)/mR+2|0),r=a,rf=0;
			if(l<33)return await insertSort(A,a,b);
			while(r<b){
				write(rs,rf++,r,0,false,true);
				r=await findRun(A,r,b,mR);
			}
			while(rf>1){
				for(let i=0;i<rf-1;i+=2){
					let eI=i+3>rf?b:rs[i+2];
					await merge(A,B,rs[i],rs[i+1],eI);
				}
				for(let i=1,j=2;i<rf;i++,j+=2,rf--)write(rs,i,rs[j],0,false,true);
			}
		}
		async function partition(A,B,a,b,p){
			for(;a<b;a++)if(compareValues(A[a],p)+1)break;
			for(;b>a;b--)if(compareValues(A[b-1],p)<1)break;
			let l=b-a,p0=a,p1=0,p2=l;
			for(let i=a;i<b;i++){
				let c=compareIndexValue(A,i,p);
				if(c<0)await write(A,p0++,A[i],.5,true);
				else if(!c)write(B,--p2,A[i],0,false,true);
				else await write(B,p1++,A[i],0,false,true);
			}
			let qZ=l-p2,gZ=p1;
			if(qZ<b-a){
				for(let i=0;i<qZ;i++)await write(A,p0+i,B[p2+qZ-1-i],.5,true);
				await arraycopy(B,0,A,p0+qZ,gZ,.5,true);
			}
			return[p0,p0+qZ];
		}
		async function sortHelper(A,B,a,b,bA,bd,dM){
			if(b-a<33)return await insertSort(A,a,b);
			if(dM){
				let m=a+(b-a)/2|0;
				await sortHelper(A,B,a,m,bA,bd,false);
				await sortHelper(A,B,m,b,bA,bd,false);
				await merge(A,B,a,m,b);
				return;
			}
			let pI=bd?medOfMed(A,a,b):medP3(A,a,b,1),[lL,rL]=await partition(A,B,a,b,A[pI]),qL=rL-lL;
			if(qL==b-a)return;
			if(!rL)bd=qL<(lL/8|0);
			else if(!lL)bd=qL<(rL/8|0);
			else bd=(rL/8|0)>lL||(lL/8|0)>rL;
			if(bd)if(!--bA)return await mergeSort(A,B,a,b);
			dM=true;
			if(rL<lL){
				await sortHelper(A,B,rL,b,bA,bd,true);
				await sortHelper(A,B,a,lL,bA,bd,true);
			}else{
				await sortHelper(A,B,a,lL,bA,bd,true);
				await sortHelper(A,B,rL,b,bA,bd,true);
			}
		}
		async function quickMergeSort(A,a,b){
			let l=b-a,bl=0,eq=0,st=0,d,qd,lp,c=l,p=a;
			while(c>16){
				for(qd=d=0,lp=0;lp<16;lp++){
					let m=compareIndices(A,p,p+1);
					d+=m>0;qd+=!m;p++;
				}
				st+=equ(d,0)|equ(d+qd,16);bl+=d;eq+=qd;c-=16;
			}
			while(--c>0){
				let m=compareIndices(A,p,p+1);
				bl+=c>0;eq+=!m;p++;
			}
			if(!bl)return;
			if(bl+eq==l-1){
				if(eq>0)await stableSegmentReversal(A,a,b-1);
				else if(b-a<4)await swap(A,a,b-1,.5,true);
				else await reversal(A,a,b-1,.5,true);
				return;
			}
			let B=new Array(l),sx=l/6|0;
			if(st>(l/20|0)||bl<=sx||bl+eq>=l-sx)await mergeSort(A,B,a,b);
			else await sortHelper(A,B,a,b,log2(l),false,false);
		}
		await quickMergeSort(arr,0,len);
	}
	async satoriSort(len){
		function ceilCbrt(n){
			let r=0;
			while(r*r*r<n)
				r++;
			return r;
		}
		async function multiSwap(A,a,b,l,d){
			if(a==b)return;
			if(d)for(let i=0;i<l;i++)await swap(A,a+i,b+i,1,true);
			else for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,1,true);
		}
		async function insertTo(A,a,b){
			let t=A[a],d=a>b?-1:1;
			for(let i=a;i-b;i+=d)await write(A,i,A[i+d],.5,true);
			if(a-b)await write(A,b,t,.5,true);
		}
		async function rotate(A,a,m,b){
			if(a>=m||m>=b)return;
			let l=m-a,r=b-m;
			if(l%r<1||r%l<1){
				while(l>1&&r>1)
					if(r<l){
						await multiSwap(A,m-r,m,r,false);
						b-=r;m-=r;l-=r;
					}else{
						await multiSwap(A,a,m,l,true);
						a+=l;m+=l;r-=l;
					}
				if(r==1)await insertTo(A,m,a);
				else if(l==1)await insertTo(A,a,b-1);
			}else{
				let p0=a,p1=m-1,p2=m,p3=b-1,t;
				while(p0<p1&&p2<p3){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p2],.5,true);
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p0<p1){
					t=A[p1];
					await write(A,p1--,A[p0],.5,true);
					await write(A,p0++,A[p3],.5,true);
					await write(A,p3--,t,.5,true);
				}
				while(p2<p3){
					t=A[p2];
					await write(A,p2++,A[p3],.5,true);
					await write(A,p3--,A[p0],.5,true);
					await write(A,p0++,t,.5,true);
				}
				if(p0<p3)
					if(p3-p0<3)await swap(A,p0,p3,1,true);
					else await reversal(A,p0,p3,1,true);
			}
		}
		function binSearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareValues(v,A[m]);
				if(c<0||l&&!c)b=m;
				else a=m+1;
			}
			return a;
		}
		function leftExpSearch(A,a,b,v,l){
			let i=1;
			while(a-1+i<b&&compareValues(A[a-1+i],v)<(l?0:1))i*=2;
			let a1=a+i/2|0,b1=minVal(b,a-1+i);
			return binSearch(A,a1,b1,v,l);
		}
		function rightExpSearch(A,a,b,v,l){
			let i=1;
			while(b-i>=a&&compareValues(v,A[b-i])<(l?1:0))i*=2;
			let a1=maxVal(a,b-i+1),b1=b-i/2|0;
			return binSearch(A,a1,b1,v,l);
		}
		async function checkReverseBounds(A,a,m,b){
			if(compareIndices(A,a,b-1)>0){
				await rotate(A,a,m,b);
				return true;
			}
			return false;
		}
		async function boundCheck(A,a,m,b){
			if(a>=m||m>=b)return true;
			return compareIndices(A,m-1,m)<1||await checkReverseBounds(A,a,m,b);
		}
		async function buildRuns(A,a,b,mR){
			let i=a+1,j=a,nS=true;
			while(i<b){
				if(compareIndices(A,i-1,i++)>0){
					while(i<b&&compareIndices(A,i-1,i)>0)i++;
					if(i-j<4)await swap(A,j,i-1,1,true);
					else await reversal(A,j,i-1,1,true);
				}else while(i<b&&compareIndices(A,i-1,i)<1)i++;
				if(i<b){
					nS=false;j=i-(i-j-1)%mR-1;
				}
				while(i-j<mR&&i<b)await insertTo(A,i,rightExpSearch(A,j,i,A[i++],false));
				j=i++;
			}
			return nS;
		}
		async function inPlaceMergeFW(A,a,m,b){
			while(a<m&&m<b){
				let i=leftExpSearch(A,m,b,A[a],true),t=i-m;
				await rotate(A,a,m,i);m=i;a+=t+1;
				if(m>=b)break;
				a=leftExpSearch(A,a,m,A[m],false);
			}
		}
		async function inPlaceMergeBW(A,a,m,b){
			while(b>m&&m>a){
				let i=rightExpSearch(A,a,m,A[b-1],false),t=m-i;
				await rotate(A,i,m,b);m=i;b-=t+1;
				if(m<=a)break;
				b=rightExpSearch(A,m,b,A[m-1],true);
			}
		}
		async function inPlaceMerge(A,a,m,b,d){
			if(d){
				if(await boundCheck(A,a,m,b))return;
				a=leftExpSearch(A,a,m,A[m],false);
				b=rightExpSearch(A,m,b,A[m-1],true);
				if(await checkReverseBounds(A,a,m,b))return;
			}
			if(b-m<=m-a)await inPlaceMergeBW(A,a,m,b);
			else await inPlaceMergeFW(A,a,m,b);
		}
		async function fragmentedMergeFW(A,a,m,b,s){
			while(m-a>s){
				let rP,d,a1=a+s;
				rP=binSearch(A,m,b,A[a1],true);
				await rotate(A,a1,m,rP);d=rP-m;a1+=d;m+=d;
				await inPlaceMerge(A,a,a1-d,a=a1,true);
			}
			await inPlaceMerge(A,a,m,b,true);
		}
		async function fragmentedMergeBW(A,a,m,b,s){
			while(b-m>s){
				let rP,d,b1=b-s;
				rP=binSearch(A,a,m,A[b1-1],false);
				await rotate(A,rP,m,b1);d=m-rP;b1-=d;m-=d;
				await inPlaceMerge(A,b1,b1+d,b,true);b=b1;
			}
			await inPlaceMerge(A,a,m,b,true);
		}
		async function fragmentedMerge(A,a,m,b,s){
			if(await boundCheck(A,a,m,b))return;
			a=leftExpSearch(A,a,m,A[m],false);
			b=rightExpSearch(A,m,b,A[m-1],true);
			if(await checkReverseBounds(A,a,m,b))return;
			if(b-m<=m-a)await fragmentedMergeBW(A,a,m,b,s);
			else await fragmentedMergeFW(A,a,m,b,s);
		}
		async function mergeSort(A,a,b){
			let l=b-a,s=ceilCbrt(l),s1=s*s;
			if(l<32)return await buildRuns(A,a,b,b-a);
			if(await buildRuns(A,a,b,s))return;
			for(let i=a+s,j=a;i<b;i+=s){
				if(i-j==s1){
					j+=s1;i+=s;
				}
				await inPlaceMerge(A,j,i,minVal(i+s,b),true);
			}
			for(let i=a+s1;i<b;i+=s1)await fragmentedMerge(A,a,i,minVal(i+s1,b),s);
		}
		await mergeSort(arr,0,len);
	}
	async lithiumSort(len){
		class BitArray{
			constructor(A,a,b,z,w){
				this.A=A;this.a=a;this.b=b;this.z=z;this.w=w;this.l=z*w;
			}
			async flipBit(a,b){
				await swap(A,a,b,.5,true);
			}
			getBit(a,b){
				return compareIndices(this.A,a,b)>0;
			}
			async setBit(a,b,t){
				if(this.getBit(a,b)^t)await this.flipBit(a,b);
			}
			async free(){
				let i1=this.a+this.l;
				for(let i=this.a,j=this.b;i<i1;i++,j++)await this.setBit(i,j,false);
			}
			async set(d,v){
				if(d<0||d>=this.z)return;
				let s=d*this.w,i1=this.a+s+this.w;
				for(let i=this.a+s,j=this.b+s;i<i1;i++,j++,v>>=1)await this.setBit(i,j,(v&1)>0);
			}
			get(d){
				if(d<0||d>=this.z)return;
				let r=0,s=d*this.w;
				for(let k=0,i=this.a+s,j=this.b+s;k<this.w;k++,i++,j++)r|=(this.getBit(i,j)?1:0)<<k;
				return r;
			}
			async swap(a,b){
				if(a<0||a>=this.z)return;if(b<0||b>=this.z)return;
				let t=this.get(a);
				await this.set(a,this.get(b));
				await this.set(b,t);
			}
		}
		async function blockSwapFW(A,a,b,l){
			for(let i=0;i<l;i++)await swap(A,a+i,b+i,.5,true);
		}
		async function blockSwapBW(A,a,b,l){
			for(let i=l-1;i>=0;i--)await swap(A,a+i,b+i,.5,true);
		}
		async function insertToLeft(A,f,t){
			let n=A[f];
			for(let i=f-1;i>=t;i--)await write(A,i+1,A[i],.25,true);
			await write(A,t,n,.25,true);
		}
		async function insertToRight(A,f,t){
			let n=A[f];
			for(let i=f;i<t;i++)await write(A,i,A[i+1],.25,true);
			await write(A,t,n,.25,true);
		}
		async function rotate(A,a,m,b){
			let rl=b-m,ll=m-a;
			while(rl>1&&ll>1)
				if(rl<ll){
					await blockSwapFW(A,a,m,rl);
					a+=rl;ll-=rl;
				}else{
					rl-=ll;
					await blockSwapBW(A,a,b-=ll,ll);
				}
			if(rl==1)await insertToLeft(A,m,a);
			else if(ll==1)await insertToRight(A,a,b-1);
		}
		function binarySearch(A,a,b,v,l){
			while(a<b){
				let m=a+(b-a)/2|0,c=compareIndexValue(A,m,v);
				if(l?c+1:c>0)b=m;
				else a=m+1;
			}
			return a;
		}
		async function findKeys(A,a,b,q){
			let n=1,p=b-1;
			for(let i=p;i>a&&n<q;i--){
				let l=binarySearch(A,p,p+n,A[i-1],true)-p;
				if(l==n||compareIndices(A,i-1,p+l)<0){
					await rotate(A,i,p,p+n++);
					await insertToRight(A,p=i-1,p+l);
				}
			}
			await rotate(A,p,p+n,b);
			return n;
		}
		async function insertSort(A,a,b){
			for(let i=a+1;i<b;i++)if(compareIndices(A,i,i-1)<0)await insertToLeft(A,i,binarySearch(A,a,i,A[i],false));
		}
		async function sortRuns(A,a,b){
			let i;
			for(i=a;i<b-32;i+=32)await insertSort(A,i,i+32);
			if(i<b)await insertSort(A,i,b);
		}
		async function mergeInPlaceBW(A,a,m,b,L){
			let s=b-1,l=m-1;
			while(s>l&&l>=a){
				let c=compareIndices(A,l,s);
				if(L?c>0:c+1){
					let p=binarySearch(A,a,l,A[s],!L);
					await rotate(A,p,l+1,s+1);
					s-=l+1-p;l=p-1;
				}else s--;
			}
		}
		async function mergeWithBufferBW(A,a,m,b,L){
			let rl=b-m;
			if(rl<17||rl>FL)return await mergeInPlaceBW(A,a,m,b,L);
			await blockSwapBW(A,m,FP,rl);
			let l=m-1,r=FP+rl-1,o=b-1;
			for(;l>=a&&r>=FP;o--){
				let c=compareIndices(A,r,l);
				if(L?c+1:c>0)await swap(A,o,r--,.5,true);
				else await swap(A,o,l--,.5,true);
			}
			while(r>=FP)await swap(A,o--,r--,.5,true);
		}
		async function mergeWithScrollingBufferBW(A,a,m,b){
			let l=m-1,r=b-1,o=r+m-a;
			while(r>=m&&l>=a)
				if(compareIndices(A,r,l)+1)await swap(A,o--,r--,.5,true);
				else await swap(A,o--,l--,.5,true);
			while(r>=m)await swap(A,o--,r--,.5,true);
			while(l>=a)await swap(A,o--,l--,.5,true);
		}
		async function shift(A,a,m,b,l){
			if(l){
				if(m==b)return;
				while(m>a)await swap(A,--b,--m,.5,true);
			}else{
				if(m==a)return;
				while(m<b)await swap(A,a++,m++,.5,true);
			}
		}
		async function dualMergeFW(A,a,m,b,r){
			let i=a,j=m,k=a-r;
			while(k<i&&i<m)
				if(compareIndices(A,i,j)<1)await swap(A,k++,i++,.5,true);
				else await swap(A,k++,j++,.5,true);
			if(k<i)await shift(A,j-r,j,b,false);
			else{
				let i2=m-1,j2=b-1;k=i2+b-j;
				while(i2>=i&&j2>=j)
					if(compareIndices(A,i2,j2)>0)await swap(A,k--,i2--,.5,true);
					else await swap(A,k--,j2--,.5,true);
				while(j2>=j)await swap(A,k--,j2--,.5,true);
			}
		}
		async function swapKeys(A,bs,a,b){
			if(bs==null)await swap(A,KP+a,KP+b,1,true);
			else await bs.swap(a,b);
		}
		function compareKeys(A,bs,a,b){
			return bs==null?compareIndices(A,KP+a,KP+b):compareValues(bs.get(a),bs.get(b));
		}
		async function blockSelect(A,bs,a,lB,rB,bL){
			let i1=0,tm=lB,j1=tm,k=0,tb=tm+rB;
			while(k<j1&&j1<tb)
				if(compareIndices(A,a+(i1+1)*bL-1,a+(j1+1)*bL-1)<1){
					if(i1>k)await blockSwapFW(A,a+k*bL,a+i1*bL,bL);
					await swapKeys(A,bs,k++,i1);i1=k;
					for(let i=maxVal(k+1,tm);i<j1;i++)if(compareKeys(A,bs,i,i1)<0)i1=i;
				}else{
					await blockSwapFW(A,a+k*bL,a+j1*bL,bL);
					await swapKeys(A,bs,k,j1++);
					if(i1==k++)i1=j1-1;
				}
			while(k<j1-1){
				if(i1>k)await blockSwapFW(A,a+k*bL,a+i1*bL,bL);
				await swapKeys(A,bs,k++,i1);i1=k;
				for(let i=k+1;i<j1;i++)if(compareKeys(A,bs,i,i1)<0)i1=i;
			}
		}
		function compareMidKey(A,bs,i,mK){
			return bs==null?compareIndexValue(A,KP+i,mK)<0:compareValues(bs.get(i),mK)<0;
		}
		async function mergeBlocks(A,a,mK,bQ,bL,lL,bs){
			let f=a,l=compareMidKey(A,bs,0,mK);
			for(let i=1;i<bQ;i++)
				if(l^compareMidKey(A,bs,i,mK)){
					let n=a+i*bL,nE=binarySearch(A,n,n+bL,A[n-1],l);
					await mergeWithBufferBW(A,f,n,f=nE,l);
					l=!l;
				}
			if(l&&lL){
				let lF=a+bQ*BL;
				await mergeWithBufferBW(A,f,lF,lF+lL,l);
			}
		}
		async function blockCycle(A,a,b,bL,bs){
			let t=(b-a)/bL|0;
			for(let i=0;i<t;i++){
				let k=bs.get(i);
				if(k-i){
					let j=i;
					do{
						await blockSwapFW(A,a+k*bL,a+j*bL,bL);
						await bs.set(j,j);
						k=bs.get(j=k);
					}while(k-i);
					await bs.set(j,j);
				}
			}
		}
		async function kotaMerge(A,a,m,b,bL,bs){
			let c=0,t=2,i=a,j=m,k=FP,l=0,r=0;
			while(c++<FL)
				if(compareIndices(A,i,j)<1){
					await swap(A,k++,i++,.5,true);l++;
				}else{
					await swap(A,k++,j++,.5,true);r++;
				}
			let L=l>=r;k=L?i-l:j-r;c=0;
			do{
				if(i<m&&(j==b||compareIndices(A,i,j)<1)){
					await swap(A,k++,i++,.5,true);l++;
				}else{
					await swap(A,k++,j++,.5,true);r++;
				}
				if(++c==bL){
					await bs.set(t++,(k-a)/bL-1|0);
					if(L)l-=bL;
					else r-=bL;
					L=l>=r;k=L?i-l:j-r;c=0;
				}
			}while(i<m||j<b);
			let b1=b-c;
			await blockSwapFW(A,k-c,b1,c);r-=c;t=0;k=FP;
			while(l>0){
				await blockSwapFW(A,k,m-l,bL);
				await bs.set(t++,(m-a-l)/bL|0);
				k+=bL;l-=bL;
			}
			while(r>0){
				await blockSwapFW(A,k,b1-r,bL);
				await bs.set(t++,(b1-a-r)/bL|0);
				k+=bL;r-=bL;
			}
		}
		function log2(n){
			return 32-clz32(n);
		}
		async function prepareKeys(bs,q){
			for(let i=0;i<q;i++)await bs.set(i,i);
		}
		async function combine(A,a,m,b,bs){
			if(b-m<=FL)return await mergeWithBufferBW(A,a,m,b,true);
			if(DB){
				await kotaMerge(A,a,m,b,BL,bs);
				await blockCycle(A,a,b,BL,bs);
			}else{
				let lB=(m-a)/BL|0,rB=(b-m)/BL|0,bQ=lB+rB,fr=b-a-bQ*BL,mK;
				if(bs==null){
					await insertSort(A,KP,KP+bQ+1);
					mK=A[KP+lB];
				}else{
					await prepareKeys(bs,bQ);
					mK=lB;
				}
				await blockSelect(A,bs,a,lB,rB,BL);
				await mergeBlocks(A,a,mK,bQ,BL,fr,bs);
			}
		}
		function strat3BLenCalc(tR,r){
			let sT=1;
			for(;sT*sT<tR;sT*=2);
			for(;(tR/sT|0)>(r/(2*(log2(tR/sT|0)+1))|0);sT*=2);
			BL=sT;
		}
		function noBitsBLenCalc(tR){
			let kL=KL,kB=(kL+(kL&1))/2|0,bL=1,t;
			if(kB>=(tR/kB|0)){
				FL=kB;FP=KP+KL-kB;t=kB;
			}else{
				FL=0;t=tR/kL|0;
			}
			for(;bL<=t;bL*=2);
			BL=bL;
		}
		function resetBuf(){
			FP=KP;FL=KL;BL=OBL;
		}
		function checkValidBitArray(A,a,b,c){
			return compareIndices(A,a+c,b-c)<0;
		}
		async function firstMerge(A,a,m,b,s3){
			if(b-m<=FL)return await mergeWithBufferBW(A,a,m,b,true);
			let m1=a+(m-a)/2|0,m2=binarySearch(A,m,b,A[m1],true),m3=m1+m2-m;
			await rotate(A,m1,m,m2);
			let tR=b-m3;
			if(s3)strat3BLenCalc(tR,m1-a);
			let nW=tR/BL|0,w=log2(nW)+1,z=nW*w;
			if(checkValidBitArray(A,a,m1,z)){
				m3=m2-((m2-m3)/BL|0)*BL;
				let bs=new BitArray(A,a,m1-z,nW,w);
				await combine(A,m3,m2,b,bs);
				await bs.free();
			}else{
				noBitsBLenCalc(twoR);
				m3=m2-((m2-m3)/BL|0)*BL;
				let dB=DB;DB=false;
				await combine(A,m3,m2,b,null);
				DB=dB;
				resetBuf();
			}
			tR=m3-a;
			if(s3)strat3BLenCalc(twoR,b-m3);
			nW=twoR/BL|0;w=log2(nW)+1;z=nW*w;
			let fr,m4,m5;
			if(checkValidBitArray(A,m3,b,z)){
				m4=a+((m1-a)/BL|0)*BL;
				m5=m3-m1+m4;
				fr=m4-m1;
				if(fr)await rotate(A,m4,m1,m3);
				let bs=new BitArray(A,m3,b-z,nW,w);
				await combine(A,a,m4,m5,bs);
				await bs.free();
			}else{
				noBitsBLenCalc(tR);
				m4=a+((m1-a)/BL|0)*BL;
				m5=m3-m1+m4;
				fr=m4-m1;
				if(fr)await rotate(A,m4,m1,m3);
				let dB=DB;DB=false;
				await combine(A,a,m4,m5,null);
				DB=dB;
				resetBuf();
			}
			if(fr)await mergeWithBufferBW(A,a,m3,m5,false);
		}
		async function lithiumLoop(A,a,b){
			let r=32,e=b-KL;
			while(r<=FL){
				let tR=2*r,i;
				for(i=a;i<e-tR;i+=tR);
				if(i+r<e)await mergeWithScrollingBufferBW(A,i,i+r,e);
				else await shift(A,i,e,e+r,true);
				for(i-=tR;i>=a;i-=tR)await mergeWithScrollingBufferBW(A,i,i+r,i+tR);
				let oR=r;r=tR;tR*=2;
				for(i=a+oR;i+tR<e+oR;i+=tR)await dualMergeFW(A,i,i+r,i+tR,oR);
				if(i+r<e+oR)await dualMergeFW(A,i,i+r,e+oR,oR);
				else await shift(A,i-oR,i,e+oR,false);
				r=tR;
			}
			b=e;e+=KL;
			let s3=!BL,tR=r*2;
			while(tR<b-a){
				let i=a+tR;
				await firstMerge(A,a,a+r,i,s3);
				if(s3)strat3BLenCalc(twoR,r);
				let nW=tR/BL|0,w=log2(nW)+1,z=nW*w,bs,dB=DB;
				if(checkValidBitArray(A,a,a+tR,z))bs=new BitArray(A,a,a+tR-z,nW,w);
				else{
					bs=null;DB=false;
					noBitsBLenCalc(tR);
				}
				for(;i<b-tR;i+=tR)await combine(A,i,i+r,i+tR,bs);
				if(i+r<b)await combine(A,i,i+r,b,bs);
				if(bs==null){
					resetBuf();
					DB=dB;
				}else await bs.free();
				r=tR;tR*=2;
			}
			await firstMerge(A,a,a+r,b,s3);
			await insertSort(A,b,e);
			r=binarySearch(A,a,b,A[e-1],false);
			await rotate(A,r,b,e);
			let d=b-r;e-=d;b-=d;
			let b0=b+(e-b)/2|0;r=binarySearch(A,a,b,A[b0-1],false);
			await rotate(A,r,b,b0);
			d=b-r;b0-=d;b-=d;
			await mergeInPlaceBW(A,b0,b0+d,e,true);
			await mergeInPlaceBW(A,a,b,b0,true);
		}
		async function inPlaceMergeSort(A,a,b){
			await sortRuns(A,a,b);
			let r=32;
			while(r<b-a){
				let t=r*2,i;
				for(i=a;i<b-t;i+=t)await mergeInPlaceBW(A,i,i+r,i+t,true);
				if(i+r<b)await mergeInPlaceBW(A,i,i+r,b,true);
				r=t;
			}
		}
		let OBL,BL,FP,FL,KP,KL,DB;
		async function sort(A,a,b,db){
			let n=b-a,sn=1;
			if(n<257)return await inPlaceMergeSort(A,a,b);
			for(;sn*sn<n;sn*=2);
			let d=db?2*sn:sn,kF=await findKeys(A,a,b,d);
			if(kF<9)return await inPlaceMergeSort(A,a,b);
			FP=b-kF;FL=kF;KL=kF;KP=FP;OBL=sn;
			if(kF==d&&db){
				BL=sn;DB=true;
			}else if(kF>=sn){
				BL=sn;DB=false;
			}else{
				BL=0;DB=false;
			}
			await sortRuns(A,a,b-kF);
			await lithiumLoop(A,a,b);
		}
		await sort(arr,0,len,true);
	}
}
const sorts=new Sorts(),sortNames=sorts.getNames();
let filtering=false;
async function filterSorts(t){
	if(filtering)return;
	filtering=true;
	t=t.replaceAll("Sort","").trim();
	if(!t.startsWith("@"))t=t.toLowerCase();
	await document.querySelectorAll("#sortsholder>div").forEach(async(e,i)=>{
		await sleep();
		if(!t.length)e.className="shown";
		else{
			/*
			@ - case sensitive
			# - match starting
			{upper} - starts with uppercase
			{lower} - starts with lowercase
			{num} - contains a digit
			*/
			let raw=e.innerText.trim().replace("Sort","");
			let txt=e.innerText.trim().replace("Sort",""),f,nt=t.slice(1);
			if(!t.startsWith("@"))txt=txt.toLowerCase();
			if(t.startsWith("#"))f=txt.startsWith(nt);
			else if(t.startsWith("!")&&nt.length)f=txt.indexOf(nt)<0;
			else if(t.startsWith("@"))f=txt.indexOf(nt)+1;
			else if(t.startsWith("{")&&t.endsWith("}")&&t.length>2){
				let n=t.substr(1,t.length-2);
				if(n.indexOf("upper")+1)f=raw[0].toUpperCase()==raw[0];
				if(n.indexOf("lower")+1)f=raw[0].toLowerCase()==raw[0];
				if(n.indexOf("num")+1)f=/\d/.test(raw);
			}else f=txt.indexOf(t)+1;
			e.className=f?"shown":"hidden";
		}
	});
	filtering=false;
}
function appendTo(p,t,c){
	function hold(e){
		["touchstart","mousedown","mouseenter","mouseover"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=.5));
		["touchend","mouseup","mouseout","mouseleave","touchcancel","contextmenu"].forEach(m=>e.addEventListener(m,v=>e.style.opacity=1));
	}
	let a=document.createElement("div");a.className="shown";a.textContent=a.title=t;hold(a);a.onclick=c;
	p.appendChild(a);
}
sortNames.forEach((e,i)=>appendTo(sortsholder,e,()=>runSort(e)));
sortsholder.style.height=parseFloat(window.getComputedStyle(cont).getPropertyValue("height"))+"px";
function runSort(name){
	if(sortRunning||!sorts[name]){
		if(!loopSort.checked&&sortnamedisp.innerText!="Running: ...")sortQueue=name;
		return;
	}
	sortRunning=true;
	if(urgentStop){
		urgentStop=false;
		loopSort.checked=willLoop;
	}
	shuffle().then(()=>{
		counts.reset();
		sortnamedisp.innerText="Running: "+name;
		startTime=Date.now();
		sorts[name](arr_size).then(async()=>{
			await sleep(50);
			let{w,h}=getPixelR();
			let delay=sqrt(arr_size),sorted=isArraySorted(arr,arr_size);
			if(!sorted)console.warn(name);
			draw(true);
			fill(sorted?"#0f0":"#f00");
			let renMd=+displayType.value;
			let rad=minVal(cvs.width,cvs.height)/2*.9;
			for(let i=0,j=0;i<arr_size;i++){
				let v=arr[i];
				if(0==renMd||1==renMd||2==renMd||4==renMd||5==renMd)ctx.fillRect(i*w,cvs.height-v*h,w*1.05,v*h);
				else if(3==renMd||8==renMd||9==renMd)ctx.fillRect(i*w,0,w*1.05,cvs.height);
				else if(6==renMd||7==renMd){
					let rd=getDisparity(v,i,rad);
					let a=2*PI/arr_size*i-PI/2;
					ctx.beginPath();
					ctx.arc(cvs.width/2+cos(a)*rd,cvs.height/2+sin(a)*rd,w,0,2*PI);
					ctx.fill();
				}
				if(++j>delay){
					sound(v,.05);
					await sleep(j=0);
				}
			}
			await sleep(250);
			throw"";
		}).catch(async e=>{
			arr.sort((i,j)=>i-j);
			draw(true);
			if(e.stack){
				let line=parseInt(e.stack.split(".html")[1].split(":")[1]);
				console.log("Error at",line-9,":",e.message);
			}
			sortRunning=false;
			if(nextSort.checked){
				let nxt=loopSort.checked?name:sortNames[(sortNames.indexOf(name)+1)%sortNames.length];
				if(sortQueue){
					nxt=sortQueue;
					sortQueue=null;
				}
				if(loopSort.checked&&nextShuffle.checked)shuffleType.value=shuffleNames[(shuffleNames.indexOf(shuffleType.value)+1)%shuffleNames.length];
				counts.reset();
				await sleep(200);
				runSort(nxt);
			}
		});
	}).catch(e=>{
		let line=parseInt(e.stack.split(".html")[1].split(":")[1]);
		console.log("Error at",line-9,":",e.message);
	});
}
let unfiltered=Object.getOwnPropertyNames(Sorts.prototype);
runSort(unfiltered.pop());
let lowercased=[...sortNames].map(e=>e.toLowerCase());
let to_do=[],dupes=to_do.filter(e=>lowercased.includes(e.toLowerCase()));
if(dupes.length)console.log(dupes.join("\n"));
//clean-up marathon at 40k lines, lets see how many lines we can reduce
		</script>
	</body>
</html>