<!DOCTYPE html>
<html>
	<head>
		<title>Array Sorting</title>
		<meta name="viewport"content="width=device-width,initial-scale=1">
		<style>
			body{margin:0 0;color:#fff}
			@media(orientation:landscape){#cvs{width:auto}}
			@media(orientation:portrait){#cvs{width:100%}}
			#cvs{
				background:#000;
			}
		</style>
	</head>
	<body bgcolor=#0e151a>
		<div id=flexbox>
			<canvas id=cvs></canvas>
			<fieldset>
				<table>
					<tr>
						<td>Mark</td>
						<td><input type=checkbox checked id=markArray /></td>
					</tr>
				</table>
			</fieldset>
		</div>
		<script>
Math.ctz=function(n){n|=n;let b=n.toString(2);return parseInt(b)!=0?(b.match(/0*$/)+"").length:32}
const ctx=cvs.getContext("2d"),{random,ceil,floor,round,sqrt,cbrt,log,abs,pow,clz32,ctz,sin,sign,PI,min:minVal,max:maxVal}=Math;
let winRtn="";
requestAnimationFrame(function update(){
	winRtn=window.innerWidth<window.innerHeight?"portrait":"landscape";
	flexbox.style.display=winRtn=="portrait"?"inline-block":"flex";
	requestAnimationFrame(update);
})
window.onresize=function(){
	let dim=minVal(window.innerWidth,window.innerHeight);
	let m=winRtn=="portrait";
	cvs.width=dim*(m?2:1);
	cvs.height=dim/(m?1:2);
}
window.onresize();
//Project Started: April 4, 2024
const arr_size=512;
let arr=new Array(arr_size).fill().map((e,i)=>++i);
function fill(hex="#fff"){
	ctx.fillStyle=hex;
}
function getPixelR(){
	return{w:cvs.width/arr_size,h:cvs.height/maxVal(...arr)};
}
function draw(){
	let{w,h}=getPixelR();
	let i=0;
	ctx.clearRect(0,0,cvs.width,cvs.height);
	fill("#fff");
	for(let v of arr){
		ctx.fillRect(i++*w,cvs.height-v*h,w,v*h);
	}
	ctx.fillStyle="#fff";
}
function sleep(ms){
	return new Promise(r=>setTimeout(r,ms));
}
draw();
function mark(i){
	if(markArray.checked){
		let{w,h}=getPixelR();
		fill("#f00");
		ctx.fillRect(i*w,cvs.height-arr[i]*h,w,arr[i]*h);
	}
}
function markSwap(a,b){
	mark(a);
	mark(b);
}
function swap(a,i,j,s,m,x){
	i|=0;j|=0;
	[a[i],a[j]]=[a[j],a[i]];
	draw();
	if(m)markSwap(i,j);
	return sleep(s);
}
function write(a,t,v,s,m,x){
	a[t|=0]=v|0;
	draw();
	if(m)mark(t);
	return sleep(s);
}
function compareValues(a,b){a|=0;b|=0;return a==b?0:a>b?1:-1}
function compareIndices(a,b,c){b|=0;c|=0;return a[b]==a[c]?0:a[b]>a[c]?1:-1}
async function shuffle(){
	let e=arr_size;
	for(let i=0;i<e;i++){
		if(i%8==0){
			await swap(arr,i,random()*(e-i)+i,0,true);
		}else{
			swap(arr,i,random()*(e-i)+i,0,true);
		}
		draw();
	}
	return true;
}
class Sorts{
	getNames(){
		return Object.getOwnPropertyNames(Sorts.prototype).filter(e=>e!="constructor"&&e!="getNames"&&e!="randomSort");
	}
	randomSort(){
		let sorts=this.getNames();
		runSort(sorts[random()*sorts.length|0]);
	}
	async bitonicSortIterative(len){
		let i,j,k;
		for(k=2;k<len*2;k=2*k){
			let m=((len+k-1)/k|0)%2!=0;
			for(j=k>>1;j>0;j=j>>1){
				for(i=0;i<len;i++){
					let n=i^j;
					if(n>i&&n<len)if(((((i&k)==0)==m)&&compareIndices(arr,i,n)>0)||((((i&k)!=0)==m)&&compareIndices(arr,i,n)<0))await swap(arr,i,n,0,true);
				}
			}
		}
	}
	async bitonicSortRecursive(len){
		function gpot(n){
			let k=1;
			while(k<n)k<<=1;
			return k>>1;
		}
		async function c(A,i,j,d){
			let m=compareIndices(A,i,j);
			if(m==1==d)await swap(A,i,j,0,true);
		}
		async function bitonicMerge(A,lo,n,d){
			if(n>1){
				let m=gpot(n);
				for(let i=lo;i<lo+n-m;i++)await c(A,i,i+m,d);
				await bitonicMerge(A,lo,m,d);
				await bitonicMerge(A,lo+m,n-m,d);
			}
		}
		async function bitonicSort(A,lo,n,d){
			if(n>1){
				let m=n/2|0;
				await bitonicSort(A,lo,m,!d);
				await bitonicSort(A,lo+m,n-m,d);
				await bitonicMerge(A,lo,n,d);
			}
		}
		bitonicSort(arr,0,len,true);
	}
	async boseNelsonSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function rc(A,a,b,o){
			let h=(b-a)/2|0,m=a+h;
			a+=o;
			for(let i=0;i<h-o;i++)if((i&~o)==i)await cs(A,a+i,m+i);
		}
		let end=len;
		len=1<<ceil(log(len)/log(2));
		for(let k=2;k<=len;k*=2)
			for(let j=0;j<k/2|0;j++)
				for(let i=0;i+j<end;i+=k)
					await rc(arr,i,i+k,j);
	}
	async boseNelsonSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function boseNelsonMerge(A,s1,l1,s2,l2){
			if(l1==1&&l2==1){
				await cs(A,s1,s2);
			}else if(l1==1&&l2==2){
				await cs(A,s1,s2+1);
				await cs(A,s1,s2);
			}else if(l1==2&&l2==1){
				await cs(A,s1,s2);
				await cs(A,s1+1,s2);
			}else{
				let m1=l1/2|0;
				let m2=l1%2?l2/2|0:(l2+1)/2|0;
				await boseNelsonMerge(A,s1,m1,s2,m2);
				await boseNelsonMerge(A,s1+m1,l1-m1,s2+m2,l2-m2);
				await boseNelsonMerge(A,s1+m1,l1-m1,s2,m2);
			}
		}
		async function boseNelson(A,s,l){
			if(l>1){
				let m=l/2|0;
				await boseNelson(A,s,m);
				await boseNelson(A,s+m,l-m);
				await boseNelsonMerge(A,s,m,s+m,l-m);
			}
		}
		boseNelson(arr,0,len);
	}
	async creaseSort(len){
		async function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				await swap(A,a,b,.5,true);
		}
		let m=1;
		for(;m*2<len;m*=2);
		for(let n=m;n>0;n=n/2|0){
			for(let i=0;i+1<len;i+=2)await cs(arr,i,i+1);
			for(let j=m;j>=n&&j>1;j=j/2|0)for(let i=1;i+j-1<len;i+=2)await cs(arr,i,i+j-1);
		}
	}
	async diamondSortIterative(len){
		function cs(A,a,b){
			if(compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		let n=1,m=4;
		for(;n<len;n*=2);
		for(;m<=n;m*=2)for(let k=0;k<m/2;k++){
			let c=k<=m/4?k:m/2-k;
			for(let j=0;j<len;j+=m)
				if(j+c+1<len)
					for(let i=j+c;i+1<minVal(len,j+m-c);i+=2)
						await cs(arr,i,i+1);
		}
		m/=2;
		for(let k=0;k<=m/2;k++)
			for(let i=k;i+1<minVal(len,m-k);i+=2)
				await cs(arr,i,i+1);
	}
	async diamondSortRecursive(len){
		async function sort(A,s,e,m){
			if(e-s==2){
				if(compareIndices(A,s,e-1)>0)
					await swap(A,s,e-1,0,true);
			}else if(e-s>=3){
				let d=(e-s)/4;
				let md=(e-s)/2+s|0;
				if(m){
					await sort(A,s,md,true);
					await sort(A,md,e,true);
				}
				await sort(A,d+s|0,d*3+s|0);
				await sort(A,s,md);
				await sort(A,md,e);
				await sort(A,d+s|0,d*3+s|0);
			}
		}
		sort(arr,0,len,true);
	}
	async foldSort(len){
		let cL=1;
		for(;1<<cL<len;cL++);
		let e=len;len=1<<cL;
		for(let k=len>>1;k>0;k>>=1)
			for(let i=len;i>=k;i>>=1)
				for(let j=0;j<e;j+=i)
					for(let l=j,h=j+i-1;l<h;l++,h--)
						if(h<e&&compareIndices(arr,l,h)>0)
							await swap(arr,l,h,.5,true);
	}
	async matrixSort(len){
		class MtSp{
			constructor(w,h,l){
				this.w=w;
				this.iL=(w==1)^(h==1)||l;
			}
		}
		async function gR(A,s,e,g){
			for(let i=s,j=e;i<j;i+=g,j-=g)await swap(A,i,j-g,0,true);
		}
		const dCV=(l,r,d)=>d?compareValues(l,r):(compareValues(l,r)*-1);
		async function inL(ar,a,b,g,dr){
			let d=0,k=ar[b],j=b-g;
			while(j>=a&&dCV(k,ar[j],dr)<0){
				await write(ar,j+g,ar[j],0,true);
				d=1;j-=g;
			}
			await write(ar,j+g,k);
			return d;
		}
		function gMD(l){
			let d=sqrt(l)|0,iL=(d*d==l-1)
			for(;l%d!=0;d--);
			return new MtSp(d,l/d|0,iL);
		}
		async function mS(a,s,e,g,dr){
			let d=0,l=(e-s)/g|0;
			if(l<2)return 0;
			else if(l<17){
				d=0;
				for(let i=s;i<e;i+=g)d=await inL(a,s,i,g,dr)|d;
			}else{
				let nd,mSh=gMD(l);
				if(mSh.iL){
					let d1=await mS(a,s,e-g,g,dr);
					let d2=await inL(a,s,e-g,g,dr);
					return d1||d2;
				}
				for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)await gR(a,i,i+mSh.w*g,g);
				d=0;
				do{
					nd=0;
					for(let i=s,cd=dr;i<e;i+=mSh.w*g){
						nd=await mS(a,i,i+mSh.w*g,g,cd)||nd;
						d=d||nd;
						cd=!cd;
					}
					nd=0;
					for(let i=0;i<mSh.w;d=d||nd,i++)nd=await mS(a,s+i*g,e+i*g,g*mSh.w,dr)||nd;
				}while(nd);
				for(let i=s+mSh.w*g;i<e;i+=2*mSh.w*g)await gR(a,i,i+mSh.w*g,g);
			}
			return d;
		}
		mS(arr,0,len,1,true);
	}
	async mergeExchangeSortIterative(len){
		let t=log(len-1)/log(2)+1|0;
		let p0=1<<(t-1);
		for(let p=p0;p>0;p>>=1){
			let q=p0,r=0,d=p;
			while(1){
				for(let i=0;i<len-d;i++)
					if((i&p)==r&&compareIndices(arr,i,i+d)>0)
						await swap(arr,i,i+d,.5,true);
				if(q==p)break;
				d=q-p;q>>=1;r=p;
			}
		}
	}
	async oddEvenMergeSortRecursive(len){
		function c(A,a,b){
			if(compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function oddEvenMerge(A,l,m2,n,r){
			let m=r*2;
			if(m<n){
				let s=(n/r|0)%2!=0;
				await oddEvenMerge(A,l,(m2+1)/2|0,n+(s?r:0),m);
				await oddEvenMerge(A,l+r,m2/2|0,n-(s?r:0),m);
				if(m2%2!=0)for(let i=l;i+r<l+n;i+=m)await c(A,i,i+r);
				else for(let i=l+r;i+r<l+n;i+=m)await c(A,i,i+r);
			}else if(n>r)await c(A,l,l+r);
		}
		async function oddEvenMergeSort(A,l,n){
			if(n>1){
				let m=n/2|0;
				await oddEvenMergeSort(A,l,m);
				await oddEvenMergeSort(A,l+m,n-m);
				await oddEvenMerge(A,l,m,n,1);
			}
		}
		oddEvenMergeSort(arr,0,len);
	}
	async pairwiseMergeSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		let e=len;
		let n=1;
		for(;n<len;n<<=1);
		for(let k=n>>1;k>0;k>>=1)
			for(let j=0;j<len;j+=k<<1)
				for(let i=0;i<k;i++)
					await cs(arr,j+i,j+k+i);
		for(let k=2;k<n;k<<=1)
			for(let m=k>>1;m>0;m>>=1)
				for(let j=0;j<len;j+=k<<1)
					for(let p=m;p<(k-m)<<1;p+=m<<1)
						for(let i=0;i<m;i++)
							await cs(arr,j+p+i,j+p+m+i);
	}
	async pairwiseMergeSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function pairwiseMerge(A,a,b){
			let m=(a+b)/2|0,m1=(a+m)/2|0,g=m-m1;
			for(let i=0;m1+i<m;i++)
				for(let j=m1,k=g;k>0;k>>=1,j-=k-(i&k))
					await cs(A,j+i,j+i+k);
			if(b-a>4)await pairwiseMerge(A,m,b);
		}
		async function pairwiseMergeSort(A,a,b){
			let m=(a+b)/2|0;
			for(let i=a,j=m;i<m;i++,j++)
				await cs(A,i,j);
			if(b-a>2){
				await pairwiseMergeSort(A,a,m);
				await pairwiseMergeSort(A,m,b);
				await pairwiseMerge(A,a,b);
			}
		}
		let e=len;
		let n=1;
		for(;n<e;n<<=1);
		pairwiseMergeSort(arr,0, n);
	}
	async pairwiseSortIterative(len){
		async function iterativepairwise(A,l){
			let a=1,b,c,d,e;
			b=c=d=e=0;
			while(a<l){
				b=a;c=0;
				while(b<l){
					if(compareIndices(A,b-a,b)>0)
						await swap(A,b-a,b,.5,true);
					c=(c+1)%a;
					b+=c?1:a+1;
				}
				a*=2;
			}
			a=a/4|0;e=1;
			while(a>0){
				d=e;
				while(d>0){
					b=(d+1)*a;c=0;
					while(b<l){
						if(compareIndices(A,b-d*a,b)>0)
							await swap(A,b-d*a,b,.5,true);
						c=(c+1)%a;
						b+=c?1:a+1;
					}
					d=d/2|0;
				}
				a=a/2|0;e=e*2+1;
			}
		}
		iterativepairwise(arr,len);
	}
	async pairwiseSortRecursive(len){
		async function pairwiserecursive(A,s,e,g){
			if(s==e-g)return;
			let b=s+g;
			while(b<e){
				if(compareIndices(A,b-g,b)>0)
					await swap(A,b-g,b,.5,true);
				b+=2*g;
			}
			if(((e-s)/g|0)%2==0){
				await pairwiserecursive(A,s,e,g*2);
				await pairwiserecursive(A,s+g,e+g,g*2);
			}else{
				await pairwiserecursive(A,s,e+g,g*2);
				await pairwiserecursive(A,s+g,e,g*2);
			}
			let a=1;
			while(a<(e-s)/g|0)a=a*2+1;
			b=s+g;
			while(b+g<e){
				let c=a;
				while(c>1){
					c=c/2|0;
					if(b+c*g<e)
						if(compareIndices(A,b,b+c*g)>0)
							await swap(A,b,b+c*g,.5,true);
				}
				b+=2*g;
			}
		}
		pairwiserecursive(arr,0,len,1);
	}
	async weaveSortIterative(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		let e=len;
		let n=1;
		for(;n<len;n*=2);
		for(let i=1;i<n;i*=2)
			for(let j=1;j<=i;j*=2)
				for(let k=0;k<n;k+=n/j|0)
					for(let d=n/i/2|0,m=0,l=n/j-d|0;l>=n/j/2|0;l-=d)
						for(let p=0;p<d;p++,m++)
							await cs(arr,k+m,k+l+p);
	}
	async weaveSortRecursive(len){
		function cs(A,a,b){
			if(b<e&&compareIndices(A,a,b)>0)
				return swap(A,a,b,.5,true);
		}
		async function circle(A,p,l,g){
			if(l<2)return;
			for(let i=0;2*i<(l-1)*g;i+=g)
				await cs(A,p+i,p+(l-1)*g-i);
			await circle(A,p,l/2|0,g);
			if(p+l*g/2|0<e)await circle(A,p+l*g/2|0,l/2|0,g);
		}
		async function weaveCircle(A,p,l,g){
			if(l<2)return;
			await weaveCircle(A,p,l/2|0,2*g);
			await weaveCircle(A,p+g,l/2|0,2*g);
			await circle(A,p,l,g);
		}
		let e=len,n=1;
		for(;n<e;n*=2);
		weaveCircle(arr,0,n,1);
	}
}
const sorts=new Sorts();
const sortsNames=sorts.getNames();
function runSort(name){
	shuffle().then(()=>{
		if(sorts[name])sorts[name](arr_size).then(draw);
	});
}
runSort("weaveSortRecursive");
		</script>
	</body>
</html>